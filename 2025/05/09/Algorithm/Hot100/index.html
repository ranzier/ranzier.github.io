

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/about/dogs.jpg">
  <link rel="icon" href="/img/about/dogs.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ranzier">
  <meta name="keywords" content="">
  
    <meta name="description" content="LeetcodeHOT100刷题笔记  0. 算法思想总结(⭐表示重要程度，⭐越多面试越容易考到) 两数之和  使用HashMap存储数组元素，查询map中是否存在target-nums[i]   字母异位词分组  转换为字符数组使用Arrays.sort()进行排序，排序后查询哈希表，放入HashMap&lt;String,List&lt;String&gt;&gt;中，键为排序后字符串，值为原">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetcodeHOT100刷题笔记">
<meta property="og:url" content="http://example.com/2025/05/09/Algorithm/Hot100/index.html">
<meta property="og:site_name" content="RANZIER">
<meta property="og:description" content="LeetcodeHOT100刷题笔记  0. 算法思想总结(⭐表示重要程度，⭐越多面试越容易考到) 两数之和  使用HashMap存储数组元素，查询map中是否存在target-nums[i]   字母异位词分组  转换为字符数组使用Arrays.sort()进行排序，排序后查询哈希表，放入HashMap&lt;String,List&lt;String&gt;&gt;中，键为排序后字符串，值为原">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bg/37.jpg">
<meta property="article:published_time" content="2025-05-09T12:21:24.000Z">
<meta property="article:modified_time" content="2025-10-14T08:16:23.166Z">
<meta property="article:author" content="ranzier">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="hot100">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/bg/37.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>LeetcodeHOT100刷题笔记 - RANZIER</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_3846514_kabxni94auf.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css">
<link rel="stylesheet" href="/css/bubble.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"🌟","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>RANZIER</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/3.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.35)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetcodeHOT100刷题笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-09 20:21" pubdate>
          2025年5月9日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          52k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          258 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          本文阅读次数：<span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LeetcodeHOT100刷题笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 align="center">LeetcodeHOT100刷题笔记</h1>

<h1 id="0-算法思想总结-⭐表示重要程度，⭐越多面试越容易考到"><a href="#0-算法思想总结-⭐表示重要程度，⭐越多面试越容易考到" class="headerlink" title="0. 算法思想总结(⭐表示重要程度，⭐越多面试越容易考到)"></a>0. 算法思想总结(⭐表示重要程度，⭐越多面试越容易考到)</h1><ol>
<li><a href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a> <ul>
<li>使用HashMap存储数组元素，查询map中是否存在<code>target-nums[i]</code></li>
</ul>
</li>
<li><a href="#2-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84">字母异位词分组</a> <ul>
<li>转换为字符数组使用Arrays.sort()进行排序，排序后查询哈希表，放入<code>HashMap&lt;String,List&lt;String&gt;&gt;</code>中，键为排序后字符串，值为原始字符串的集合</li>
</ul>
</li>
<li><a href="#3-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97">最长连续序列</a> ⭐ <ul>
<li>使用HashSet去重后，遍历HashSet</li>
<li>当<code>nums[i]-1</code>不存在时，开始从<code>nums[i]</code>往后查询</li>
<li>不断查询<code>nums[i]+1,nums[i]+2...</code></li>
</ul>
</li>
<li><a href="#4-%E7%A7%BB%E5%8A%A8%E9%9B%B6">移动零</a> <ul>
<li>第一遍遍历： j初始为0，j 作为非零元素的插入位置，把所有 非零元素 依次填入 <code>nums[j]</code></li>
<li>第二遍遍历： 把 j 之后的元素全部填 0。</li>
</ul>
</li>
<li><a href="#5-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">盛最多水的容器</a> <ul>
<li>left从左，right从右向中间移动，计算区间面积，每次计算后<strong>移动高度较小的指针</strong>，向中间靠拢</li>
</ul>
</li>
<li><a href="#6-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">三数之和</a> ⭐ <ul>
<li><strong>先排序</strong>，三个指针：<ul>
<li>i : 从0到nums.length-2遍历</li>
<li>left: 从i+1往后遍历</li>
<li>right：从nums.length-1往前遍历</li>
</ul>
</li>
<li>如果sum&#x3D;0: left++,right–; 如果sum&gt;0: right–; 如果sum&lt;0: left++;</li>
<li>i 在遍历时，跳过相同的 <code>nums[i]</code>;  left 和 right 指针移动时，也要跳过重复值。</li>
</ul>
</li>
<li><a href="#7-%E6%8E%A5%E9%9B%A8%E6%B0%B4">接雨水</a> <ul>
<li><strong>水的面积&#x3D;全部面积-柱子的面积</strong><ul>
<li>全部面积 +&#x3D; 每一层的长度*1</li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2">无重复字符的最长字串</a>  ⭐⭐⭐⭐<ul>
<li>用一个<strong>集合ArrayList维护当前的无重复子串</strong>,遍历字符串，如果当前字符已在list集合中重复，记录当前最大值，删除list中重复元素及以前的元素，添加当前元素</li>
</ul>
</li>
<li><a href="#9-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">找到字符串中所有字母异位词</a> <ul>
<li><strong>滑动窗口 + 频率数组</strong>比较；维护两个长度为26的数组来比较窗口内的字符频率是否和 p 匹配，每次移除窗口左边的元素，添加新字符到窗口的右侧</li>
</ul>
</li>
<li><a href="#10-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">和为K的子数组</a> <ul>
<li><strong>前缀和 + 哈希表</strong><ul>
<li>哈希表：Key存储前缀和，Value存储这个前缀和出现的次数</li>
<li>通过 prefixSum - k 计算是否有之前的前缀和能构成和 k 的子数组</li>
<li>preSum - k &#x3D; (前面一个preSum索引,当前索引)的子数组之和</li>
<li>加上之前的前缀和出现的次数即可</li>
<li><strong>注意</strong>：哈希表要添加： <code>map.put(0,1)</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="#11-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC">滑动窗口最大值</a> <ul>
<li><strong>单调双端队列</strong>：使用双端队列(Deque)存储<strong>索引</strong>，在遍历数组时始终保持队列中元素对应的值<strong>单调递减</strong>，并在每次滑动窗口形成后，通过<strong>队头索引</strong>快速获取当前窗口的最大值，同时<strong>移除队头已滑出窗口范围的元素</strong>和<strong>队尾比当前元素小的元素</strong></li>
<li><strong>如何更新队头的最大值？</strong><ul>
<li>当新元素来的时候，从队尾往队头移动，把小于新元素的元素全部出队，然后从队尾入队</li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">最小覆盖子串</a> ⭐⭐ <ul>
<li><strong>滑动窗口+哈希表</strong><ul>
<li><strong>一个哈希表记录t</strong>的字符出现的次数，<strong>另一个哈希表记录s</strong>当前窗口的字符出现的次数</li>
<li>右指针<strong>right先往右移动</strong>，<strong>直到包含t所有的字符</strong>(借助valid记录窗口内满足条件的字符数)，记录当前最短子串的右边界</li>
<li>左指针<strong>left收缩窗口</strong>，尝试寻找更短的子串，记录当前最短子串的左边界</li>
</ul>
</li>
</ul>
</li>
<li><a href="#13-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">最大子数组和</a> <ul>
<li><strong>局部最优 -&gt; 推导全局最优</strong> sum+&#x3D;当前元素，如果sum&gt;max，更新max；如果sum&lt;0，将sum重置为0(因为前面的子数组对后续没有正向贡献)</li>
</ul>
</li>
<li><a href="#14-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">合并区间</a> ⭐⭐⭐ <ul>
<li><strong>先根据start排序</strong>：</li>
<li><strong>初始化</strong>结果集合，<strong>加入第一个区间</strong></li>
<li>遍历剩余区间：<ul>
<li>如果<strong>当前区间和结果中的最后一个区间有重叠</strong>（即：上一个区间的 end &gt;&#x3D; 当前区间的 start）<ul>
<li>→ 合并两个区间（<strong>更新 end 为两者最大值</strong>）</li>
</ul>
</li>
<li>否则<strong>直接加入结果集合</strong>（无重叠）</li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84">轮转数组</a> <ul>
<li><strong>三次翻转法</strong>：<ul>
<li>先整体翻转数组；再翻转前 k 个元素；最后翻转后 n-k个元素；</li>
</ul>
</li>
<li><strong>注意：</strong> k可能大于数组长度，所以要先对数组长度取模(k%&#x3D;nums.length;)</li>
</ul>
</li>
<li><a href="#16-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF">除自身以外数组的乘积</a> <ul>
<li><strong>前缀积和后缀积</strong>：第一次从前往后遍历，构建结果数组每个位置前缀乘积，第二次从后往前遍历乘上后缀乘积</li>
</ul>
</li>
<li><a href="#17-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">缺失的第一个正数</a> ⭐ <ul>
<li>将<code>[8,2,0,1,3,4]</code>遍历转换为<code>[1,2,3,4,0,8]</code>,通过原地<strong>交换</strong>的方式将正整数放到对应的位置上，然后从头遍历找到第一个不符合的正数</li>
</ul>
</li>
<li><a href="#18-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6">矩阵置零</a> <ul>
<li>利用<strong>矩阵的第一行和第一列作为标记位</strong>来记录哪一行、哪一列需要被置 0  <strong>注意：</strong> 标记记录的过程中应该跳过第一行和第一列</li>
</ul>
</li>
<li><a href="#19-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">螺旋矩阵</a> ⭐ <ul>
<li>定义top, bottom, left, right<strong>四个边界变量</strong>控制遍历范围</li>
<li>按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素</li>
<li><strong>注意：最后两个遍历(往左和往上)要判断是否还有行或列剩下</strong></li>
</ul>
</li>
<li><a href="#20-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">旋转图像</a> <ul>
<li><strong>旋转&#x3D;转置+翻转</strong><ul>
<li>先转置：将 <code>matrix[i][j]</code> 变成 <code>matrix[j][i]</code>。</li>
<li>再水平翻转：让 <code>matrix[j][i]</code> 变成 <code>matrix[j][n-1-i]</code>。</li>
</ul>
</li>
</ul>
</li>
<li><a href="#21-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii">搜索二维矩阵-ii</a> <ul>
<li>从右上角出发，向下或向左移动，相等时返回true</li>
</ul>
</li>
<li><a href="#22-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">相交链表</a> <ul>
<li><strong>双指针一块走</strong>，当 pA 走到尾巴 null，它就切换到 headB 重新开始。当 pB 走到尾巴 null，它就切换到 headA 重新开始。如果两个链表有交点，那么两个指针<strong>一定会在交点相遇</strong>。如果没有交点，最终两个指针<strong>都会走到 null</strong></li>
</ul>
</li>
<li><a href="#23-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a> ⭐</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">原链表:1→2→3→4</span><br><span class="hljs-attr">1:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1</span> <span class="hljs-number">2</span><span class="hljs-string">→3→4</span><br><span class="hljs-attr">2:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2</span> <span class="hljs-number">3</span><span class="hljs-string">→4</span><br><span class="hljs-attr">3:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3</span> <span class="hljs-number">4</span><br><span class="hljs-attr">4:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3←4</span><br></code></pre></td></tr></table></figure>

<ol start="24">
<li><a href="#24-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">回文链表</a> <ul>
<li>先用<strong>快慢指针找中点</strong>，把<strong>中点以后的链表反转</strong>，<strong>再比较</strong>反转后的一半链表和原链表的前一半</li>
</ul>
</li>
<li><a href="#25-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">环形链表</a> <ul>
<li><strong>快慢指针找环</strong>：如果相遇了返回true</li>
</ul>
</li>
<li><a href="#26-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii">环形链表-ii</a>  ⭐<ul>
<li>当快慢指针相遇时：定义<strong>一个指针从相遇点开始走</strong>；<strong>另一个指针从链表头开始走</strong>，他们<strong>会在环的入口点相遇</strong></li>
</ul>
</li>
<li><a href="#27-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">合并两个有序链表</a> ⭐⭐⭐ <ul>
<li>使用<strong>虚拟头结点</strong>，双指针遍历两个链表；<strong>谁的值小，就连接谁</strong>；遍历完一个，直接连接另一个</li>
</ul>
</li>
<li><a href="#28-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0">两数相加</a> <ul>
<li>创建一个新链表记录两个链表之和，<strong>注意进位</strong></li>
</ul>
</li>
<li><a href="#29-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9">删除链表的倒数第n个结点</a> ⭐⭐⭐⭐⭐<ul>
<li>创建一个dummy,<strong>快慢指针指向dummy</strong>；<strong>快指针先走n+1步</strong>，然后<strong>快慢指针一起移动直到快指针为null</strong>，此时慢指针的位置就是要删除结点的前一个结点位置</li>
</ul>
</li>
<li><a href="#30-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">两两交换链表中的节点</a> <ul>
<li>模拟即可</li>
</ul>
</li>
<li><a href="#31-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8">k个一组翻转链表</a> ⭐⭐<ul>
<li><strong>反转</strong>+<strong>找到K个结点一组</strong>即可，每次记录开始结点和终止结点</li>
</ul>
</li>
<li><a href="#32-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">随机链表的复制</a> <ul>
<li>使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制</li>
</ul>
</li>
<li><a href="#33-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8">排序链表</a>  <ul>
<li><strong>插入排序</strong>&#x2F;<strong>归并排序</strong><ul>
<li>使用<strong>快慢指针找到链表中点</strong>，将链表以中点<strong>拆分</strong>成左右链表递归排序，将两个链表<strong>合并</strong>成有序链表</li>
</ul>
</li>
</ul>
</li>
<li><a href="#34-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8">合并k个升序链表</a> <ul>
<li>使用<strong>最小堆</strong>(优先级队列)维护k个链表的当前最小节点，每次<strong>出队最小结点</strong>，<strong>入队最小结点的下一个结点</strong>，直到队列为空</li>
</ul>
</li>
<li><a href="#35-lru%E7%BC%93%E5%AD%98">lru缓存</a><ul>
<li>定义<strong>双向链表</strong>维护缓存队列，定义<strong>哈希表</strong>维护当前队列的键和值，并提供快速查找结点</li>
</ul>
</li>
<li><a href="#36-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的中序遍历</a> <ul>
<li><strong>左根右递归</strong></li>
</ul>
</li>
<li><a href="#37-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a><ul>
<li>当前节点为空返回0，递归计算左右子树的深度，取左右子树的较大值加1</li>
</ul>
</li>
<li><a href="#38-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">翻转二叉树</a> <ul>
<li>递归交换左右子树即可</li>
</ul>
</li>
<li><a href="#39-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">对称二叉树</a> ⭐<ul>
<li>两个子树<strong>都为空则对称</strong></li>
<li>如果<strong>左右子树都不为空且值相等</strong>，同时<strong>左树的右子树和右树的左子树对称</strong>，同时<strong>左树的左子树和右树的右子树对称</strong>，则对称</li>
</ul>
</li>
<li><a href="#40-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">二叉树的直径</a> <ul>
<li>递归计算每个节点的<strong>左右子树的最大深度</strong>，<strong>当前节点的直径&#x3D;左子树深度+右子树深度</strong>，<strong>更新</strong>最大直径</li>
</ul>
</li>
<li><a href="#41-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的层序遍历</a><ul>
<li>使用队列存储每层的结点，使用size记录当前层结点的个数，循环<strong>出队</strong>层中的结点，<strong>入队下一层左右子树的结点</strong>，直到队空为止</li>
</ul>
</li>
<li><a href="#42-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">将有序数组转换为二叉搜索树</a><ul>
<li>以数组的中间元素作为root结点，左区间递归构造左子树root.left,右区间递归构造右子树root.right，直到数组区间索引left&gt;right终止</li>
</ul>
</li>
<li><a href="#43-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">验证二叉搜索树</a><ul>
<li><strong>构建子树的大小边界</strong>，左右子树的值在边界外返回false，递归遍历左右子树</li>
</ul>
</li>
<li><a href="#44-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">二叉搜索树中第k小的元素</a><ul>
<li>二叉搜索树用<strong>中序遍历</strong>即为一个升序的数组，<strong>直接计数</strong>到第k个遍历的结点时，返回当前元素即可</li>
</ul>
</li>
<li><a href="#45-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE">二叉树的右视图</a> ⭐<ul>
<li>使用队列进行<strong>层序遍历</strong>，找到每层最右边的结点即可</li>
</ul>
</li>
<li><a href="#46-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8">二叉树展开为链表</a><ul>
<li>创建一个新结点，使用<strong>新结点的右子树连接当前root结点</strong>，然后<strong>前序遍历</strong>递归连接root的左子树、root的右子树</li>
</ul>
</li>
<li><a href="#47-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">从前序与中序遍历序列构造二叉树</a><ul>
<li><strong>哈希表</strong>存储中序数组便于查找索引，前序数组第一个元素就是根节点，使用<strong>中序数组划分左右子树</strong>后进行递归构建左右子树</li>
</ul>
</li>
<li><a href="#48-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii">路径总和-iii</a><ul>
<li>使用<strong>哈希表存储前缀和</strong>出现次数，</li>
<li>backtracking(){终止条件{在哈希表找到(<strong>当前路径总和-目标值</strong>)的次数加到结果}，在哈希表<strong>添加当前路径总和</strong>，<strong>递归</strong>左右子树，<strong>回溯撤销</strong>哈希表添加的当前路径总和}</li>
</ul>
</li>
<li><a href="#49-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉树的最近公共祖先</a> ⭐<ul>
<li>先判断当前结点是否是p或q，再递归判断左右子树，分为左右子树都找到了结点，左右子树只有一个找到了，左右子树都没找到四种情况</li>
</ul>
</li>
<li><a href="#50-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">二叉树中的最大路径和</a> ⭐<ul>
<li>用一个全局变量记录最大值，<strong>递归记录左右子树的最大贡献</strong>，更新最大值，返回当前结点能为父节点的最大路径值(<strong>只能选左右子树的其中一个贡献大的子树</strong>)</li>
</ul>
</li>
<li><a href="#51-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">岛屿数量</a>  ⭐<ul>
<li>若当前元素为’1’则计数加1，并递归的感染周围的元素为’2’，防止重复计数</li>
</ul>
</li>
<li><a href="#52-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90">腐烂的橘子</a> <ul>
<li>先把当前状态转换替代成其他值，用<strong>时间标记当前腐烂的橘子</strong>，下一轮腐烂的橘子&#x3D;当前time+1，直到没有新橘子被感染跳出循环</li>
</ul>
</li>
<li><a href="#53-%E8%AF%BE%E7%A8%8B%E8%A1%A8">课程表</a><ul>
<li>判断一个有向图是否有环，不会….</li>
</ul>
</li>
<li><a href="#54-%E5%AE%9E%E7%8E%B0trie%E5%89%8D%E7%BC%80%E6%A0%91">实现trie前缀树</a><ul>
<li>面试会考吗？不会》….</li>
</ul>
</li>
<li><a href="#55-%E5%85%A8%E6%8E%92%E5%88%97">全排列</a><ul>
<li>用一个boolean<strong>数组visited</strong>保存已经访问的元素，下次循环直接跳过；回溯三部曲：<strong>终止条件，for循环递归，回溯撤销</strong></li>
</ul>
</li>
<li><a href="#56-%E5%AD%90%E9%9B%86">子集</a> <ul>
<li>收集子集，for(){收集元素，递归到下一层元素，回溯撤销}</li>
</ul>
</li>
<li><a href="#57-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88">电话号码的字母组合</a><ul>
<li>通过回溯法依次遍历输入数字串 digits，从第一个数字开始，根据数字映射的字母表，逐个尝试<strong>每个字母，将其加入当前路径</strong> path，然后<strong>递归处理下一个数字</strong>。当遍历到<strong>路径长度等于输入长度</strong>时，说明已生成一个完整组合，将其拼接成字符串<strong>加入结果列表</strong> result，随后<strong>回退</strong>（撤销最后一个字符）继续尝试其它可能，直到穷尽所有组合。</li>
</ul>
</li>
<li><a href="#58-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C">组合总和</a>  ⭐<ul>
<li>当前缀和等于target时，终止递归；for(){添加当前元素，递归进入下一层，回溯撤销}</li>
</ul>
</li>
<li><a href="#59-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90">括号生成</a> <ul>
<li>当<strong>左右括号用完了</strong>终止递归加入结果(left&#x3D;&#x3D;0&amp;&amp;right&#x3D;&#x3D;0)</li>
<li>当<strong>左括号数量大于0</strong>可以选择左括号</li>
<li>当<strong>右括号剩余数量大于左括号剩余数量</strong>，可以选择右括号，然后<strong>添加递归回溯</strong></li>
</ul>
</li>
<li><a href="#60-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2">单词搜索</a> <ul>
<li>通过双重循环遍历二维字符数组的每个元素，<strong>找到与单词首字符相同的位置后</strong>，调用递归函数<strong>向上下左右四个方向查找下一个字符</strong>，每访问一个字符就将其暂时<strong>标记为已访问</strong>（用 <code>#</code> 替换），<strong>防止重复</strong>走回头路，递归如果找到完整单词则返回 true，<strong>未找到则恢复该位置原字符</strong>，继续尝试其他路径，直到所有可能都搜索完毕。</li>
</ul>
</li>
<li><a href="#61-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2">分割回文串</a> <ul>
<li>通过从字符串的起始位置开始，用循环<strong>依次截取不同长度的子串</strong>，判断当前子串是否是回文串，如果是则将其加入路径列表，并<strong>递归继续处理剩余部分</strong>，直到遍历完整个字符串，将完整路径加入结果列表，递归返回时通过 removeLast() 撤销上一次添加的子串，继续尝试下一种截取方式。</li>
</ul>
</li>
<li><a href="#62-n%E7%9A%87%E5%90%8E">n皇后</a> <ul>
<li>循环尝试在棋盘的<strong>每一行每一列放置皇后</strong>，遇到<strong>符合条件的位置</strong>就将皇后<strong>放下</strong>，并<strong>递归进入下一行</strong>继续放置，直到所有行都放置完毕时将当前棋盘状态转换成字符串列表加入结果集中，递归返回时通过将皇后位置<strong>回溯复原</strong>，继续尝试下一列的位置，最终遍历出所有可能的皇后摆放方案。</li>
</ul>
</li>
<li><a href="#63-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE">搜索插入位置</a> <ul>
<li>二分查找</li>
</ul>
</li>
<li><a href="#64-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5">搜索二维矩阵</a><ul>
<li>二分查找：从右上角元素向下或向左移动</li>
</ul>
</li>
<li><a href="#65-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE">在排序数组中查找元素的第一个和最后一个位置</a><ul>
<li>二分查找<strong>先查找第一个位置，再查找结束位置</strong></li>
<li>查找左边位置时，当<code>nums[mid] == target</code>，<code>right = mid - 1</code>不断向左收缩</li>
<li>查找右边位置时，当<code>nums[mid] == target</code>，<code>left = mid + 1</code>不断向右收缩</li>
</ul>
</li>
<li><a href="#66-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">搜索旋转排序数组</a> <ul>
<li>直接对数组进行二分，其中一定有一个子区间是<strong>有序的</strong>，另一个<strong>部分有序</strong></li>
<li>判断哪个区间是有序的，然后继续进行逻辑判断</li>
</ul>
</li>
<li><a href="#67-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">寻找旋转排序数组的最小值</a> ⭐<ul>
<li>如果 <code>nums[mid] &gt; nums[right]</code>，最小值一定在右边，left&#x3D;mid+1</li>
<li>如果 <code>nums[mid] &lt;= nums[right]</code>，最小值在左边，right&#x3D;mid</li>
<li>退出循环时，left &#x3D;&#x3D; right，正是最小值的位置</li>
</ul>
</li>
<li><a href="#68-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">寻找两个正序数组的中位数</a> <ul>
<li>暴力依次从前往后走 mid 步，此时是O(m+n)</li>
</ul>
</li>
<li><a href="#69-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7">有效的括号</a><ul>
<li>遇到左括号入栈，右括号如果能与栈顶左括号匹配则正确，不匹配返回false</li>
</ul>
</li>
<li><a href="#70-%E6%9C%80%E5%B0%8F%E6%A0%88">最小栈</a> <ul>
<li>用一个<strong>链表</strong>包含val和min两个成员变量，min用来保存最小值，入栈就是链表头结点<strong>头插一个新元素</strong>，出栈就是指向头结点下一个结点</li>
</ul>
</li>
<li><a href="#71-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81">字符串解码</a><ul>
<li>难，使用两个栈</li>
</ul>
</li>
<li><a href="#72-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6">每日温度</a> <ul>
<li>使用一个单调<strong>递减</strong>的栈，栈用来<strong>存储索引</strong></li>
<li>如果当前温度小于等于栈顶温度则入栈</li>
<li>当前温度大于栈顶元素，栈顶元素的天数更新并出栈</li>
</ul>
</li>
<li><a href="#73-%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱形图中最大的矩形</a><ul>
<li><strong>双指针暴力</strong>，以当前柱子<strong>向左向右</strong>，找比自己高度大(大于等于)的柱子，计算当前面积并更新</li>
</ul>
</li>
<li><a href="#74-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">数组中的第k个最大元素</a>  ⭐⭐⭐<ul>
<li>使用<strong>小顶堆</strong>，堆顶元素始终是最小的元素，如果当前元素大于堆顶元素，堆顶元素出堆，当前元素入堆，最后堆顶元素就是第k个大的元素；<strong>换句话说就是用小顶堆把k-1个小的元素挤出去</strong></li>
</ul>
</li>
<li><a href="#75-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">前k个高频元素</a><ul>
<li><strong>哈希表统计频率</strong>，用<strong>小根堆</strong>维护前k个高频元素</li>
<li><code>PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;(k,(l1, l2) -&gt; l1.getValue() - l2.getValue());</code></li>
<li><code>for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {}</code></li>
</ul>
</li>
<li><a href="#76-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">数据流的中位数</a> ⭐<ul>
<li>利用两个堆（<strong>大根堆+小根堆</strong>），</li>
<li>添加元素<strong>先添加到小顶堆</strong>，再把小顶堆的<strong>堆顶元素添加到大顶堆</strong>，</li>
<li>如果小顶堆大小小于大顶堆大小(<code>minHeap.size() &lt; maxHeap.size()</code>)，把<strong>大顶堆的堆顶元素添加到小顶堆</strong></li>
</ul>
</li>
<li><a href="#77-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">买卖股票的最佳时机</a><ul>
<li>要想卖的时候利润最多，就要在之前<strong>最便宜的时候买入</strong>，因此维护之前的<strong>最小值</strong>即可。</li>
</ul>
</li>
<li><a href="#78-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">跳跃游戏</a> <ul>
<li>维护一个 farthest 变量，记录能跳到的最远距离</li>
<li>如果<strong>当前索引超过了能跳到的最远距离，则跳不到终点</strong></li>
</ul>
</li>
<li><a href="#79-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii">跳跃游戏-ii</a><ul>
<li>局部最优，找到<strong>下一个能跳的最远的位置</strong>，找最大的(<strong>下一个位置索引加上下一个位置最大跳跃距离</strong>)</li>
<li>如果当前位置已经能到达终点，count++,跳出循环</li>
</ul>
</li>
<li><a href="#80-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4">划分字母区间</a><ul>
<li>使用<strong>哈希表</strong>保存每个字符的最后出现位置</li>
<li>若发现<strong>某个字符的最后出现位置超出了当前片段范围，则更新 nextIndex</strong></li>
</ul>
</li>
<li><a href="#81-%E7%88%AC%E6%A5%BC%E6%A2%AF">爬楼梯</a> ⭐<ul>
<li><code>dp[i]</code>： 爬到第i层楼梯，有<code>dp[i]</code>种方法</li>
</ul>
</li>
<li><a href="#82-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">杨辉三角</a><ul>
<li><code>dp[i][j]</code> 代表第i行第j列元素的值</li>
<li><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></li>
</ul>
</li>
<li><a href="#83-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">打家劫舍</a> <ul>
<li><code>dp[i]</code>：盗窃到第i间房间所获得的最高金额</li>
<li><code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code></li>
</ul>
</li>
<li><a href="#84-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">完全平方数</a><ul>
<li>转换为<strong>完全背包问题</strong><ul>
<li><code>dp[i][j]</code> 表示使用前 i 个完全平方数（1^2, 2^2, …, i^2）凑出 j 需要的最少个数。</li>
<li>不选当前平方数 i^2：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行）。</li>
<li>选择当前平方数 i^2：<code>dp[i][j] = dp[i][j - square] + 1</code>（选 i^2 之后，继续凑 j - i^2）</li>
</ul>
</li>
</ul>
</li>
<li><a href="#85-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">零钱兑换</a><ul>
<li>转换为<strong>完全背包问题</strong></li>
<li><code>dp[i][j]</code>：用前 i 种硬币，凑成金额 j 所需的最少硬币数量</li>
</ul>
</li>
<li><a href="#86-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">单词拆分</a> <ul>
<li><code>dp[i]</code> 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成</li>
<li><code>dp[i]</code>的值依赖于i<strong>之前某个 dp[j] &#x3D;&#x3D; true</strong>，说明 <code>s[0 ~ j-1]</code>可以用字典单词拼接。 s.substring(j, i) 必须在 wordDict 里面，说明 <strong>j~i-1 这一段是一个合法单词</strong></li>
</ul>
</li>
<li><a href="#87-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列</a><ul>
<li><code>dp[i]</code> 表示<strong>以 <code>nums[i]</code> 结尾的最长递增子序列的长度</strong></li>
<li>两次遍历：第一次遍历求每个以 nums[i] 结尾的最长递增子序列，第二次遍历i之前的元素，比较元素是否加入当前元素的后面作为结尾</li>
</ul>
</li>
<li><a href="#88-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84">乘积最大子数组</a> ⭐<ul>
<li>用max和min维护遍历到当前元素时的最大值和最小值</li>
<li>如果当前元素是<strong>负数</strong>，那么会导致<strong>最大的变最小的，最小的变最大的</strong>。因此交换两个的值。</li>
<li><code>max = Math.max(max * nums[i], nums[i])</code><ul>
<li>对于每一个 <code>nums[i]</code>，最大乘积有两种选择： </li>
<li>1️⃣ <strong>继续累乘</strong>：<code>max * nums[i]</code> —— 把前面的乘积继续乘上这个 nums[i]，不切断子数组。</li>
<li>2️⃣ <strong>重新开始</strong>：<code>nums[i]</code> —— 从当前位置 i 开始一个新的乘积子数组。</li>
</ul>
</li>
</ul>
</li>
<li><a href="#89-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">分割等和子集</a><ul>
<li><strong>转换为0-1背包问题</strong></li>
<li><code>dp[i][j]</code>：从前 i 个数里，能否选出一些数，使它们的和接近j</li>
</ul>
</li>
<li><a href="#90-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7">最长有效括号</a> ⭐<ul>
<li><code>dp[i]</code> 表示以下标 i <strong>结尾</strong>的最长有效括号子串的长度，主要在于分情况讨论</li>
<li>当 <code>s[i] == &#39;(&#39;</code> 时</li>
<li>当 <code>s[i] == &#39;)&#39;</code> 时<ul>
<li>如果 <code>s[i-1] == &#39;(&#39;</code></li>
<li>如果 <code>s[i-1] == &#39;)&#39;</code></li>
<li>如果 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="#91-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">不同路径</a> <ul>
<li><code>dp[i][j]</code>代表到达第i行第j列的不同路径有多少个</li>
</ul>
</li>
<li><a href="#92-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">最小路径和</a> <ul>
<li><code>dp[i][j]</code>:走到第i行第j列时的最小总和</li>
</ul>
</li>
<li><a href="#93-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">最长回文子串</a> ⭐⭐<ul>
<li>定义 <code>dp[i][j]</code> 表示字符串<strong>从索引 i 到 j 的子串是否是回文子串</strong></li>
<li>更长的子串，<code>s[i] == s[j]</code> 时，它是否回文取决于 <code>s[i+1:j-1]</code> 是否回文串</li>
<li><strong>外层循环 i 递减</strong>（从后往前遍历）,内层循环 j 递增（从左到右遍历）,因为 <code>dp[i][j]</code> 依赖于 <code>dp[i+1][j-1]</code></li>
</ul>
</li>
<li><a href="#94-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">最长公共子序列</a> ⭐⭐⭐ <ul>
<li><code>dp[i][j]</code>: text1前i个字符串和text2前j个字符串的最长公共子序列长度</li>
<li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li>如果i和j的字符不相同，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
</li>
<li><a href="#95-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">编辑距离</a>  ⭐<ul>
<li><code>dp[i][j]</code> 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符的最小操作数</li>
<li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] </code></li>
<li>如果i和j的字符不相同<ul>
<li>替换操作：dp[i-1][j-1] + 1</li>
<li>删除操作：dp[i-1][j] + 1</li>
<li>插入操作：dp[i][j-1] + 1</li>
</ul>
</li>
</ul>
</li>
<li><a href="#96-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">只出现一次的数字</a><ul>
<li>使用<strong>异或</strong>运算符(^)，a^a&#x3D;0,a^0&#x3D;a</li>
</ul>
</li>
<li><a href="#97-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0">多数元素</a><ul>
<li>res&#x3D;当前元素，用一个计数器，当<strong>出现自己时，计数+1</strong>，<strong>不是自己计数-1</strong>，当<strong>计数器&#x3D;0时，重新把res置为当前元素</strong></li>
</ul>
</li>
<li><a href="#98-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB">颜色分类</a><ul>
<li><strong>两个指针</strong>：一个指针<strong>指向0位置</strong>，依次存储0元素，一个指针<strong>指向数组结尾位置</strong>，依次存储2元素</li>
</ul>
</li>
<li><a href="#99-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">下一个排列</a> <ul>
<li><code>2, 6, 3, 5, 4, 1 --&gt; 2, 6, 4, 1, 3, 5</code> 分为以下几步：<ol>
<li>从后往前找到3</li>
<li>从后往前找，找到第一个大于3的数：4</li>
<li><code>swap(3,4)</code>，此时：<code>2, 6, 4, 5, 3, 1</code></li>
<li>最后<strong>反转5，3，1</strong>即可得到<code>2, 6, 4, 1, 3, 5</code></li>
</ol>
</li>
</ul>
</li>
<li><a href="#100-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0">寻找重复数</a> <ul>
<li><strong>快慢指针找环</strong>，相遇之后，将fast重新置为0，两个指针每次移动一步，再次相遇就是重复数所在位置</li>
<li><code>fast = nums[nums[fast]]</code> &#x2F;&#x2F; 快指针每次移动两步</li>
<li><code>slow = nums[slow]</code> &#x2F;&#x2F; 慢指针每次移动一步</li>
</ul>
</li>
</ol>
<hr>
<ol start="201">
<li><a href="#201-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">合并两个有序数组</a> ⭐<ul>
<li><strong>双指针从后往前合并</strong>，避免覆盖还没处理的数据</li>
</ul>
</li>
<li><a href="#202-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0">字符串相加</a> ⭐⭐<ul>
<li>从 num1 和 num2 的末尾开始，一位一位相加,记得进位</li>
</ul>
</li>
<li><a href="#203-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0">最小k个数</a> ⭐<ul>
<li>使用<strong>大顶堆</strong>（PriorityQueue）来筛选数组中最小的 k 个数</li>
</ul>
</li>
<li><a href="#204-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii">买卖股票的最佳时机-ii</a><ul>
<li>贪心：<strong>只要今天比昨天大，就卖出</strong></li>
</ul>
</li>
<li><a href="#205-%E6%9C%80%E5%A4%A7%E6%95%B0">最大数</a><ul>
<li>使用<strong>自定义排序规则</strong>：<code>Arrays.sort(strNums,(a,b)-&gt;(b+a).compareTo(a+b));</code></li>
</ul>
</li>
<li><a href="#206-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80">最长公共前缀</a><ul>
<li>用第一个字符串的每个字符，依次与后面所有字符串的相应字符进行比较即可</li>
</ul>
</li>
<li><a href="#207-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">重排链表</a> ⭐⭐⭐⭐⭐<ul>
<li><strong>重排链表&#x3D;找链表中点+反转链表+合并链表</strong></li>
</ul>
</li>
<li><a href="#208-%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80">复原ip地址</a><ul>
<li><strong>回溯算法</strong></li>
</ul>
</li>
<li><a href="#209-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">排序数组</a><ul>
<li><strong>快速排序</strong>：O(nlogn)</li>
</ul>
</li>
<li><a href="#210-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ab">多线程交替打印ab</a><ul>
<li>synchronized+wait()&#x2F;notify()</li>
</ul>
</li>
</ol>
<hr>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><ul>
<li><strong>一句话总结</strong>：使用HashMap存储数组元素，查询map中是否存在target-nums[i]</li>
</ul>
<h2 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h2><ul>
<li>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</li>
<li>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
<h2 id="1-2-算法思想和代码实现"><a href="#1-2-算法思想和代码实现" class="headerlink" title="1.2 算法思想和代码实现"></a>1.2 算法思想和代码实现</h2><h3 id="1-2-1-暴力枚举法"><a href="#1-2-1-暴力枚举法" class="headerlink" title="1.2.1 暴力枚举法"></a>1.2.1 暴力枚举法</h3><p>通过<strong>两层循环遍历数组</strong>的每一对元素，判断它们的和是否等于目标值 target。如果找到符合条件的两个数，你就将它们的下标保存在结果数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                    result[<span class="hljs-number">0</span>] = i;<br>                    result[<span class="hljs-number">1</span>] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-2-哈希表实现"><a href="#1-2-2-哈希表实现" class="headerlink" title="1.2.2 哈希表实现"></a>1.2.2 哈希表实现</h3><p>使用 哈希表（HashMap） 来实现 O(n) 的时间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2. 字母异位词分组"></a>2. 字母异位词分组</h1><ul>
<li><strong>一句话总结</strong>：转换为字符数组使用Arrays.sort()进行排序，排序后查询哈希表，放入<code>HashMap&lt;String,List&lt;String&gt;&gt;</code>中，键为排序后字符串，值为原始字符串的集合</li>
</ul>
<h2 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h2><ul>
<li>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</li>
<li><strong>字母异位词</strong>： 是由重新排列源单词的所有字母得到的一个新单词。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="2-2-算法思想和代码实现"><a href="#2-2-算法思想和代码实现" class="headerlink" title="2.2 算法思想和代码实现"></a>2.2 算法思想和代码实现</h2><h3 id="2-2-1-方法1"><a href="#2-2-1-方法1" class="headerlink" title="2.2.1 方法1"></a>2.2.1 方法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 将第一个元素放入第一个分组</span><br>    List&lt;String&gt; firstGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    firstGroup.add(strs[<span class="hljs-number">0</span>]);<br>    ans.add(firstGroup);<br><br>    <span class="hljs-comment">// 遍历剩余的字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记是否找到匹配的分组</span><br><br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; group : ans) &#123;<br>            <span class="hljs-keyword">if</span> (isSameWords(strs[i], group.get(<span class="hljs-number">0</span>))) &#123; <span class="hljs-comment">// 和已有分组的第一个元素比较</span><br>                group.add(strs[i]);<br>                found = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到匹配的分组后跳出</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有找到匹配的分组，则创建新的分组</span><br>        <span class="hljs-keyword">if</span> (!found) &#123;<br>            List&lt;String&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            newList.add(strs[i]);<br>            ans.add(newList);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 判断两个字符串是否是异位词</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameWords</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str1.length() != str2.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>[] ch1 = str1.toCharArray();<br>    <span class="hljs-type">char</span>[] ch2 = str2.toCharArray();<br>    Arrays.sort(ch1);<br>    Arrays.sort(ch2);<br><br>    <span class="hljs-keyword">return</span> Arrays.equals(ch1, ch2);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-2-方法2"><a href="#2-2-2-方法2" class="headerlink" title="2.2.2 方法2"></a>2.2.2 方法2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为空判断</span><br>        <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br><br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-comment">// 转换为字符数组并对其排序</span><br>            <span class="hljs-type">char</span>[] chars = strs[i].toCharArray();<br>            Arrays.sort(chars);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sortedChars</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br><br>            <span class="hljs-comment">// 在哈希表中查询是否存在，存在则添加到集合中，不存在创建一个新的键值对，值为集合列表</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(sortedChars)) &#123;<br>                map.get(sortedChars).add(strs[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(sortedChars, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                map.get(sortedChars).add(strs[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将哈希表中的值添加到结果集合中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : map.entrySet()) &#123;<br>            res.add(entry.getValue());<br>        &#125;<br><br><span class="hljs-comment">//        //返回遍历map的所有值</span><br><span class="hljs-comment">//        return new ArrayList&lt;&gt;(map.values());</span><br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="3-最长连续序列"><a href="#3-最长连续序列" class="headerlink" title="3. 最长连续序列"></a>3. 最长连续序列</h1><ul>
<li><strong>一句话总结</strong>：使用HashSet去重后，遍历HashSet,当<code>nums[i]-1</code>不存在时开始从<code>nums[i]</code>往后查询，不断查询<code>nums[i]+1,nums[i]+2...</code></li>
</ul>
<h2 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">200</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure>

<h2 id="3-2-算法思想和代码实现"><a href="#3-2-算法思想和代码实现" class="headerlink" title="3.2 算法思想和代码实现"></a>3.2 算法思想和代码实现</h2><h3 id="3-2-1-HashSet-去重-排序-遍历"><a href="#3-2-1-HashSet-去重-排序-遍历" class="headerlink" title="3.2.1  HashSet 去重 + 排序 + 遍历"></a>3.2.1  HashSet 去重 + 排序 + 遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//使用HashSet去重</span><br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-type">int</span>[] nums1=  set.stream().mapToInt(i -&gt; i).toArray();<br><br>    <span class="hljs-comment">//对数组元素排序</span><br>    Arrays.sort(nums1);<br><br>    <span class="hljs-comment">//遍历数组，对符合的最长序列进行计数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums1.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums1[i]==nums1[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)&#123;<br>            max++;<br>            <span class="hljs-keyword">if</span>(max&gt;res)<br>                res = max;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            max=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-2-使用-哈希表（HashSet）-贪心"><a href="#3-2-2-使用-哈希表（HashSet）-贪心" class="headerlink" title="3.2.2 使用 哈希表（HashSet）+ 贪心"></a>3.2.2 使用 哈希表（HashSet）+ 贪心</h3><ol>
<li>先用 HashSet 存储所有数字，去重并提供 O(1) 时间复杂度的查询。</li>
<li>遍历数组中的每个数字 num：<ul>
<li>如果 num-1 不在 set 中，说明它是一个连续序列的起点，开始寻找最长的连续序列。</li>
<li>依次检查 num+1, num+2，直到找不到为止，更新最长序列的长度。</li>
</ul>
</li>
<li>遍历完数组后，返回最长的连续序列长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        set.add(num); <span class="hljs-comment">// 添加到 HashSet 去重</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>        <span class="hljs-comment">// 只有当 num-1 不在集合中时，才从 num 开始找</span><br>        <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currNum</span> <span class="hljs-operator">=</span> num;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 不断查找 num+1，num+2...</span><br>            <span class="hljs-keyword">while</span> (set.contains(currNum + <span class="hljs-number">1</span>)) &#123;<br>                currNum++;<br>                currLen++;<br>            &#125;<br><br>            maxLen = Math.max(maxLen, currLen);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="4-移动零"><a href="#4-移动零" class="headerlink" title="4. 移动零"></a>4. 移动零</h1><p><strong>一句话总结：</strong></p>
<ul>
<li>第一遍遍历： j初始为0，j 作为非零元素的插入位置，把所有 非零元素 依次填入 <code>nums[j]</code></li>
<li>第二遍遍历： 把 j 之后的元素全部填 0</li>
</ul>
<h2 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<ul>
<li>请注意：必须在不复制数组的情况下原地对数组进行操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">0</span>]<br>输出: [<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<h2 id="4-2-算法思想和代码实现"><a href="#4-2-算法思想和代码实现" class="headerlink" title="4.2 算法思想和代码实现"></a>4.2 算法思想和代码实现</h2><h3 id="4-2-1-双指针"><a href="#4-2-1-双指针" class="headerlink" title="4.2.1 双指针"></a>4.2.1 双指针</h3><ol>
<li>维护一个指针 j，表示当前应当放置非零元素的位置（即 左侧应保持所有的非零元素）</li>
<li>遍历整个数组：<ul>
<li>遇到 非零元素：让 j 右移一位，并将该非零元素与 j 位置的元素交换。</li>
<li>遇到 零元素：继续遍历，不执行任何操作（即 j 不变）。</li>
</ul>
</li>
<li>最终所有 0 会被推到数组末尾，而所有非零元素保持相对顺序不变。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>            j++;  <span class="hljs-comment">// j 指向当前应存放非零元素的位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i]; <span class="hljs-comment">// 交换 nums[i] 和 nums[j]</span><br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-2-双指针-方法2"><a href="#4-2-2-双指针-方法2" class="headerlink" title="4.2.2 双指针(方法2)"></a>4.2.2 双指针(方法2)</h3><p>第一遍遍历： j 作为非零元素的插入位置，把所有 非零元素 依次填入 nums[j] 。<br>第二遍遍历： 把 j 之后的元素全部填 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// j 记录非零元素该存放的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>            nums[j++] = nums[i]; <span class="hljs-comment">// 把非零元素依次放入左侧</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将剩余的部分填充 0</span><br>    <span class="hljs-keyword">while</span> (j &lt; nums.length) &#123;<br>        nums[j++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="5-盛最多水的容器"><a href="#5-盛最多水的容器" class="headerlink" title="5. 盛最多水的容器"></a>5. 盛最多水的容器</h1><ul>
<li><strong>一句话总结：</strong> left从左，right从右向中间移动，计算区间面积，每次计算后<strong>移动高度较小的指针</strong>，向中间靠拢</li>
</ul>
<h2 id="5-1-题目描述"><a href="#5-1-题目描述" class="headerlink" title="5.1 题目描述"></a>5.1 题目描述</h2><ul>
<li>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</li>
<li>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</li>
<li>返回容器可以储存的最大水量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure>

<h2 id="5-2-算法思想和代码实现"><a href="#5-2-算法思想和代码实现" class="headerlink" title="5.2 算法思想和代码实现"></a>5.2 算法思想和代码实现</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><ol>
<li>双指针初始化：<ul>
<li>用 left 指向数组的起始位置（左端）。</li>
<li>用 right 指向数组的末尾（右端）。</li>
<li>计算当前双指针围成的水容量 currentWater &#x3D; (right - left) * Math.min(height[left], height[right])，并更新 maxWater。</li>
</ul>
</li>
<li>双指针移动策略：<ul>
<li>移动高度较小的指针，向中间靠拢：</li>
<li>如果 height[left] &lt; height[right]，则 left++，因为移动较矮的边可能会遇到更高的边，使得最小高度变大，从而可能获得更大面积。</li>
<li>否则 right–，类似地希望遇到更高的柱子增加容积。</li>
</ul>
</li>
<li>终止条件：<ul>
<li>当 left &gt;&#x3D; right 时，搜索结束，返回 maxWater。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentArea</span> <span class="hljs-operator">=</span> (right - left) * Math.min(height[left], height[right]);<br><br>        maxArea = Math.max(maxArea, currentArea);<br><br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right])<br>            left++;<br>        <span class="hljs-keyword">else</span> right--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6. 三数之和"></a>6. 三数之和</h1><p><strong>一句话总结：</strong> </p>
<ul>
<li>先排序，三个指针：<ul>
<li>i : 从0到nums.length-2遍历</li>
<li>left: 从i+1往后遍历</li>
<li>right：从nums.length-1往前遍历</li>
</ul>
</li>
<li>如果sum&#x3D;0: left++,right–; 如果sum&gt;0: right–; 如果sum&lt;0: left++;</li>
<li>i 在遍历时，跳过相同的 nums[i];  left 和 right 指针移动时，也要跳过重复值</li>
</ul>
<h2 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1 题目描述"></a>6.1 题目描述</h2><ul>
<li>给你一个整数数组 nums </li>
<li>判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k </li>
<li>同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 </li>
<li>请你返回所有和为 0 且不重复的三元组。</li>
</ul>
<p>注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>]<br>输出：[[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>解释：<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] = (-<span class="hljs-number">1</span>) + <span class="hljs-number">0</span> + <span class="hljs-number">1</span> = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span> + <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>) = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">3</span>] + nums[<span class="hljs-number">4</span>] = (-<span class="hljs-number">1</span>) + <span class="hljs-number">2</span> + (-<span class="hljs-number">1</span>) = <span class="hljs-number">0</span> 。<br>不同的三元组是 [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure>

<h2 id="6-2-算法思想和代码实现"><a href="#6-2-算法思想和代码实现" class="headerlink" title="6.2 算法思想和代码实现"></a>6.2 算法思想和代码实现</h2><h3 id="双指针法-排序"><a href="#双指针法-排序" class="headerlink" title="双指针法+排序"></a>双指针法+排序</h3><ol>
<li>对 nums 进行排序：这样可以方便地跳过重复元素，并且利用双指针寻找目标值。</li>
<li>遍历 nums 作为第一个元素：<ul>
<li>设 nums[i] 作为三元组中的 第一个数。</li>
<li>采用 双指针 方法，在 nums[i] 右侧找到 两个数 使得 nums[i] + nums[left] + nums[right] &#x3D; 0。</li>
</ul>
</li>
<li>使用左右双指针 (left 和 right)：<ul>
<li>初始 left &#x3D; i + 1，right &#x3D; nums.length - 1。</li>
<li>如果 sum &gt; 0，说明 right 选得过大，右指针 right–。</li>
<li>如果 sum &lt; 0，说明 left 选得过小，左指针 left++。</li>
<li>如果 sum &#x3D;&#x3D; 0，找到一组解，存入结果集。</li>
</ul>
</li>
<li>避免重复解：<ul>
<li>i 在遍历时，跳过相同的 nums[i] 。</li>
<li>left 和 right 指针移动时，也要跳过重复值。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums); <span class="hljs-comment">// 先排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-comment">// 跳过重复的 `nums[i]`</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br><br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br><br>                <span class="hljs-comment">// 跳过重复的 `left` 和 `right`</span><br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br><br>                left++;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                left++; <span class="hljs-comment">// 和太小，移动左指针</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--; <span class="hljs-comment">// 和太大，移动右指针</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="7-接雨水"><a href="#7-接雨水" class="headerlink" title="7. 接雨水"></a>7. 接雨水</h1><ul>
<li><strong>一句话描述：</strong></li>
</ul>
<h2 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：height = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure>

<h2 id="7-2-算法思想和代码实现"><a href="#7-2-算法思想和代码实现" class="headerlink" title="7.2 算法思想和代码实现"></a>7.2 算法思想和代码实现</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>左右指针从两端往中间移动，记录左右最大高度</li>
<li>当左低右高时，左位置接水量由左最大高度决定</li>
<li>当左高右低时，右位置接水量由右最大高度决定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sumOfWater</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 更新左右最大高度</span><br>        leftMax = Math.max(leftMax, height[left]);<br>        rightMax = Math.max(rightMax, height[right]);<br><br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>            <span class="hljs-comment">// 左低右高，左位置接水量由左最大高度决定</span><br>            sumOfWater += leftMax - height[left];<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 左高右低，右位置接水量由右最大高度决定</span><br>            sumOfWater += rightMax - height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sumOfWater;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="全部面积-柱子的面积-水的面积"><a href="#全部面积-柱子的面积-水的面积" class="headerlink" title="全部面积-柱子的面积&#x3D;水的面积"></a>全部面积-柱子的面积&#x3D;水的面积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">sumHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">maxHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>          sumHeight += height[i];<br>          maxHeight = Math.max(maxHeight, height[i]);<br>      &#125;<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">sumAll</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= maxHeight; i++) &#123;<br>          <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; height[l] &lt; i) l++;<br>          <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; height[r] &lt; i) r--;<br>          sumAll += r - l + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sumAll - sumHeight;<br>  &#125;<br></code></pre></td></tr></table></figure>




<h1 id="8-无重复字符的最长字串"><a href="#8-无重复字符的最长字串" class="headerlink" title="8. 无重复字符的最长字串"></a>8. 无重复字符的最长字串</h1><ul>
<li><strong>一句话总结：</strong> 用一个集合ArrayList维护当前的无重复子串,遍历字符串，如果当前字符已在list集合中重复，记录当前最大值，删除list中重复元素及以前的元素，添加当前元素</li>
</ul>
<h2 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;abcabcbb&quot;</span><br>输出: <span class="hljs-number">3</span> <br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;abc&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure>

<h2 id="8-2-算法思想和代码实现"><a href="#8-2-算法思想和代码实现" class="headerlink" title="8.2 算法思想和代码实现"></a>8.2 算法思想和代码实现</h2><h3 id="滑动窗口（基于列表维护的窗口）"><a href="#滑动窗口（基于列表维护的窗口）" class="headerlink" title="滑动窗口（基于列表维护的窗口）"></a>滑动窗口（基于列表维护的窗口）</h3><p>该算法用于求解无重复字符的最长子串长度，使用了滑动窗口的思想，通过一个 <code>List&lt;Character&gt;</code> 维护当前的无重复子串。</p>
<ol>
<li>初始化<ul>
<li>维护 maxSubstringLength 记录最长无重复子串的长度。</li>
<li>用 <code>List&lt;Character&gt;</code> 作为滑动窗口，初始时加入 <code>s[0]</code>。</li>
</ul>
</li>
<li>遍历字符串<ul>
<li>若 <code>s[i]</code> 已在窗口中，说明出现重复：</li>
<li>更新 maxSubstringLength。</li>
<li>删除窗口内重复字符及其之前的字符，确保窗口无重复。</li>
<li>将 <code>s[i]</code> 加入窗口，继续扩展子串。</li>
</ul>
</li>
<li>遍历结束后，检查 chars 长度是否比 maxSubstringLength 更大，取最大值返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">1</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>       List&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>           <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br><br>           <span class="hljs-comment">// 当前字符已存在，记录最大值，删除list中重复元素及以前的元素</span><br>           <span class="hljs-keyword">if</span> (list.contains(c)) &#123;<br>               max = Math.max(max, list.size());<br>               <br>               <span class="hljs-keyword">while</span> (list.get(<span class="hljs-number">0</span>) != c) &#123;<br>                   list.remove(<span class="hljs-number">0</span>);<br>               &#125;<br>               list.remove(<span class="hljs-number">0</span>);<br>           &#125;<br><br>           <span class="hljs-comment">// 无论重复不重复，list最后加上当前元素</span><br>           list.add(c);<br>       &#125;<br>       max = Math.max(max, list.size());<br>       <span class="hljs-keyword">return</span> max;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h1 id="9-找到字符串中所有字母异位词"><a href="#9-找到字符串中所有字母异位词" class="headerlink" title="9. 找到字符串中所有字母异位词"></a>9. 找到字符串中所有字母异位词</h1><ul>
<li><strong>一句话总结：</strong> 滑动窗口 + 频率数组比较；维护两个长度为26的数组来比较窗口内的字符频率是否和 p 匹配，每次移除窗口左边的元素，添加新字符到窗口的右侧</li>
</ul>
<h2 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, p = <span class="hljs-string">&quot;abc&quot;</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]<br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure>

<h2 id="9-2-算法思想和代码实现"><a href="#9-2-算法思想和代码实现" class="headerlink" title="9.2 算法思想和代码实现"></a>9.2 算法思想和代码实现</h2><h3 id="9-2-1-方法1"><a href="#9-2-1-方法1" class="headerlink" title="9.2.1 方法1"></a>9.2.1 方法1</h3><ol>
<li>首先对 p 字符串进行排序，并将其存储在 ch2 中。</li>
<li>遍历字符串 s 的每个子字符串，长度与 p 相同。</li>
<li>每次取出子字符串并对其进行排序，与 ch2 比较是否相同，如果相同，则说明该子字符串是 p 的异位词，记录其起始位置。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    List&lt;Integer&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//排除特殊情况：s&lt;p的长度等</span><br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span>||p==<span class="hljs-literal">null</span>||s.length()&lt;p.length()||s.length()==<span class="hljs-number">0</span>||p.length()==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-type">char</span>[] ch1=s.toCharArray();<br>    <span class="hljs-type">char</span>[] ch2=p.toCharArray();<br><br>    Arrays.sort(ch2); <span class="hljs-comment">//对字符数组p进行排序</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ch1.length-ch2.length+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-comment">//创建一个新的数组存储</span><br>        <span class="hljs-type">char</span>[] ch3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[ch2.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;ch2.length;j++)&#123;<br>            ch3[j]=ch1[i+j];<br>        &#125;<br>        Arrays.sort(ch3);<br>        <span class="hljs-keyword">if</span>(Arrays.equals(ch2,ch3))&#123;<span class="hljs-comment">//证明二者是异位词</span><br>            result.add(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-2-2-滑动窗口-频率数组比较"><a href="#9-2-2-滑动窗口-频率数组比较" class="headerlink" title="9.2.2 滑动窗口 + 频率数组比较"></a>9.2.2 滑动窗口 + 频率数组比较</h3><ol>
<li>使用两个长度为 26 的频率数组，charP 存储 p 的字符频率，charS 存储当前滑动窗口中字符的频率。</li>
<li>滑动窗口从左到右逐字符遍历 s：<ul>
<li>每次将窗口右边界的字符加入 charS。</li>
<li>如果窗口的大小超过 p 的长度，则移除窗口左边界的字符。</li>
</ul>
</li>
<li>每次窗口调整后，比较 charP 和 charS，如果相等，则说明当前窗口是 p 的异位词。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    <span class="hljs-comment">// 如果主串 s 的长度小于模式串 p，直接返回空列表（不可能有异位词）</span><br>    <span class="hljs-keyword">if</span> (s.length() &lt; p.length())<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 用两个数组统计字符出现次数，长度为26代表26个小写字母</span><br>    <span class="hljs-type">int</span>[] charS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 用于滑动窗口中当前子串的字符计数</span><br>    <span class="hljs-type">int</span>[] charP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 用于模式串 p 的字符计数</span><br><br>    <span class="hljs-comment">// 统计模式串 p 中每个字符出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charP[index]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化滑动窗口，统计 s 的前 p.length() 个字符的频率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charS[index]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 滑动窗口开始滑动，从索引 p.length() 开始，直到 s 的结尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 如果当前窗口的字符频率和目标频率相同，则记录起始索引</span><br>        <span class="hljs-keyword">if</span> (Arrays.equals(charS, charP)) &#123;<br>            list.add(i - p.length());<br>        &#125;<br>        <span class="hljs-comment">// 将窗口左边的字符移除</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charS[index]--;<br>        <span class="hljs-comment">// 加入窗口右边的新字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curI</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charS[curI]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查最后一个窗口是否匹配</span><br>    <span class="hljs-keyword">if</span> (Arrays.equals(charS, charP)) &#123;<br>        list.add(s.length() - p.length());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="10-和为K的子数组"><a href="#10-和为K的子数组" class="headerlink" title="10. 和为K的子数组"></a>10. 和为K的子数组</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li><strong>前缀和 + 哈希表</strong><ul>
<li>哈希表：Key存储前缀和，Value存储这个前缀和出现的次数</li>
<li>通过 prefixSum - k 计算是否有之前的前缀和能构成和 k 的子数组</li>
<li>加上之前的前缀和出现的次数即可</li>
</ul>
</li>
</ul>
<h2 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h2><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的连续非空序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br><br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="10-2-算法思想和代码实现"><a href="#10-2-算法思想和代码实现" class="headerlink" title="10.2 算法思想和代码实现"></a>10.2 算法思想和代码实现</h2><h3 id="10-2-1-暴力遍历"><a href="#10-2-1-暴力遍历" class="headerlink" title="10.2.1 暴力遍历"></a>10.2.1 暴力遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>||nums.length==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> sum=nums[i];<br>        <span class="hljs-keyword">if</span>(sum==k)&#123;<br>            result++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;<br>            sum+=nums[j];<br>            <span class="hljs-keyword">if</span>(sum==k)&#123;<br>                result++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(nums[nums.length-<span class="hljs-number">1</span>]==k)<br>        result++;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="10-2-2-前缀和-哈希表（O-n-）-前缀和-前面的某个前缀和-这段区间的和"><a href="#10-2-2-前缀和-哈希表（O-n-）-前缀和-前面的某个前缀和-这段区间的和" class="headerlink" title="10.2.2 前缀和 + 哈希表（O(n)）|| 前缀和 - 前面的某个前缀和 &#x3D; 这段区间的和"></a>10.2.2 前缀和 + 哈希表（O(n)）|| 前缀和 - 前面的某个前缀和 &#x3D; 这段区间的和</h3><ul>
<li>前缀和：利用 prefixSum[j] - prefixSum[i] &#x3D; k 的性质，我们可以快速判断子数组 [i+1, j] 是否符合要求。</li>
<li>哈希表：用 HashMap 存储前缀和的出现次数，避免重复计算，达到 O(n) 的时间复杂度。</li>
</ul>
<ol>
<li>维护前缀和，计算 prefixSum &#x3D; sum(0…j)。</li>
<li>通过 prefixSum - k 计算是否有之前的前缀和能构成和 k 的子数组。</li>
<li>使用 HashMap 记录 prefixSum 出现的次数，以便快速查找是否存在满足条件的子数组。</li>
</ol>
<ul>
<li>但是答案中为什么是查找 pre - k? pre - k 又代表了什么？</li>
<li>这里要做个公式转换：<ul>
<li>preSum[j] - preSum[i] &#x3D; k &#x3D;&gt; preSum[j] - k &#x3D; preSum[i]</li>
<li>当前下标为 j，要寻找另一个下标i，他的前缀和与j的前缀和差值为k！！</li>
</ul>
</li>
<li>所以map中应该存储的就是下标为i时，其前缀和。</li>
<li>这样就好理解为什么在map中寻找的是 preSum[j] - k。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">prefixSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 处理从索引0开始的子数组</span><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>           prefixSum += num;  <span class="hljs-comment">// 计算前缀和</span><br>           <br>           <span class="hljs-comment">// 检查是否存在 prefixSum - k</span><br>           <span class="hljs-keyword">if</span> (map.containsKey(prefixSum - k)) &#123;<br>               count += map.get(prefixSum - k); <span class="hljs-comment">// 统计满足条件的子数组个数</span><br>           &#125;<br>           <br>           <span class="hljs-comment">// 记录当前前缀和出现的次数</span><br>           map.put(prefixSum, map.getOrDefault(prefixSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> count;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h1 id="11-滑动窗口最大值"><a href="#11-滑动窗口最大值" class="headerlink" title="11. 滑动窗口最大值"></a>11. 滑动窗口最大值</h1><ul>
<li><strong>一句话描述：</strong> <strong>单调双端队列</strong>：使用双端队列(Deque)存储<strong>索引</strong>，在遍历数组时始终保持队列中元素对应的值<strong>单调递减</strong>，并在每次滑动窗口形成后，通过<strong>队头索引</strong>快速获取当前窗口的最大值，同时<strong>移除队头已滑出窗口范围的元素</strong>和<strong>队尾比当前元素小的元素</strong></li>
</ul>
<h2 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1 题目描述"></a>11.1 题目描述</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。<br>你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[<span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span>] -<span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> [<span class="hljs-number">3</span>  -<span class="hljs-number">1</span>  -<span class="hljs-number">3</span>] <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span> [-<span class="hljs-number">1</span>  -<span class="hljs-number">3</span>  <span class="hljs-number">5</span>] <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span> [-<span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>] <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span>  -<span class="hljs-number">3</span> [<span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>] <span class="hljs-number">7</span>       <span class="hljs-number">6</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span>  -<span class="hljs-number">3</span>  <span class="hljs-number">5</span> [<span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]      <span class="hljs-number">7</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h2 id="11-2-算法思想和代码实现"><a href="#11-2-算法思想和代码实现" class="headerlink" title="11.2 算法思想和代码实现"></a>11.2 算法思想和代码实现</h2><h3 id="单调双端队列"><a href="#单调双端队列" class="headerlink" title="单调双端队列"></a>单调双端队列</h3><ul>
<li>队头存放的是最大值</li>
<li>每次从队尾入队</li>
<li><strong>如何更新队头的最大值？</strong><ul>
<li>当新元素来的时候，从队尾往队头移动，把小于新元素的元素全部出队，然后从队尾入队</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] maxSlidingWindow2(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 移除超出窗口范围的元素</span><br>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="hljs-number">1</span>) &#123;<br>            deque.pollFirst();<br>        &#125;<br><br>        <span class="hljs-comment">// 维持队列单调递减，移除队尾小于当前元素的索引</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>            deque.pollLast();<br>        &#125;<br><br>        <span class="hljs-comment">// 添加当前元素索引</span><br>        deque.offerLast(i);<br><br>        <span class="hljs-comment">// 记录窗口最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="12-最小覆盖子串"><a href="#12-最小覆盖子串" class="headerlink" title="12. 最小覆盖子串"></a>12. 最小覆盖子串</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li><strong>滑动窗口+哈希表</strong><ul>
<li><strong>一个哈希表记录t</strong>的字符出现的次数，<strong>另一个哈希表记录s</strong>当前窗口的字符出现的次数</li>
<li>右指针right先往右移动，直到包含t所有的字符(借助valid记录窗口内满足条件的字符数)，记录当前最短子串的右边界</li>
<li>左指针left收缩窗口，尝试寻找更短的子串，记录当前最短子串的左边界</li>
</ul>
</li>
</ul>
<h2 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1 题目描述"></a>12.1 题目描述</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。<br>如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<ul>
<li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li>
<li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br>解释：最小覆盖子串 <span class="hljs-string">&quot;BANC&quot;</span> 包含来自字符串 t 的 <span class="hljs-string">&#x27;A&#x27;</span>、<span class="hljs-string">&#x27;B&#x27;</span> 和 <span class="hljs-string">&#x27;C&#x27;</span>。<br></code></pre></td></tr></table></figure>

<h2 id="12-2-算法思想和代码实现"><a href="#12-2-算法思想和代码实现" class="headerlink" title="12.2 算法思想和代码实现"></a>12.2 算法思想和代码实现</h2><h3 id="滑动窗口-哈希表"><a href="#滑动窗口-哈希表" class="headerlink" title="滑动窗口+哈希表"></a>滑动窗口+哈希表</h3><p>我们维护一个窗口 [left, right]，在窗口中寻找包含 t 所有字符的最小子串。</p>
<ol>
<li>使用 need 哈希表 记录 t 中所有字符及其出现的次数。</li>
<li>使用 window 哈希表 记录当前窗口内的字符出现次数。</li>
<li>右指针 right 扩展窗口，直到窗口包含 t 中所有字符。</li>
<li>左指针 left 收缩窗口，尝试寻找更短的子串，同时保证窗口仍然有效。</li>
<li>记录当前最短子串的 start 和 length，最终返回结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s.length() &lt; t.length()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 记录 t 中的字符及其数量</span><br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 滑动窗口左右指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录窗口内满足条件的字符数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, minLen = Integer.MAX_VALUE;  <span class="hljs-comment">// 记录最小子串的位置和长度</span><br><br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right); <span class="hljs-comment">// 右侧字符进入窗口</span><br>        right++; <span class="hljs-comment">// 右指针扩展窗口</span><br><br>        <span class="hljs-comment">// 如果是 t 需要的字符，则更新窗口数据</span><br>        <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                valid++;  <span class="hljs-comment">// 该字符的数量达标</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 当窗口包含 t 的所有字符时，尝试收缩窗口</span><br>        <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>            <span class="hljs-comment">// 记录最小子串</span><br>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;<br>                start = left;<br>                minLen = right - left;<br>            &#125;<br><br>            <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left); <span class="hljs-comment">// 左侧字符即将移出窗口</span><br>            left++; <span class="hljs-comment">// 左指针收缩窗口</span><br><br>            <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                    valid--;  <span class="hljs-comment">// 该字符不再满足要求</span><br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + minLen);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="13-最大子数组和"><a href="#13-最大子数组和" class="headerlink" title="13. 最大子数组和"></a>13. 最大子数组和</h1><ul>
<li><strong>一句话总结：</strong> <strong>局部最优 -&gt; 推导全局最优</strong> sum+&#x3D;当前元素，如果sum&gt;max，更新max；如果sum&lt;0，将sum重置为0(因为前面的子数组对后续没有正向贡献)</li>
</ul>
<h2 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1 题目描述"></a>13.1 题目描述</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组是数组中的一个连续部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">6</span><br>解释：连续子数组 [<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span> 。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="13-2-算法思想和代码实现"><a href="#13-2-算法思想和代码实现" class="headerlink" title="13.2 算法思想和代码实现"></a>13.2 算法思想和代码实现</h2><p>如果 sum 大于 max，说明找到了一个更大的子数组和，将 max 更新为 sum。如果 sum 小于等于 0，说明当前子数组对后续的和没有正向贡献，将 sum 重置为 0，从下一个元素开始重新考虑新的子数组。</p>
<ol>
<li>遍历数组 nums，更新 sum：</li>
<li>将 nums[i] 加入当前 sum，表示扩展当前子数组。</li>
<li>如果 sum &gt; max，更新 max，记录新的最大和。</li>
<li>如果 sum 变成负数（sum &lt;&#x3D; 0），说明当前子数组对后续部分无贡献，需要重新开始新的子数组（即 sum &#x3D; 0）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        sum += nums[i];<br><br>        <span class="hljs-comment">//如果 sum &gt; max，更新 max，记录新的最大和。</span><br>        max = Math.max(max, sum);<br><br>        <span class="hljs-comment">//如果 sum 变成负数（sum &lt;= 0），说明当前子数组对后续部分无贡献，需要重新开始新的子数组（即 sum = 0）。</span><br>        sum = Math.max(sum, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="14-合并区间"><a href="#14-合并区间" class="headerlink" title="14. 合并区间"></a>14. 合并区间</h1><ul>
<li><strong>一句话总结</strong>：</li>
<li>先根据start排序：<ul>
<li>上一个end小于下一个start：直接加入结果集，continue;</li>
<li>上一个end 大于等于下一个start: 有重复进行合并</li>
</ul>
</li>
</ul>
<h2 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1 题目描述"></a>14.1 题目描述</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br><br>示例 <span class="hljs-number">2</span>：<br>输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure>

<h2 id="14-2-算法思想和代码实现"><a href="#14-2-算法思想和代码实现" class="headerlink" title="14.2 算法思想和代码实现"></a>14.2 算法思想和代码实现</h2><h3 id="排序-遍历合并"><a href="#排序-遍历合并" class="headerlink" title="排序+遍历合并"></a>排序+遍历合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>      Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>      List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      list.add(intervals[<span class="hljs-number">0</span>]);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (list.getLast()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> list.getLast()[<span class="hljs-number">0</span>];<br>              <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> Math.max(list.getLast()[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>              list.removeLast();<br>              list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;first, last&#125;);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              list.add(intervals[i]);<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][<span class="hljs-number">2</span>]);<br>  &#125;<br></code></pre></td></tr></table></figure>


<h1 id="15-轮转数组"><a href="#15-轮转数组" class="headerlink" title="15. 轮转数组"></a>15. 轮转数组</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li><strong>三次翻转法</strong>：<ul>
<li>先整体翻转数组；再翻转前 k 个元素；最后翻转后 n-k个元素；</li>
</ul>
</li>
<li><strong>注意：</strong> k可能大于数组长度，所以要先对数组长度取模(k%&#x3D;nums.length;)</li>
</ul>
<h2 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1 题目描述"></a>15.1 题目描述</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>解释:<br>向右轮转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>向右轮转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>向右轮转 <span class="hljs-number">3</span> 步: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<h2 id="15-2-算法思想和代码实现"><a href="#15-2-算法思想和代码实现" class="headerlink" title="15.2 算法思想和代码实现"></a>15.2 算法思想和代码实现</h2><h3 id="三次翻转法-时间复杂度-O-n-，空间复杂度-O-1"><a href="#三次翻转法-时间复杂度-O-n-，空间复杂度-O-1" class="headerlink" title="三次翻转法 时间复杂度 O(n)，空间复杂度 O(1)"></a>三次翻转法 时间复杂度 O(n)，空间复杂度 O(1)</h3><ol>
<li>先整体翻转数组，得到 [7, 6, 5, 4, 3, 2, 1]</li>
<li>再翻转前 k&#x3D;3 个元素，变成 [5, 6, 7, 4, 3, 2, 1]</li>
<li>最后翻转后 n-k&#x3D;4 个元素，得到 [5, 6, 7, 1, 2, 3, 4]</li>
</ol>
<p>三次翻转的过程可以理解为：</p>
<ul>
<li>整体翻转 → 把右边 k 个元素移动到前面，但顺序错了</li>
<li>前 k 个元素翻转 → 让被移动到前面的元素恢复正确的顺序</li>
<li>后 n-k 个元素翻转 → 让剩余元素恢复正确的顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    k = k % n; <span class="hljs-comment">// 避免 k 超过数组长度</span><br><br>    reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 翻转整个数组</span><br>    reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 翻转前 k 个元素</span><br>    reverse(nums, k, n - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 翻转剩下的元素</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="16-除自身以外数组的乘积"><a href="#16-除自身以外数组的乘积" class="headerlink" title="16. 除自身以外数组的乘积"></a>16. 除自身以外数组的乘积</h1><ul>
<li><strong>一句话描述</strong>：<strong>前缀积和后缀积</strong>：第一次从前往后遍历，构建结果数组每个位置前缀乘积，第二次从后往前遍历乘上后缀乘积</li>
</ul>
<h2 id="16-1-题目描述"><a href="#16-1-题目描述" class="headerlink" title="16.1 题目描述"></a>16.1 题目描述</h2><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">24</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure>

<h2 id="16-2-算法思想和代码实现"><a href="#16-2-算法思想和代码实现" class="headerlink" title="16.2 算法思想和代码实现"></a>16.2 算法思想和代码实现</h2><h3 id="前缀积和后缀积"><a href="#前缀积和后缀积" class="headerlink" title="前缀积和后缀积"></a>前缀积和后缀积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, suf = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        res[i] = pre;<br>        pre *= nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        res[i] *= suf;<br>        suf *= nums[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="17-缺失的第一个正数"><a href="#17-缺失的第一个正数" class="headerlink" title="17. 缺失的第一个正数"></a>17. 缺失的第一个正数</h1><ul>
<li><strong>一句话总结：</strong> 将<code>[8,2,0,1,3,4]</code>遍历转换为<code>[1,2,3,4,0,8]</code>,通过原地<strong>交换</strong>的方式将正整数放到对应的位置上，然后从头遍历找到第一个不符合的正数</li>
</ul>
<h2 id="17-1-题目描述"><a href="#17-1-题目描述" class="headerlink" title="17.1 题目描述"></a>17.1 题目描述</h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">3</span><br>解释：范围 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 中的数字都在数组中。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">1</span> 在数组中，但 <span class="hljs-number">2</span> 没有。<br></code></pre></td></tr></table></figure>

<h2 id="17-2-算法思想和代码实现"><a href="#17-2-算法思想和代码实现" class="headerlink" title="17.2 算法思想和代码实现"></a>17.2 算法思想和代码实现</h2><h3 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h3><ul>
<li>由于缺失的最小正整数一定在 [1, N+1] 之间（其中 N 是 nums.length），我们可以利用数组本身作为哈希表，将每个元素放到正确的位置（即 nums[i] &#x3D;&#x3D; i + 1）。</li>
<li>然后再遍历数组，找到第一个 nums[i] !&#x3D; i + 1 的索引 i，即 i + 1 为缺失的最小正整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 将每个数放到正确的位置上，即 nums[i] = i + 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                swap(nums, nums[i] - <span class="hljs-number">1</span>, i);<br>                i--;  <span class="hljs-comment">// 退一步，重新检查交换过来的那个值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找到第一个 nums[i] != i + 1 的位置，返回 i + 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若数组是 [1,2,3,4] 这样完整的，则返回 n+1</span><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br></code></pre></td></tr></table></figure>


<h1 id="18-矩阵置零"><a href="#18-矩阵置零" class="headerlink" title="18. 矩阵置零"></a>18. 矩阵置零</h1><ul>
<li><strong>一句话总结：</strong> 利用<strong>矩阵的第一行和第一列作为标记位</strong>来记录哪一行、哪一列需要被置 0  <strong>注意：</strong> 标记记录的过程中应该跳过第一行和第一列</li>
</ul>
<h2 id="18-1-题目描述"><a href="#18-1-题目描述" class="headerlink" title="18.1 题目描述"></a>18.1 题目描述</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="18-2-算法思想和代码实现"><a href="#18-2-算法思想和代码实现" class="headerlink" title="18.2 算法思想和代码实现"></a>18.2 算法思想和代码实现</h2><h3 id="18-2-1-方法1"><a href="#18-2-1-方法1" class="headerlink" title="18.2.1 方法1"></a>18.2.1 方法1</h3><ol>
<li>第一遍遍历：使用 HashSet 记录包含 0 的行索引 setRow 和列索引 setColumn。</li>
<li>第二遍遍历：将所有 setColumn 中的列全部置 0。</li>
<li>第三遍遍历：将所有 setRow 中的行全部置 0。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">//创建两个哈希表用来存储为0的行和列值</span><br>    HashSet&lt;Integer&gt; setRow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>    HashSet&lt;Integer&gt; setColumn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br><br>    <span class="hljs-comment">//遍历矩阵，找到为0的元素的行和列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)&#123;<br>                setRow.add(i);<br>                setColumn.add(j);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-comment">//将有0的列都置为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">for</span>(Integer j:setColumn)<br>            matrix[i][j]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//将有0的行都置为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        <span class="hljs-keyword">for</span>(Integer i:setRow)<br>            matrix[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="18-2-2-方法2（O-1-空间复杂度）"><a href="#18-2-2-方法2（O-1-空间复杂度）" class="headerlink" title="18.2.2 方法2（O(1) 空间复杂度）"></a>18.2.2 方法2（O(1) 空间复杂度）</h3><p>我们可以 利用矩阵的第一行和第一列作为标记位 来记录哪一行、哪一列需要被置 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRowZero</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, firstColZero = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 1. 检查第一列是否有 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            firstColZero = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 检查第一行是否有 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>            firstRowZero = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 使用第一行和第一列记录需要置 0 的行和列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录该行需要清零</span><br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录该列需要清零</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 置 0（根据第一行和第一列的标记）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 处理第一列</span><br>    <span class="hljs-keyword">if</span> (firstColZero) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 处理第一行</span><br>    <span class="hljs-keyword">if</span> (firstRowZero) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="19-螺旋矩阵"><a href="#19-螺旋矩阵" class="headerlink" title="19. 螺旋矩阵"></a>19. 螺旋矩阵</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>定义top, bottom, left, right<strong>四个边界变量</strong>控制遍历范围</li>
<li>按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素</li>
<li><strong>注意：最后两个遍历(往左和往上)要判断是否还有行或列剩下</strong></li>
</ul>
<h2 id="19-1-题目描述"><a href="#19-1-题目描述" class="headerlink" title="19.1 题目描述"></a>19.1 题目描述</h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>

<h2 id="19-2-算法思想和代码实现"><a href="#19-2-算法思想和代码实现" class="headerlink" title="19.2 算法思想和代码实现"></a>19.2 算法思想和代码实现</h2><h3 id="按照-右-→-下-→-左-→-上-的顺序依次遍历矩阵的元素。"><a href="#按照-右-→-下-→-左-→-上-的顺序依次遍历矩阵的元素。" class="headerlink" title="按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素。"></a>按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素。</h3><p>我们可以使用 四个边界变量 控制遍历范围：</p>
<ul>
<li>top：当前未遍历的上边界</li>
<li>bottom：当前未遍历的下边界</li>
<li>left：当前未遍历的左边界</li>
<li>right：当前未遍历的右边界<br>在遍历过程中，每遍历完一圈，就收缩对应的边界，直到所有元素都被访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>     List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>     <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><br>     <span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<br>         <span class="hljs-comment">// 从左到右</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left; j &lt;= right; j++) &#123;<br>             result.add(matrix[top][j]);<br>         &#125;<br>         top++; <span class="hljs-comment">// 上边界收缩</span><br><br>         <span class="hljs-comment">// 从上到下</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>             result.add(matrix[i][right]);<br>         &#125;<br>         right--; <span class="hljs-comment">// 右边界收缩</span><br><br>         <span class="hljs-comment">// 判断是否还有行需要遍历</span><br>         <span class="hljs-keyword">if</span> (top &lt;= bottom) &#123;<br>             <span class="hljs-comment">// 从右到左</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right; j &gt;= left; j--) &#123;<br>                 result.add(matrix[bottom][j]);<br>             &#125;<br>             bottom--; <span class="hljs-comment">// 下边界收缩</span><br>         &#125;<br><br>         <span class="hljs-comment">// 判断是否还有列需要遍历</span><br>         <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>             <span class="hljs-comment">// 从下到上</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                 result.add(matrix[i][left]);<br>             &#125;<br>             left++; <span class="hljs-comment">// 左边界收缩</span><br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure>

<h1 id="20-旋转图像"><a href="#20-旋转图像" class="headerlink" title="20. 旋转图像"></a>20. 旋转图像</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li><strong>旋转&#x3D;转置+翻转</strong><ol>
<li>先转置：将 <code>matrix[i][j]</code> 变成 <code>matrix[j][i]</code>。</li>
<li>再水平翻转：让 <code>matrix[j][i]</code> 变成 <code>matrix[j][n-1-i]</code>。</li>
</ol>
</li>
</ul>
<h2 id="20-1-题目描述"><a href="#20-1-题目描述" class="headerlink" title="20.1 题目描述"></a>20.1 题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[[<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="20-2-算法思想和代码实现"><a href="#20-2-算法思想和代码实现" class="headerlink" title="20.2 算法思想和代码实现"></a>20.2 算法思想和代码实现</h2><h3 id="转置-翻转"><a href="#转置-翻转" class="headerlink" title="转置+翻转"></a>转置+翻转</h3><ol>
<li>转置矩阵（行变列，列变行）</li>
<li>翻转每一行（实现 90° 旋转）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">假设 matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]：<br><br>第一步：转置矩阵<br>转置后（行变列，列变行）：<br><span class="hljs-number">1</span>  <span class="hljs-number">4</span>  <span class="hljs-number">7</span><br><span class="hljs-number">2</span>  <span class="hljs-number">5</span>  <span class="hljs-number">8</span><br><span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">9</span><br><br>第二步：翻转每一行<br>左右翻转后：<br><span class="hljs-number">7</span>  <span class="hljs-number">4</span>  <span class="hljs-number">1</span><br><span class="hljs-number">8</span>  <span class="hljs-number">5</span>  <span class="hljs-number">2</span><br><span class="hljs-number">9</span>  <span class="hljs-number">6</span>  <span class="hljs-number">3</span><br>最终结果符合要求！<br></code></pre></td></tr></table></figure>

<h4 id="为什么旋转-转置-翻转？"><a href="#为什么旋转-转置-翻转？" class="headerlink" title="为什么旋转&#x3D;转置+翻转？"></a>为什么旋转&#x3D;转置+翻转？</h4><p>旋转的最终的目标公式 matrix[i][j] → matrix[j][n-1-i]<br>拆解成两步：</p>
<ol>
<li>先转置：将 matrix[i][j] 变成 matrix[j][i]。</li>
<li>再水平翻转：让 matrix[j][i] 变成 matrix[j][n-1-i]。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br><br>    <span class="hljs-comment">//先转置矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[j][i];<br>            matrix[j][i] = temp;<br>        &#125;<br><br>    <span class="hljs-comment">//在反转每一行(左右翻转)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n/<span class="hljs-number">2</span>;j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[i][n-<span class="hljs-number">1</span>-j];<br>            matrix[i][n-<span class="hljs-number">1</span>-j] = temp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="21-搜索二维矩阵-II"><a href="#21-搜索二维矩阵-II" class="headerlink" title="21. 搜索二维矩阵 II"></a>21. 搜索二维矩阵 II</h1><ul>
<li><strong>一句话总结：</strong> 从右上角出发，向下或向左移动，或返回true</li>
</ul>
<h2 id="21-1-题目描述"><a href="#21-1-题目描述" class="headerlink" title="21.1 题目描述"></a>21.1 题目描述</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">19</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>,<span class="hljs-number">26</span>,<span class="hljs-number">30</span>]], target = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h2 id="21-2-算法思想和代码实现"><a href="#21-2-算法思想和代码实现" class="headerlink" title="21.2 算法思想和代码实现"></a>21.2 算法思想和代码实现</h2><h3 id="从右上角出发"><a href="#从右上角出发" class="headerlink" title="从右上角出发"></a>从右上角出发</h3><p>就是要选择一个点，使得横向和纵向移动，martix能够有不同的变化</p>
<ul>
<li>左上角：往右往下移动，martix值都变大，无法区分，不可用</li>
<li>右上角：往左martix变小，往下martix变大，可区分，可用</li>
<li>左下角：往右martix变大，往上martix变小，可区分，可用</li>
<li>右下角：往左往上移动，martix都变小，不可区分，不可用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">//从矩阵的右上角出发</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果相等返回true</span><br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果大于target，往左移动</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target)<br>            j--;<br>            <span class="hljs-comment">//如果小于target，往下移动</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target)<br>            i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="22-相交链表"><a href="#22-相交链表" class="headerlink" title="22. 相交链表"></a>22. 相交链表</h1><ul>
<li><strong>一句话总结：</strong> 双指针一块走，当 pA 走到尾巴 null，它就切换到 headB 重新开始。当 pB 走到尾巴 null，它就切换到 headA 重新开始。如果两个链表有交点，那么两个指针<strong>一定会在交点相遇</strong>。如果没有交点，最终两个指针<strong>都会走到 null</strong></li>
</ul>
<h2 id="22-1-题目描述"><a href="#22-1-题目描述" class="headerlink" title="22.1 题目描述"></a>22.1 题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>图示两个链表在节点 c1 开始相交：</p>
<p>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<h2 id="22-2-算法思想和代码实现"><a href="#22-2-算法思想和代码实现" class="headerlink" title="22.2 算法思想和代码实现"></a>22.2 算法思想和代码实现</h2><h3 id="22-2-1-暴力遍历-O-m-n"><a href="#22-2-1-暴力遍历-O-m-n" class="headerlink" title="22.2.1 暴力遍历(O(m*n))"></a>22.2.1 暴力遍历(O(m*n))</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempA</span> <span class="hljs-operator">=</span> headA;<br>    <span class="hljs-keyword">while</span> (tempA != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempB</span> <span class="hljs-operator">=</span> headB; <span class="hljs-comment">// **每次遍历 headA 的一个节点，都要重新遍历 headB**</span><br>        <span class="hljs-keyword">while</span> (tempB != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (tempA == tempB) <span class="hljs-keyword">return</span> tempA; <span class="hljs-comment">// **找到相交点**</span><br>            tempB = tempB.next;<br>        &#125;<br>        tempA = tempA.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// **如果没有相交节点**</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="22-2-2-双指针法（O-m-n-）"><a href="#22-2-2-双指针法（O-m-n-）" class="headerlink" title="22.2.2 双指针法（O(m + n)）"></a>22.2.2 双指针法（O(m + n)）</h3><p>双指针法通过两个指针分别遍历 headA 和 headB，当一个指针到达链表尾部时，切换到另一个链表的头部，这样可以在 一次遍历 中找到相交节点。</p>
<ul>
<li>思路：拼接链表分别得到 A + B 和 B + A。双指针遍历找到地址相同节点</li>
<li>证明：假设 A &#x3D; a + m, B &#x3D; b + m (m 是相交之后的长度，相交之后剩下的长度一样)。</li>
<li>那么双指针同时遍历 A + B 和 B + A 会在 a + m + b 和 b + m + a的位置（长度一致了！）找到相交节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br><br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        <span class="hljs-keyword">if</span> (pA == <span class="hljs-literal">null</span>)<br>            pA = headB;<br>        <span class="hljs-keyword">else</span><br>            pA = pA.next;<br><br>        <span class="hljs-keyword">if</span> (pB == <span class="hljs-literal">null</span>)<br>            pB = headA;<br>        <span class="hljs-keyword">else</span><br>            pB = pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="23-反转链表"><a href="#23-反转链表" class="headerlink" title="23. 反转链表"></a>23. 反转链表</h1><ul>
<li><strong>一句话描述：</strong></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">原链表:1→2→3→4</span><br><span class="hljs-attr">1:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1</span> <span class="hljs-number">2</span><span class="hljs-string">→3→4</span><br><span class="hljs-attr">2:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2</span> <span class="hljs-number">3</span><span class="hljs-string">→4</span><br><span class="hljs-attr">3:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3</span> <span class="hljs-number">4</span><br><span class="hljs-attr">4:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3←4</span><br></code></pre></td></tr></table></figure>

<h2 id="23-1-题目描述"><a href="#23-1-题目描述" class="headerlink" title="23.1 题目描述"></a>23.1 题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h2 id="23-2-算法思想和代码实现"><a href="#23-2-算法思想和代码实现" class="headerlink" title="23.2 算法思想和代码实现"></a>23.2 算法思想和代码实现</h2><h3 id="迭代反转-时间复杂度-O-n"><a href="#迭代反转-时间复杂度-O-n" class="headerlink" title="迭代反转 时间复杂度 O(n)"></a>迭代反转 时间复杂度 O(n)</h3><ul>
<li>使用 p 指针 记录前一个节点（初始为 null）。</li>
<li>使用 curr 指针 遍历链表，并逐个反转指针方向。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 反转后的链表头</span><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// 当前遍历的节点</span><br><br>       <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextTemp</span> <span class="hljs-operator">=</span> curr.next; <span class="hljs-comment">// 记录下一个节点</span><br>           curr.next = p; <span class="hljs-comment">// 反转当前节点指针</span><br>           p = curr; <span class="hljs-comment">//前进</span><br>           curr = nextTemp; <span class="hljs-comment">// `curr` 前进</span><br>       &#125;<br><br>       <span class="hljs-keyword">return</span> p; <span class="hljs-comment">// 反转后的头节点</span><br>   &#125;<br></code></pre></td></tr></table></figure>


<h1 id="24-回文链表"><a href="#24-回文链表" class="headerlink" title="24. 回文链表"></a>24. 回文链表</h1><ul>
<li><strong>一句话总结：</strong> 先用<strong>快慢指针找中点</strong>，把<strong>中点以后的链表反转</strong>，<strong>再比较</strong>反转后的一半链表和原链表的前一半</li>
</ul>
<h2 id="24-1-题目描述"><a href="#24-1-题目描述" class="headerlink" title="24.1 题目描述"></a>24.1 题目描述</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h2 id="24-2-算法思想和代码实现"><a href="#24-2-算法思想和代码实现" class="headerlink" title="24.2 算法思想和代码实现"></a>24.2 算法思想和代码实现</h2><h3 id="24-2-1-利用额外空间存储链表元素，然后双指针比较是否为回文"><a href="#24-2-1-利用额外空间存储链表元素，然后双指针比较是否为回文" class="headerlink" title="24.2.1 利用额外空间存储链表元素，然后双指针比较是否为回文"></a>24.2.1 利用额外空间存储链表元素，然后双指针比较是否为回文</h3><ol>
<li>遍历链表，将所有节点值存入 ArrayList。</li>
<li>使用双指针，一个从 list 末尾 开始，一个从链表 头部 开始，逐个比较值是否相等。</li>
<li>若所有对应元素相等，则链表是 回文链表，否则返回 false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">//创建一个集合保存链表元素</span><br>    List&lt;Integer&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)&#123;<br>        list.add(p.val);<br>        p=p.next;<br>    &#125;<br><br>    p=head;<br><br>    <span class="hljs-comment">//集合元素从后往前与链表元素从前往后进行比较</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=list.size()-<span class="hljs-number">1</span>;i&gt;=list.size()/<span class="hljs-number">2</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(list.get(i)!=p.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        p=p.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="24-2-2-快慢指针找中点-反转链表（O-n-O-1-）"><a href="#24-2-2-快慢指针找中点-反转链表（O-n-O-1-）" class="headerlink" title="24.2.2 快慢指针找中点 + 反转链表（O(n),O(1)）"></a>24.2.2 快慢指针找中点 + 反转链表（O(n),O(1)）</h3><ol>
<li>使用快慢指针 找到链表的 中点。</li>
<li>反转后半部分链表。</li>
<li>从头和反转后的部分进行对比，判断是否为回文。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 1. 使用快慢指针找到链表的中点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 反转后半部分链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">secondHalf</span> <span class="hljs-operator">=</span> reverseList(slow);<br><br>    <span class="hljs-comment">// 3. 进行回文判断</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head, p2 = secondHalf;<br>    <span class="hljs-keyword">while</span> (p2 != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 只需要比较后半部分</span><br>        <span class="hljs-keyword">if</span> (p1.val != p2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        p1 = p1.next;<br>        p2 = p2.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 可选：恢复链表</span><br>    reverseList(secondHalf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = prev;<br>        prev = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="25-环形链表"><a href="#25-环形链表" class="headerlink" title="25. 环形链表"></a>25. 环形链表</h1><ul>
<li><strong>一句话总结：</strong> <strong>快慢指针找环</strong>：如果相遇了返回true</li>
</ul>
<h2 id="25-1-题目描述"><a href="#25-1-题目描述" class="headerlink" title="25.1 题目描述"></a>25.1 题目描述</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], pos = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>

<h2 id="25-2-算法思想和代码实现"><a href="#25-2-算法思想和代码实现" class="headerlink" title="25.2 算法思想和代码实现"></a>25.2 算法思想和代码实现</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_80344616/article/details/136419017">为什么快慢指针一定会相遇</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//定义快慢指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span>head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>    <br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//慢的一次走一步</span><br>        slow = slow.next;<br>        <span class="hljs-comment">//快的一次走两步</span><br>        fast = fast.next.next;<br>        <span class="hljs-comment">//如果他们能相遇，就一定是有环的</span><br>        <span class="hljs-keyword">if</span>(slow==fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="26-环形链表-II"><a href="#26-环形链表-II" class="headerlink" title="26. 环形链表 II"></a>26. 环形链表 II</h1><ul>
<li><strong>一句话总结：</strong> 当快慢指针相遇时：定义<strong>一个指针从相遇点开始走</strong>；<strong>另一个指针从链表头开始走</strong>，他们<strong>会在环的入口点相遇</strong></li>
</ul>
<h2 id="26-1-题目描述"><a href="#26-1-题目描述" class="headerlink" title="26.1 题目描述"></a>26.1 题目描述</h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], pos = <span class="hljs-number">1</span><br>输出：返回索引为 <span class="hljs-number">1</span> 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>

<h2 id="26-2-算法思想和代码实现"><a href="#26-2-算法思想和代码实现" class="headerlink" title="26.2 算法思想和代码实现"></a>26.2 算法思想和代码实现</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_80344616/article/details/136419017">为什么快慢指针一定会相遇</a></p>
<p><strong>定义一个指针从相遇点开始走；另一个指针从链表头开始走，他们会在环的入口点相遇</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">//快慢指针判断是否有环</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span>head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>    <br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <br>        <span class="hljs-comment">//如果有环</span><br>        <span class="hljs-keyword">if</span>(slow==fast)&#123;<br>            <span class="hljs-comment">//定义两个指针，一个从相遇点slow出发，另一个从head头出发</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">meet</span> <span class="hljs-operator">=</span>slow;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>            <br>            <span class="hljs-comment">//当二者相遇时，此结点就是环起点</span><br>            <span class="hljs-keyword">while</span>(p!=meet)&#123;<br>                p = p.next;<br>                meet = meet.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> meet;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="27-合并两个有序链表"><a href="#27-合并两个有序链表" class="headerlink" title="27. 合并两个有序链表"></a>27. 合并两个有序链表</h1><ul>
<li><strong>一句话描述：</strong> 使用<strong>虚拟头结点</strong>，双指针遍历两个链表；<strong>谁的值小，就连接谁</strong>；遍历完一个，直接连接另一个</li>
</ul>
<h2 id="27-1-题目描述"><a href="#27-1-题目描述" class="headerlink" title="27.1 题目描述"></a>27.1 题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], l2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<h2 id="27-2-算法思想和代码实现"><a href="#27-2-算法思想和代码实现" class="headerlink" title="27.2 算法思想和代码实现"></a>27.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            cur.next = list1;<br>            cur = cur.next;<br>            list1 = list1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.next = list2;<br>            cur = cur.next;<br>            list2 = list2.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = list1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list2 != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = list2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="28-两数相加"><a href="#28-两数相加" class="headerlink" title="28. 两数相加"></a>28. 两数相加</h1><ul>
<li><strong>一句话总结：</strong> 创建一个新链表记录两个链表之和，<strong>注意进位</strong></li>
</ul>
<h2 id="28-1-题目描述"><a href="#28-1-题目描述" class="headerlink" title="28.1 题目描述"></a>28.1 题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], l2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>]<br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807.</span><br></code></pre></td></tr></table></figure>

<h2 id="28-2-算法思想和代码实现"><a href="#28-2-算法思想和代码实现" class="headerlink" title="28.2 算法思想和代码实现"></a>28.2 算法思想和代码实现</h2><p>创建一个新的链表存储最终的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-comment">// 创建一个新的链表用来保存最终结果</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> l3; <span class="hljs-comment">// 记录结果链表的头部</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历两个链表，直到两个链表都遍历完</span><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>; <br>        <br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            x = l1.val;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            y = l2.val;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算当前位的和与进位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br>        carry = sum / <span class="hljs-number">10</span>; <br><br>        <span class="hljs-comment">// 取当前位的数字，创建新节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>        l3.next = newNode; <br>        l3 = l3.next; <br><br>        <span class="hljs-comment">// 继续遍历 l1 和 l2</span><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            l1 = l1.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            l2 = l2.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果最后还有进位，创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        l3.next = newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 返回头节点</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="29-删除链表的倒数第N个结点"><a href="#29-删除链表的倒数第N个结点" class="headerlink" title="29. 删除链表的倒数第N个结点"></a>29. 删除链表的倒数第N个结点</h1><ul>
<li><strong>一句话总结：</strong> 创建一个dummy,<strong>快慢指针指向dummy</strong>；<strong>快指针先走n+1步</strong>，然后<strong>快慢指针一起移动直到快指针为null</strong>，此时慢指针的位置就是要删除结点的前一个结点位置</li>
</ul>
<h2 id="29-1-题目描述"><a href="#29-1-题目描述" class="headerlink" title="29.1 题目描述"></a>29.1 题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>

<h2 id="29-2-算法思想和代码实现"><a href="#29-2-算法思想和代码实现" class="headerlink" title="29.2 算法思想和代码实现"></a>29.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 创建虚拟头结点，避免删除头节点时判断麻烦</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-comment">// fast先走n+1步，保持间距</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        fast = fast.next;<br>    &#125;<br><br>    <span class="hljs-comment">// fast 和 slow 同时移动，直到 fast 到达链表末尾</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除倒数第n个节点</span><br>    slow.next = slow.next.next;<br><br>    <span class="hljs-comment">// 返回新的头结点</span><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="30-两两交换链表中的节点"><a href="#30-两两交换链表中的节点" class="headerlink" title="30. 两两交换链表中的节点"></a>30. 两两交换链表中的节点</h1><ul>
<li><strong>一句话描述：</strong> 模拟即可</li>
</ul>
<h2 id="30-1-题目描述"><a href="#30-1-题目描述" class="headerlink" title="30.1 题目描述"></a>30.1 题目描述</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>

<h2 id="30-2-算法思想和代码实现"><a href="#30-2-算法思想和代码实现" class="headerlink" title="30.2 算法思想和代码实现"></a>30.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>     <span class="hljs-comment">// 创建虚拟头节点，方便处理头节点交换的问题</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>     dummy.next = head;<br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy; <span class="hljs-comment">// cur用来遍历链表</span><br>     <br>     <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// node1是第一个结点，node2是第二个结点</span><br>         <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> cur.next;<br>         <span class="hljs-type">ListNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> cur.next.next;<br><br>         <span class="hljs-comment">// 交换节点</span><br>         cur.next = node2;<br>         node1.next = node2.next;<br>         node2.next = node1;<br><br>         <span class="hljs-comment">// cur 移动到下一对节点前的位置</span><br>         cur = node1;<br>     &#125;<br>     <br>     <span class="hljs-keyword">return</span> dummy.next;<br> &#125;<br></code></pre></td></tr></table></figure>


<h1 id="31-K个一组翻转链表"><a href="#31-K个一组翻转链表" class="headerlink" title="31. K个一组翻转链表"></a>31. K个一组翻转链表</h1><ul>
<li><strong>一句话总结：</strong> <strong>反转</strong>+<strong>找到K个结点一组</strong>即可，每次记录开始结点和终止结点</li>
</ul>
<h2 id="31-1-题目描述"><a href="#31-1-题目描述" class="headerlink" title="31.1 题目描述"></a>31.1 题目描述</h2><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>

<h2 id="31-2-算法思想和代码实现"><a href="#31-2-算法思想和代码实现" class="headerlink" title="31.2 算法思想和代码实现"></a>31.2 算法思想和代码实现</h2><ol>
<li>找到 k 个节点，如果数量不足 k，直接返回 head。</li>
<li>翻转 k 个节点，并将翻转后的部分连接到新链表。</li>
<li>更新指针，继续处理下一个 k 组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> cur.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> cur;<br><br>        <span class="hljs-comment">// 判断剩余长度是否 &gt;= k</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">null</span>; i++) &#123;<br>            end = end.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 不足k个，结束循环</span><br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>        end.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 截断k组</span><br>        cur.next = reverse(start);  <span class="hljs-comment">// 翻转k组</span><br>        start.next = next;  <span class="hljs-comment">// 接回链表</span><br>        cur = start;  <span class="hljs-comment">// cur 移动到下一组前</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br><span class="hljs-comment">//反转链表</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = cur;<br>        cur = head;<br>        head = nextNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="32-随机链表的复制"><a href="#32-随机链表的复制" class="headerlink" title="32. 随机链表的复制"></a>32. 随机链表的复制</h1><ul>
<li><strong>一句话总结：</strong> 使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制</li>
</ul>
<h2 id="32-1-题目描述"><a href="#32-1-题目描述" class="headerlink" title="32.1 题目描述"></a>32.1 题目描述</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br>输出：[[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="32-2-算法思想和代码实现"><a href="#32-2-算法思想和代码实现" class="headerlink" title="32.2 算法思想和代码实现"></a>32.2 算法思想和代码实现</h2><h3 id="使用-HashMap-存储旧节点与新节点的对应关系，并分两步完成链表复制："><a href="#使用-HashMap-存储旧节点与新节点的对应关系，并分两步完成链表复制：" class="headerlink" title="使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制："></a>使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制：</h3><ol>
<li>复制 next 指针并建立映射关系<ul>
<li>遍历原链表，创建新链表的 next 结构，同时在 HashMap 中存储每个旧节点对应的新节点。</li>
<li>这样可以保证新链表的 next 结构和原链表一致。</li>
</ul>
</li>
<li>复制 random 指针<ul>
<li>再次遍历链表，通过 HashMap 查询旧链表的 random 指向的节点，并将其映射到新链表的 random 指针。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>     <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 若链表为空，则直接返回 null</span><br><br>     <span class="hljs-comment">// 创建 HashMap，用于保存旧节点与新节点的对应关系</span><br>     Map&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>     <span class="hljs-comment">// 1. 通过 next 指针创建出新链表，并建立旧节点到新节点的映射关系</span><br>     <span class="hljs-type">Node</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(head.val); <span class="hljs-comment">// 复制头节点</span><br>     <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> newHead, oldNode = head.next; <span class="hljs-comment">// newNode 指向新链表，oldNode 遍历旧链表</span><br>     map.put(head, newHead); <span class="hljs-comment">// 记录头节点映射关系</span><br>     map.put(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 处理 random 指向 null 的情况</span><br><br>     <span class="hljs-keyword">while</span> (oldNode != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 遍历旧链表，复制所有节点</span><br>         <span class="hljs-type">Node</span> <span class="hljs-variable">tempNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(oldNode.val); <span class="hljs-comment">// 创建新节点</span><br>         newNode.next = tempNode; <span class="hljs-comment">// 连接新节点</span><br>         newNode = newNode.next; <span class="hljs-comment">// 移动新链表指针</span><br>         map.put(oldNode, newNode); <span class="hljs-comment">// 记录映射关系</span><br>         oldNode = oldNode.next; <span class="hljs-comment">// 继续遍历旧链表</span><br>     &#125;<br><br>     <span class="hljs-comment">// 2. 复制 random 指针</span><br>     oldNode = head;<br>     newNode = newHead;<br>     <span class="hljs-keyword">while</span> (oldNode != <span class="hljs-literal">null</span>) &#123;<br>         newNode.random = map.get(oldNode.random); <span class="hljs-comment">// 通过 map 获取对应的新节点并赋值</span><br>         newNode = newNode.next; <span class="hljs-comment">// 移动到下一个新节点</span><br>         oldNode = oldNode.next; <span class="hljs-comment">// 移动到下一个旧节点</span><br>     &#125;<br><br>     <span class="hljs-keyword">return</span> newHead; <span class="hljs-comment">// 返回新链表的头节点</span><br> &#125;<br></code></pre></td></tr></table></figure>


<h1 id="33-排序链表"><a href="#33-排序链表" class="headerlink" title="33. 排序链表"></a>33. 排序链表</h1><ul>
<li><strong>一句话总结：</strong></li>
<li><strong>归并排序</strong><ul>
<li>使用<strong>快慢指针找到链表中点</strong>，将链表以中点<strong>拆分</strong>成左右链表递归排序，将两个链表<strong>合并</strong>成有序链表</li>
</ul>
</li>
</ul>
<h2 id="33-1-题目描述"><a href="#33-1-题目描述" class="headerlink" title="33.1 题目描述"></a>33.1 题目描述</h2><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<h2 id="33-2-算法思想和代码实现"><a href="#33-2-算法思想和代码实现" class="headerlink" title="33.2 算法思想和代码实现"></a>33.2 算法思想和代码实现</h2><ul>
<li>归并排序: 分治法，将链表递归拆分，然后合并排序</li>
</ul>
<ol>
<li>递归终止条件<ul>
<li>当链表为空（head &#x3D;&#x3D; null）或只有一个节点（head.next &#x3D;&#x3D; null），直接返回 head。</li>
</ul>
</li>
<li>找到链表中点（快慢指针法）<ul>
<li>使用 slow 和 fast 指针，让 fast 先走一步，保证 slow 取左中位数，防止死循环。</li>
</ul>
</li>
<li>拆分链表<ul>
<li>mid.next &#x3D; null 断开链表，分为左右两部分递归排序。</li>
</ul>
</li>
<li>合并有序链表<ul>
<li>使用双指针合并两个有序链表（归并排序的核心）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-comment">//将链表从中间分割成两个链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> getMiddle(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightHead</span> <span class="hljs-operator">=</span> mid.next;<br>    mid.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//断开前一个链表</span><br><br>    <span class="hljs-comment">//递归排序分割后的两块链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(rightHead);<br><br>    <span class="hljs-comment">//将链表归并</span><br>    <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br><br><br><span class="hljs-comment">//找到链表中间结点</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">//归并两个链表</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-comment">//依次比较两个链表的结点的大小，小的加上去</span><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            cur.next = l1;<br>            l1 = l1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.next = l2;<br>            l2 = l2.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-comment">//看哪个链表有剩余的，加上去</span><br>    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) cur.next = l1;<br>    <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) cur.next = l2;<br><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="34-合并K个升序链表"><a href="#34-合并K个升序链表" class="headerlink" title="34. 合并K个升序链表"></a>34. 合并K个升序链表</h1><ul>
<li><strong>一句话总结：</strong> 使用<strong>最小堆</strong>(优先级队列)维护k个链表的当前最小节点，每次<strong>出队最小结点</strong>，<strong>入队最小结点的下一个结点</strong>，直到队列为空</li>
</ul>
<h2 id="34-1-题目描述"><a href="#34-1-题目描述" class="headerlink" title="34.1 题目描述"></a>34.1 题目描述</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<h2 id="34-2-算法思想和代码实现"><a href="#34-2-算法思想和代码实现" class="headerlink" title="34.2 算法思想和代码实现"></a>34.2 算法思想和代码实现</h2><ul>
<li>使用最小堆（优先队列）来维护 k 个链表的当前最小节点，每次取出最小值并推进链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>       <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> lists.length;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>       PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> &#123; <span class="hljs-comment">//重写比较器</span><br>               <span class="hljs-keyword">return</span> o1.val - o2.val;<br>           &#125;<br>       &#125;);<br><br>       <span class="hljs-comment">//先把k个链表的头结点放进优先级队列中</span><br>       <span class="hljs-keyword">for</span> (ListNode head : lists) &#123;<br>           <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>               pq.offer(head);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">//将最小的结点弹出来并连接到有序链表后，将弹出来的结点的下一个结点入队</span><br>       <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> pq.poll();<br>           cur.next = minNode;<br>           cur = cur.next;<br><br>           <span class="hljs-keyword">if</span> (minNode.next != <span class="hljs-literal">null</span>)<br>               pq.offer(minNode.next);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dummy.next;<br>   &#125;<br></code></pre></td></tr></table></figure>


<h1 id="35-LRU缓存"><a href="#35-LRU缓存" class="headerlink" title="35. LRU缓存"></a>35. LRU缓存</h1><ul>
<li><strong>一句话描述：</strong> 定义<strong>双向链表</strong>维护缓存队列，定义<strong>哈希表</strong>维护当前队列的键和值，并提供快速查找结点</li>
</ul>
<h2 id="35-1-题目描述"><a href="#35-1-题目描述" class="headerlink" title="35.1 题目描述"></a>35.1 题目描述</h2><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<h2 id="35-2-算法思想和代码实现"><a href="#35-2-算法思想和代码实现" class="headerlink" title="35.2 算法思想和代码实现"></a>35.2 算法思想和代码实现</h2><h3 id="双向链表-HashMap"><a href="#双向链表-HashMap" class="headerlink" title="双向链表 + HashMap"></a>双向链表 + HashMap</h3><ul>
<li>双向链表维护缓存队列</li>
<li>哈希表：通过key快速查找Node</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">//哈希表保存结点的键和值</span><br>    HashMap&lt;Integer, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">//创建一个虚头结点和尾结点</span><br>    Node head, tail;<br><br>    <span class="hljs-comment">//使用双向链表模拟缓存队列</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node next, prev;<br><br>        Node() &#123;<br>        &#125;<br><br>        Node(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value) &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br><br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-comment">//使用缓存中的key，更新缓存队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//如果不存在，返回-1</span><br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//存在，将缓存中的当前结点移动到队头的后面，并删除当前位置的当前结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.get(key);<br>        removeNode(cur);<br>        moveToHead(cur);<br><br>        <span class="hljs-keyword">return</span> cur.value;<br>    &#125;<br><br>    <span class="hljs-comment">//添加缓存中的结点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//已经存在了当前的key，删除原本的结点和哈希表中的key</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">olddNode</span> <span class="hljs-operator">=</span> map.get(key);<br>            removeNode(olddNode);<br>            map.remove(key);<br>        &#125;<br><br>        <span class="hljs-comment">//在哈希表和缓存队列中添加当前结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        map.put(key, newNode);<br>        moveToHead(newNode);<br><br>        <span class="hljs-comment">//如果哈希表中的结点大于容量，删除队尾的缓存结点和哈希表中的队尾结点元素</span><br>        <span class="hljs-keyword">if</span> (map.size() &gt; capacity) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">lastNode</span> <span class="hljs-operator">=</span> tail.prev;<br>            <span class="hljs-keyword">if</span> (lastNode != head) &#123;<br>                removeNode(lastNode);<br>                map.remove(lastNode.key);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//删除当前结点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-comment">//将当前结点添加到头结点的后面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="36-二叉树的中序遍历"><a href="#36-二叉树的中序遍历" class="headerlink" title="36. 二叉树的中序遍历"></a>36. 二叉树的中序遍历</h1><ul>
<li><strong>一句话总结：</strong> <strong>左根右递归</strong></li>
</ul>
<h2 id="36-1-题目描述"><a href="#36-1-题目描述" class="headerlink" title="36.1 题目描述"></a>36.1 题目描述</h2><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<h2 id="36-2-算法思想和代码实现"><a href="#36-2-算法思想和代码实现" class="headerlink" title="36.2 算法思想和代码实现"></a>36.2 算法思想和代码实现</h2><h3 id="递归：左根右"><a href="#递归：左根右" class="headerlink" title="递归：左根右"></a>递归：左根右</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> list;<br>    inorderTraversal(root.left);<br>    list.add(root.val);<br>    inorderTraversal(root.right);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="37-二叉树的最大深度"><a href="#37-二叉树的最大深度" class="headerlink" title="37. 二叉树的最大深度"></a>37. 二叉树的最大深度</h1><ul>
<li><strong>一句话总结：</strong> 当前节点为空返回0，递归计算左右子树的深度，取左右子树的较大值加1</li>
</ul>
<h2 id="37-1-题目描述"><a href="#37-1-题目描述" class="headerlink" title="37.1 题目描述"></a>37.1 题目描述</h2><p>给定一个二叉树 root ，返回其最大深度。</p>
<p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="37-2-算法思想和代码实现"><a href="#37-2-算法思想和代码实现" class="headerlink" title="37.2 算法思想和代码实现"></a>37.2 算法思想和代码实现</h2><p>递归计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 如果当前节点为空，则返回深度 0</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 递归计算左子树的最大深度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br><br>    <span class="hljs-comment">// 递归计算右子树的最大深度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>    <span class="hljs-comment">// 当前节点的深度为左右子树深度的较大值 + 1</span><br>    <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="38-翻转二叉树"><a href="#38-翻转二叉树" class="headerlink" title="38. 翻转二叉树"></a>38. 翻转二叉树</h1><ul>
<li><strong>一句话描述：</strong> 递归交换左右子树即可</li>
</ul>
<h2 id="38-1-题目描述"><a href="#38-1-题目描述" class="headerlink" title="38.1 题目描述"></a>38.1 题目描述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h2 id="38-2-算法思想和代码实现"><a href="#38-2-算法思想和代码实现" class="headerlink" title="38.2 算法思想和代码实现"></a>38.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 如果当前节点为空，则直接返回 null</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 暂存当前节点的左子节点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br><br>    <span class="hljs-comment">// 递归反转右子树，并赋值给当前节点的左子节点</span><br>    root.left = invertTree(root.right);<br>    <span class="hljs-comment">// 递归反转左子树，并赋值给当前节点的右子节点</span><br>    root.right = invertTree(left);<br>    <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="39-对称二叉树"><a href="#39-对称二叉树" class="headerlink" title="39. 对称二叉树"></a>39. 对称二叉树</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li>两个子树<strong>都为空则对称</strong></li>
<li>如果<strong>左右子树都不为空且值相等</strong>，同时<strong>左树的右子树和右树的左子树对称</strong>，同时<strong>左树的左子树和右树的右子树对称</strong>，则对称</li>
</ul>
<h2 id="39-1-题目描述"><a href="#39-1-题目描述" class="headerlink" title="39.1 题目描述"></a>39.1 题目描述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h2 id="39-2-算法思想和代码实现"><a href="#39-2-算法思想和代码实现" class="headerlink" title="39.2 算法思想和代码实现"></a>39.2 算法思想和代码实现</h2><ol>
<li>怎么判断一棵树是不是对称二叉树？<br>答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对称时，他对称</li>
<li>那么怎么知道左子树与右子树对不对称呢？在这我直接叫为左树和右树<br>答案：如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">return</span> fun(root.left, root.right);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>       <span class="hljs-comment">// 如果两个子树都为空，则对称</span><br>       <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>       <span class="hljs-comment">// 如果左右子树都不为空且值相等，</span><br>       <span class="hljs-comment">// 同时左树的右子树和右树的左子树对称，</span><br>       <span class="hljs-comment">// 同时左树的左子树和右树的右子树对称，则对称</span><br>       <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span> &amp;&amp; left.val == right.val &amp;&amp; fun(left.left, right.right)<br>               &amp;&amp; fun(left.right, right.left))<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>       <span class="hljs-comment">// 其他情况不对称</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>


<h1 id="40-二叉树的直径"><a href="#40-二叉树的直径" class="headerlink" title="40. 二叉树的直径"></a>40. 二叉树的直径</h1><ul>
<li><strong>一句话描述：</strong> 递归计算每个节点的<strong>左右子树的最大深度</strong>，<strong>当前节点的直径&#x3D;左子树深度+右子树深度</strong>，<strong>更新</strong>最大直径</li>
</ul>
<h2 id="40-1-题目描述"><a href="#40-1-题目描述" class="headerlink" title="40.1 题目描述"></a>40.1 题目描述</h2><p>给你一棵二叉树的根节点，返回该树的 直径 。<br>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。<br>两节点之间路径的 长度 由它们之间边数表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> ，取路径 [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 或 [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 的长度。<br></code></pre></td></tr></table></figure>

<h2 id="40-2-算法思想和代码实现"><a href="#40-2-算法思想和代码实现" class="headerlink" title="40.2 算法思想和代码实现"></a>40.2 算法思想和代码实现</h2><ul>
<li>递归思想：计算每个节点的左右子树深度，并更新最大直径。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      maxDepth(root);<br>      <span class="hljs-keyword">return</span> max;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-comment">// 递归计算左右子树的最大深度</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>      <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>      <span class="hljs-comment">// 用左子树深度 + 右子树深度更新最大直径</span><br>      max = Math.max(max, left + right);<br><br>      <span class="hljs-comment">// 返回当前节点的最大深度 = 左右子树最大深度 + 1（算上当前节点）</span><br>      <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>


<h1 id="41-二叉树的层序遍历"><a href="#41-二叉树的层序遍历" class="headerlink" title="41. 二叉树的层序遍历"></a>41. 二叉树的层序遍历</h1><ul>
<li><strong>一句话描述：</strong> 使用队列存储每层的结点，使用size记录当前层结点的个数，循环<strong>出队</strong>层中的结点，<strong>入队下一层左右子树的结点</strong>，直到队空为止</li>
</ul>
<h2 id="41-1-题目描述"><a href="#41-1-题目描述" class="headerlink" title="41.1 题目描述"></a>41.1 题目描述</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="41-2-算法思想和代码实现"><a href="#41-2-算法思想和代码实现" class="headerlink" title="41.2 算法思想和代码实现"></a>41.2 算法思想和代码实现</h2><p>使用<strong>队列</strong>（Queue） 作为辅助数据结构，按照层的顺序依次处理每个节点。</p>
<ol>
<li>先将 根节点入队，然后进入循环：<ul>
<li>记录当前层的节点个数 size。</li>
<li>遍历当前层的 size 个节点：<ul>
<li>弹出队列头部节点，并将其值存入当前层的列表中。</li>
<li>将该节点的左右子节点入队（若存在）。</li>
</ul>
</li>
</ul>
</li>
<li>遍历完整层后，将当前层的列表加入最终结果。</li>
<li>继续处理下一层，直至队列为空，即所有节点都被遍历完。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br><br>     <span class="hljs-comment">// 创建队列用于层序遍历</span><br>     Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>     <span class="hljs-comment">// 用于存储最终的层序遍历结果</span><br>     List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br><br>     queue.offer(root); <span class="hljs-comment">// 先将根节点入队</span><br><br>     <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size(); <span class="hljs-comment">// 记录当前层的节点数</span><br>         List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 用于存储当前层的节点值</span><br>         <br>         <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll(); <span class="hljs-comment">// 取出队列元素</span><br><br>             <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>                 queue.offer(node.left); <span class="hljs-comment">// 左子节点入队</span><br>             <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>                 queue.offer(node.right); <span class="hljs-comment">// 右子节点入队</span><br><br>             list.add(node.val); <br>             size--;<br>         &#125;<br><br>         res.add(list); <br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>


<h1 id="42-将有序数组转换为二叉搜索树"><a href="#42-将有序数组转换为二叉搜索树" class="headerlink" title="42. 将有序数组转换为二叉搜索树"></a>42. 将有序数组转换为二叉搜索树</h1><ul>
<li><strong>一句话描述：</strong> 以数组的中间元素作为root结点，左区间递归构造左子树root.left,右区间递归构造右子树root.right，直到数组区间索引left&gt;right终止</li>
</ul>
<h2 id="42-1-题目描述"><a href="#42-1-题目描述" class="headerlink" title="42.1 题目描述"></a>42.1 题目描述</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [-<span class="hljs-number">10</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">0</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,-<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>]<br>解释：[<span class="hljs-number">0</span>,-<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,-<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>] 也将被视为正确答案：<br></code></pre></td></tr></table></figure>

<h2 id="42-2-算法思想和代码实现"><a href="#42-2-算法思想和代码实现" class="headerlink" title="42.2 算法思想和代码实现"></a>42.2 算法思想和代码实现</h2><ul>
<li>将有序数组从中间分割，分为左区间和右区间</li>
<li>左区间用来构造左子树</li>
<li>右区间用来构造右子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">return</span> sortTree(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">//构造当前结点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br><br>    <span class="hljs-comment">//递归构造左子树和右子树</span><br>    root.left = sortTree(nums, left, mid - <span class="hljs-number">1</span>);<br>    root.right = sortTree(nums, mid + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="43-验证二叉搜索树"><a href="#43-验证二叉搜索树" class="headerlink" title="43. 验证二叉搜索树"></a>43. 验证二叉搜索树</h1><ul>
<li><strong>一句话描述：</strong> <strong>构建子树的大小边界</strong>，左右子树的值在边界外返回false，递归遍历左右子树</li>
</ul>
<h2 id="43-1-题目描述"><a href="#43-1-题目描述" class="headerlink" title="43.1 题目描述"></a>43.1 题目描述</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h2 id="43-2-算法思想和代码实现"><a href="#43-2-算法思想和代码实现" class="headerlink" title="43.2 算法思想和代码实现"></a>43.2 算法思想和代码实现</h2><h3 id="43-2-1-中序遍历-集合有序"><a href="#43-2-1-中序遍历-集合有序" class="headerlink" title="43.2.1 中序遍历+集合有序"></a>43.2.1 中序遍历+集合有序</h3><ul>
<li>中序遍历的结果如果是一个升序的，则返回true</li>
<li>用一个集合保存中序遍历结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个集合保存二叉树元素</span><br>List&lt;Integer&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    inorderTraversal(root);<br>    <span class="hljs-comment">//中序遍历如果是一个升序的结果，则返回true</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size()-<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(list.get(i)&gt;=list.get(i+<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    inorderTraversal(root.left);<br>    list.add(root.val);<br>    inorderTraversal(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="43-2-2-递归检查"><a href="#43-2-2-递归检查" class="headerlink" title="43.2.2 递归检查"></a>43.2.2 递归检查</h3><ul>
<li>每个节点 root.val 必须在某个范围内，即：<ul>
<li>左子树的所有节点值必须 小于 root.val</li>
<li>右子树的所有节点值必须 大于 root.val</li>
</ul>
</li>
<li>递归过程中，维护 <strong>当前允许的最大值 max 和最小值 min</strong>，如果 root.val 超出范围，则不是 BST。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> min, <span class="hljs-type">long</span> max)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 检查当前节点是否在允许范围内</span><br>        <span class="hljs-keyword">if</span> (node.val &lt;= min || node.val &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 递归检查左右子树</span><br>        <span class="hljs-keyword">return</span> isValidBST(node.left, min, node.val) &amp;&amp; isValidBST(node.right, node.val, max);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="44-二叉搜索树中第K小的元素"><a href="#44-二叉搜索树中第K小的元素" class="headerlink" title="44. 二叉搜索树中第K小的元素"></a>44. 二叉搜索树中第K小的元素</h1><ul>
<li><strong>一句话描述：</strong> 二叉搜索树用<strong>中序遍历</strong>即为一个升序的数组，<strong>直接计数</strong>到第k个遍历的结点时，返回当前元素即可</li>
</ul>
<h2 id="44-1-题目描述"><a href="#44-1-题目描述" class="headerlink" title="44.1 题目描述"></a>44.1 题目描述</h2><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="44-2-算法思想和代码实现"><a href="#44-2-算法思想和代码实现" class="headerlink" title="44.2 算法思想和代码实现"></a>44.2 算法思想和代码实现</h2><ul>
<li>二叉搜索树的中序遍历是一个升序的数据</li>
<li>中序遍历，到第k个遍历的元素后，返回当前结点元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前访问的节点数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最终结果</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>    inorder(root, k);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    inorder(node.left, k); <span class="hljs-comment">// 递归左子树</span><br><br>    count++; <span class="hljs-comment">// 访问当前节点</span><br>    <span class="hljs-keyword">if</span> (count == k) &#123;<br>        result = node.val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    inorder(node.right, k); <span class="hljs-comment">// 递归右子树</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="45-二叉树的右视图"><a href="#45-二叉树的右视图" class="headerlink" title="45. 二叉树的右视图"></a>45. 二叉树的右视图</h1><ul>
<li><strong>一句话描述：</strong> 使用队列进行<strong>层序遍历</strong>，找到每层最右边的结点即可</li>
</ul>
<h2 id="45-1-题目描述"><a href="#45-1-题目描述" class="headerlink" title="45.1 题目描述"></a>45.1 题目描述</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<h2 id="45-2-算法思想和代码实现"><a href="#45-2-算法思想和代码实现" class="headerlink" title="45.2 算法思想和代码实现"></a>45.2 算法思想和代码实现</h2><ul>
<li>思想：找到层序遍历的每层最后一个结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br><br>    <span class="hljs-comment">//层序遍历</span><br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><br>        <span class="hljs-keyword">while</span>(size&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br><br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)<br>                queue.offer(node.left);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)<br>                queue.offer(node.right);<br><br>            size--;<br>            <br>            <span class="hljs-comment">//返回每层的最后一个结果，也就是最右边的结点</span><br>            <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>) res.add(node.val);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="46-二叉树展开为链表"><a href="#46-二叉树展开为链表" class="headerlink" title="46. 二叉树展开为链表"></a>46. 二叉树展开为链表</h1><ul>
<li><strong>一句话描述：</strong> 创建一个新结点，使用<strong>新结点的右子树连接当前root结点</strong>，然后<strong>前序遍历</strong>递归连接root的左子树、root的右子树</li>
</ul>
<h2 id="46-1-题目描述"><a href="#46-1-题目描述" class="headerlink" title="46.1 题目描述"></a>46.1 题目描述</h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure>

<h2 id="46-2-算法思想和代码实现"><a href="#46-2-算法思想和代码实现" class="headerlink" title="46.2 算法思想和代码实现"></a>46.2 算法思想和代码实现</h2><ul>
<li>以 先序遍历（根-左-右） 的方式展开二叉树。</li>
<li>使用 cur 变量记录上一个访问的节点，并将 cur.right 指向当前节点 root，从而形成链表结构。</li>
<li>cur 变量始终存储着已经展开的最后一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cur 记录上一个访问的节点</span><br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 先保存左、右子树（因为后面会修改 root.left 和 root.right）</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br><br>    <span class="hljs-comment">// 如果 cur 不为空，说明已经处理过前一个节点</span><br>    <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        cur.left = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 断开左子树</span><br>        cur.right = root; <span class="hljs-comment">// 让上一个节点的右子树指向当前节点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 更新 cur 为当前节点</span><br>    cur = root;<br><br>    <span class="hljs-comment">// 递归处理左右子树</span><br>    flatten(left);<br>    flatten(right);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="47-从前序与中序遍历序列构造二叉树"><a href="#47-从前序与中序遍历序列构造二叉树" class="headerlink" title="47. 从前序与中序遍历序列构造二叉树"></a>47. 从前序与中序遍历序列构造二叉树</h1><ul>
<li><strong>一句话描述：</strong> <strong>哈希表</strong>存储中序数组便于查找索引，前序数组第一个元素就是根节点，使用<strong>中序数组划分左右子树</strong>后进行递归构建左右子树</li>
</ul>
<h2 id="47-1-题目描述"><a href="#47-1-题目描述" class="headerlink" title="47.1 题目描述"></a>47.1 题目描述</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]<br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure>

<h2 id="47-2-算法思想和代码实现"><a href="#47-2-算法思想和代码实现" class="headerlink" title="47.2 算法思想和代码实现"></a>47.2 算法思想和代码实现</h2><h3 id="递归-哈希表优化查找"><a href="#递归-哈希表优化查找" class="headerlink" title="递归 + 哈希表优化查找"></a>递归 + 哈希表优化查找</h3><ul>
<li>先序遍历的第一个元素一定是当前子树的根节点</li>
<li>利用中序遍历划分左右子树<ul>
<li>中序遍历查找根节点的位置 rootIndex，从而确定 左子树的大小 (leftSize &#x3D; rootIndex - inLeft)</li>
<li>左子树的范围在 [inLeft, rootIndex - 1]，右子树的范围在 [rootIndex + 1, inRight]</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>       <span class="hljs-comment">//将中序遍历数组的元素作为key,索引作为value存储在哈希表中</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>           map.put(inorder[i], i);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> buildTree(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight)</span> &#123;<br>       <span class="hljs-comment">//递归终止条件</span><br>       <span class="hljs-keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-comment">//前序遍历第一个结点一定是根结点，记录此根结点在中序遍历的位置，计算左子树大小</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preLeft]);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(preorder[preLeft]);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> rootIndex - inLeft;<br><br>       <span class="hljs-comment">//递归构造左右子树</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> buildTree(preorder, preLeft + <span class="hljs-number">1</span>, preLeft + leftSize, inLeft, rootIndex - <span class="hljs-number">1</span>);<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> buildTree(preorder, preLeft + leftSize + <span class="hljs-number">1</span>, preRight, rootIndex + <span class="hljs-number">1</span>, inRight);<br><br>       root.left = left;<br>       root.right = right;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h1 id="48-路径总和-III"><a href="#48-路径总和-III" class="headerlink" title="48. 路径总和 III"></a>48. 路径总和 III</h1><ul>
<li><strong>一句话描述：</strong> 使用<strong>哈希表存储前缀和</strong>出现次数，backtracking(){终止条件{在哈希表找到(<strong>当前路径总和-目标值</strong>)的次数加到结果}，在哈希表<strong>添加当前路径总和</strong>，<strong>递归</strong>左右子树，<strong>回溯撤销</strong>哈希表添加的当前路径总和}</li>
</ul>
<h2 id="48-1-题目描述"><a href="#48-1-题目描述" class="headerlink" title="48.1 题目描述"></a>48.1 题目描述</h2><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], targetSum = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">3</span><br>解释：和等于 <span class="hljs-number">8</span> 的路径有 <span class="hljs-number">3</span> 条，如图所示。<br></code></pre></td></tr></table></figure>

<h2 id="48-2-算法思想和代码实现"><a href="#48-2-算法思想和代码实现" class="headerlink" title="48.2 算法思想和代码实现"></a>48.2 算法思想和代码实现</h2><h3 id="48-2-1-递归遍历所有的子树"><a href="#48-2-1-递归遍历所有的子树" class="headerlink" title="48.2.1 递归遍历所有的子树"></a>48.2.1 递归遍历所有的子树</h3><ol>
<li>递归遍历<ul>
<li>以当前节点为起点计算符合条件的路径数（调用 dfs）。</li>
<li>分别递归左子树和右子树，继续以子树的根作为起点计算符合条件的路径数（调用 pathSum）。</li>
</ul>
</li>
<li>深度优先搜索（DFS）计算路径数<ul>
<li>dfs(root, target): 计算以 root 为起点的路径总数：<ul>
<li>若当前节点值 root.val 等于 target，则计数 count++。</li>
<li>递归计算 root.left 和 root.right，更新路径数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">//依次将当前根结点作为一个树，左子树作为一个树，右子树作为一个树进行递归</span><br>       <span class="hljs-keyword">return</span> dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);<br>   &#125;<br><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> target)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <br>       <span class="hljs-comment">//如果当前结点等于Target则为一个路径</span><br>       <span class="hljs-keyword">if</span> (root.val == target)<br>           count++;<br><br>       <span class="hljs-comment">//递归左子树和右子树，将target减去当前结点的值</span><br>       count += dfs(root.left, target - root.val) + dfs(root.right, target - root.val);<br>       <span class="hljs-keyword">return</span> count;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="48-2-2-前缀和-回溯"><a href="#48-2-2-前缀和-回溯" class="headerlink" title="48.2.2 前缀和+回溯"></a>48.2.2 前缀和+回溯</h3><ol>
<li>使用哈希表存储前缀和出现次数<ul>
<li>设 prefixSum 记录从根到当前节点的路径和：<ul>
<li>若 prefixSum[j] - prefixSum[i] &#x3D; targetSum，则说明从 i+1 到 j 的路径和为 targetSum。</li>
</ul>
</li>
<li>只需要查询 prefixSum[j] - targetSum 是否出现过。</li>
</ul>
</li>
<li>深度优先遍历 + 回溯<ul>
<li>使用 <code>HashMap&lt;Long, Integer&gt;</code> 记录遍历过程中所有的 prefixSum 及其出现次数。</li>
<li>在递归进入子节点时，更新前缀和哈希表；</li>
<li>递归完成后，回溯删除当前节点贡献的前缀和，避免影响其他路径计算。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        HashMap&lt;Long, Integer&gt; prefixSumCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化前缀和为 0 的路径数量为 1（空路径）</span><br>        prefixSumCount.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>, targetSum, prefixSumCount);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> currSum, <span class="hljs-type">int</span> targetSum, HashMap&lt;Long, Integer&gt; prefixSumCount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 更新当前前缀和</span><br>        currSum += node.val;<br><br>        <span class="hljs-comment">// 检查是否存在从某个祖先节点到当前节点的路径和等于 targetSum</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> prefixSumCount.getOrDefault(currSum - targetSum, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 记录当前前缀和出现次数</span><br>        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归进入左右子树</span><br>        count += dfs(node.left, currSum, targetSum, prefixSumCount);<br>        count += dfs(node.right, currSum, targetSum, prefixSumCount);<br><br>        <span class="hljs-comment">// 回溯：撤销当前节点对前缀和的影响</span><br>        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h1 id="49-二叉树的最近公共祖先"><a href="#49-二叉树的最近公共祖先" class="headerlink" title="49. 二叉树的最近公共祖先"></a>49. 二叉树的最近公共祖先</h1><ul>
<li><strong>一句话描述：</strong> 先判断当前结点是否是p或q，再递归判断左右子树，分为左右子树都找到了结点，左右子树只有一个找到了，左右子树都没找到四种情况</li>
</ul>
<h2 id="49-1-题目描述"><a href="#49-1-题目描述" class="headerlink" title="49.1 题目描述"></a>49.1 题目描述</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], p = <span class="hljs-number">5</span>, q = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure>

<h2 id="49-2-算法思想和代码实现"><a href="#49-2-算法思想和代码实现" class="headerlink" title="49.2 算法思想和代码实现"></a>49.2 算法思想和代码实现</h2><ol>
<li>终止条件：<ul>
<li>如果 root 为空，说明已经递归到了叶子节点的空子树，返回 null。</li>
<li>如果 root 等于 p 或 q，说明找到了其中一个目标节点，直接返回 root（可能是最近公共祖先）。</li>
</ul>
</li>
<li>递归查找：<ul>
<li>在左子树中递归查找 p 和 q 的最近公共祖先 (left)。</li>
<li>在右子树中递归查找 p 和 q 的最近公共祖先 (right)。</li>
</ul>
</li>
<li>回溯过程：<ul>
<li>如果 left 和 right 都不为空，说明 p 和 q 分别位于 root 的左右子树，root 就是它们的最近公共祖先。</li>
<li>如果 left 为空，说明 p 和 q 都在 root 的右子树，返回 right。</li>
<li>如果 right 为空，说明 p 和 q 都在 root 的左子树，返回 left。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>       <span class="hljs-comment">//先看根结点是不是祖先(理论上，一定是祖先，但不一定是最近的祖先)</span><br>       <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||root==p||root==q)<br>           <span class="hljs-keyword">return</span> root;<br><br>       <span class="hljs-comment">//找找最近的祖先，先看左子树，再看右子树</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br><br>       <span class="hljs-comment">//左右子树都找到了，说明是root</span><br>       <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> root;<br>       <span class="hljs-comment">//左子树找到了右子树没找到，返回左子树</span><br>       <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> left;<br>       <span class="hljs-comment">//左子树没找到右子树找到了，返回右子树</span><br>       <span class="hljs-keyword">return</span> right;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h1 id="50-二叉树中的最大路径和"><a href="#50-二叉树中的最大路径和" class="headerlink" title="50. 二叉树中的最大路径和"></a>50. 二叉树中的最大路径和</h1><ul>
<li><strong>一句话总结：</strong> 用一个全局变量记录最大值，<strong>递归记录左右子树的最大贡献</strong>，更新最大值，返回当前结点能为父节点的最大路径值(<strong>只能选左右子树的其中一个贡献大的子树</strong>)</li>
</ul>
<h2 id="50-1-题目描述"><a href="#50-1-题目描述" class="headerlink" title="50.1 题目描述"></a>50.1 题目描述</h2><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">6</span><br>解释：最优路径是 <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> ，路径和为 <span class="hljs-number">2</span> + <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<h2 id="50-2-算法思想和代码实现"><a href="#50-2-算法思想和代码实现" class="headerlink" title="50.2 算法思想和代码实现"></a>50.2 算法思想和代码实现</h2><ol>
<li><p>递归遍历整棵树：</p>
<ul>
<li>计算左右子树的最大贡献值（如果贡献值小于 0，则丢弃）。</li>
<li>计算当前节点作为路径顶点时的最大路径和，并更新全局 maxPathSum。</li>
<li>计算当前节点能提供的最大贡献值，并返回给上一层递归。</li>
</ul>
</li>
<li><p>分情况讨论：</p>
<ul>
<li>路径断裂：返回当前子树的最大贡献值（只能选左右子树之一）。</li>
<li>路径不断裂：更新全局最大路径和（包含左右子树和当前节点）。</li>
</ul>
</li>
</ol>
<p>1、那么，首先我们可以假设走到了某个节点，现在要面临的问题是路径的最大值问题，显然对于这种问题，每遍历到一个节点，我们都要求出包含该节点在内的此时的最大路径，并且在之后的遍历中更新这个最大值。对于该节点来说，它的最大路径currpath就等于左右子树的最大路径加上本身的值，也就是currpath &#x3D; left+right+node,val，但是有一个前提，我们要求的是最大路径，所以若是left或者right小于等于0了，那么我们就没有必要把这些值加上了，因为加上一个负数，会使得最大路径变小。这里的最大路径中的最其实就是一个限定条件，也就是我们常说的贪心算法，只取最大，最好，其余的直接丢弃。</p>
<p>2、好了，1中的主体我们已经明确了，但是还存在一个问题，那就是left和right具体应该怎么求，也就是left和right的递归形式。显然我们要把node.left和node.right再次传输到递归函数中，重复上述的操作。但如果到达了叶子节点，是不是需要往上一层返回了呢？那么返回值又是多少呢？<br>我们要明确left和right的基本含义，它们表示的是最大贡献，那么一个节点的最大贡献就等于node.val+max(left,right)，这个节点本身选上，然后从它的左右子树中选择最大的那个加上。<br>对于叶子节点也是这样，但是叶子节点的左右子树都为空，所以加上0，哎，注意看，此时是不是边界条件也出来了，但节点为空时，返回0 。 好了，至此循环的主体，返回值，边界条件都定义好了，那么整个递归的代码是不是就水到渠成了。这样一看递归也没什么了不起的！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, dfs(node.left)); <span class="hljs-comment">// 左子树最大贡献</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, dfs(node.right)); <span class="hljs-comment">// 右子树最大贡献</span><br><br>    <span class="hljs-comment">// 以当前节点为最高点的路径和</span><br>    maxSum = Math.max(maxSum, left + right + node.val);<br><br>    <span class="hljs-comment">// 返回当前节点能为父节点贡献的最大路径值</span><br>    <span class="hljs-keyword">return</span> Math.max(left, right) + node.val;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="51-岛屿数量"><a href="#51-岛屿数量" class="headerlink" title="51. 岛屿数量"></a>51. 岛屿数量</h1><ul>
<li><strong>一句话总结：</strong> 若当前元素为’1’则计数加1，并感染周围的元素为’2’，防止重复计数</li>
</ul>
<h2 id="51-1-题目描述"><a href="#51-1-题目描述" class="headerlink" title="51.1 题目描述"></a>51.1 题目描述</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="51-2-算法思想和代码实现"><a href="#51-2-算法思想和代码实现" class="headerlink" title="51.2 算法思想和代码实现"></a>51.2 算法思想和代码实现</h2><ul>
<li>遍历岛这个二维数组，如果当前数为1，则进入感染函数并将岛个数+1</li>
<li>感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。<ul>
<li>为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//遍历所有元素，找到所有的岛，并感染岛的上下左右</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                count++;<br>                infect(grid, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//将当前的岛的元素全部感染成2，上下左右的元素置为2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infect</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br><br>    <span class="hljs-comment">//感染上下左右的元素</span><br>    infect(grid, i - <span class="hljs-number">1</span>, j);<br>    infect(grid, i + <span class="hljs-number">1</span>, j);<br>    infect(grid, i, j - <span class="hljs-number">1</span>);<br>    infect(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="52-腐烂的橘子"><a href="#52-腐烂的橘子" class="headerlink" title="52. 腐烂的橘子"></a>52. 腐烂的橘子</h1><ul>
<li><strong>一句话描述：</strong> 先把当前状态转换替代成其他值，用<strong>时间标记当前腐烂的橘子</strong>，下一轮腐烂的橘子&#x3D;当前time+1，直到没有新橘子被感染跳出循环</li>
</ul>
<h2 id="52-1-题目描述"><a href="#52-1-题目描述" class="headerlink" title="52.1 题目描述"></a>52.1 题目描述</h2><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格；</li>
<li>值 1 代表新鲜橘子；</li>
<li>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<h2 id="52-2-算法思想和代码实现"><a href="#52-2-算法思想和代码实现" class="headerlink" title="52.2 算法思想和代码实现"></a>52.2 算法思想和代码实现</h2><ol>
<li>状态转换：<ul>
<li>空位 0 被标记为 -2; 新鲜橘子 1 被标记为 -1; 腐烂橘子 2 被标记为 0</li>
</ul>
</li>
<li>BFS 模拟腐烂过程：<ul>
<li>遍历整个网格，找到所有腐烂橘子（初始 0 值）。</li>
<li>在 while 循环中，每分钟所有<strong>当前腐烂的橘子尝试感染其四个方向的新鲜橘子</strong></li>
<li>被感染的橘子被赋值为 time + 1，即表示它在 time+1 分钟后变烂。</li>
</ul>
</li>
<li>终止条件：<ul>
<li>如果在某一轮遍历中没有橘子被感染，说明腐烂过程结束，跳出循环。</li>
</ul>
</li>
<li>检查是否仍有未腐烂的橘子：<ul>
<li>遍历网格，如果仍然存在 -1（新鲜橘子），则返回 -1，表示无法全部腐烂。</li>
<li>否则，返回 time，即腐烂传播所需的总时间。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录腐烂传播所需的分钟数</span><br><br>        <span class="hljs-comment">// -2 表示空位，-1 表示新鲜橘子，0 表示腐烂橘子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                grid[i][j] -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 模拟腐烂过程</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">finished</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == time) &#123;<br>                        <span class="hljs-comment">// 当前腐烂的橘子，尝试感染四个方向的新鲜橘子</span><br>                        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i - <span class="hljs-number">1</span>][j] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i][j - <span class="hljs-number">1</span>] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i + <span class="hljs-number">1</span>][j] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i][j + <span class="hljs-number">1</span>] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (finished)<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果没有橘子被感染，结束循环</span><br>            <span class="hljs-keyword">else</span><br>                time++;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历网格，如果仍然存在未腐烂的橘子，返回 -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == -<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br></code></pre></td></tr></table></figure>


<h1 id="53-课程表"><a href="#53-课程表" class="headerlink" title="53. 课程表"></a>53. 课程表</h1><ul>
<li><strong>一句话描述：</strong> 判断一个有向图是否有环，不会….</li>
</ul>
<h2 id="53-1-题目描述"><a href="#53-1-题目描述" class="headerlink" title="53.1 题目描述"></a>53.1 题目描述</h2><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：numCourses = <span class="hljs-number">2</span>, prerequisites = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-literal">true</span><br>解释：总共有 <span class="hljs-number">2</span> 门课程。学习课程 <span class="hljs-number">1</span> 之前，你需要完成课程 <span class="hljs-number">0</span> 。这是可能的。<br></code></pre></td></tr></table></figure>

<h2 id="53-2-算法思想和代码实现"><a href="#53-2-算法思想和代码实现" class="headerlink" title="53.2 算法思想和代码实现"></a>53.2 算法思想和代码实现</h2><p>拓扑排序，用于判断一个有向图是否存在环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prerequisites.length;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">int</span>[] pointer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<span class="hljs-comment">// 每个课程被指向的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : prerequisites) ++pointer[p[<span class="hljs-number">1</span>]];<br>    <span class="hljs-type">boolean</span>[] removed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len];<span class="hljs-comment">// 标记prerequisites中的元素是否被移除</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 移除的元素数量</span><br>    <span class="hljs-keyword">while</span> (remove &lt; len) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currRemove</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 本轮移除的元素数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (removed[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 被移除的元素跳过</span><br>            <span class="hljs-type">int</span>[] p = prerequisites[i];<br>            <span class="hljs-keyword">if</span> (pointer[p[<span class="hljs-number">0</span>]] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 如果被安全课程指向</span><br>                --pointer[p[<span class="hljs-number">1</span>]];<span class="hljs-comment">// 被指向次数减1</span><br>                removed[i] = <span class="hljs-literal">true</span>;<br>                ++currRemove;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (currRemove == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 如果一轮跑下来一个元素都没移除，则没必要进行下一轮</span><br>        remove += currRemove;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="54-实现Trie-前缀树"><a href="#54-实现Trie-前缀树" class="headerlink" title="54. 实现Trie(前缀树)"></a>54. 实现Trie(前缀树)</h1><ul>
<li><strong>一句话描述：</strong> 面试会考吗？不会》….</li>
</ul>
<h2 id="54-1-题目描述"><a href="#54-1-题目描述" class="headerlink" title="54.1 题目描述"></a>54.1 题目描述</h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p>
<p>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">输入<br>[<span class="hljs-string">&quot;Trie&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>, <span class="hljs-string">&quot;startsWith&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>]<br>[[], [<span class="hljs-string">&quot;apple&quot;</span>], [<span class="hljs-string">&quot;apple&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>]<br><br>解释<br><span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>trie.insert(<span class="hljs-string">&quot;apple&quot;</span>);<br>trie.search(<span class="hljs-string">&quot;apple&quot;</span>);   <span class="hljs-comment">// 返回 True</span><br>trie.search(<span class="hljs-string">&quot;app&quot;</span>);     <span class="hljs-comment">// 返回 False</span><br>trie.startsWith(<span class="hljs-string">&quot;app&quot;</span>); <span class="hljs-comment">// 返回 True</span><br>trie.insert(<span class="hljs-string">&quot;app&quot;</span>);<br>trie.search(<span class="hljs-string">&quot;app&quot;</span>);     <span class="hljs-comment">// 返回 True</span><br></code></pre></td></tr></table></figure>

<h2 id="54-2-算法思想和代码实现"><a href="#54-2-算法思想和代码实现" class="headerlink" title="54.2 算法思想和代码实现"></a>54.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    TrieNode[] children;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 假设只包含小写字母 a-z</span><br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="55-全排列"><a href="#55-全排列" class="headerlink" title="55. 全排列"></a>55. 全排列</h1><ul>
<li><strong>一句话描述：</strong> 用一个boolean<strong>数组visited</strong>保存已经访问的元素，下次循环直接跳过；回溯三部曲：<strong>终止条件，for循环递归，回溯撤销</strong></li>
</ul>
<h2 id="55-1-题目描述"><a href="#55-1-题目描述" class="headerlink" title="55.1 题目描述"></a>55.1 题目描述</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="55-2-算法思想和代码实现"><a href="#55-2-算法思想和代码实现" class="headerlink" title="55.2 算法思想和代码实现"></a>55.2 算法思想和代码实现</h2><ul>
<li>用visited保存已经访问过的元素，下次循环直接跳过</li>
<li>终止条件：排列的长度等于数组长度</li>
<li>循环+递归：跳过已经访问过的元素，没有访问的元素加入排列结果</li>
<li>回溯：撤销当前选择的元素，并将visited改为true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution055</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// 存储最终的全排列结果</span><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// 存储当前排列的路径</span><br>    <span class="hljs-type">boolean</span>[] visited;<span class="hljs-comment">// 记录某个元素是否被使用</span><br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> result;<br><br>        <span class="hljs-comment">// 初始化 visited 数组，长度等于输入数组长度，初始值默认为 false</span><br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        <br>        permuteHelper(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归回溯函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permuteHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 终止条件：当前排列的长度等于输入数组长度</span><br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            <span class="hljs-comment">// 返回当前路径</span><br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历所有元素，尝试加入排列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前元素已被使用，则跳过</span><br>            <span class="hljs-keyword">if</span> (visited[i])<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 选择当前元素</span><br>            path.add(nums[i]);<br>            visited[i] = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 递归进入下一层</span><br>            permuteHelper(nums);<br><br>            <span class="hljs-comment">// 撤销选择，进行回溯</span><br>            path.removeLast();<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="56-子集"><a href="#56-子集" class="headerlink" title="56. 子集"></a>56. 子集</h1><ul>
<li><strong>一句话描述：</strong> 收集子集，for(){收集元素，递归到下一层元素，回溯撤销}</li>
</ul>
<h2 id="56-1-题目描述"><a href="#56-1-题目描述" class="headerlink" title="56.1 题目描述"></a>56.1 题目描述</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="56-2-算法思想和代码实现"><a href="#56-2-算法思想和代码实现" class="headerlink" title="56.2 算法思想和代码实现"></a>56.2 算法思想和代码实现</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">                        <span class="hljs-comment">[]</span><br>           /            |            \<br>        <span class="hljs-comment">[1]</span>            <span class="hljs-comment">[2]</span>           <span class="hljs-comment">[3]</span><br>       /   \           /            /<br>   <span class="hljs-comment">[1,2]</span>  <span class="hljs-comment">[1,3]</span>     <span class="hljs-comment">[2,3]</span>        <br>    /                    <br><span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class="hljs-comment">//保存最终结果</span><br>List&lt;Integer&gt; path=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//保存当前路径下的结果</span><br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    subsetsHelper(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsetsHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> start)</span>&#123;<br>    <span class="hljs-comment">//返回当前每一种情况的子集</span><br>    result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>    <br>    <span class="hljs-comment">//遍历完整个数组之后结束</span><br>    <span class="hljs-keyword">if</span>(start&gt;nums.length)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.length;i++)&#123;<br>        path.add(nums[i]);<br>        subsetsHelper(nums,i+<span class="hljs-number">1</span>);<br>        path.removeLast();<span class="hljs-comment">//撤销，回溯</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="57-电话号码的字母组合"><a href="#57-电话号码的字母组合" class="headerlink" title="57. 电话号码的字母组合"></a>57. 电话号码的字母组合</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li>通过回溯法依次遍历输入数字串 digits，从第一个数字开始，根据数字映射的字母表，逐个尝试<strong>每个字母，将其加入当前路径</strong> path，然后<strong>递归处理下一个数字</strong>。当遍历到<strong>路径长度等于输入长度</strong>时，说明已生成一个完整组合，将其拼接成字符串<strong>加入结果列表</strong> result，随后<strong>回退</strong>（撤销最后一个字符）继续尝试其它可能，直到穷尽所有组合。</li>
</ul>
<h2 id="57-1-题目描述"><a href="#57-1-题目描述" class="headerlink" title="57.1 题目描述"></a>57.1 题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：digits = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="57-2-算法思想和代码实现"><a href="#57-2-算法思想和代码实现" class="headerlink" title="57.2 算法思想和代码实现"></a>57.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-comment">// 用于存储最终的组合结果</span><br>List&lt;Character&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-comment">// 用于存储当前递归路径上的字符</span><br><br><span class="hljs-comment">// 用于映射数字到对应的字母字符</span><br>String[] mapString = &#123;<br>        <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>    <span class="hljs-comment">// 如果输入为空，则直接返回空列表</span><br>    <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// 进行回溯搜索</span><br>    letterCombinationsHelper(digits, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">letterCombinationsHelper</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件：当索引等于字符串长度时，表示已经生成了一个完整的组合</span><br>    <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>        <br>        <span class="hljs-comment">// 将 path 中的字符拼接成字符串并加入结果列表</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : path) &#123;<br>            sb.append(c);<br>        &#125;<br>        result.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 取出当前索引对应的数字，并找到其对应的字母字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> mapString[digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>];<br><br>    <span class="hljs-comment">// 遍历该数字对应的所有字母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-comment">// 选择当前字母，加入路径</span><br>        path.add(str.charAt(i));<br>        <span class="hljs-comment">// 递归处理下一个数字</span><br>        letterCombinationsHelper(digits, index + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择（回溯）</span><br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="58-组合总和"><a href="#58-组合总和" class="headerlink" title="58. 组合总和"></a>58. 组合总和</h1><ul>
<li><strong>一句话描述：</strong> 当前缀和等于target时，终止递归；for(){添加当前元素，递归进入下一层，回溯撤销}</li>
</ul>
<h2 id="58-1-题目描述"><a href="#58-1-题目描述" class="headerlink" title="58.1 题目描述"></a>58.1 题目描述</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], target = <span class="hljs-number">7</span><br>输出：[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>]]<br>解释：<br><span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 可以形成一组候选，<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">7</span> 。注意 <span class="hljs-number">2</span> 可以使用多次。<br><span class="hljs-number">7</span> 也是一个候选， <span class="hljs-number">7</span> = <span class="hljs-number">7</span> 。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure>

<h2 id="58-2-算法思想和代码实现"><a href="#58-2-算法思想和代码实现" class="headerlink" title="58.2 算法思想和代码实现"></a>58.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>   <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-comment">//先对整数数组进行排序</span><br>     <span class="hljs-comment">//  Arrays.sort(candidates);</span><br><br>       combinationSumHelper(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combinationSumHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span> &#123;<br>       <span class="hljs-keyword">if</span> (sum == target) &#123;<br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>           <span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>           <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">break</span>;<br><br>           path.add(candidates[i]);<br>           combinationSumHelper(candidates, target, i, sum + candidates[i]);<br>           path.removeLast();<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure>


<h1 id="59-括号生成"><a href="#59-括号生成" class="headerlink" title="59. 括号生成"></a>59. 括号生成</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>当<strong>左右括号用完了</strong>终止递归加入结果(left&#x3D;&#x3D;0&amp;&amp;right&#x3D;&#x3D;0)</li>
<li>当<strong>左括号数量大于0</strong>可以选择左括号</li>
<li>当<strong>右括号剩余数量大于左括号剩余数量</strong>，可以选择右括号，然后<strong>添加递归回溯</strong></li>
</ul>
<h2 id="59-1-题目描述"><a href="#59-1-题目描述" class="headerlink" title="59.1 题目描述"></a>59.1 题目描述</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="59-2-算法思想和代码实现"><a href="#59-2-算法思想和代码实现" class="headerlink" title="59.2 算法思想和代码实现"></a>59.2 算法思想和代码实现</h2><ul>
<li>只有剩余的左括号数量大于 0 时，才可以选择左括号</li>
<li>只有右括号剩余数量大于左括号时，才可以选择右括号</li>
<li>递归终止条件：如果左右括号都用完了，加入结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Character&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    generateParenthesisHelper(n, n);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateParenthesisHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件：如果左右括号都用完了，加入结果</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : path) &#123;<br>            sb.append(c);<br>        &#125;<br>        res.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 只有剩余的左括号数量大于 0 时，才可以选择左括号</span><br>    <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>        path.add(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        generateParenthesisHelper(left - <span class="hljs-number">1</span>, right);<br>        path.removeLast();<br>    &#125;<br><br>    <span class="hljs-comment">// 只有右括号剩余数量大于左括号时，才可以选择右括号</span><br>    <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>        path.add(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        generateParenthesisHelper(left, right - <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="60-单词搜索"><a href="#60-单词搜索" class="headerlink" title="60. 单词搜索"></a>60. 单词搜索</h1><ul>
<li><strong>一句话描述：</strong> 通过双重循环遍历二维字符数组的每个元素，<strong>找到与单词首字符相同的位置后</strong>，调用递归函数<strong>向上下左右四个方向查找下一个字符</strong>，每访问一个字符就将其暂时<strong>标记为已访问</strong>（用 <code>#</code> 替换），<strong>防止重复</strong>走回头路，递归如果找到完整单词则返回 true，<strong>未找到则恢复该位置原字符</strong>，继续尝试其他路径，直到所有可能都搜索完毕。</li>
</ul>
<h2 id="60-1-题目描述"><a href="#60-1-题目描述" class="headerlink" title="60.1 题目描述"></a>60.1 题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h2 id="60-2-算法思想和代码实现"><a href="#60-2-算法思想和代码实现" class="headerlink" title="60.2 算法思想和代码实现"></a>60.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>              <span class="hljs-keyword">if</span> (isExist(board, word, i, j, <span class="hljs-number">0</span>)) &#123;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> num)</span> &#123;<br>      <span class="hljs-comment">// 递归终止条件：找到完整单词</span><br>      <span class="hljs-keyword">if</span> (num == word.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-comment">// 边界检查：是否超出范围</span><br>      <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= board.length || col &gt;= board[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-comment">// 检查当前字符是否匹配</span><br>      <span class="hljs-keyword">if</span> (board[row][col] != word.charAt(num)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span>; <span class="hljs-comment">// 标记已访问，防止重复使用</span><br><br>      <span class="hljs-comment">// 尝试向四个方向寻找下一个字符</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> isExist(board, word, row + <span class="hljs-number">1</span>, col, num + <span class="hljs-number">1</span>) ||<br>              isExist(board, word, row - <span class="hljs-number">1</span>, col, num + <span class="hljs-number">1</span>) ||<br>              isExist(board, word, row, col + <span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>) ||<br>              isExist(board, word, row, col - <span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>);<br><br>      <span class="hljs-comment">// 恢复原来的字符</span><br>      board[row][col] = word.charAt(num);<br><br>      <span class="hljs-keyword">return</span> found;<br>  &#125;<br></code></pre></td></tr></table></figure>


<h1 id="61-分割回文串"><a href="#61-分割回文串" class="headerlink" title="61. 分割回文串"></a>61. 分割回文串</h1><ul>
<li><strong>一句话描述：</strong> 通过从字符串的起始位置开始，用循环<strong>依次截取不同长度的子串</strong>，判断当前子串是否是回文串，如果是则将其加入路径列表，并<strong>递归继续处理剩余部分</strong>，直到遍历完整个字符串，将完整路径加入结果列表，递归返回时通过 removeLast() 撤销上一次添加的子串，继续尝试下一种截取方式。</li>
</ul>
<h2 id="61-1-题目描述"><a href="#61-1-题目描述" class="headerlink" title="61.1 题目描述"></a>61.1 题目描述</h2><p>给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="61-2-算法思想和代码实现"><a href="#61-2-算法思想和代码实现" class="headerlink" title="61.2 算法思想和代码实现"></a>61.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储每个回文子串</span><br><br> <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>     partitionHelper(s, <span class="hljs-number">0</span>);<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">partitionHelper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>     <span class="hljs-keyword">if</span> (start == s.length()) &#123;<br>         res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++) &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取出子串【start,i+1),左闭区间，右开区间</span><br><br>         <span class="hljs-keyword">if</span> (isPalindrome(sub)) &#123;<br>             path.add(sub); <span class="hljs-comment">// 记录回文子串</span><br>             partitionHelper(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归</span><br>             path.removeLast(); <span class="hljs-comment">// 回溯，移除最后加入的子串</span><br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 回文判断</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>         <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>         left++;<br>         right--;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure>



<h1 id="62-N皇后"><a href="#62-N皇后" class="headerlink" title="62. N皇后"></a>62. N皇后</h1><ul>
<li><strong>一句话描述：</strong> 循环尝试在棋盘的<strong>每一行每一列放置皇后</strong>，遇到<strong>符合条件的位置</strong>就将皇后<strong>放下</strong>，并<strong>递归进入下一行</strong>继续放置，直到所有行都放置完毕时将当前棋盘状态转换成字符串列表加入结果集中，递归返回时通过将皇后位置<strong>回溯复原</strong>，继续尝试下一列的位置，最终遍历出所有可能的皇后摆放方案。</li>
</ul>
<h2 id="62-1-题目描述"><a href="#62-1-题目描述" class="headerlink" title="62.1 题目描述"></a>62.1 题目描述</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure>

<h2 id="62-2-算法思想和代码实现"><a href="#62-2-算法思想和代码实现" class="headerlink" title="62.2 算法思想和代码实现"></a>62.2 算法思想和代码实现</h2><ol>
<li><strong>递归搜索</strong><ul>
<li>按行进行搜索，每行尝试放置一个皇后。</li>
<li>当所有行都放置完皇后时，将当前棋盘加入 ans 结果集。</li>
</ul>
</li>
<li><strong>合法性检查</strong> <ul>
<li>在尝试放置皇后前，检查当前列、左上方 45° 对角线、右上方 135° 对角线是否已有皇后。</li>
<li>只有满足条件的位置才能放置皇后。</li>
</ul>
</li>
<li><strong>回溯</strong><ul>
<li>先尝试在当前行的某一列放置皇后。</li>
<li>递归处理下一行。</li>
<li>如果递归失败（即后续行无法放置皇后），撤销当前放置（回溯），尝试当前行的下一列。</li>
</ul>
</li>
<li><strong>终止条件</strong><ul>
<li>当 row &#x3D;&#x3D; n（即所有行都放置完皇后）时，表示找到了一种合法解法，存入 ans</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储所有可能的 N 皇后解法</span><br><br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">char</span>[][] chess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n]; <span class="hljs-comment">// 创建 n × n 的棋盘</span><br>    <span class="hljs-comment">// 初始化棋盘，所有位置填充为 &#x27;.&#x27;（表示空位）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chess)<br>        Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br>    dfs(<span class="hljs-number">0</span>, n, chess); <span class="hljs-comment">// 递归回溯从第 0 行开始</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] chess)</span> &#123;<br>    <span class="hljs-comment">// 终止条件：所有行都已经放置了皇后</span><br>    <span class="hljs-keyword">if</span> (row == n) &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chess)  <span class="hljs-comment">// 将当前棋盘的每一行转换为字符串</span><br>            list.add(String.copyValueOf(c));<br>        ans.add(list);  <span class="hljs-comment">// 将这一种可行解加入结果集</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在当前行的每一列尝试放置皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-keyword">if</span> (isValid(row, col, n, chess)) &#123; <span class="hljs-comment">// 检查当前位置是否可以放置皇后</span><br>            chess[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;  <span class="hljs-comment">// 放置皇后</span><br>            dfs(row + <span class="hljs-number">1</span>, n, chess);  <span class="hljs-comment">// 递归放置下一行的皇后</span><br>            chess[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;  <span class="hljs-comment">// 回溯：撤销放置，尝试下一列</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] chess)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查当前列是否已有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++)<br>        <span class="hljs-keyword">if</span> (chess[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 2. 检查左上方 45° 斜线是否已有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)<br>        <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 3. 检查右上方 135° 斜线是否已有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++)<br>        <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 如果当前位置符合规则，则返回 true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="63-搜索插入位置"><a href="#63-搜索插入位置" class="headerlink" title="63. 搜索插入位置"></a>63. 搜索插入位置</h1><ul>
<li><strong>一句话描述：</strong> 二分查找</li>
</ul>
<h2 id="63-1-题目描述"><a href="#63-1-题目描述" class="headerlink" title="63.1 题目描述"></a>63.1 题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="63-2-算法思想和代码实现"><a href="#63-2-算法思想和代码实现" class="headerlink" title="63.2 算法思想和代码实现"></a>63.2 算法思想和代码实现</h2><p>二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当目标值不存在于数组中时，返回插入位置，即左指针的位置</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="64-搜索二维矩阵"><a href="#64-搜索二维矩阵" class="headerlink" title="64. 搜索二维矩阵"></a>64. 搜索二维矩阵</h1><ul>
<li><strong>一句话描述：</strong> 二分查找：从右上角元素向下或向左移动</li>
</ul>
<h2 id="64-1-题目描述"><a href="#64-1-题目描述" class="headerlink" title="64.1 题目描述"></a>64.1 题目描述</h2><p>给你一个满足下述两条属性的 m x n 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。<br>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">23</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">60</span>]], target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<h2 id="64-2-算法思想和代码实现"><a href="#64-2-算法思想和代码实现" class="headerlink" title="64.2 算法思想和代码实现"></a>64.2 算法思想和代码实现</h2><p>二分查找：从右上角元素向下或向左移动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">//i和j分别记录右上角的元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target)<br>            j--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target)<br>            i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="65-在排序数组中查找元素的第一个和最后一个位置"><a href="#65-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="65. 在排序数组中查找元素的第一个和最后一个位置"></a>65. 在排序数组中查找元素的第一个和最后一个位置</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>二分查找<strong>先查找第一个位置，再查找结束位置</strong></li>
<li>查找左边位置时，当<code>nums[mid] == target</code>，<code>right = mid - 1</code>不断向左收缩</li>
<li>查找右边位置时，当<code>nums[mid] == target</code>，<code>left = mid + 1</code>不断向右收缩</li>
</ul>
<h2 id="65-1-题目描述"><a href="#65-1-题目描述" class="headerlink" title="65.1 题目描述"></a>65.1 题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">8</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>

<h2 id="65-2-算法思想和代码实现"><a href="#65-2-算法思想和代码实现" class="headerlink" title="65.2 算法思想和代码实现"></a>65.2 算法思想和代码实现</h2><p>分两次查找，第一次二分查找开始位置，第二次二分查找结束位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> findFirstPosition(nums, target);<br>    <span class="hljs-keyword">if</span> (first == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLastPosition(nums, target);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;first, last&#125;;<br>&#125;<br><br><span class="hljs-comment">//二分查找第一个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFirstPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 不断收缩右边界，直到找到最左的target</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target) &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//二分查找最后一个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLastPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 不断收缩左边界，直到找到最右的target</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == target) &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="66-搜索旋转排序数组"><a href="#66-搜索旋转排序数组" class="headerlink" title="66. 搜索旋转排序数组"></a>66. 搜索旋转排序数组</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>直接对数组进行二分，其中一定有一个子区间是<strong>有序的</strong>，另一个<strong>部分有序</strong></li>
<li>判断哪个区间是有序的，然后继续进行逻辑判断</li>
</ul>
<h2 id="66-1-题目描述"><a href="#66-1-题目描述" class="headerlink" title="66.1 题目描述"></a>66.1 题目描述</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<h2 id="66-2-算法思想和代码实现"><a href="#66-2-算法思想和代码实现" class="headerlink" title="66.2 算法思想和代码实现"></a>66.2 算法思想和代码实现</h2><ul>
<li>直接对数组进行二分，其中一定有一个子区间是有序的，另一个部分有序<ol>
<li>如果target在这个有序区间内：直接二分</li>
<li>如果target在另一个区间内：二分后仍得到一个有序和部分有序区间，不断往复。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br><br>     <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <br>         <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>         <span class="hljs-comment">// 如果中间元素就是目标值，则返回索引</span><br>         <span class="hljs-keyword">if</span> (nums[mid] == target) &#123; <br>             <span class="hljs-keyword">return</span> mid;<br>         &#125;<br><br>         <span class="hljs-comment">// 判断左半部分是否是有序的</span><br>         <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;<br>             <span class="hljs-comment">// 如果目标值在左半部分范围内，则缩小右边界</span><br>             <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;<br>                 right = mid - <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则搜索右半部分</span><br>                 left = mid + <span class="hljs-number">1</span>;<br>             &#125;<br>         &#125;<br><br>         <span class="hljs-comment">// 如果右半部分是有序的</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;<br>             <span class="hljs-comment">// 如果目标值在右半部分范围内，则缩小左边界</span><br>             <span class="hljs-keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]) &#123;<br>                 left = mid + <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则搜索左半部分</span><br>                 right = mid - <span class="hljs-number">1</span>;<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标值，返回 -1</span><br> &#125;<br></code></pre></td></tr></table></figure>


<h1 id="67-寻找旋转排序数组的最小值"><a href="#67-寻找旋转排序数组的最小值" class="headerlink" title="67. 寻找旋转排序数组的最小值"></a>67. 寻找旋转排序数组的最小值</h1><ul>
<li><strong>一句话描述：</strong><ul>
<li>如果 <code>nums[mid] &gt; nums[right]</code>，最小值一定在右边，left&#x3D;mid+1</li>
<li>如果 <code>nums[mid] &lt;= nums[right]</code>，最小值在左边，right&#x3D;mid</li>
<li>退出循环时，left &#x3D;&#x3D; right，正是最小值的位置</li>
</ul>
</li>
</ul>
<h2 id="67-1-题目描述"><a href="#67-1-题目描述" class="headerlink" title="67.1 题目描述"></a>67.1 题目描述</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li>
<li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</li>
</ul>
<p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">1</span><br>解释：原数组为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure>

<h2 id="67-2-算法思想和代码实现"><a href="#67-2-算法思想和代码实现" class="headerlink" title="67.2 算法思想和代码实现"></a>67.2 算法思想和代码实现</h2><ul>
<li>如果 <code>nums[mid] &gt; nums[right]</code>，最小值一定在右边，left&#x3D;mid+1</li>
<li>如果 <code>nums[mid] &lt;= nums[right]</code>，最小值在左边，right&#x3D;mid</li>
<li>退出循环时，left &#x3D;&#x3D; right，正是最小值的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<br>            <span class="hljs-comment">// 最小值在右半边</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 最小值在左半边（包含 mid）</span><br>            right = mid;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[left]; <span class="hljs-comment">// 或 nums[right]，此时 left == right</span><br>&#125;<br><br></code></pre></td></tr></table></figure>


<h1 id="68-寻找两个正序数组的中位数"><a href="#68-寻找两个正序数组的中位数" class="headerlink" title="68. 寻找两个正序数组的中位数"></a>68. 寻找两个正序数组的中位数</h1><ul>
<li><strong>一句话描述：</strong> 难，，直接暴力吧</li>
</ul>
<h2 id="68-1-题目描述"><a href="#68-1-题目描述" class="headerlink" title="68.1 题目描述"></a>68.1 题目描述</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], nums2 = [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2.00000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] ，中位数 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="68-2-算法思想和代码实现"><a href="#68-2-算法思想和代码实现" class="headerlink" title="68.2 算法思想和代码实现"></a>68.2 算法思想和代码实现</h2><ul>
<li>将两个数组划分为左右两部分，确保：<ul>
<li>左半部分的所有元素 ≤ 右半部分的所有元素。</li>
<li>这样，左半部分的最大值是中位数（如果总数是奇数）。</li>
<li>如果总数是偶数，中位数是左半部分的最大值和右半部分的最小值的平均值。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br><br>        <span class="hljs-comment">// 保证 nums1 是较短的数组</span><br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m, halfLen = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> halfLen - i;<br><br>            <span class="hljs-keyword">if</span> (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                left = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// i 过小，需要右移</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[i - <span class="hljs-number">1</span>] &gt; nums2[j]) &#123;<br>                right = i - <span class="hljs-number">1</span>; <span class="hljs-comment">// i 过大，需要左移</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// i 是合适的切割位置</span><br>                <span class="hljs-type">int</span> maxLeft;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    maxLeft = nums2[j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    maxLeft = nums1[i - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxLeft = Math.max(nums1[i - <span class="hljs-number">1</span>], nums2[j - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxLeft; <span class="hljs-comment">// 奇数长度直接返回中位数</span><br>                &#125;<br><br>                <span class="hljs-type">int</span> minRight;<br>                <span class="hljs-keyword">if</span> (i == m) &#123;<br>                    minRight = nums2[j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;<br>                    minRight = nums1[i];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minRight = Math.min(nums1[i], nums2[j]);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> (maxLeft + minRight) / <span class="hljs-number">2.0</span>; <span class="hljs-comment">// 偶数长度返回均值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>


<h1 id="69-有效的括号"><a href="#69-有效的括号" class="headerlink" title="69. 有效的括号"></a>69. 有效的括号</h1><ul>
<li><strong>一句话描述：</strong> 遇到左括号入栈，右括号如果能与栈顶左括号匹配则正确，不匹配返回false</li>
</ul>
<h2 id="69-1-题目描述"><a href="#69-1-题目描述" class="headerlink" title="69.1 题目描述"></a>69.1 题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<h2 id="69-2-算法思想和代码实现"><a href="#69-2-算法思想和代码实现" class="headerlink" title="69.2 算法思想和代码实现"></a>69.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <br>        <span class="hljs-comment">//如果字符是左括号，则入栈</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            stack.push(c);<br><br>        <span class="hljs-comment">//如果字符是右括号</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span> || c == <span class="hljs-string">&#x27;&#125;&#x27;</span> || c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-comment">//为空返回false</span><br>            <span class="hljs-keyword">if</span> (stack.isEmpty())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-comment">//如果此时字符和栈顶元素相同，则弹出栈顶元素，否则返回false</span><br>            <span class="hljs-keyword">if</span> (stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span> || stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span> || stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="70-最小栈"><a href="#70-最小栈" class="headerlink" title="70. 最小栈"></a>70. 最小栈</h1><ul>
<li><strong>一句话描述：</strong> 用一个链表包含val和min两个成员变量，min用来保存最小值，入栈就是链表头结点<strong>头插一个新元素</strong>，出栈就是指向头结点下一个结点</li>
</ul>
<h2 id="70-1-题目描述"><a href="#70-1-题目描述" class="headerlink" title="70.1 题目描述"></a>70.1 题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<ul>
<li>MinStack() 初始化堆栈对象。</li>
<li>void push(int val) 将元素val推入堆栈。</li>
<li>void pop() 删除堆栈顶部的元素。</li>
<li>int top() 获取堆栈顶部的元素。</li>
<li>int getMin() 获取堆栈中的最小元素。</li>
</ul>
<h2 id="70-2-算法思想和代码实现"><a href="#70-2-算法思想和代码实现" class="headerlink" title="70.2 算法思想和代码实现"></a>70.2 算法思想和代码实现</h2><ul>
<li>使用链表实现一个栈的操作</li>
<li>链表的头部始终指向栈顶元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">// 头节点，始终指向栈顶</span><br>    Node head;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 栈初始化为空</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 如果栈为空，则新节点的 min 值就是 val 本身</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果栈非空，新节点的 min 取当前值与前一个 min 的较小值</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, Math.min(val, head.min), head);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        head = head.next; <span class="hljs-comment">// 直接指向下一个节点，删除当前栈顶</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.min;<br>    &#125;<br>    <br>    <span class="hljs-comment">//创建一个链表内部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-type">int</span> min;<br>        Node next;<br><br>        <span class="hljs-comment">// 构造方法（用于创建栈底节点）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> min)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 构造方法（用于创建普通节点，包含 next 指针）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> min, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="71-字符串解码"><a href="#71-字符串解码" class="headerlink" title="71. 字符串解码"></a>71. 字符串解码</h1><ul>
<li><strong>一句话描述：</strong> 难，使用两个栈</li>
</ul>
<h2 id="71-1-题目描述"><a href="#71-1-题目描述" class="headerlink" title="71.1 题目描述"></a>71.1 题目描述</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;3[a]2[bc]&quot;</span><br>输出：<span class="hljs-string">&quot;aaabcbc&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="71-2-算法思想和代码实现"><a href="#71-2-算法思想和代码实现" class="headerlink" title="71.2 算法思想和代码实现"></a>71.2 算法思想和代码实现</h2><p>使用两个栈：</p>
<ul>
<li>一个存放重复次数（countStack）</li>
<li>一个存放之前的部分字符串（resStack）</li>
</ul>
<ol>
<li>当遇到 [ 时，意味着开始一个新的子串，需要把当前的 StringBuilder 存入栈，新的部分重新开始。</li>
<li>当遇到 ] 时，意味着这个子串已经结束，要取出 count 并重复添加到上一级字符串中。</li>
<li>当遇到数字字符时，计算对应的数字，因为数字取值在300以内，不一定是单个字符，可能为多个字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Integer&gt; countStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">//存放次数</span><br>    Stack&lt;StringBuilder&gt; resStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">//存放括号中的字符串</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">currentStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>            <span class="hljs-comment">// 计算完整的数字</span><br>            k = k * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>            <br>            <span class="hljs-comment">// 将当前的字符串和次数入栈</span><br>            countStack.push(k);<br>            resStack.push(currentStr);<br>            <br>            <span class="hljs-comment">// 开始新的字符串</span><br>            currentStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            k = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <br>            <span class="hljs-comment">// 结束当前字符串，取出对应的次数</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">decodedStr</span> <span class="hljs-operator">=</span> resStack.pop();<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">repeatTimes</span> <span class="hljs-operator">=</span> countStack.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; repeatTimes; i++) &#123;<br>                decodedStr.append(currentStr);<br>            &#125;<br>            <br>            currentStr = decodedStr;  <span class="hljs-comment">// 继续拼接上层字符串</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            currentStr.append(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentStr.toString();<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="72-每日温度"><a href="#72-每日温度" class="headerlink" title="72. 每日温度"></a>72. 每日温度</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>使用一个单调<strong>递减</strong>的栈，栈用来<strong>存储索引</strong></li>
<li>如果当前温度小于等于栈顶温度则入栈</li>
<li>当前温度大于栈顶元素，栈顶元素的天数更新并出栈</li>
</ul>
<h2 id="72-1-题目描述"><a href="#72-1-题目描述" class="headerlink" title="72.1 题目描述"></a>72.1 题目描述</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: temperatures = [<span class="hljs-number">73</span>,<span class="hljs-number">74</span>,<span class="hljs-number">75</span>,<span class="hljs-number">71</span>,<span class="hljs-number">69</span>,<span class="hljs-number">72</span>,<span class="hljs-number">76</span>,<span class="hljs-number">73</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<h2 id="72-2-算法思想和代码实现"><a href="#72-2-算法思想和代码实现" class="headerlink" title="72.2 算法思想和代码实现"></a>72.2 算法思想和代码实现</h2><ol>
<li>初始化一个单调递减栈 stack，<strong>存储温度的索引</strong>。</li>
<li>遍历 temperatures 数组：<ul>
<li>当栈不为空，且当前温度大于栈顶索引对应的温度时：<ul>
<li>说明找到了栈顶元素的下一个更高温度，计算间隔天数并更新 res。</li>
<li>继续弹出栈顶，直到栈为空或栈顶温度大于当前温度。</li>
<li>将当前索引 i 入栈。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>     <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length]; <span class="hljs-comment">//res数组存储最终结果</span><br>     Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(); <span class="hljs-comment">//定义一个单调栈</span><br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>         <span class="hljs-comment">//只有栈为空或者当前温度比栈顶温度小的时候，入栈</span><br>         <span class="hljs-keyword">if</span> (stack.isEmpty() || temperatures[i] &lt;= temperatures[stack.peek()]) &#123;<br>             stack.push(i);<br>         &#125;<br><br>         <span class="hljs-comment">//如果当前温度比栈顶温度大</span><br>         <span class="hljs-keyword">if</span> (temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>             <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) &#123;<br>                 res[stack.peek()] = i - stack.peek();<br>                 stack.pop();<br>             &#125;<br>             stack.push(i);<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>


<h1 id="73-柱形图中最大的矩形"><a href="#73-柱形图中最大的矩形" class="headerlink" title="73. 柱形图中最大的矩形"></a>73. 柱形图中最大的矩形</h1><ul>
<li><strong>一句话描述：</strong> <strong>双指针暴力</strong>，以当前柱子<strong>向左向右</strong>，找比自己高度大(大于等于)的柱子，计算当前面积并更新</li>
</ul>
<h2 id="73-1-题目描述"><a href="#73-1-题目描述" class="headerlink" title="73.1 题目描述"></a>73.1 题目描述</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：heights = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<h2 id="73-2-算法思想和代码实现"><a href="#73-2-算法思想和代码实现" class="headerlink" title="73.2 算法思想和代码实现"></a>73.2 算法思想和代码实现</h2><ul>
<li>双指针暴力</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> heights[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i;<br><br>        <span class="hljs-comment">// 向左扩展</span><br>        <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; heights[left - <span class="hljs-number">1</span>] &gt;= height) &#123;<br>            left--;<br>        &#125;<br><br>        <span class="hljs-comment">// 向右扩展</span><br>        <span class="hljs-keyword">while</span> (right &lt; n - <span class="hljs-number">1</span> &amp;&amp; heights[right + <span class="hljs-number">1</span>] &gt;= height) &#123;<br>            right++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> height * width;<br>        maxArea = Math.max(maxArea, area);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>利用单调递增栈快速找到每个柱子的左右边界，计算出以该柱子为高的最大矩形面积</strong></p>
<ul>
<li><strong>对于每根柱子，如何快速找到其左右边界</strong>？<br>通常，我们关心 以某个柱子 <code>heights[i]</code> 为高的最大矩形：<ul>
<li>这个矩形的 宽度 由该柱子 左侧第一个小于该柱子的柱子 和 右侧第一个小于该柱子的柱子 决定。</li>
<li>这个矩形的 面积 &#x3D; 高度 × 宽度。<br><strong>如何快速找到左右边界</strong>?</li>
<li>用单调递增栈（从小到大存柱子的索引）来维护递增序列：</li>
<li>当当前柱子 <code>heights[i]</code> 大于等于栈顶柱子，说明矩形还可以扩展，入栈。</li>
<li>当当前柱子 <code>heights[i]</code> 小于栈顶柱子，说明矩形不能继续扩展了，<strong>栈顶柱子对应的最大矩形的宽度边界已经确定</strong>，可以计算面积。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>      <span class="hljs-comment">// 使用单调栈（存储柱子的索引）来计算最大矩形面积</span><br>      Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-comment">// 遍历数组，并在最后额外处理一次栈中剩余的元素</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= heights.length; i++) &#123;<br>          <span class="hljs-type">int</span> h;<br>          <span class="hljs-comment">// 当遍历到最后一个位置时，假设一个高度为 0 的柱子，以便清空栈</span><br>          <span class="hljs-keyword">if</span> (i == heights.length) &#123;<br>              h = <span class="hljs-number">0</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              h = heights[i];<br>          &#125;<br><br>          <span class="hljs-comment">// 维护单调递增栈（栈中存放的是索引）</span><br>          <span class="hljs-comment">// 如果当前柱子的高度 h 小于栈顶索引对应的柱子高度，则说明栈顶柱子的右边界确定</span><br>          <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; h &lt; heights[stack.peek()]) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> heights[stack.pop()]; <span class="hljs-comment">// 弹出栈顶元素，表示以该柱子为高的矩形结束</span><br>              <span class="hljs-type">int</span> width;<br><br>              <span class="hljs-comment">// 如果栈为空，说明当前弹出的柱子是所有柱子中最矮的，其宽度是 `i`</span><br>              <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                  width = i;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">//宽度 = 右边界 i - 左边界 stack.peek() - 1</span><br>                  <span class="hljs-comment">// 否则，矩形的宽度是 `i - stack.peek() - 1`</span><br>                  <span class="hljs-comment">// 其中 `stack.peek()` 是左边第一个比它小的柱子</span><br>                  width = i - stack.peek() - <span class="hljs-number">1</span>;<br>              &#125;<br>              <br>              area = Math.max(area, width * height);<br>          &#125;<br><br>          <span class="hljs-comment">// 将当前柱子索引入栈，确保栈内索引对应的高度是递增的</span><br>          stack.push(i);<br>      &#125;<br>      <span class="hljs-keyword">return</span> area;<br>  &#125;<br></code></pre></td></tr></table></figure>



<h1 id="74-数组中的第K个最大元素"><a href="#74-数组中的第K个最大元素" class="headerlink" title="74. 数组中的第K个最大元素"></a>74. 数组中的第K个最大元素</h1><ul>
<li><strong>一句话描述：</strong> 使用<strong>小顶堆</strong>，堆顶元素始终是最小的元素，如果当前元素大于堆顶元素，堆顶元素出堆，当前元素入堆，最后堆顶元素就是第k个大的元素；<strong>换句话说就是用小顶堆把k-1个小的元素挤出去</strong></li>
</ul>
<h2 id="74-1-题目描述"><a href="#74-1-题目描述" class="headerlink" title="74.1 题目描述"></a>74.1 题目描述</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], k = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<h2 id="74-2-算法思想和代码实现"><a href="#74-2-算法思想和代码实现" class="headerlink" title="74.2 算法思想和代码实现"></a>74.2 算法思想和代码实现</h2><ul>
<li>采用小顶堆维护前 k 大元素<ul>
<li>由于 Java 的 PriorityQueue 默认是小顶堆，所以堆顶元素（peek()）始终是堆中最小的元素。</li>
<li>这样，我们可以用大小为 k 的最小堆，确保堆中存储的是数组中前 k 大的元素。</li>
<li>最后栈顶元素就是数组第k个大的元素</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>       <span class="hljs-comment">// 使用小顶堆，用于维护前 k 大的元素</span><br>       PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br>       <span class="hljs-comment">// 先将前 k 个元素加入堆中，建立一个大小为 k 的最小堆</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>           pq.offer(nums[i]);<br>       &#125;<br><br>       <span class="hljs-comment">// 遍历数组剩余元素，确保堆中始终保留 k 个最大的元素</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (nums[i] &gt; pq.peek()) &#123; <span class="hljs-comment">// 只有当前元素比堆顶元素大时，才进行替换</span><br>               pq.poll(); <span class="hljs-comment">// 最小的元素弹出堆顶</span><br>               pq.offer(nums[i]); <span class="hljs-comment">// 插入新元素，保证堆中始终有 k 个最大的元素</span><br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">// 堆顶元素就是整个数组中第 k 大的元素</span><br>       <span class="hljs-keyword">return</span> pq.peek();<br>   &#125;<br></code></pre></td></tr></table></figure>



<h1 id="75-前K个高频元素"><a href="#75-前K个高频元素" class="headerlink" title="75. 前K个高频元素"></a>75. 前K个高频元素</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><strong>哈希表统计频率</strong>，用<strong>小根堆</strong>维护前k个高频元素</li>
<li><code>PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;(k,(l1, l2) -&gt; l1.getValue() - l2.getValue());</code></li>
<li><code>for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {}</code></li>
</ul>
<h2 id="75-1-题目描述"><a href="#75-1-题目描述" class="headerlink" title="75.1 题目描述"></a>75.1 题目描述</h2><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<h2 id="75-2-算法思想和代码实现"><a href="#75-2-算法思想和代码实现" class="headerlink" title="75.2 算法思想和代码实现"></a>75.2 算法思想和代码实现</h2><h3 id="小根堆-哈希表"><a href="#小根堆-哈希表" class="headerlink" title="小根堆 + 哈希表"></a>小根堆 + 哈希表</h3><ul>
<li>利用哈希表统计频率</li>
<li>然后用小根堆维护前 K 个高频元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 统计频率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用最小堆，按频率排序</span><br>    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k,(l1, l2) -&gt; l1.getValue() - l2.getValue());<br><br>    <span class="hljs-comment">// 维护一个大小为 k 的小根堆</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (pq.size() &lt; k) &#123;<br>            pq.offer(entry);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.getValue() &gt; pq.peek().getValue()) &#123;<br>            pq.poll();<br>            pq.offer(entry);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 取出堆中的 k 个元素</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        res[i] = pq.poll().getKey();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="76-数据流的中位数"><a href="#76-数据流的中位数" class="headerlink" title="76. 数据流的中位数"></a>76. 数据流的中位数</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>利用两个堆（<strong>大根堆+小根堆</strong>），</li>
<li>添加元素<strong>先添加到小顶堆</strong>，再把小顶堆的<strong>堆顶元素添加到大顶堆</strong>，</li>
<li>如果小顶堆大小小于大顶堆大小(<code>minHeap.size() &lt; maxHeap.size()</code>)，把<strong>大顶堆的堆顶元素添加到小顶堆</strong></li>
</ul>
<h2 id="76-1-题目描述"><a href="#76-1-题目描述" class="headerlink" title="76.1 题目描述"></a>76.1 题目描述</h2><p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<ul>
<li>例如 arr &#x3D; [2,3,4] 的中位数是 3 。</li>
<li>例如 arr &#x3D; [2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>实现 MedianFinder 类:</li>
<li>MedianFinder() 初始化 MedianFinder 对象。</li>
<li>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。</li>
<li>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">输入<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;findMedian&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [<span class="hljs-number">3</span>], []]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1.5</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2.0</span>]<br><br>解释<br><span class="hljs-type">MedianFinder</span> <span class="hljs-variable">medianFinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MedianFinder</span>();<br>medianFinder.addNum(<span class="hljs-number">1</span>);    <span class="hljs-comment">// arr = [1]</span><br>medianFinder.addNum(<span class="hljs-number">2</span>);    <span class="hljs-comment">// arr = [1, 2]</span><br>medianFinder.findMedian(); <span class="hljs-comment">// 返回 1.5 ((1 + 2) / 2)</span><br>medianFinder.addNum(<span class="hljs-number">3</span>);    <span class="hljs-comment">// arr[1, 2, 3]</span><br>medianFinder.findMedian(); <span class="hljs-comment">// return 2.0</span><br></code></pre></td></tr></table></figure>

<h2 id="76-2-算法思想和代码实现"><a href="#76-2-算法思想和代码实现" class="headerlink" title="76.2 算法思想和代码实现"></a>76.2 算法思想和代码实现</h2><p><strong>利用两个堆（大根堆+小根堆）维护数据流的中位数</strong></p>
<ul>
<li>采用两个堆<ul>
<li>大根堆 maxHeap（存较小的一半）：堆顶是较小的一半数据中的 最大值。</li>
<li>小根堆 minHeap（存较大的一半）：堆顶是较大的一半数据中的 最小值。</li>
</ul>
</li>
<li>保证大根堆 maxHeap 的元素个数 不小于 小根堆 minHeap</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>      PriorityQueue&lt;Integer&gt; minHeap;<br>      PriorityQueue&lt;Integer&gt; maxHeap;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>          minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>          <span class="hljs-comment">// 使用自定义比较器，降序排列</span><br>          maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>          <span class="hljs-comment">// 先将新元素添加到大根堆</span><br>          maxHeap.offer(num);<br>          <span class="hljs-comment">// 把大根堆的最大值移动到小根堆，保证 minHeap 存储较大的一半数据</span><br>          minHeap.offer(maxHeap.poll());<br><br>          <span class="hljs-comment">// 如果小根堆的大小大于大根堆，则需要调整，保持 maxHeap &gt;= minHeap</span><br>          <span class="hljs-keyword">if</span> (minHeap.size() &gt; maxHeap.size()) &#123;<br>              maxHeap.offer(minHeap.poll());<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">// 若两个堆大小相等，说明总元素个数是偶数，取两个堆顶元素的平均值</span><br>          <span class="hljs-keyword">if</span> (minHeap.size() == maxHeap.size()) &#123;<br>              <span class="hljs-keyword">return</span> (minHeap.peek() + maxHeap.peek()) / <span class="hljs-number">2.0</span>;<br>          &#125;<br>          <span class="hljs-comment">// 若大根堆元素较多，说明总数是奇数，中位数是大根堆的堆顶元素</span><br>          <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> maxHeap.peek();<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>



<h1 id="77-买卖股票的最佳时机"><a href="#77-买卖股票的最佳时机" class="headerlink" title="77. 买卖股票的最佳时机"></a>77. 买卖股票的最佳时机</h1><ul>
<li><strong>一句话描述；</strong> 要想卖的时候利润最多，就要在之前<strong>最便宜的时候买入</strong>，因此维护之前的<strong>最小值</strong>即可。</li>
</ul>
<h2 id="77-1-题目描述"><a href="#77-1-题目描述" class="headerlink" title="77.1 题目描述"></a>77.1 题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span>-<span class="hljs-number">1</span> = <span class="hljs-number">5</span> 。<br>     注意利润不能是 <span class="hljs-number">7</span>-<span class="hljs-number">1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>

<h2 id="77-2-算法思想和代码实现"><a href="#77-2-算法思想和代码实现" class="headerlink" title="77.2 算法思想和代码实现"></a>77.2 算法思想和代码实现</h2><p>要想卖的时候利润最多，就要在之前最便宜的时候买入，因此维护之前的最小值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//要想卖的时候利润最多，就要在之前最便宜的时候买入，因此维护之前的最小值即可。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxProfit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-comment">//维护之前的最小值</span><br>        <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) &#123;<br>            minPrice = prices[i];<br>        &#125;<br>        <br>        <span class="hljs-comment">//如果当前卖出的利润最多，则更新最大利润</span><br>        <span class="hljs-keyword">if</span> (prices[i] - minPrice &gt; maxProfit) &#123;<br>            maxProfit = prices[i] - minPrice;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxProfit;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="78-跳跃游戏"><a href="#78-跳跃游戏" class="headerlink" title="78. 跳跃游戏"></a>78. 跳跃游戏</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>维护一个 farthest 变量，记录能跳到的最远距离</li>
<li>如果<strong>当前索引超过了能跳到的最远距离，则跳不到终点</strong></li>
</ul>
<h2 id="78-1-题目描述"><a href="#78-1-题目描述" class="headerlink" title="78.1 题目描述"></a>78.1 题目描述</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：可以先跳 <span class="hljs-number">1</span> 步，从下标 <span class="hljs-number">0</span> 到达下标 <span class="hljs-number">1</span>, 然后再从下标 <span class="hljs-number">1</span> 跳 <span class="hljs-number">3</span> 步到达最后一个下标。<br></code></pre></td></tr></table></figure>

<h2 id="78-2-算法思想和代码实现"><a href="#78-2-算法思想和代码实现" class="headerlink" title="78.2 算法思想和代码实现"></a>78.2 算法思想和代码实现</h2><p>使用 贪心算法 维护一个 farthest 变量，记录能跳到的最远距离</p>
<ul>
<li>如果遍历到 i 时 farthest 不能再往前推进，则返回 false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">farthest</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 维护能跳到的最远距离</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; farthest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果当前索引超过了能跳到的最远距离，则跳不到终点</span><br>        farthest = Math.max(farthest, i + nums[i]); <span class="hljs-comment">// 更新最远能到达的位置</span><br>        <span class="hljs-keyword">if</span> (farthest &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果最远可以到达终点，则直接返回 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="79-跳跃游戏-II"><a href="#79-跳跃游戏-II" class="headerlink" title="79. 跳跃游戏 II"></a>79. 跳跃游戏 II</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>局部最优，找到<strong>下一个能跳的最远的位置</strong>，找最大的(<strong>下一个位置索引加上下一个位置最大跳跃距离</strong>)</li>
<li>如果当前位置已经能到达终点，count++,跳出循环</li>
</ul>
<h2 id="79-1-题目描述"><a href="#79-1-题目描述" class="headerlink" title="79.1 题目描述"></a>79.1 题目描述</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<ul>
<li>0 &lt;&#x3D; j &lt;&#x3D; nums[i] </li>
<li>i + j &lt; n</li>
</ul>
<p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">2</span><br>解释: 跳到最后一个位置的最小跳跃数是 <span class="hljs-number">2</span>。<br>     从下标为 <span class="hljs-number">0</span> 跳到下标为 <span class="hljs-number">1</span> 的位置，跳 <span class="hljs-number">1</span> 步，然后跳 <span class="hljs-number">3</span> 步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure>

<h2 id="79-2-算法思想和代码实现"><a href="#79-2-算法思想和代码实现" class="headerlink" title="79.2 算法思想和代码实现"></a>79.2 算法思想和代码实现</h2><p>维护当前跳跃的覆盖范围，更新最远可达位置<br>记录下一次能到达的最远位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ) &#123;<br>        <span class="hljs-comment">//如果当前位置已经能到达终点，count++,跳出循环</span><br>        <span class="hljs-keyword">if</span> (nums[i] + i &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//局部最优，找到下一个能跳的最远的位置，找最大的(下一个位置索引加上下一个位置最大跳跃距离)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nextJump = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt;= i + nums[i]; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j + nums[j] &gt;= nextNum) &#123;<br>                nextJump = j;<br>                nextNum = j + nums[j];<br>            &#125;<br>        &#125;<br>        i = nextJump;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="80-划分字母区间"><a href="#80-划分字母区间" class="headerlink" title="80. 划分字母区间"></a>80. 划分字母区间</h1><ul>
<li><strong>一句话描述：</strong></li>
<li>使用<strong>哈希表</strong>保存每个字符的最后出现位置</li>
<li>若发现<strong>某个字符的最后出现位置超出了当前片段范围，则更新 nextIndex</strong></li>
</ul>
<h2 id="80-1-题目描述"><a href="#80-1-题目描述" class="headerlink" title="80.1 题目描述"></a>80.1 题目描述</h2><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>、<span class="hljs-string">&quot;defegde&quot;</span>、<span class="hljs-string">&quot;hijhklij&quot;</span> 。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 这样的划分是错误的，因为划分的片段数较少。 <br></code></pre></td></tr></table></figure>

<h2 id="80-2-算法思想和代码实现"><a href="#80-2-算法思想和代码实现" class="headerlink" title="80.2 算法思想和代码实现"></a>80.2 算法思想和代码实现</h2><ol>
<li>使用哈希表保存每个字符的最后出现位置</li>
<li>划分字符串：<ul>
<li>遍历字符串，每次确定当前字符所在的片段范围（从 i 到 nextIndex）。</li>
<li>继续遍历该范围内的字符，若发现<strong>某个字符的最后出现位置超出了当前片段范围，则更新 nextIndex</strong>，以保证这个片段包含所有出现过的字符。</li>
<li>计算该片段的长度，并添加到结果列表中</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 记录每个字符的最后出现位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        map.put(s.charAt(i), i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        nextIndex = Math.max(nextIndex, map.get(s.charAt(i)));<br>        <br>        <span class="hljs-keyword">if</span> (i == nextIndex) &#123;<br>            res.add(nextIndex - start + <span class="hljs-number">1</span>);<br>            start = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="81-爬楼梯"><a href="#81-爬楼梯" class="headerlink" title="81. 爬楼梯"></a>81. 爬楼梯</h1><ul>
<li><strong>一句话描述：</strong> <code>dp[i]</code>： 爬到第i层楼梯，有<code>dp[i]</code>种方法</li>
</ul>
<h2 id="81-1-题目描述"><a href="#81-1-题目描述" class="headerlink" title="81.1 题目描述"></a>81.1 题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：有两种方法可以爬到楼顶。<br><span class="hljs-number">1.</span> <span class="hljs-number">1</span> 阶 + <span class="hljs-number">1</span> 阶<br><span class="hljs-number">2.</span> <span class="hljs-number">2</span> 阶<br></code></pre></td></tr></table></figure>

<h2 id="81-2-算法思想和代码实现"><a href="#81-2-算法思想和代码实现" class="headerlink" title="81.2 算法思想和代码实现"></a>81.2 算法思想和代码实现</h2><ol>
<li>确定dp数组以及下标的含义<ul>
<li>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li>
</ul>
</li>
<li>确定递推公式<ul>
<li>dp[i] &#x3D; dp[i - 1] + dp[i - 2]</li>
</ul>
</li>
<li>dp数组如何初始化<ul>
<li>dp[1]&#x3D;1;dp[2]&#x3D;2;</li>
</ul>
</li>
<li>确定遍历顺序<ul>
<li>从前往后遍历</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">//确定递推公式</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="82-杨辉三角"><a href="#82-杨辉三角" class="headerlink" title="82. 杨辉三角"></a>82. 杨辉三角</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><code>dp[i][j]</code> 代表第i行第j列元素的值</li>
<li><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></li>
</ul>
<h2 id="82-1-题目描述"><a href="#82-1-题目描述" class="headerlink" title="82.1 题目描述"></a>82.1 题目描述</h2><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: numRows = <span class="hljs-number">5</span><br>输出: [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure>

<h2 id="82-2-算法思想和代码实现"><a href="#82-2-算法思想和代码实现" class="headerlink" title="82.2 算法思想和代码实现"></a>82.2 算法思想和代码实现</h2><ol>
<li>确定dp数组<ul>
<li>dp[i][j] 代表第i行第j列元素的值</li>
</ul>
</li>
<li>初始化dp数组<ul>
<li>dp[0][0]&#x3D;1;dp[i][0]&#x3D;1;dp[i][i]&#x3D;1;</li>
</ul>
</li>
<li>递推公式<ul>
<li><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>;</li>
</ul>
</li>
<li>遍历顺序<ul>
<li>从前往后，从上到下遍历二维数组</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numRows][numRows];<br><br>    <span class="hljs-comment">// 初始化第一行</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    List&lt;Integer&gt; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    first.add(<span class="hljs-number">1</span>);<br>    res.add(first);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numRows; i++) &#123;<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        temp.add(dp[i][<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">//递推公式</span><br>            temp.add(dp[i][j]);<br>        &#125;<br><br>        dp[i][i] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 右边界元素也是1</span><br>        temp.add(dp[i][i]);<br><br>        res.add(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="83-打家劫舍"><a href="#83-打家劫舍" class="headerlink" title="83. 打家劫舍"></a>83. 打家劫舍</h1><ul>
<li><strong>一句话描述：</strong></li>
<li><code>dp[i]</code>：盗窃到第i间房间所获得的最高金额</li>
<li><code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code></li>
</ul>
<h2 id="83-1-题目描述"><a href="#83-1-题目描述" class="headerlink" title="83.1 题目描述"></a>83.1 题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">4</span><br>解释：偷窃 <span class="hljs-number">1</span> 号房屋 (金额 = <span class="hljs-number">1</span>) ，然后偷窃 <span class="hljs-number">3</span> 号房屋 (金额 = <span class="hljs-number">3</span>)。<br>     偷窃到的最高金额 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>

<h2 id="83-2-算法思想和代码实现"><a href="#83-2-算法思想和代码实现" class="headerlink" title="83.2 算法思想和代码实现"></a>83.2 算法思想和代码实现</h2><ol>
<li>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</li>
<li>递推公式：<ul>
<li>决定dp[i]的因素就是第i房间偷还是不偷。</li>
<li>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i]</li>
<li>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考 虑i-1房</li>
<li>dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</li>
</ul>
</li>
<li>初始化：dp[1] &#x3D; max(nums[0], nums[1]);dp[0] 一定是 nums[0]</li>
<li>从前到后遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>       <br>       <span class="hljs-comment">//dp数组：考虑是否偷dp[i]所得的最大值</span><br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br><br>       <span class="hljs-comment">//是否偷dp[0]所得的最大值，这里肯定是要偷的，才能得到最大值</span><br>       dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>       dp[<span class="hljs-number">1</span>]=Math.max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]); <span class="hljs-comment">//dp[1]的最大值取决于nums[0]和nums[1]哪个大，偷哪个</span><br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.length;i++)&#123;<br>           dp[i]=Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i]); <span class="hljs-comment">//递推公式</span><br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure>



<h1 id="84-完全平方数"><a href="#84-完全平方数" class="headerlink" title="84. 完全平方数"></a>84. 完全平方数</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>转换为<strong>完全背包问题</strong><ul>
<li><code>dp[i][j]</code> 表示使用前 i 个完全平方数（1^2, 2^2, …, i^2）凑出 j 需要的最少个数。</li>
<li>不选当前平方数 i^2：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行）。</li>
<li>选择当前平方数 i^2：<code>dp[i][j] = dp[i][j - square] + 1</code>（选 i^2 之后，继续凑 j - i^2）</li>
</ul>
</li>
</ul>
<h2 id="84-1-题目描述"><a href="#84-1-题目描述" class="headerlink" title="84.1 题目描述"></a>84.1 题目描述</h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">12</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<h2 id="84-2-算法思想和代码实现"><a href="#84-2-算法思想和代码实现" class="headerlink" title="84.2 算法思想和代码实现"></a>84.2 算法思想和代码实现</h2><h3 id="转换为完全背包问题"><a href="#转换为完全背包问题" class="headerlink" title="转换为完全背包问题"></a>转换为完全背包问题</h3><ol>
<li>状态定义<ul>
<li><code>dp[i][j]</code> 表示使用前 i 个完全平方数（1^2, 2^2, …, i^2）凑出 j 需要的最少个数。</li>
</ul>
</li>
<li>初始化<ul>
<li><code>dp[0][0] = 0</code>（凑出 0 需要 0 个数）。</li>
<li>其他 dp[i][j] 设为 Integer.MAX_VALUE，表示默认无法凑出。</li>
</ul>
</li>
<li>状态转移<ul>
<li>不选当前平方数 i^2：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行）。</li>
<li>选择当前平方数 i^2：<code>dp[i][j] = dp[i][j - square] + 1</code>（选 i^2 之后，继续凑 j - i^2）。</li>
</ul>
</li>
<li>遍历方式<ul>
<li>外层循环 遍历所有可能的平方数 i^2。</li>
<li>内层循环 遍历目标值 j，尝试用 i^2 进行凑数。</li>
</ul>
</li>
<li>结果<br>最终 <code>dp[maxSqrt][n]</code> 即为凑出 n 所需的最少完全平方数个数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSqrt</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(n);<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSqrt + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化dp数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= maxSqrt; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            dp[i][j] = Integer.MAX_VALUE; <span class="hljs-comment">// 设为默认最大值</span><br>        &#125;<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 凑成 0 需要 0 个数</span><br>    <br>    <span class="hljs-comment">// 遍历平方数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= maxSqrt; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">square</span> <span class="hljs-operator">=</span> i * i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; square) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 不能选当前平方数，则继承上一行</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - square] + <span class="hljs-number">1</span>); <span class="hljs-comment">// 选或者不选</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[maxSqrt][n];<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="85-零钱兑换"><a href="#85-零钱兑换" class="headerlink" title="85. 零钱兑换"></a>85. 零钱兑换</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>转换为<strong>完全背包问题</strong></li>
<li><code>dp[i][j]</code>：用前 i 种硬币，凑成金额 j 所需的最少硬币数量</li>
</ul>
<h2 id="85-1-题目描述"><a href="#85-1-题目描述" class="headerlink" title="85.1 题目描述"></a>85.1 题目描述</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], amount = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="85-2-算法思想和代码实现"><a href="#85-2-算法思想和代码实现" class="headerlink" title="85.2 算法思想和代码实现"></a>85.2 算法思想和代码实现</h2><h3 id="转换为完全背包问题-1"><a href="#转换为完全背包问题-1" class="headerlink" title="转换为完全背包问题"></a>转换为完全背包问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>    <span class="hljs-comment">// dp[i][j]：用前 i 种硬币，凑成金额 j 所需的最少硬币数量</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化：</span><br>    <span class="hljs-comment">// 金额为0时，不需要任何硬币</span><br>    <span class="hljs-comment">// 其余金额初始化为一个大数，表示暂时无法凑成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= amount; j++) &#123;<br>            dp[i][j] = Integer.MAX_VALUE - <span class="hljs-number">1</span>; <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <br>            <span class="hljs-keyword">if</span> (j &lt; coins[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 当前硬币面值大于目标金额，无法选，继承上一行的方案</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 可以选择当前硬币（无限次）</span><br>                <span class="hljs-comment">// 两种方案取较小值：</span><br>                <span class="hljs-comment">// 1️⃣ 不选当前硬币：dp[i-1][j]</span><br>                <span class="hljs-comment">// 2️⃣ 选当前硬币一次：dp[i][j - coins[i-1]] + 1</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - coins[i - <span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dp[n][amount] == Integer.MAX_VALUE - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> dp[n][amount];<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="86-单词拆分"><a href="#86-单词拆分" class="headerlink" title="86. 单词拆分"></a>86. 单词拆分</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li><code>dp[i]</code> 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成</li>
<li><code>dp[i]</code>的值依赖于i<strong>之前某个 dp[j] &#x3D;&#x3D; true</strong>，说明 <code>s[0 ~ j-1]</code>可以用字典单词拼接。 s.substring(j, i) 必须在 wordDict 里面，说明 <strong>j~i-1 这一段是一个合法单词</strong></li>
</ul>
<h2 id="86-1-题目描述"><a href="#86-1-题目描述" class="headerlink" title="86.1 题目描述"></a>86.1 题目描述</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;leetcode&quot;</span>, wordDict = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以由 <span class="hljs-string">&quot;leet&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 拼接成。<br></code></pre></td></tr></table></figure>

<h2 id="86-2-算法思想和代码实现"><a href="#86-2-算法思想和代码实现" class="headerlink" title="86.2 算法思想和代码实现"></a>86.2 算法思想和代码实现</h2><ol>
<li>状态定义：<ul>
<li>dp[i] 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成。</li>
</ul>
</li>
<li>状态转移方程：<ul>
<li>dp[i] &#x3D; true 当且仅当 存在某个 j，满足：<ul>
<li>dp[j] &#x3D;&#x3D; true（表示 s[0:j] 可以被拆分）</li>
<li>s[j:i] 存在于 wordDict 中（表示 s[j:i] 是一个有效单词）</li>
</ul>
</li>
</ul>
</li>
<li>初始化：<ul>
<li>dp[0] &#x3D; true，表示空字符串可以被拆分</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 空字符串可以组成</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.length()];<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="87-最长递增子序列"><a href="#87-最长递增子序列" class="headerlink" title="87. 最长递增子序列"></a>87. 最长递增子序列</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><code>dp[i]</code> 表示<strong>以 <code>nums[i]</code> 结尾的最长递增子序列的长度</strong></li>
<li>两次遍历：第一次遍历求每个以 nums[i] 结尾的最长递增子序列，第二次遍历i之前的元素，比较元素是否加入当前元素的后面作为结尾</li>
</ul>
<h2 id="87-1-题目描述"><a href="#87-1-题目描述" class="headerlink" title="87.1 题目描述"></a>87.1 题目描述</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>

<h2 id="87-2-算法思想和代码实现"><a href="#87-2-算法思想和代码实现" class="headerlink" title="87.2 算法思想和代码实现"></a>87.2 算法思想和代码实现</h2><ol>
<li>状态定义：<ul>
<li>设 dp[i] 表示 以 nums[i] 结尾的最长递增子序列的长度。</li>
</ul>
</li>
<li>状态转移方程：<ul>
<li>遍历 j（0 ≤ j &lt; i），检查所有可能的前一个元素：<ul>
<li>如果 nums[i] &gt; nums[j]，即 nums[i] 可以接在 nums[j] 之后形成更长的递增子序列：<ul>
<li><code>dp[i]=max(dp[i],dp[j]+1)</code></li>
</ul>
</li>
</ul>
</li>
<li>遍历完成后，更新 res 记录 全局最长递增子序列的长度。</li>
</ul>
</li>
<li>初始化：<ul>
<li>每个元素 单独作为子序列时，长度至少是 1，所以 dp[i] 初始为 1。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br><br>    <span class="hljs-comment">// 初始化 dp 数组，每个元素单独作为子序列时长度为 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历数组，计算每个以 nums[i] 结尾的最长递增子序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 遍历 i 之前的元素 nums[j]，找到比 nums[i] 小的元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-comment">// 如果 nums[i] &gt; nums[j]，说明可以接在 nums[j] 之后形成递增子序列</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        res = Math.max(res, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="88-乘积最大子数组"><a href="#88-乘积最大子数组" class="headerlink" title="88. 乘积最大子数组"></a>88. 乘积最大子数组</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>用max和min维护遍历到当前元素时的最大值和最小值</li>
<li>如果当前元素是<strong>负数</strong>，那么会导致<strong>最大的变最小的，最小的变最大的</strong>。因此交换两个的值。</li>
<li><code>max = Math.max(max * nums[i], nums[i])</code><ul>
<li>对于每一个 <code>nums[i]</code>，最大乘积有两种选择： <ul>
<li>1️⃣ <strong>继续累乘</strong>：<code>max * nums[i]</code> —— 把前面的乘积继续乘上这个 nums[i]，不切断子数组。</li>
<li>2️⃣ <strong>重新开始</strong>：<code>nums[i]</code> —— 从当前位置 i 开始一个新的乘积子数组。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="88-1-题目描述"><a href="#88-1-题目描述" class="headerlink" title="88.1 题目描述"></a>88.1 题目描述</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">6</span><br>解释: 子数组 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 有最大乘积 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure>

<h2 id="88-2-算法思想和代码实现"><a href="#88-2-算法思想和代码实现" class="headerlink" title="88.2 算法思想和代码实现"></a>88.2 算法思想和代码实现</h2><p>对于每个元素 nums[i]，有三种可能的情况：</p>
<ol>
<li>当前元素为正数：imax 可能增大，imin 可能减小。分别更新 imax 和 imin。</li>
<li>当前元素为负数：负数会导致最大乘积变成最小乘积，最小乘积变成最大乘积。此时，应该交换 imax 和 imin，然后根据当前元素更新这两个值。</li>
<li>当前元素为零：乘积会重置为零，可以跳过对最大和最小值的更新。</li>
</ol>
<ul>
<li>更新 max 为 max(imax, max)，记录当前的最大乘积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, imax = <span class="hljs-number">1</span>, imin = <span class="hljs-number">1</span>; <span class="hljs-comment">//一个保存最大的，一个保存最小的。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的。因此交换两个的值。</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> imax;<br>            imax = imin;<br>            imin = tmp;<br>        &#125;<br><br>        imax = Math.max(imax * nums[i], nums[i]);<br>        imin = Math.min(imin * nums[i], nums[i]);<br><br>        max = Math.max(max, imax);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="89-分割等和子集"><a href="#89-分割等和子集" class="headerlink" title="89. 分割等和子集"></a>89. 分割等和子集</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><strong>转换为0-1背包问题</strong></li>
<li><code>dp[i][j]</code>：从前 i 个数里，能否选出一些数，使它们的和接近j</li>
</ul>
<h2 id="89-1-题目描述"><a href="#89-1-题目描述" class="headerlink" title="89.1 题目描述"></a>89.1 题目描述</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：数组可以分割成 [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>] 和 [<span class="hljs-number">11</span>] 。<br></code></pre></td></tr></table></figure>

<h2 id="89-2-算法思想和代码实现"><a href="#89-2-算法思想和代码实现" class="headerlink" title="89.2 算法思想和代码实现"></a>89.2 算法思想和代码实现</h2><h3 id="89-2-1-转换为0-1背包问题"><a href="#89-2-1-转换为0-1背包问题" class="headerlink" title="89.2.1 转换为0-1背包问题"></a>89.2.1 转换为0-1背包问题</h3><ol>
<li>如果<strong>当前背包容量小于当前物品容量</strong>，那就放不进，那就<strong>只能取同列上一行的价值</strong>(相同的背包，上一个物品时的最优价值)</li>
<li>在<strong>当前背包容量大于当前物品容量时</strong><ul>
<li>放入该物品得到一个价值，因为还有剩余容量(剩余容量等于当前背包容量减去当前放入物品容量)，然后到上一行去找这个剩余容量的价值(肯定是最优价值)</li>
<li>然后把<strong>新放入物品价值加上剩余容量价值的和</strong>与<strong>上一行同列的价值</strong>进行比较，价值较大者为最优解。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为最小背包问题</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 计算数组的总和,如果总和为奇数，无法分割成两个和相等的子集,目标是凑够总和/2</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>          sum += num;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>      <span class="hljs-comment">//dp[i][j]代表放入i时，大小为j的容量的最优解; 初始化：默认初始化为0</span><br>      <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++)<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>              <span class="hljs-keyword">if</span> (j &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]] + nums[i - <span class="hljs-number">1</span>]);<br>              &#125;<br>          &#125;<br><br>      <span class="hljs-keyword">return</span> dp[nums.length][target] == target;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="89-2-2-方法2"><a href="#89-2-2-方法2" class="headerlink" title="89.2.2 方法2"></a>89.2.2 方法2</h3><ol>
<li><p>状态定义</p>
<ul>
<li>dp[i][j] 表示在前 i 个元素中，是否可以选出若干个数，使其和为 j。</li>
</ul>
</li>
<li><p>状态转移方程</p>
<ul>
<li>对于每个元素 nums[i-1]，可以选择“选它”或者“不选它”：<ul>
<li>不选 nums[i-1]：dp[i][j] &#x3D; dp[i-1][j]</li>
<li>选 nums[i-1]（前提 j &gt;&#x3D; nums[i-1]）：dp[i][j] &#x3D; dp[i-1][j] || dp[i-1][j - nums[i-1]]</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">// 计算数组的总和,如果总和为奇数，无法分割成两个和相等的子集,目标是凑够总和/2</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>           sum += num;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>       <span class="hljs-comment">// dp[i][j] 表示是否可以从前 i 个数中选出若干个数，使其和为 j</span><br>       <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br><br>       <span class="hljs-comment">// 初始化：当 j=0 时，即不选任何数，总和可以为 0</span><br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; j++) &#123;<br>               <span class="hljs-comment">// 继承上一个状态：不选当前数时，是否能凑出 j</span><br>               dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><br>               <span class="hljs-comment">// 选当前数：如果 j &gt;= nums[i-1]，则可以尝试选它</span><br>               <span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>                   dp[i][j] = dp[i][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];<br>               &#125;<br><br>               <span class="hljs-comment">// 如果已经找到一个子集使其和为 target，提前返回 true</span><br>               <span class="hljs-keyword">if</span> (dp[i][target]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>


<h1 id="90-最长有效括号"><a href="#90-最长有效括号" class="headerlink" title="90. 最长有效括号"></a>90. 最长有效括号</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><code>dp[i]</code> 表示以下标 i <strong>结尾</strong>的最长有效括号子串的长度，主要在于分情况讨论</li>
<li>当 <code>s[i] == &#39;(&#39;</code> 时</li>
<li>当 <code>s[i] == &#39;)&#39;</code> 时<ul>
<li>如果 <code>s[i-1] == &#39;(&#39;</code></li>
<li>如果 <code>s[i-1] == &#39;)&#39;</code><ul>
<li>如果 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="90-1-题目描述"><a href="#90-1-题目描述" class="headerlink" title="90.1 题目描述"></a>90.1 题目描述</h2><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="90-2-算法思想和代码实现"><a href="#90-2-算法思想和代码实现" class="headerlink" title="90.2 算法思想和代码实现"></a>90.2 算法思想和代码实现</h2><p>定义 <code>dp[i]</code> 表示以下标 i 结尾的最长有效括号子串的长度。状态转移方程如下：</p>
<ol>
<li>当 <code>s[i] == &#39;(&#39;</code> 时，<code>dp[i] = 0</code>，因为以左括号结尾不可能是有效括号序列。</li>
<li>当 <code>s[i] == &#39;)&#39;</code> 时，需要考虑：<ul>
<li>如果 <code>s[i-1] == &#39;(&#39;</code>，那么 <code>dp[i] = dp[i-2] + 2</code>（前面已有的有效括号子串加上这对新匹配的括号）。</li>
<li>如果 <code>s[i-1] == &#39;)&#39;</code>，那么需要检查 <code>i - dp[i-1] - 1</code> 位置的字符是否是 ‘(‘：<ul>
<li>如果 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code>，那么 <code>dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]</code>（前一个有效括号子串加上新匹配的括号，再加上更前面的有效子串）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-comment">// dp[i] 表示以 s[i] 结尾的最长有效括号子串长度</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长有效括号子串的长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            dp[i] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 只有当前字符是 &#x27;)&#x27; 时才有可能形成有效括号</span><br>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123; <br><br>            <span class="hljs-comment">// 情况1：前一个字符是 &#x27;(&#x27;，可以直接与它配对形成 &quot;()&quot;</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 如果 i &gt;= 2，则需要加上 dp[i - 2]，表示连接前面的有效括号子串</span><br>                    dp[i] = dp[i - <span class="hljs-number">2</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果 i &lt; 2，说明 &quot;()&quot; 是当前能形成的唯一有效子串</span><br>                    dp[i] = <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 情况2：前一个字符是 &#x27;)&#x27;，需要看 i-dp[i-1]-1 是否是 &#x27;(&#x27;，才能形成有效括号</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 只有 i - dp[i - 1] - 1 在有效范围内且 s[i - dp[i - 1] - 1] == &#x27;(&#x27;，才能形成匹配</span><br>                <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br><br>                    <span class="hljs-comment">// 如果 i - dp[i - 1] - 1 前面还有有效括号子串，则需要加上它的长度</span><br>                    <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                        dp[i] += dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 记录最大值</span><br>            maxLen = Math.max(maxLen, dp[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="91-不同路径"><a href="#91-不同路径" class="headerlink" title="91. 不同路径"></a>91. 不同路径</h1><ul>
<li><strong>一句话描述：</strong> <code>dp[i][j]</code>代表到达第i行第j列的不同路径有多少个</li>
</ul>
<h2 id="91-1-题目描述"><a href="#91-1-题目描述" class="headerlink" title="91.1 题目描述"></a>91.1 题目描述</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure>

<h2 id="91-2-算法思想和代码实现"><a href="#91-2-算法思想和代码实现" class="headerlink" title="91.2 算法思想和代码实现"></a>91.2 算法思想和代码实现</h2><ul>
<li><code>dp[i][j]</code>代表到达第i行第j列的不同路径有多少个</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]代表到达第i行第j列的不同路径有多少个</span><br>    <span class="hljs-type">int</span>[][] dp =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>    <span class="hljs-comment">//初始化dp</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)<br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>        dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//从左往右，从上到下遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-comment">//状态转移方程</span><br>            dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="92-最小路径和"><a href="#92-最小路径和" class="headerlink" title="92. 最小路径和"></a>92. 最小路径和</h1><ul>
<li><strong>一句话描述：</strong> <code>dp[i][j]</code>:走到第i行第j列时的最小总和</li>
</ul>
<h2 id="92-1-题目描述"><a href="#92-1-题目描述" class="headerlink" title="92.1 题目描述"></a>92.1 题目描述</h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure>

<h2 id="92-2-算法思想和代码实现"><a href="#92-2-算法思想和代码实现" class="headerlink" title="92.2 算法思想和代码实现"></a>92.2 算法思想和代码实现</h2><ul>
<li>本单元格的最小路径和依赖于上一行同列和上一列同行的路径和的最小值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">//dp[i][j]:走到第i行第j列时的最小总和</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>        &#125;<br><br>        <span class="hljs-comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure>


<h1 id="93-最长回文子串"><a href="#93-最长回文子串" class="headerlink" title="93. 最长回文子串"></a>93. 最长回文子串</h1><ul>
<li><strong>一句话总结：</strong> </li>
<li>定义 <code>dp[i][j]</code> 表示字符串<strong>从索引 i 到 j 的子串是否是回文子串</strong></li>
<li>更长的子串，<code>s[i] == s[j]</code> 时，它是否回文取决于 <code>s[i+1:j-1]</code> 是否回文串</li>
<li><strong>外层循环 i 递减</strong>（从后往前遍历）,内层循环 j 递增（从左到右遍历）,因为 <code>dp[i][j]</code> 依赖于 <code>dp[i+1][j-1]</code></li>
</ul>
<h2 id="93-1-题目描述"><a href="#93-1-题目描述" class="headerlink" title="93.1 题目描述"></a>93.1 题目描述</h2><p>给你一个字符串 s，找到 s 中最长的 回文 子串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure>

<h2 id="93-2-算法思想和代码实现"><a href="#93-2-算法思想和代码实现" class="headerlink" title="93.2 算法思想和代码实现"></a>93.2 算法思想和代码实现</h2><p>与回文子串题目一样，只不过这里求了最长的(<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a>)</p>
<ul>
<li>定义 <code>dp[i][j]</code> 表示字符串 s 从索引 i 到 j 的子串是否是回文子串</li>
<li>当s[i]和s[j]不相同时，一定是false</li>
<li>当s[i]和s[j]相同时，分以下三种情况：<ul>
<li>单个字符一定是回文串，所以 dp[i][i] &#x3D; true</li>
<li>相邻字符相等时也是回文串，即 dp[i][i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</li>
<li>更长的子串，s[i] &#x3D;&#x3D; s[j] 时，它是否回文取决于 s[i+1:j-1] 是否回文，即 dp[i][j] &#x3D; dp[i+1][j-1]。</li>
</ul>
</li>
<li>外层循环 i 递减（从后往前遍历）<ul>
<li>因为 dp[i][j] 依赖于 dp[i+1][j-1]，所以要先计算 dp[i+1][j-1] 再计算 dp[i][j]。</li>
</ul>
</li>
<li>内层循环 j 递增（从左到右遍历）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//dp[i][j]:从i到j的子串是不是回文的</span><br>       <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br><br>       <span class="hljs-comment">//i必须要从后往前遍历</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>           <span class="hljs-comment">//j从i开始往后遍历</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++) &#123;<br>               <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                   <span class="hljs-keyword">if</span> (j == i || j == i + <span class="hljs-number">1</span>) &#123;<br>                       dp[i][j] = <span class="hljs-literal">true</span>;<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                           dp[i][j] = <span class="hljs-literal">true</span>;<br>                       &#125;<br>                   &#125;<br>               &#125;<br><br>               <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                   <span class="hljs-keyword">if</span> (j - i &gt; maxLen) &#123;<br>                       maxLen = j - i;<br>                       left = i;<br>                       right = j;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> s.substring(left, right + <span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>


<h1 id="94-最长公共子序列"><a href="#94-最长公共子序列" class="headerlink" title="94. 最长公共子序列"></a>94. 最长公共子序列</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><code>dp[i][j]</code>: text1前i个字符串和text2前j个字符串的最长公共子序列长度</li>
<li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li>如果i和j的字符不相同，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li>
</ul>
<h2 id="94-1-题目描述"><a href="#94-1-题目描述" class="headerlink" title="94.1 题目描述"></a>94.1 题目描述</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：text1 = <span class="hljs-string">&quot;abcde&quot;</span>, text2 = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure>

<h2 id="94-2-算法思想和代码实现"><a href="#94-2-算法思想和代码实现" class="headerlink" title="94.2 算法思想和代码实现"></a>94.2 算法思想和代码实现</h2><ul>
<li><code>dp[i][j]</code>：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</li>
<li>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</li>
<li>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。<ul>
<li>即：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]:text1在0~i子串和text2在0~j子串中的最长公共子序列长度</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[text1.length() + <span class="hljs-number">1</span>][text2.length() + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//从前往后，从上到下遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[text1.length()][text2.length()];<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="95-编辑距离"><a href="#95-编辑距离" class="headerlink" title="95. 编辑距离"></a>95. 编辑距离</h1><ul>
<li><strong>一句话描述:</strong></li>
<li><code>dp[i][j]</code> 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符的最小操作数</li>
<li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] </code></li>
<li>如果i和j的字符不相同<ul>
<li>替换操作：dp[i-1][j-1] + 1</li>
<li>删除操作：dp[i-1][j] + 1</li>
<li>插入操作：dp[i][j-1] + 1</li>
</ul>
</li>
</ul>
<h2 id="95-1-题目描述"><a href="#95-1-题目描述" class="headerlink" title="95.1 题目描述"></a>95.1 题目描述</h2><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>horse -&gt; rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br>rorse -&gt; rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br>rose -&gt; ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="95-2-算法思想和代码实现"><a href="#95-2-算法思想和代码实现" class="headerlink" title="95.2 算法思想和代码实现"></a>95.2 算法思想和代码实现</h2><ul>
<li><code>dp[i][j]</code> 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符的最小操作数</li>
<li>初始化：<ul>
<li>dp[i][0] &#x3D; i：word1 变成空串，需要 i 次删除操作。</li>
<li>dp[0][j] &#x3D; j：空串变成 word2，需要 j 次插入操作。</li>
</ul>
</li>
<li>状态转移方程：<ul>
<li>若 word1[i-1] &#x3D;&#x3D; word2[j-1]，则 dp[i][j] &#x3D; dp[i-1][j-1]（当前字符相同，无需操作）。</li>
<li>否则，取三种操作的最小值：<ul>
<li>替换操作：dp[i-1][j-1] + 1</li>
<li>删除操作：dp[i-1][j] + 1</li>
<li>插入操作：dp[i][j-1] + 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化 dp 数组</span><br>        <span class="hljs-comment">// 当 word2 为空时，word1 需要删除 i 个字符才能变成 word2</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word1.length(); i++)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-comment">// 当 word1 为空时，word2 需要插入 i 个字符才能变成 word1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word2.length(); i++)<br>            dp[<span class="hljs-number">0</span>][i] = i;<br><br>        <span class="hljs-comment">// 从左到右，从上到下遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++) &#123;<br>                <span class="hljs-comment">// 如果当前字符相等，则不需要额外操作，继承前一个状态</span><br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 三种操作：</span><br>                    <span class="hljs-comment">// 1. 替换（dp[i - 1][j - 1] + 1）</span><br>                    <span class="hljs-comment">// 2. 删除 word1 的字符（dp[i - 1][j] + 1）</span><br>                    <span class="hljs-comment">// 3. 插入 word2 的字符（dp[i][j - 1] + 1）</span><br>                    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>    &#125;<br></code></pre></td></tr></table></figure>



<h1 id="96-只出现一次的数字"><a href="#96-只出现一次的数字" class="headerlink" title="96. 只出现一次的数字"></a>96. 只出现一次的数字</h1><ul>
<li><strong>一句话描述：</strong> 使用<strong>异或</strong>运算符(^)，a^a&#x3D;0,a^0&#x3D;a</li>
</ul>
<h2 id="96-1-题目描述"><a href="#96-1-题目描述" class="headerlink" title="96.1 题目描述"></a>96.1 题目描述</h2><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="96-2-算法思想和代码实现"><a href="#96-2-算法思想和代码实现" class="headerlink" title="96.2 算法思想和代码实现"></a>96.2 算法思想和代码实现</h2><h3 id="96-2-1-排序后遍历-O-nlogn"><a href="#96-2-1-排序后遍历-O-nlogn" class="headerlink" title="96.2.1 排序后遍历(O(nlogn))"></a>96.2.1 排序后遍历(O(nlogn))</h3><p>先排序，在遍历找到出现一次的数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Arrays.sort(nums);<br><br>    <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i+=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i]!=nums[i-<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> nums[i-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[nums.length-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="96-2-2-位运算：异或"><a href="#96-2-2-位运算：异或" class="headerlink" title="96.2.2 位运算：异或"></a>96.2.2 位运算：异或</h3><p>异或：位运算时，相同为0，不同为1</p>
<ul>
<li>a ^ a &#x3D; 0（相同的数异或后变成 0）</li>
<li>a ^ 0 &#x3D; a（任何数与 0 异或还是它本身）</li>
<li>异或运算满足交换律和结合律，因此所有成对的数字都会变成 0，最终只剩下那个唯一的数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        result ^= num;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="97-多数元素"><a href="#97-多数元素" class="headerlink" title="97. 多数元素"></a>97. 多数元素</h1><ul>
<li><strong>一句话描述：</strong> res&#x3D;当前元素，用一个计数器，当出现自己时，计数+1，不是自己计数-1，当计数器&#x3D;0时，重新把res置为当前元素</li>
</ul>
<h2 id="97-1-题目描述"><a href="#97-1-题目描述" class="headerlink" title="97.1 题目描述"></a>97.1 题目描述</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="97-2-算法思想和代码实现"><a href="#97-2-算法思想和代码实现" class="headerlink" title="97.2 算法思想和代码实现"></a>97.2 算法思想和代码实现</h2><h3 id="97-2-1-先排序-取中位数"><a href="#97-2-1-先排序-取中位数" class="headerlink" title="97.2.1 先排序+取中位数"></a>97.2.1 先排序+取中位数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       Arrays.sort(nums);<br>       <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="97-2-2-摩尔投票法"><a href="#97-2-2-摩尔投票法" class="headerlink" title="97.2.2 摩尔投票法"></a>97.2.2 摩尔投票法</h3><p>核心就是对拼消耗。<br>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。<br>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。<br>最后能剩下的必定是自己人。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>           <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>               x = nums[i];<br>           &#125;<br>           <span class="hljs-keyword">if</span> (nums[i] == x) &#123;<br>               count++;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               count--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> x;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h1 id="98-颜色分类"><a href="#98-颜色分类" class="headerlink" title="98. 颜色分类"></a>98. 颜色分类</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li>两个指针：一个指针指向0位置，依次存储0元素，一个指针指向数组结尾位置，依次存储2元素</li>
</ul>
<h2 id="98-1-题目描述"><a href="#98-1-题目描述" class="headerlink" title="98.1 题目描述"></a>98.1 题目描述</h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<h2 id="98-2-算法思想和代码实现"><a href="#98-2-算法思想和代码实现" class="headerlink" title="98.2 算法思想和代码实现"></a>98.2 算法思想和代码实现</h2><p>0，1，2 排序。一次遍历，如果是0，则移动到表头，如果是2，则移动到表尾，不用考虑1。0和2处理完，1还会有错吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-comment">//x,y记录0和2的位置</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = nums.length - <span class="hljs-number">1</span>;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>         <span class="hljs-comment">//如果当前元素是0，把它放到数组开头位置</span><br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span> &amp;&amp; i &gt; x) &#123;<br>             nums[i] = nums[x];<br>             nums[x] = <span class="hljs-number">0</span>;<br>             x++;<br>             i--;<br>         &#125;<br>         <br>         <span class="hljs-comment">//如果当前元素是2，把它放到数组结尾位置</span><br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">2</span> &amp;&amp; i &lt; y) &#123;<br>             nums[i] = nums[y];<br>             nums[y] = <span class="hljs-number">2</span>;<br>             y--;<br>             i--;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>


<h1 id="99-下一个排列"><a href="#99-下一个排列" class="headerlink" title="99. 下一个排列"></a>99. 下一个排列</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><code>2, 6, 3, 5, 4, 1 --&gt; 2, 6, 4, 1, 3, 5</code> 分为以下几步：<ol>
<li>从后往前找到3</li>
<li>从后往前找，找到第一个大于3的数：4</li>
<li><code>swap(3,4)</code>，此时：<code>2, 6, 4, 5, 3, 1</code></li>
<li>最后<strong>反转5，3，1</strong>即可得到<code>2, 6, 4, 1, 3, 5</code></li>
</ol>
</li>
</ul>
<h2 id="99-1-题目描述"><a href="#99-1-题目描述" class="headerlink" title="99.1 题目描述"></a>99.1 题目描述</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li>
</ul>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li>
<li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。</li>
<li>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。<br>必须 原地 修改，只允许使用额外常数空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<h2 id="99-2-算法思想和代码实现"><a href="#99-2-算法思想和代码实现" class="headerlink" title="99.2 算法思想和代码实现"></a>99.2 算法思想和代码实现</h2><ol>
<li>从后往前找出数值下降的位置 i</li>
<li>交换 nums[i] 和 i之后比nums[i]大的最小数</li>
<li>让i+1位及其之后的排列最小即 递增（其实已经是递减的了，直接反转就行）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//从后往前遍历，找到第一个非递减的元素，该元素就是排列的起点start</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>            start = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果整个数组是降序排列，则直接反转它变成最小排列</span><br>    <span class="hljs-keyword">if</span> (start == -<span class="hljs-number">1</span>) &#123;<br>        reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//找到比start大的最小的元素,并与start交换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; start; i--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[start]) &#123;<br>            swap(nums, i, start);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//反转从start+1到最后的数组元素</span><br>    reverse(nums, start + <span class="hljs-number">1</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//交换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br><br><span class="hljs-comment">//反转</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        swap(nums, start, end);<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="100-寻找重复数"><a href="#100-寻找重复数" class="headerlink" title="100. 寻找重复数"></a>100. 寻找重复数</h1><ul>
<li><strong>一句话描述：</strong> </li>
<li><strong>快慢指针找环</strong>，相遇之后，将fast重新置为0，两个指针每次移动一步，再次相遇就是重复数所在位置</li>
<li><code>fast = nums[nums[fast]]</code> &#x2F;&#x2F; 快指针每次移动两步</li>
<li><code>slow = nums[slow]</code> &#x2F;&#x2F; 慢指针每次移动一步</li>
</ul>
<h2 id="100-1-题目描述"><a href="#100-1-题目描述" class="headerlink" title="100.1 题目描述"></a>100.1 题目描述</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="100-2-算法思想和代码实现"><a href="#100-2-算法思想和代码实现" class="headerlink" title="100.2 算法思想和代码实现"></a>100.2 算法思想和代码实现</h2><ol>
<li><p>数组大小为 n+1，其中的数字范围是 [1, n]，因此必然有一个数字重复</p>
</li>
<li><p>快慢指针判圈</p>
</li>
</ol>
<ul>
<li><p>定义两个指针：</p>
<ul>
<li>慢指针 (slow) 每次移动一步。</li>
<li>快指针 (fast) 每次移动两步。</li>
</ul>
</li>
<li><p>为什么存在环？</p>
<ul>
<li>由于 nums[i] 指向数组中的索引，这实际上形成了一个 链表 结构。</li>
<li>由于存在 重复元素，意味着<strong>至少有两个索引指向 同一位置</strong>，从而形成 环。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>找到环的入口（即重复数）<ul>
<li>当 slow &#x3D;&#x3D; fast 时，说明快慢指针相遇，表明存在环。</li>
<li>让 fast 指针回到 <strong>起点 (0)</strong>，然后 <strong>两个指针都每次移动一步</strong>。</li>
<li>他们再次相遇的地方，就是 环的入口（即重复的数字）。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 使用快慢指针寻找相遇点</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        fast = nums[nums[fast]]; <span class="hljs-comment">// 快指针每次移动两步</span><br>        slow = nums[slow]; <span class="hljs-comment">// 慢指针每次移动一步</span><br><br>        <span class="hljs-comment">// 当快慢指针相遇时，说明存在环</span><br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            fast = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重新将快指针置于起点</span><br><br>            <span class="hljs-comment">// 通过第二次相遇点确定重复的数字</span><br>            <span class="hljs-keyword">while</span> (nums[slow] != nums[fast]) &#123;<br>                fast = nums[fast]; <span class="hljs-comment">// 快指针每次移动一步</span><br>                slow = nums[slow]; <span class="hljs-comment">// 慢指针每次移动一步</span><br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> nums[slow]; <span class="hljs-comment">// 返回找到的重复数字</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><hr>
<hr>
<hr>
<h1 id="101-使用最小花费爬楼梯"><a href="#101-使用最小花费爬楼梯" class="headerlink" title="101. 使用最小花费爬楼梯"></a>101. 使用最小花费爬楼梯</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">使用最小花费爬楼梯</a></p>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-comment">//dp[i]代表爬到第i个台阶所花费的最小费用</span><br>    <span class="hljs-type">int</span>[] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化dp</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=cost.length;i++)&#123;<br>        dp[i]=Math.min(dp[i-<span class="hljs-number">1</span>]+cost[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+cost[i-<span class="hljs-number">2</span>]); <span class="hljs-comment">//状态转移方程</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[cost.length];<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="102-不同路径II"><a href="#102-不同路径II" class="headerlink" title="102. 不同路径II"></a>102. 不同路径II</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">不同路径II</a></p>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br><br>       <span class="hljs-comment">//dp[i][j]：到达第i行第j列的不同路径个数</span><br>       <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>       <span class="hljs-comment">//初始化</span><br>       <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>           <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>               dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>           <span class="hljs-keyword">else</span><br>               dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>           <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)<br>               dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">else</span><br>               dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-comment">//状态转移方程</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>               <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                   dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   dp[i][j] = <span class="hljs-number">0</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure>

<h1 id="103-整数拆分"><a href="#103-整数拆分" class="headerlink" title="103. 整数拆分"></a>103. 整数拆分</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">整数拆分</a></p>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//dp[i]代表i可以拆分的最大乘积</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//dp[i] = Math.max(dp[i],j*(i-j),j*dp[i-j]);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i/<span class="hljs-number">2</span>;j++)&#123;<br>            dp[i]=Math.max(Math.max(j*(i-j),j*dp[i-j]),dp[i]);<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="104-不同的二叉搜索树"><a href="#104-不同的二叉搜索树" class="headerlink" title="104. 不同的二叉搜索树"></a>104. 不同的二叉搜索树</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/">不同的二叉搜索树</a></p>
<p><code>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)G(n-1)+G(1)(n-2)+...+G(n-1)*G(0)</code></p>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//dp[i]：由i个结点组成的二叉树的种类</span><br>    <span class="hljs-type">int</span>[] dp =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//dp[i]=dp[0]*dp[i-1]+dp[1]*dp[i-2]+...+dp[i]*dp[0]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>            dp[i]+=dp[j]*dp[i-j-<span class="hljs-number">1</span>];<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="105-最后一块石头的重量-II"><a href="#105-最后一块石头的重量-II" class="headerlink" title="105. 最后一块石头的重量 II"></a>105. 最后一块石头的重量 II</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">最后一块石头的重量 II</a></p>
<p>转换为0-1背包问题：</p>
<ul>
<li>尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。</li>
<li>一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum &#x2F; 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum&#x2F;2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum &#x2F; 2的背包。</li>
</ul>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为01背包问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++)<br>        sum += stones[i];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[stones.length + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= stones.length; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; stones[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - stones[i - <span class="hljs-number">1</span>]] + stones[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[stones.length][target];<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="106-回文子串"><a href="#106-回文子串" class="headerlink" title="106. 回文子串"></a>106. 回文子串</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">回文子串</a><br>该题目与最长回文子串类似(<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a>)</p>
<ul>
<li>dp定义：布尔类型的dp[i][j]：表示区间范围[i,j]的子串是否是回文子串，如果是dp[i][j]为true，否则为false</li>
<li>状态转移方程：<ul>
<li>当s[i]与s[j]不相等，dp[i][j]一定是false。</li>
<li>当s[i]与s[j]相等时，有如下三种情况<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//dp[i][j]:从i到j的子串是不是回文的</span><br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 逆序遍历i</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                <span class="hljs-keyword">if</span> (j == i || j == i + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 单个字符 or 相邻字符</span><br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="201-合并两个有序数组"><a href="#201-合并两个有序数组" class="headerlink" title="201. 合并两个有序数组"></a>201. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a></h1><p><strong>双指针从后往前合并</strong>，避免覆盖还没处理的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;<br>            nums1[p] = nums1[p1];<br>            p1--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums1[p] = nums2[p2];<br>            p2--;<br>        &#125;<br>        p--;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 nums2 还有剩余元素，复制到 nums1</span><br>    <span class="hljs-keyword">while</span> (p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        nums1[p] = nums2[p2];<br>        p2--;<br>        p--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="202-字符串相加"><a href="#202-字符串相加" class="headerlink" title="202. 字符串相加"></a>202. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></h1><p>1️⃣ 从 num1 和 num2 的末尾开始，一位一位相加。<br>2️⃣ 用一个 carry 保存进位，初始为 0。<br>3️⃣ 每次把当前位的和 sum &#x3D; digit1 + digit2 + carry 计算好，sum % 10 放入结果，sum &#x2F; 10 更新 carry。<br>4️⃣ 最后别忘了：如果 carry !&#x3D; 0，还要加到结果前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">addStrings</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br><br>        sb.append(sum % <span class="hljs-number">10</span>);<br>        carry = sum / <span class="hljs-number">10</span>;<br><br>        i--;<br>        j--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="203-最小K个数"><a href="#203-最小K个数" class="headerlink" title="203. 最小K个数"></a>203. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-k-lcci/">最小K个数</a></h1><p>使用大顶堆（PriorityQueue）来筛选数组中最小的 k 个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] smallestK(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k, (l1, l2) -&gt; l2 - l1);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (pq.size() &lt; k) &#123;<br>            pq.offer(num);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; pq.peek()) &#123;<br>            pq.poll();<br>            pq.offer(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        res[i++] = pq.poll();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="204-买卖股票的最佳时机-II"><a href="#204-买卖股票的最佳时机-II" class="headerlink" title="204. 买卖股票的最佳时机 II"></a>204. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h1><p>贪心：<strong>只要今天比昨天大，就卖出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;<br>            res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="205-最大数"><a href="#205-最大数" class="headerlink" title="205. 最大数"></a>205. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-number/description/">最大数</a></h1><p>使用<strong>自定义排序规则</strong>：<code>Arrays.sort(strNums,(a,b)-&gt;(b+a).compareTo(a+b));</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    String[] strNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[nums.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        strNums[i] = String.valueOf(nums[i]);<br>    &#125;<br><br>    Arrays.sort(strNums, (a, b) -&gt; (b + a).compareTo(a + b));<br>    <span class="hljs-keyword">if</span> (strNums[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;0&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (String str : strNums) &#123;<br>        sb.append(str);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="206-最长公共前缀"><a href="#206-最长公共前缀" class="headerlink" title="206. 最长公共前缀"></a>206. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/description/">最长公共前缀</a></h1><p>用第一个字符串的每个字符，依次与后面所有字符串的相应字符进行比较即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].charAt(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= strs[j].length() || c != strs[j].charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> sb.toString();<br>            &#125;<br>        &#125;<br>        sb.append(c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="207-重排链表"><a href="#207-重排链表" class="headerlink" title="207. 重排链表"></a>207. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">重排链表</a></h1><p><strong>重排链表&#x3D;找链表中点+反转链表+合并链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 找中点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMid(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> reverse(mid.next);<br>    mid.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 切断前后链表</span><br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = l1;<br>        l1 = l1.next;<br>        cur = cur.next;<br><br>        cur.next = l2;<br>        l2 = l2.next;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>)<br>        cur.next = l1; <span class="hljs-comment">// 补上尾巴</span><br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findMid</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = cur;<br>        cur = head;<br>        head = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="208-复原-IP-地址"><a href="#208-复原-IP-地址" class="headerlink" title="208. 复原 IP 地址"></a>208. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/description/">复原 IP 地址</a></h1><p><strong>回溯算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 用于存储 &quot;255&quot; 这种IP段</span><br>List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>    backtracking(s, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-comment">// 如果已经切了 4 段，并且刚好用完所有字符，说明找到一个合法的 IP</span><br>    <span class="hljs-keyword">if</span> (path.size() == <span class="hljs-number">4</span> &amp;&amp; start == s.length()) &#123;<br>        res.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 start 开始，尝试截取 1~3 位的子串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length() &amp;&amp; i - start &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-comment">// 防止出现 &quot;01&quot; &quot;00&quot; 这种非法格式</span><br>        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; s.charAt(start) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 截取 startIdx 到 i 的子串，转成整数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>));<br>        <br>        <span class="hljs-keyword">if</span> (v &gt;= <span class="hljs-number">0</span> &amp;&amp; v &lt;= <span class="hljs-number">255</span>) &#123;<br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            backtracking(s, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="209-排序数组"><a href="#209-排序数组" class="headerlink" title="209. 排序数组"></a>209. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a></h1><p><strong>快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low, j = high;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[(low + high) / <span class="hljs-number">2</span>];  <span class="hljs-comment">// 选取中间值作为基准</span><br><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] &lt; pivot) i++;<br>        <span class="hljs-keyword">while</span> (nums[j] &gt; pivot) j--;<br>        <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>            swap(nums, i, j);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 递归左右两边</span><br>    quickSort(nums, low, j);<br>    quickSort(nums, i, high);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="210-多线程交替打印ab"><a href="#210-多线程交替打印ab" class="headerlink" title="210. 多线程交替打印ab"></a>210. 多线程交替打印ab</h1><p>使用synchronized和wait()&#x2F;notify()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">printA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printA</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>          <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>              <span class="hljs-keyword">while</span> (!printA) &#123;<br>                  lock.wait();<br>              &#125;<br>              System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>              printA = <span class="hljs-literal">false</span>;<br>              lock.notify();<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printB</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>          <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>              <span class="hljs-keyword">while</span> (printA) &#123;<br>                  lock.wait();<br>              &#125;<br>              System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br>              printA = <span class="hljs-literal">true</span>;<br>              lock.notify();<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          <span class="hljs-type">Solution000</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution000</span>();<br><br>          <span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) sl.printA();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>          &#125;);<br><br>          <span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) sl.printB();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>          &#125;);<br><br>          threadA.start();<br>          threadB.start();<br>      &#125;<br></code></pre></td></tr></table></figure>



                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
        <a href="/tags/LeetCode/" class="print-no-link">#LeetCode</a>
      
        <a href="/tags/hot100/" class="print-no-link">#hot100</a>
      
        <a href="/tags/JAVA/" class="print-no-link">#JAVA</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/06/11/JAVA/GoodsKill/" title="GoodsKill项目分析及亮点解析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GoodsKill项目分析及亮点解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/18/JAVA/mysql/" title="MySQL原理学习笔记">
                        <span class="hidden-mobile">MySQL原理学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sj2tGuxMGSDhkN5hNuOIVta1-gzGzoHsz","appKey":"ysR5OTuTzoby2oNvNyGOtXFQ","path":"window.location.pathname","placeholder":"如有问题，欢迎指正~","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>AI</span> <i class="iconfont icon-love"></i> <span>CPP</span> <i class="iconfont icon-love"></i> <span>JAVA</span> <i class="iconfont icon-love"></i> <span>CyberSec</span> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script>
<script src="/js/bubble.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
