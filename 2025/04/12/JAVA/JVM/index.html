

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/about/dogs.jpg">
  <link rel="icon" href="/img/about/dogs.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ranzier">
  <meta name="keywords" content="">
  
    <meta name="description" content="JVM学习笔记  〇. 什么是JVM 定义Java Virtual Machine ，Java 程序的运行环境（Java 二进制字节码的运行环境）。  好处  一次编译，处处执行 自动的内存管理，垃圾回收机制 数组下标越界检查   JVM、JRE、JDK 的关系     JVM的执行流程   一. 内存结构1. 程序计数器Program Counter Register 程序计数器（寄存器）  作">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记">
<meta property="og:url" content="http://example.com/2025/04/12/JAVA/JVM/index.html">
<meta property="og:site_name" content="RANZIER">
<meta property="og:description" content="JVM学习笔记  〇. 什么是JVM 定义Java Virtual Machine ，Java 程序的运行环境（Java 二进制字节码的运行环境）。  好处  一次编译，处处执行 自动的内存管理，垃圾回收机制 数组下标越界检查   JVM、JRE、JDK 的关系     JVM的执行流程   一. 内存结构1. 程序计数器Program Counter Register 程序计数器（寄存器）  作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bg/36.jpg">
<meta property="article:published_time" content="2025-04-12T11:01:24.000Z">
<meta property="article:modified_time" content="2025-10-14T07:31:43.650Z">
<meta property="article:author" content="ranzier">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/bg/36.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JVM学习笔记 - RANZIER</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_3846514_kabxni94auf.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css">
<link rel="stylesheet" href="/css/bubble.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"🌟","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>RANZIER</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/3.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.35)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JVM学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-12 19:01" pubdate>
          2025年4月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          35 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          本文阅读次数：<span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JVM学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 align="center">JVM学习笔记</h1>

<h1 id="〇-什么是JVM"><a href="#〇-什么是JVM" class="headerlink" title="〇. 什么是JVM"></a>〇. 什么是JVM</h1><ol>
<li><p>定义<br>Java Virtual Machine ，Java 程序的运行环境（Java 二进制字节码的运行环境）。</p>
</li>
<li><p>好处</p>
<ul>
<li>一次编译，处处执行</li>
<li>自动的内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
</ul>
</li>
<li><p>JVM、JRE、JDK 的关系</p>
</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.0.1.png" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li>JVM的执行流程</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.0.2.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="一-内存结构"><a href="#一-内存结构" class="headerlink" title="一. 内存结构"></a>一. 内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>Program Counter Register 程序计数器（寄存器）</p>
<ol>
<li>作用：记录下一条 jvm 指令的执行地址。</li>
<li>特点：<ul>
<li>是线程私有的</li>
<li>不会存在内存溢出</li>
</ul>
</li>
</ol>
<h2 id="2-虚拟机栈-JVM-Stacks"><a href="#2-虚拟机栈-JVM-Stacks" class="headerlink" title="2. 虚拟机栈(JVM Stacks)"></a>2. 虚拟机栈(JVM Stacks)</h2><ul>
<li>栈：线程运行需要的内存空间</li>
<li>栈帧：每个方法运行时需要的内存，包括参数、局部变量和返回地址</li>
<li>每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存</li>
</ul>
<h3 id="2-1-问题分析"><a href="#2-1-问题分析" class="headerlink" title="2.1 问题分析"></a>2.1 问题分析</h3><ol>
<li>垃圾回收是否涉及栈内存？<br> 不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</li>
<li>栈内存分配越大越好吗？<br> 不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是<strong>可执行的线程数就会越少</strong>。</li>
<li>方法内的局部变量是否线程安全？<ul>
<li><strong>共享的变量static</strong>需要考虑线程安全</li>
<li><strong>私有的变量是线程安全的</strong></li>
<li>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</li>
</ul>
</li>
</ol>
<h3 id="2-2-栈内存溢出-java-lang-stackOverflowError"><a href="#2-2-栈内存溢出-java-lang-stackOverflowError" class="headerlink" title="2.2 栈内存溢出(java.lang.stackOverflowError)"></a>2.2 栈内存溢出(java.lang.stackOverflowError)</h3><ol>
<li>栈帧过多导致栈内存溢出：<strong>无限递归调用</strong></li>
<li>栈帧过大导致栈内存溢出</li>
</ol>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>有些时候JAVA代码不能与操作系统直接进行操作，就需要一些C&#x2F;C++代码进行操作，这些C&#x2F;C++代码就是本地方法，存储在本地方法栈</p>
<h2 id="4-堆-Heap"><a href="#4-堆-Heap" class="headerlink" title="4. 堆(Heap)"></a>4. 堆(Heap)</h2><ul>
<li><p>通过<strong>new关键字创建</strong>的对象都会被放在堆内存</p>
</li>
<li><p>特点</p>
<ul>
<li>它是线程共享，堆内存中的对象<strong>都需要考虑线程安全</strong>问题</li>
<li>有垃圾回收机制</li>
</ul>
</li>
</ul>
<h3 id="4-1-堆内存溢出-java-lang-OutofMemoryError"><a href="#4-1-堆内存溢出-java-lang-OutofMemoryError" class="headerlink" title="4.1 堆内存溢出(java.lang.OutofMemoryError)"></a>4.1 堆内存溢出(java.lang.OutofMemoryError)</h3><p>源源不断产生对象，并且对象一直在被使用，导致无法被回收，从而导致堆内存溢出</p>
<h3 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h3><ol>
<li>jps 工具<br> 查看当前系统中有哪些 java 进程</li>
<li>jmap 工具<br> 查看堆内存占用情况 <code>jmap - heap 进程id</code></li>
<li>jconsole 工具<br> 图形界面的，多功能的监测工具，可以连续监测</li>
</ol>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-方法区的定义"><a href="#5-1-方法区的定义" class="headerlink" title="5.1 方法区的定义"></a>5.1 方法区的定义</h3><ul>
<li><strong>存储每个类的结构</strong>，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法</li>
<li>用于类和实例初始化以及接口初始化方法区域是<strong>在虚拟机启动时创建的</strong></li>
<li>方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它</li>
<li>方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.1.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-2-方法区内存溢出"><a href="#5-2-方法区内存溢出" class="headerlink" title="5.2 方法区内存溢出"></a>5.2 方法区内存溢出</h3><ul>
<li>1.8 之前会导致永久代内存溢出</li>
<li>1.8 之后会导致元空间内存溢出</li>
</ul>
<h3 id="5-3-运行时常量池"><a href="#5-3-运行时常量池" class="headerlink" title="5.3 运行时常量池"></a>5.3 运行时常量池</h3><ul>
<li>二进制字节码包含：（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）</li>
<li>常量池：就是一张<strong>常量表</strong>，虚拟机<strong>指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</strong></li>
<li>运行时常量池：<br>  常量池是 <em>.class 文件中的，当该类被加载以后，它的*<em>常量池信息就会被加载成运行时常量池</em></em>，并把里面的符号地址变为真实地址</li>
</ul>
<ol>
<li>常量池表中的地址可能对应着一个类名、方法名、参数类型等信息：</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.1.2.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>类方法的每条指令都会对应常量池表中一个地址：</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.1.3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-4-StringTable-字符串常量池，串池"><a href="#5-4-StringTable-字符串常量池，串池" class="headerlink" title="5.4 StringTable(字符串常量池，串池)"></a>5.4 StringTable(字符串常量池，串池)</h3><h4 id="5-4-1-常量池和串池的关系"><a href="#5-4-1-常量池和串池的关系" class="headerlink" title="5.4.1 常量池和串池的关系"></a>5.4.1 常量池和串池的关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable[&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;] Hashtable 结构,不能扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">//常量池中的信息,都会被加载到运行时常量池中,这时a b ab 都是常量池中的符号,还没有变为java 字符串对象</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为“a”字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为“b&quot;字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为“ab&quot;字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-4-2-StringTable的特性"><a href="#5-4-2-StringTable的特性" class="headerlink" title="5.4.2 StringTable的特性"></a>5.4.2 StringTable的特性</h4><ul>
<li>常量池中的字符串<strong>仅是符号</strong>，只有在被用到时才会转化为对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是StringBuilder</li>
<li>字符串<strong>常量</strong>拼接的原理是编译器优化</li>
<li>可以使用intern方法，主动<strong>将串池中还没有的字符串对象放入串池中</strong></li>
<li>new出来的放在堆里；直接赋值的放在串池里，虽然串池也在堆里，但是地址不同</li>
</ul>
<h4 id="5-4-3-intern-方法"><a href="#5-4-3-intern-方法" class="headerlink" title="5.4.3 intern()方法"></a>5.4.3 intern()方法</h4><p>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>		<span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br>		<span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>		<span class="hljs-comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span><br>		System.out.println(str == st2);<br>		System.out.println(str == str3);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>        <span class="hljs-comment">// false</span><br>		System.out.println(str == str2);<br>        <span class="hljs-comment">// false</span><br>		System.out.println(str == str3);<br>        <span class="hljs-comment">// true</span><br>		System.out.println(str2 == str3);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</li>
</ul>
<h4 id="5-4-4-StringTable位置"><a href="#5-4-4-StringTable位置" class="headerlink" title="5.4.4 StringTable位置"></a>5.4.4 StringTable位置</h4><p>jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在<strong>堆中</strong>。</p>
<h4 id="5-4-5-StringTable垃圾回收"><a href="#5-4-5-StringTable垃圾回收" class="headerlink" title="5.4.5 StringTable垃圾回收"></a>5.4.5 StringTable垃圾回收</h4><p>如果内存不够了，StringTable会把无用的数据进行垃圾回收</p>
<h4 id="5-4-6-StringTable性能调优"><a href="#5-4-6-StringTable性能调优" class="headerlink" title="5.4.6 StringTable性能调优"></a>5.4.6 StringTable性能调优</h4><ul>
<li>因为StringTable是由<strong>HashTable实现</strong>的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</li>
<li><strong>当重复的字符串过多时</strong>，需要考虑是否需要将字符串对象入池：可以通过 <strong>intern</strong>方法减少重复入池</li>
</ul>
<h2 id="6-直接内存-操作系统的内存"><a href="#6-直接内存-操作系统的内存" class="headerlink" title="6. 直接内存(操作系统的内存)"></a>6. 直接内存(操作系统的内存)</h2><ul>
<li>常见于 NIO 操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受 JVM 内存回收管理</li>
</ul>
<h3 id="6-1-使用直接内存的好处"><a href="#6-1-使用直接内存的好处" class="headerlink" title="6.1 使用直接内存的好处"></a>6.1 使用直接内存的好处</h3><p>直接内存是<strong>操作系统和 Java 代码都可以访问</strong>的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率:</p>
<p><img src="/img/blogs/java/jvm-juc/jvm.1.4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-2-直接内存的回收机制"><a href="#6-2-直接内存的回收机制" class="headerlink" title="6.2 直接内存的回收机制"></a>6.2 直接内存的回收机制</h3><ul>
<li>直接内存的回收<strong>不是通过 JVM 的垃圾回收来释放</strong>的，而是通过unsafe.freeMemory 来手动释放。</li>
<li>直接内存的回收机制总结<ul>
<li>使用了 <strong>Unsafe 类来完成直接内存的分配回收</strong>，回收需要主动调用freeMemory 方法</li>
<li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</li>
</ul>
</li>
</ul>
<h1 id="二-垃圾回收"><a href="#二-垃圾回收" class="headerlink" title="二. 垃圾回收"></a>二. 垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p>当一个对象被引用时，就当引用对象的值+1，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。</p>
<ul>
<li>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</li>
</ul>
<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><ol>
<li>确定根对象(肯定不能被垃圾回收的对象)</li>
<li>每个对象是不是被根对象直接或间接的引用,如果是,则将来不能作为垃圾回收,反之则可以回收</li>
</ol>
<ul>
<li>JVM 中的垃圾回收器通过可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收</li>
</ul>
<h4 id="哪些对象可以作为GC-Root对象？"><a href="#哪些对象可以作为GC-Root对象？" class="headerlink" title="哪些对象可以作为GC Root对象？"></a>哪些对象可以作为GC Root对象？</h4><ol>
<li>系统类对象(System Class)</li>
<li>调用操作系统方法中引用的JAVA对象(Native Stack)</li>
<li>活动<strong>线程的对象</strong>(Thread)</li>
<li>被加锁的对象，正在加锁的对象</li>
</ol>
<h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="/img/blogs/java/jvm-juc/jvm.2.1.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>强引用<ul>
<li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
</li>
<li>软引用<ul>
<li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时会再次出发垃圾回收，回收软引用对象</strong></li>
<li>可以配合引用队列来释放软引用自身</li>
</ul>
</li>
<li>弱引用<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足，都会回收弱引用对象</strong></li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
</li>
<li>虚引用<ul>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队</li>
<li>由 Reference Handler 线程调用虚引用相关方法释放直接内存</li>
</ul>
</li>
<li>终结器引用<ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收）;再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</li>
</ul>
</li>
</ol>
<h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><ol>
<li><strong>标记</strong>：标记没有被GC Root引用的对象</li>
<li><strong>清除</strong>：释放对象占用的内存空间</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.2.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>速度较快</li>
<li>会产生内存碎片</li>
</ul>
<h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><ol>
<li><strong>标记</strong>：标记没有被GC Root引用的对象</li>
<li><strong>整理</strong>：释放对象空间，之后将内存碎片移动到一块，成为一段连续的空间</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.3.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>速度慢</li>
<li>没有内存碎片</li>
</ul>
<h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><ol>
<li><strong>标记</strong>：标记没有被GC Root引用的对象</li>
<li><strong>复制</strong>：将内存空间复制到另一块内存地址中，然后再交换回来</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>不会有内存碎片</li>
<li>需要占用两倍内存空间</li>
</ul>
<h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><ul>
<li>新生代频繁发生垃圾回收，老年代很少发生垃圾回收</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.5.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>新创建的对象首先分配在伊甸园区</li>
<li>新生代空间不足时，触发 minor GC，伊甸园区和 from 区存活的对象使用copy复制到to中，存活的对象年龄加一，然后交换 from to</li>
<li>minor GC会引发 stop the world：暂停其他用户线程，等垃圾回收结束后，恢复用户线程运行</li>
<li>当幸存区对象的寿命超过阈值时，会晋升到老年代，最大的寿命是 15（4bit）</li>
<li>当老年代空间不足时，会先触发 minor GC，如果空间仍然不足，那么就触发 full GC，stop the world停止的时间更长！</li>
</ol>
<ul>
<li>当新创建的对象比新生代还要大的时候，如果老年代大小能容下，则会直接放到老年代</li>
<li>当新创建的对象比新生代和老年代的大小总和都大时，会抛出内存溢出(OutOfMemoryError)</li>
</ul>
<h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h3><ul>
<li>单线程</li>
<li>堆内存较少，适合个人电脑</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.6.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</li>
<li>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</li>
</ul>
<h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><ul>
<li>多线程</li>
<li>适用于堆内存较大，多核CPU</li>
<li>让单位时间内，STW(stop the world)的时间最短</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.7.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当开始垃圾回收时，所有的CPU线程都会进行垃圾回收，此时CPU占有率达到100%</li>
</ul>
<p>两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）</li>
<li>XX:GCTimeRatio&#x3D;rario 直接设置吞吐量的大小</li>
</ul>
<h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h3><ul>
<li>多线程</li>
<li>适用于堆内存较大，多核CPU</li>
<li>尽可能让STW(stop the world)的单次时间最短</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.8.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-4-CMS-收集器"><a href="#4-4-CMS-收集器" class="headerlink" title="4.4 CMS 收集器"></a>4.4 CMS 收集器</h3><ul>
<li>CMS 收集器：Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</li>
<li>CMS 收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的,有些阶段不需要stop the world，可以和用户阶段一起并发运行</li>
</ul>
<p>CMS 收集器的运行过程分为下列4步：</p>
<ol>
<li><strong>初始标记</strong>：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</li>
<li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。</li>
<li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题</li>
<li><strong>并发清除</strong>：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！</li>
</ol>
<h2 id="5-G1-Garbage-First"><a href="#5-G1-Garbage-First" class="headerlink" title="5. G1(Garbage First)"></a>5. G1(Garbage First)</h2><p>适用场景</p>
<ul>
<li>同时注重吞吐量和低延迟（响应时间），默认暂停目标是200ms</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li>
<li><strong>整体上是标记-整理算法</strong>，<strong>两个区域之间是复制算法</strong></li>
</ul>
<h3 id="5-1-G1垃圾回收阶段"><a href="#5-1-G1垃圾回收阶段" class="headerlink" title="5.1 G1垃圾回收阶段"></a>5.1 G1垃圾回收阶段</h3><p><img src="/img/blogs/java/jvm-juc/jvm.2.9.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>Young Collection：对新生代垃圾收集</li>
<li>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</li>
<li>Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</li>
</ul>
<h3 id="5-2-Young-Collection"><a href="#5-2-Young-Collection" class="headerlink" title="5.2 Young Collection"></a>5.2 Young Collection</h3><ul>
<li>存在STW</li>
</ul>
<ol>
<li>新生代的垃圾回收会将幸存的对象复制放到幸存区</li>
<li>当幸存区对象过多了，继续垃圾回收，会放到老年代</li>
</ol>
<h3 id="5-3-Young-Collection-CM"><a href="#5-3-Young-Collection-CM" class="headerlink" title="5.3 Young Collection + CM"></a>5.3 Young Collection + CM</h3><ul>
<li>在 Young GC 时会进行 GC Root 的初始化标记</li>
<li>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的 JVM 参数决定</li>
</ul>
<h3 id="5-3-Mixed-Collection"><a href="#5-3-Mixed-Collection" class="headerlink" title="5.3 Mixed Collection"></a>5.3 Mixed Collection</h3><p>会对 E、S、O 进行全面的回收</p>
<ul>
<li>最终标记 会STW</li>
<li>拷贝存活 会STW</li>
</ul>
<p>问：为什么有的老年代被拷贝了，有的没拷贝？</p>
<ul>
<li>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</li>
</ul>
<h3 id="5-4-Full-GC"><a href="#5-4-Full-GC" class="headerlink" title="5.4 Full GC"></a>5.4 Full GC</h3><ul>
<li>G1 在老年代内存不足时（老年代所占内存超过阈值）<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理</li>
<li>如果<strong>垃圾产生速度快于垃圾回收速度，便会触发 Full GC</strong>，然后退化成 serial Old 收集器串行的收集，就会导致停顿的时候长。</li>
</ul>
</li>
</ul>
<h3 id="5-5-Young-Collection-跨代引用"><a href="#5-5-Young-Collection-跨代引用" class="headerlink" title="5.5 Young Collection 跨代引用"></a>5.5 Young Collection 跨代引用</h3><p>新生代回收的跨代引用（老年代引用新生代）问题</p>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.10.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>脏卡：O 被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
<li>通过遍历脏卡找到老年代引用，从而加速找到引用标记</li>
</ul>
<h3 id="5-6-Remark-重新标记阶段"><a href="#5-6-Remark-重新标记阶段" class="headerlink" title="5.6 Remark(重新标记阶段)"></a>5.6 Remark(重新标记阶段)</h3><p>在垃圾回收时，收集器处理对象的过程中</p>
<ul>
<li>黑色：已被处理，需要保留的</li>
<li>灰色：正在处理中的</li>
<li>白色：还未处理的(如果没有黑色的强引用，则会被回收)</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.11.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-7-JDK-8u20-字符串去重"><a href="#5-7-JDK-8u20-字符串去重" class="headerlink" title="5.7 JDK 8u20 字符串去重"></a>5.7 JDK 8u20 字符串去重</h3><ol>
<li>将所有新分配的字符串（底层是 char[] ）放入一个队列</li>
<li>当新生代回收时，G1 并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们引用同一个字符串对象</li>
</ol>
<p>与 String.intern() 的区别</p>
<ul>
<li>String.intern() 关注的是字符串对象</li>
<li>字符串去重关注的是 char[]</li>
<li>在 JVM 内部，使用了不同的字符串标</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用 CPU</li>
</ul>
<h3 id="5-8-JDK-8u40-并发标记类卸载"><a href="#5-8-JDK-8u40-并发标记类卸载" class="headerlink" title="5.8 JDK 8u40 并发标记类卸载"></a>5.8 JDK 8u40 并发标记类卸载</h3><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h3 id="5-9-JDK-8u60-回收巨型对象"><a href="#5-9-JDK-8u60-回收巨型对象" class="headerlink" title="5.9 JDK 8u60 回收巨型对象"></a>5.9 JDK 8u60 回收巨型对象</h3><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li><strong>回收时被优先考虑</strong></li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.2.12.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-10-JDK-9-并发标记起始时间的调整"><a href="#5-10-JDK-9-并发标记起始时间的调整" class="headerlink" title="5.10 JDK 9 并发标记起始时间的调整"></a>5.10 JDK 9 并发标记起始时间的调整</h3><ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li>
<li>JDK 9 可以动态调整<ul>
<li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空挡空间</li>
</ul>
</li>
</ul>
<h2 id="6-GC调优"><a href="#6-GC调优" class="headerlink" title="6. GC调优"></a>6. GC调优</h2><h3 id="6-1-调优领域"><a href="#6-1-调优领域" class="headerlink" title="6.1 调优领域"></a>6.1 调优领域</h3><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h3 id="6-2-确定目标"><a href="#6-2-确定目标" class="headerlink" title="6.2 确定目标"></a>6.2 确定目标</h3><p>低延迟&#x2F;高吞吐量？ 选择合适的GC回收器</p>
<ul>
<li>CMS G1 ZGC ParallelGC</li>
</ul>
<h3 id="6-3-最快的GC是不发生GC"><a href="#6-3-最快的GC是不发生GC" class="headerlink" title="6.3 最快的GC是不发生GC"></a>6.3 最快的GC是不发生GC</h3><ul>
<li>数据是不是太多？<ul>
<li>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</li>
</ul>
</li>
<li>数据表示是否太臃肿</li>
<li>是否存在内存泄漏</li>
</ul>
<h3 id="6-4-新生代调优"><a href="#6-4-新生代调优" class="headerlink" title="6.4 新生代调优"></a>6.4 新生代调优</h3><ul>
<li>新生代的特点：所有的 new 操作分配内存都是非常廉价的</li>
<li>死亡对象的回收代价是0</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>Minor GC 所用时间远小于 Full GC</li>
</ul>
<h4 id="新生代内存越大越好么？"><a href="#新生代内存越大越好么？" class="headerlink" title="新生代内存越大越好么？"></a>新生代内存越大越好么？</h4><ul>
<li>新生代内存太小：<strong>小了回收频繁</strong>，频繁触发 Minor GC ，会 STW ，会使得吞吐量下降</li>
<li>新生代内存太大：<strong>空间大回收的时间过长</strong>，老年代内存占比有所降低，<strong>会更频繁地触发 Full GC</strong>。而且触发 Minor GC 时，清理新生代所花费的时间会更长</li>
</ul>
<p>调优方法：</p>
<ul>
<li>新生代内存设置【并发量*(请求-响应)】的数据为宜</li>
<li>幸存区需要能够保存 【当前活跃对象+需要晋升的对象】</li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h3 id="6-5-老年代调优"><a href="#6-5-老年代调优" class="headerlink" title="6.5 老年代调优"></a>6.5 老年代调优</h3><p>以 CMS 为例：</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代。</li>
<li>观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</li>
</ul>
<h1 id="三-类加载与字节码技术"><a href="#三-类加载与字节码技术" class="headerlink" title="三. 类加载与字节码技术"></a>三. 类加载与字节码技术</h1><h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h2><p>根据JVM规范，类文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs s">ClassFile&#123;<br>u4 			   magic<br>u2             minor_version;    <br>u2             major_version;    <br>u2             constant_pool_count;    <br>cp_info        constant_pool[constant_pool_count-1];    <br>u2             access_flags;    <br>u2             this_class;    <br>u2             super_class;   <br>u2             interfaces_count;    <br>u2             interfaces[interfaces_count];   <br>u2             fields_count;    <br>field_info     fields[fields_count];   <br>u2             methods_count;    <br>method_info    methods[methods_count];    <br>u2             attributes_count;    <br>attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>魔数：0~3个字节，表示是否为.class类型的文件</li>
<li>版本：4~7个字节，表示类的版本号</li>
<li>常量池</li>
</ol>
<h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h2><h3 id="2-1-javap工具"><a href="#2-1-javap工具" class="headerlink" title="2.1 javap工具"></a>2.1 javap工具</h3><p>Java 中提供了 javap 工具来反编译 class 文件</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">javap -v HelloWorld.<span class="hljs-built_in">class</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-图解方法执行流程"><a href="#2-2-图解方法执行流程" class="headerlink" title="2.2 图解方法执行流程"></a>2.2 图解方法执行流程</h3><ol>
<li>代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_1</span> &#123;    <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br>		<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <br>		<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br>		<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;        <br>		System.out.println(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>常量池载入运行时常量池</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.3.1.png" srcset="/img/loading.gif" lazyload></p>
<ol start="3">
<li>方法字节码载入方法区</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.3.2.png" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li>main线程开始运行，分配栈帧内存</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/jvm.3.3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h3><ul>
<li>私有、构造、被 final 修饰的方法，在调用时都使用 invokespecial 指令</li>
<li>普通成员方法在调用时，使用 invokevirtual 指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用 invokestatic 指令</li>
</ul>
<h3 id="2-4-多态原理"><a href="#2-4-多态原理" class="headerlink" title="2.4 多态原理"></a>2.4 多态原理</h3><p>在执行 invokevirtual 指令时：</p>
<ol>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的 Class</li>
<li>Class 结构中有 vtable</li>
<li>查询 vtable 找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h3 id="2-5-异常处理"><a href="#2-5-异常处理" class="headerlink" title="2.5 异常处理"></a>2.5 异常处理</h3><ul>
<li>try-catch；多出来一个 Exception table 的结构，通过查表进行异常处理</li>
<li>finally:<ul>
<li>看到 ﬁnally 中的代码<strong>被复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</li>
<li>虽然从字节码指令看来，每个块中都有 finally 块，但是 finally 块中的代码<strong>只会被执行一次</strong></li>
<li>如果在 ﬁnally 中出现了 return，会吞掉异常</li>
</ul>
</li>
</ul>
<h2 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3. 编译期处理"></a>3. 编译期处理</h2><p>语法糖：其实就是指 java 编译器把 <strong>.java 源码编译为 .class 字节码</strong>的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<h3 id="3-1-自动拆装箱"><a href="#3-1-自动拆装箱" class="headerlink" title="3.1 自动拆装箱"></a>3.1 自动拆装箱</h3><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy2</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-泛型集合取值"><a href="#3-2-泛型集合取值" class="headerlink" title="3.2 泛型集合取值"></a>3.2 泛型集合取值</h3><p>java 在<strong>编译泛型代码后会执行泛型擦除</strong>的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理.</p>
<h3 id="3-3-可变参数"><a href="#3-3-可变参数" class="headerlink" title="3.3 可变参数"></a>3.3 可变参数</h3><p>可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy4</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String... args)</span> &#123;<br>      <span class="hljs-comment">// 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-4-方法重写时的桥接方法"><a href="#3-4-方法重写时的桥接方法" class="headerlink" title="3.4 方法重写时的桥接方法"></a>3.4 方法重写时的桥接方法</h3><p>方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <br>	<span class="hljs-keyword">public</span> Number <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>	&#125; <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; <br>	<span class="hljs-meta">@Override</span> <br>	<span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 	</span><br>	<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于子类，java 编译器会做如下处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; <br>	<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>	&#125;<br>	<span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br>	<span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br>		<span class="hljs-comment">// 调用 public Integer m() </span><br>		<span class="hljs-keyword">return</span> m(); <br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><ul>
<li>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法表</li>
</ul>
</li>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/jvm.3.4.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><ol>
<li><strong>验证</strong>：验证类是否符合 JVM规范，安全性检查</li>
<li><strong>准备</strong>：为 static 变量分配空间，设置默认值<ul>
<li>static变量<strong>分配空间和赋值是两个步骤</strong>，分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用</li>
</ul>
</li>
<li><strong>解析</strong>：将常量池的符号引用解析为直接引用</li>
</ol>
<h3 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h3><ul>
<li><p><code>&lt;cinit&gt;()V</code>：初始化即调用 <code>&lt;cinit&gt;()V</code> ，虚拟机会保证这个类的『构造方法』的线程安全</p>
</li>
<li><p>发生的时机(<strong>类初始化是懒惰的，用到了才会初始化</strong>)</p>
<ul>
<li>会导致类初始化的：<ul>
<li><strong>main方法所在的类</strong>，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
</li>
<li>不会导致类初始化的：<ul>
<li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h2><table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td>上级为Bootstrap，显示为null</td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<h3 id="5-1-启动类加载器"><a href="#5-1-启动类加载器" class="headerlink" title="5.1 启动类加载器"></a>5.1 启动类加载器</h3><p>用Bootstrap类加载器加载类</p>
<h3 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h3><p>如果 classpath 和 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p>
<h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，<strong>查找类</strong>的规则。</p>
<h3 id="5-4-自定义类加载器"><a href="#5-4-自定义类加载器" class="headerlink" title="5.4 自定义类加载器"></a>5.4 自定义类加载器</h3><ul>
<li><p><strong>使用场景</strong></p>
<ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
</li>
<li><p><strong>步骤</strong></p>
<ul>
<li>继承 ClassLoader 父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法</li>
<li>不是重写 loadClass 方法，否则不会走双亲委派机制</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ul>
</li>
</ul>
<h2 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6. 运行期优化"></a>6. 运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>为什么代码循环运行时，遇到相同的代码块，运行的速度会越来越快？<br>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 即时编译器编译执行（不带 profiling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>prfiling 是指在运行过程中收集一些程序执行状态的数据，例如【<strong>方法的调用次数</strong>】，【循环的回边次数】等</p>
<ul>
<li>即时编译器与解释器的区别<ul>
<li><strong>解释器</strong><ul>
<li>将字节码解释为机器码，下次即使<strong>遇到相同的字节码，仍会执行重复的解释</strong></li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li><strong>即时编译器</strong><ul>
<li>将一些字节码编译为机器码，并存入 Code Cache，<strong>下次遇到相同的代码，直接执行，无需再编译</strong></li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><ul>
<li>一开始if条件不满足，就会调用本地方法 invoke0</li>
<li>随着 numInvocation 的增大，当它大于 ReflectionFactory，inflationThreshold 的值 16 时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul>
<li>这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()</li>
</ul>
</li>
</ul>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JAVA/" class="category-chain-item">JAVA</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JAVA/" class="print-no-link">#JAVA</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
        <a href="/tags/JVM/" class="print-no-link">#JVM</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/18/JAVA/mysql/" title="MySQL原理学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySQL原理学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/12/JAVA/JUC/" title="JUC并发编程学习笔记">
                        <span class="hidden-mobile">JUC并发编程学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sj2tGuxMGSDhkN5hNuOIVta1-gzGzoHsz","appKey":"ysR5OTuTzoby2oNvNyGOtXFQ","path":"window.location.pathname","placeholder":"如有问题，欢迎指正~","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>AI</span> <i class="iconfont icon-love"></i> <span>CPP</span> <i class="iconfont icon-love"></i> <span>JAVA</span> <i class="iconfont icon-love"></i> <span>CyberSec</span> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script>
<script src="/js/bubble.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
