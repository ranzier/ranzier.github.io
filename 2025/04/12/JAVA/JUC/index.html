

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/about/dogs.jpg">
  <link rel="icon" href="/img/about/dogs.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ranzier">
  <meta name="keywords" content="">
  
    <meta name="description" content="JUC并发编程学习笔记   一. 基本概念1. 进程与线程 进程  程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发编程学习笔记">
<meta property="og:url" content="http://example.com/2025/04/12/JAVA/JUC/index.html">
<meta property="og:site_name" content="RANZIER">
<meta property="og:description" content="JUC并发编程学习笔记   一. 基本概念1. 进程与线程 进程  程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/bg/35.jpg">
<meta property="article:published_time" content="2025-04-12T03:29:24.000Z">
<meta property="article:modified_time" content="2025-10-14T07:27:19.504Z">
<meta property="article:author" content="ranzier">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JUC">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/bg/35.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JUC并发编程学习笔记 - RANZIER</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_3846514_kabxni94auf.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css">
<link rel="stylesheet" href="/css/bubble.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"🌟","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.0.0"></head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>RANZIER</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/3.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.35)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JUC并发编程学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-12 11:29" pubdate>
          2025年4月12日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          23k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          116 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          本文阅读次数：<span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JUC并发编程学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 align="center">JUC并发编程学习笔记</h1>


<h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一. 基本概念"></a>一. 基本概念</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><ul>
<li><p><strong>进程</strong></p>
<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。<strong>进程就是用来加载指令、管理内存、管理 IO 的</strong>。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li><strong>进程就可以视为程序的一个实例</strong>。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
</li>
<li><p><strong>线程</strong></p>
<ul>
<li><strong>一个进程之内可以分为一到多个线程</strong>。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行。<strong>线程负责执行指令</strong>。</li>
<li>Java 中，<strong>线程作为最小调度单位，进程作为资源分配的最小单位</strong>。 在 windows 中进程是不活动的，只是作为线程的容器</li>
</ul>
</li>
<li><p><strong>两者对比</strong></p>
<ul>
<li>进程基本上相互独立的，而<strong>线程存在于进程内，是进程的一个子集</strong> </li>
<li><strong>进程拥有共享的资源，如内存空间等，供其内部的线程共享</strong></li>
<li>进程间通信较为复杂 <ul>
<li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
</li>
</ul>
<h2 id="2-并行和并发"><a href="#2-并行和并发" class="headerlink" title="2. 并行和并发"></a>2. 并行和并发</h2><ul>
<li>并发是一个CPU在不同的时间去不同线程中执行指令。<strong>线程轮流使用CPU的做法称为并发</strong></li>
<li>并行是多个CPU同时处理不同的线程。<strong>多核CPU下，每个核调度运行线程，这个时候线程是并行的</strong></li>
<li>并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li>并行： 单位时间内，多个任务<strong>同时执行</strong>。</li>
</ul>
<h2 id="3-同步和异步"><a href="#3-同步和异步" class="headerlink" title="3. 同步和异步"></a>3. 同步和异步</h2><p>从调用方的角度，如果</p>
<ul>
<li>同步：<strong>需要等待结果返回才能继续运行</strong>的话就是同步</li>
<li>异步：<strong>不需要等待</strong>就是异步</li>
</ul>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><ol>
<li><strong>单核cpu下，多线程不能实际提高程序运行效率</strong>，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，<strong>将任务拆分，并行执行，当然可以提高程序的运行效率。<strong>但</strong>不是所有计算任务都能拆分</strong></li>
<li><strong>也不是所有任务都需要拆分</strong>，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li><strong>IO 操作不占用 cpu</strong>，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。</li>
</ol>
<h1 id="二-Java线程"><a href="#二-Java线程" class="headerlink" title="二. Java线程"></a>二. Java线程</h1><h2 id="1-创建和运行线程"><a href="#1-创建和运行线程" class="headerlink" title="1. 创建和运行线程"></a>1. 创建和运行线程</h2><h3 id="1-1-直接使用Thread"><a href="#1-1-直接使用Thread" class="headerlink" title="1.1 直接使用Thread"></a>1.1 直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 匿名内部类方式创建 Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">//run方法内实现要执行的任务</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-使用-Runnable-配合-Thread（推荐）"><a href="#1-2-使用-Runnable-配合-Thread（推荐）" class="headerlink" title="1.2 使用 Runnable 配合 Thread（推荐）"></a>1.2 使用 Runnable 配合 Thread（推荐）</h3><p>把线程和任务分开</p>
<ul>
<li>Thread 代表线程</li>
<li>Runnable 可运行的任务（线程要执行的代码）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure>
<p>lambda 精简代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> <br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure>

<ul>
<li>Thread 与 Runnable 的关系<ul>
<li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
</li>
</ul>
<h3 id="1-3-FutureTask-配合-Thread"><a href="#1-3-FutureTask-配合-Thread" class="headerlink" title="1.3 FutureTask 配合 Thread"></a>1.3 FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br>FutureTask&lt;Integer&gt; task3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;);<br> <br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<h2 id="2-查看进程线程的方法"><a href="#2-查看进程线程的方法" class="headerlink" title="2. 查看进程线程的方法"></a>2. 查看进程线程的方法</h2><ul>
<li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li>
<li>tasklist  查看进程</li>
<li>taskkill  杀死进程</li>
<li>jps  命令查看所有 Java 进程</li>
<li><code>jstack &lt;PID&gt;</code>  查看某个 Java 进程（PID）的所有线程状态 </li>
<li>jconsole  来查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<h2 id="3-线程运行的原理"><a href="#3-线程运行的原理" class="headerlink" title="3. 线程运行的原理"></a>3. 线程运行的原理</h2><h3 id="3-1-栈与栈帧"><a href="#3-1-栈与栈帧" class="headerlink" title="3.1 栈与栈帧"></a>3.1 栈与栈帧</h3><ul>
<li>JVM 中由堆、栈、方法区所组成</li>
<li>其中栈内存是给线程用的，每个<strong>线程启动后，虚拟机就会为其分配一块栈内存</strong>。<ul>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li><strong>每个线程只能有一个活动栈帧</strong>，对应着当前正在执行的那个方法</li>
</ul>
</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.2.1.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-线程上下文切换"><a href="#3-2-线程上下文切换" class="headerlink" title="3.2 线程上下文切换"></a>3.2 线程上下文切换</h3><p>从使用CPU到不使用CPU就是线程切换</p>
<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当上下文切换发生时，<strong>需要由操作系统保存当前线程的状态</strong>，并恢复另一个线程的状态，Java 中对应的概念</p>
<ul>
<li>程序计数器，它的作用是<strong>记住下一条 jvm 指令的执行地址</strong>，是线程私有的</li>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>上下文<strong>切换频繁发生会影响性能</strong></li>
</ul>
<h2 id="4-线程的常见方法"><a href="#4-线程的常见方法" class="headerlink" title="4. 线程的常见方法"></a>4. 线程的常见方法</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新线程中运行 run 方法中的代码</td>
<td>start 方法只是让线程进入就绪状态，里面代码不一定立刻运行。每个线程的 start 方法只能调用一次。</td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动会调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法。</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束,最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的 id</td>
<td>id 唯一</td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>Java 中线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率。</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断</td>
<td>不会清除 打断标记</td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除 打断标记。</td>
</tr>
<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除 打断标记</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h3 id="4-1-start-与-run"><a href="#4-1-start-与-run" class="headerlink" title="4.1  start 与 run"></a>4.1  start 与 run</h3><ul>
<li>必须<strong>要先调用start开启线程，再调用run运行</strong></li>
<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li>
<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>
</ul>
<h3 id="4-2-sleep-与-yield"><a href="#4-2-sleep-与-yield" class="headerlink" title="4.2 sleep 与 yield"></a>4.2 sleep 与 yield</h3><h4 id="4-2-1-sleep-睡眠"><a href="#4-2-1-sleep-睡眠" class="headerlink" title="4.2.1 sleep (睡眠)"></a>4.2.1 sleep (睡眠)</h4><ol>
<li>调用 sleep 会让<strong>当前线程从 Running 运行状态 进入 Timed Waiting 睡眠状态</strong>（阻塞）</li>
<li>其它线程可以使用  <strong>interrupt 方法打断正在睡眠的线程</strong>，这时 sleep 方法会抛出  InterruptedException  </li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
</ol>
<h4 id="4-2-2-yield-让出"><a href="#4-2-2-yield-让出" class="headerlink" title="4.2.2 yield (让出)"></a>4.2.2 yield (让出)</h4><ul>
<li>调用 yield 会<strong>让当前线程从 Running(运行状态) 进入 Runnable (就绪状态)</strong>，然后调度执行其它线程</li>
</ul>
<h4 id="4-2-3-线程优先级"><a href="#4-2-3-线程优先级" class="headerlink" title="4.2.3 线程优先级"></a>4.2.3 线程优先级</h4><ul>
<li>线程优先级会提示（hint）调度器<strong>优先调度该线程</strong>，但它仅仅是一个提示，调度器可以忽略它</li>
<li>如果 cpu 比较忙，那么<strong>优先级高的线程会获得更多的时间片</strong>，但 cpu 闲时，优先级几乎没作用</li>
</ul>
<h4 id="4-2-4-防止CPU占用100"><a href="#4-2-4-防止CPU占用100" class="headerlink" title="4.2.4 防止CPU占用100%"></a>4.2.4 防止CPU占用100%</h4><p>在没有利用cpu来计算时,不要让while(true)空转浪费cpu,这时可以使用yield或sleep来让出cpu的使用权给其他程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-join"><a href="#4-3-join" class="headerlink" title="4.3 join"></a>4.3 join</h3><p><strong>等待某个线程运行结束</strong><br>在<strong>同步应用</strong>要使用join</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.2.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="4-4-interrupt"><a href="#4-4-interrupt" class="headerlink" title="4.4 interrupt"></a>4.4 interrupt</h3><p>调用interrupt方法可以打断当前运行的线程，并将打断状态置为true。</p>
<h4 id="4-4-1-打断-sleep，wait，join-的线程"><a href="#4-4-1-打断-sleep，wait，join-的线程" class="headerlink" title="4.4.1 打断 sleep，wait，join 的线程"></a>4.4.1 打断 sleep，wait，join 的线程</h4><p>这几个方法都会让线程进入阻塞状态</p>
<ul>
<li>打断 sleep 的线程, <strong>会清空打断状态</strong></li>
</ul>
<h4 id="4-4-2-打断正常运行的线程"><a href="#4-4-2-打断正常运行的线程" class="headerlink" title="4.4.2 打断正常运行的线程"></a>4.4.2 打断正常运行的线程</h4><p>打断正常运行的线程, 不会清空打断状态</p>
<h4 id="4-4-3-两阶段终止模式"><a href="#4-4-3-两阶段终止模式" class="headerlink" title="4.4.3 两阶段终止模式"></a>4.4.3 两阶段终止模式</h4><p><img src="/img/blogs/java/jvm-juc/juc.2.3.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="4-4-4-打断-park-线程"><a href="#4-4-4-打断-park-线程" class="headerlink" title="4.4.4 打断 park 线程"></a>4.4.4 打断 park 线程</h4><p>park也是让当前线程停下来<br>打断 park 线程, 不会清空打断状态</p>
<h3 id="4-5-不推荐的方法"><a href="#4-5-不推荐的方法" class="headerlink" title="4.5 不推荐的方法"></a>4.5 不推荐的方法</h3><p>这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop()</td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend()</td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume()</td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
<h2 id="5-主线程和守护线程"><a href="#5-主线程和守护线程" class="headerlink" title="5. 主线程和守护线程"></a>5. 主线程和守护线程</h2><ul>
<li>默认情况下，<strong>Java 进程需要等待所有线程都运行结束，才会结束</strong>。</li>
<li>有一种特殊的线程叫做守护线程，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong></li>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
<h2 id="6-线程的五种状态-操作系统层面"><a href="#6-线程的五种状态-操作系统层面" class="headerlink" title="6. 线程的五种状态(操作系统层面)"></a>6. 线程的五种状态(操作系统层面)</h2><p><img src="/img/blogs/java/jvm-juc/juc.2.4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>【<strong>初始状态</strong>】仅是在语言层面<strong>创建了线程对象</strong>，还未与操作系统线程关联</li>
<li>【<strong>可运行状态</strong>】（就绪状态）指该线程<strong>已经被创建</strong>（与操作系统线程关联），<strong>可以由 CPU 调度执行，但还没有被分配时间片</strong></li>
<li>【<strong>运行状态</strong>】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【<strong>阻塞状态</strong>】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会<strong>导致线程上下文切换</strong>，进入【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说<strong>只要它们一直不唤醒，调度器就一直不会考虑调度它们</strong></li>
</ul>
</li>
<li>【<strong>终止状态</strong>】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h2 id="7-线程的六种状态-JAVA-API层面"><a href="#7-线程的六种状态-JAVA-API层面" class="headerlink" title="7. 线程的六种状态(JAVA API层面)"></a>7. 线程的六种状态(JAVA API层面)</h2><p>根据 Thread.State 枚举，分为六种状态</p>
<p><img src="/img/blogs/java/jvm-juc/juc.2.5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>NEW</strong>:  线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong>:  当调用了start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态涵盖了操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong>:  都是 Java API 层面对【阻塞状态】的细分</li>
<li><strong>TERMINATED</strong>:  当线程代码运行结束</li>
</ul>
<h1 id="三-共享模型之管程"><a href="#三-共享模型之管程" class="headerlink" title="三. 共享模型之管程"></a>三. 共享模型之管程</h1><h2 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1. 共享带来的问题"></a>1. 共享带来的问题</h2><p>多线程下，对共享资源访问带来的问题</p>
<h3 id="1-1-临界区-Critical-Section"><a href="#1-1-临界区-Critical-Section" class="headerlink" title="1.1 临界区 Critical Section"></a>1.1 临界区 Critical Section</h3><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在<strong>多个线程访问共享资源</strong><ul>
<li>多个线程<strong>读共享资源</strong>其实也没有问题</li>
<li>在多个线程<strong>对共享资源读写操作时发生指令交错</strong>，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果<strong>存在对共享资源的多线程读写</strong>操作，称<strong>这段代码块为临界区</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <br><span class="hljs-comment">// 临界区</span><br>&#123;    <br>    counter++; <span class="hljs-comment">//counter就是共享资源</span><br>&#125;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <br><span class="hljs-comment">// 临界区</span><br>&#123;    <br>    counter--; <span class="hljs-comment">//counter就是共享资源</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-竞态条件-Race-Condition"><a href="#1-2-竞态条件-Race-Condition" class="headerlink" title="1.2 竞态条件 Race Condition"></a>1.2 竞态条件 Race Condition</h3><p>多个线程在临界区内执行，由于<strong>代码的执行序列不同而导致结果无法预测</strong>，称之为发生了<strong>竞态条件</strong></p>
<h2 id="2-synchronized-解决方案"><a href="#2-synchronized-解决方案" class="headerlink" title="2. synchronized 解决方案"></a>2. synchronized 解决方案</h2><ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>synchronized，俗称【对象锁】，它采用<strong>互斥</strong>的方式让<strong>同一时刻至多只有一个线程</strong>能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<h3 id="2-1-synchronized语法"><a href="#2-1-synchronized语法" class="headerlink" title="2.1 synchronized语法"></a>2.1 synchronized语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>    临界区<br>&#125;<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<span class="hljs-comment">//加锁</span><br>                counter++;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<span class="hljs-comment">//加锁</span><br>                counter--;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-synchronized的原子性"><a href="#2-2-synchronized的原子性" class="headerlink" title="2.2 synchronized的原子性"></a>2.2 synchronized的原子性</h3><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是<strong>不可分割的</strong>，不会被线程切换所打断。</p>
<h3 id="2-3-面向对象的改进"><a href="#2-3-面向对象的改进" class="headerlink" title="2.3 面向对象的改进"></a>2.3 面向对象的改进</h3><p>把需要保护的共享变量放入一个类，封装成一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              value++;<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              value--;<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              <span class="hljs-keyword">return</span> value;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.increment();<br>                &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br> <br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span> , room.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-方法上的-synchronized"><a href="#3-方法上的-synchronized" class="headerlink" title="3. 方法上的 synchronized"></a>3. 方法上的 synchronized</h2><ul>
<li>加在方法上的锁，不代表锁的是方法，而是锁的<strong>方法中的this对象</strong></li>
<li>加在静态方法(static)上的锁，不代表锁的是方法，而是锁的<strong>静态方法的类对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <br>    &#125;<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>        <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br> <br>    &#125;<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Test.class) &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-变量的线程安全分析"><a href="#4-变量的线程安全分析" class="headerlink" title="4. 变量的线程安全分析"></a>4. 变量的线程安全分析</h2><h3 id="4-1-成员变量和静态变量是否线程安全？"><a href="#4-1-成员变量和静态变量是否线程安全？" class="headerlink" title="4.1 成员变量和静态变量是否线程安全？"></a>4.1 成员变量和静态变量是否线程安全？</h3><ul>
<li>如果它们<strong>没有共享，则线程安全</strong></li>
<li>如果它们被<strong>共享了</strong>，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果<strong>只有读操作</strong>，则线程安全</li>
<li>如果<strong>有读写操作</strong>，则这段代码是<strong>临界区</strong>，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="4-2-局部变量是否线程安全？"><a href="#4-2-局部变量是否线程安全？" class="headerlink" title="4.2 局部变量是否线程安全？"></a>4.2 局部变量是否线程安全？</h3><ul>
<li>局部变量是线程安全的</li>
<li>但局部变量<strong>引用的对象</strong>则未必<ul>
<li>如果该对象<strong>没有逃离方法的作用访问</strong>，它是线程安全的</li>
<li>如果该对象<strong>逃离方法的作用范围，需要考虑线程安全</strong></li>
</ul>
</li>
<li>局部变量是线程安全的: 因为每个线程都会分配一块栈帧空间用来存放局部变量，<strong>是独立的，不会被其他线程所共享</strong></li>
</ul>
<h3 id="4-3-常见线程安全类"><a href="#4-3-常见线程安全类" class="headerlink" title="4.3 常见线程安全类"></a>4.3 常见线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法</strong>时，<strong>是线程安全</strong>的，它们的<strong>每个方法是原子的</strong><br>但注意它们<strong>多个方法的组合不是原子的</strong>，线程安全类方法的组合不一定是线程安全的</p>
<ul>
<li><strong>不可变类</strong>线程安全性 (<strong>只能读，不能改，所以线程安全</strong>)<ul>
<li>String、Integer 等都是不可变类，因为<strong>其内部的状态不可以改变</strong>，因此它们的方法都是线程安全的</li>
</ul>
</li>
</ul>
<h2 id="5-Monitor-锁"><a href="#5-Monitor-锁" class="headerlink" title="5. Monitor(锁)"></a>5. Monitor(锁)</h2><h3 id="5-1-Java-对象头"><a href="#5-1-Java-对象头" class="headerlink" title="5.1 Java 对象头"></a>5.1 Java 对象头</h3><p>普通对象的对象头：</p>
<p><img src="/img/blogs/java/jvm-juc/juc.3.1.png" srcset="/img/loading.gif" lazyload></p>
<p>其中的Mark Word结构：</p>
<p><img src="/img/blogs/java/jvm-juc/juc.3.2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-2-Monitor-原理"><a href="#5-2-Monitor-原理" class="headerlink" title="5.2 Monitor 原理"></a>5.2 Monitor 原理</h3><ul>
<li>Monitor 被翻译为监视器或者说<strong>管程</strong></li>
<li><strong>每个 java 对象都可以关联一个 Monitor</strong> ，如果使用 synchronized 给对象上锁（重量级），该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.3.3.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>刚开始时 Monitor 中的 Owner 为 null</li>
<li>当 Thread-2 执行 synchronized(obj){} 代码时就会将 Monitor 的所有者Owner 设置为 Thread-2，上锁成功，Monitor 中同一时刻只能有一个 Owner</li>
<li>当 Thread-2 占据锁时，如果线程 Thread-3 ，Thread-4 也来执行synchronized(obj){} 代码，就会进入 EntryList（阻塞队列） 中变成BLOCKED（阻塞） 状态</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li>
</ol>
<h2 id="6-synchronized-原理进阶"><a href="#6-synchronized-原理进阶" class="headerlink" title="6. synchronized 原理进阶"></a>6. synchronized 原理进阶</h2><h3 id="6-1-轻量级锁"><a href="#6-1-轻量级锁" class="headerlink" title="6.1 轻量级锁"></a>6.1 轻量级锁</h3><p>轻量级锁的使用场景</p>
<ul>
<li>如果一个对象虽然有多个线程要对它进行加锁，但是<strong>加锁的时间是错开的</strong>（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。</li>
<li>轻量级锁对使用者是透明的，即语法仍然是 synchronized</li>
</ul>
<ol>
<li>每次指向到 synchronized 代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的 Mark Word 和对象引用 reference</li>
<li>让锁记录中的 Object reference 指向对象，并且尝试用 cas(compare and sweep) 替换 Object 对象的 Mark Word ，将 Mark Word 的值存入锁记录中。</li>
<li>如果 cas 替换成功，那么对象的对象头储存的就是锁记录的地址和状态 00 表示轻量级锁</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.3.4.png" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li>如果cas失败，有两种情况<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，那么表示有竞争，首先会进行自旋锁，自旋一定次数后，如果还是失败就进入锁膨胀阶段。</li>
<li>如果是自己的线程已经执行了 synchronized 进行加锁，那么再添加一条 Lock Record 作为重入的计数。</li>
</ul>
</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.3.5.png" srcset="/img/loading.gif" lazyload></p>
<ol start="5">
<li>当线程退出 synchronized 代码块的时候，如果获取的是取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>
<li>当线程退出 synchronized 代码块的时候，如果获取的锁记录取值不为 null，那么使用 cas 将 Mark Word 的值恢复给对象<ul>
<li>成功则解锁成功</li>
<li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ol>
<h3 id="6-2-锁膨胀"><a href="#6-2-锁膨胀" class="headerlink" title="6.2 锁膨胀"></a>6.2 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，cas 操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要<strong>进行锁膨胀，将轻量级锁变成重量级锁</strong></p>
<p><img src="/img/blogs/java/jvm-juc/juc.3.6.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程，</li>
</ol>
<ul>
<li>即为对象申请Monitor锁，让Object指向重量级锁地址</li>
<li>然后自己进入Monitor 的EntryList 变成BLOCKED状态</li>
</ul>
<ol start="3">
<li>当 Thread-0 退出 synchronized 同步块时，使用 cas 将 Mark Word 的值恢复给对象头，对象的对象头指向 Monitor，那么会进入重量级锁的解锁过程，即按照 Monitor 的地址找到 Monitor 对象，将 Owner 设置为 null ，唤醒 EntryList 中的 Thread-1 线程</li>
</ol>
<h3 id="6-3-自旋优化"><a href="#6-3-自旋优化" class="headerlink" title="6.3 自旋优化"></a>6.3 自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋（循环）来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁</p>
<h3 id="6-4-偏向锁"><a href="#6-4-偏向锁" class="headerlink" title="6.4 偏向锁"></a>6.4 偏向锁</h3><p>在轻量级的锁中，如果同一个线程对同一个对象进行<strong>重入</strong>锁时，也需要执行 CAS 操作</p>
<ul>
<li>偏向锁：只有第一次使用 CAS 时将对象的 Mark Word 头设置为偏向线程 ID，之后这个入锁线程再进行重入锁时，发现线程 ID 是自己的，那么就不用再进行CAS了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">synchronized</span>(obj) &#123;<br>		<span class="hljs-comment">// 同步块 A</span><br>		m2();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">synchronized</span>(obj) &#123;<br>		<span class="hljs-comment">// 同步块 B</span><br>		m3();<br>	&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">synchronized</span>(obj) &#123;<br>		<span class="hljs-comment">// 同步块 C</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/blogs/java/jvm-juc/juc.3.7.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-4-1-偏向状态"><a href="#6-4-1-偏向状态" class="headerlink" title="6.4.1 偏向状态"></a>6.4.1 偏向状态</h4><p>一个对象的创建过程</p>
<ul>
<li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，<strong>Mark Word 最后三位的值101</strong>，并且这是它的 Thread，epoch，age 都是 0 ，在加锁的时候进行设置这些的值.</li>
<li><strong>偏向锁默认是延迟的</strong>，不会在程序启动的时候立刻生效</li>
</ul>
<h4 id="6-4-2-撤销偏向"><a href="#6-4-2-撤销偏向" class="headerlink" title="6.4.2 撤销偏向"></a>6.4.2 撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p>
<ul>
<li>调用对象的 hashCode 方法</li>
<li>多个线程使用该对象</li>
<li>调用了 wait&#x2F;notify 方法（调用wait方法会导致锁膨胀而使用重量级锁）</li>
</ul>
<h4 id="6-4-3-批量重偏向"><a href="#6-4-3-批量重偏向" class="headerlink" title="6.4.3 批量重偏向"></a>6.4.3 批量重偏向</h4><p>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时<strong>偏向 t1 的对象仍有机会重新偏向 t2</strong></p>
<ul>
<li>重偏向会重置Thread ID<br>当撤销超过20次后（<strong>超过阈值</strong>），JVM 会觉得是不是偏向错了，这时会在给对象加锁时，<strong>重新偏向至加锁线程</strong>。</li>
</ul>
<h4 id="6-4-4-批量撤销"><a href="#6-4-4-批量撤销" class="headerlink" title="6.4.4 批量撤销"></a>6.4.4 批量撤销</h4><p>当撤销偏向锁的<strong>阈值超过 40 以后</strong>，就会将<strong>整个类</strong>的对象<strong>都改为不可偏向的</strong></p>
<h2 id="7-wait-notify"><a href="#7-wait-notify" class="headerlink" title="7. wait notify"></a>7. wait notify</h2><h3 id="7-1-wait-notify-API介绍"><a href="#7-1-wait-notify-API介绍" class="headerlink" title="7.1 wait notify API介绍"></a>7.1 wait notify API介绍</h3><ul>
<li>obj.wait()  让进入 object 监视器的线程到 waitSet 等待</li>
<li>obj.notify()  在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li>
<li>obj.notifyAll()  让 object 上正在 waitSet 等待的线程全部唤醒</li>
</ul>
<p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。<strong>必须获得此对象的锁，才能调用这几个方法</strong></p>
<ul>
<li>wait()  方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</li>
<li>wait(long n)  有时限的等待, 到 n 毫秒后结束等待，或是被 notify</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;).start();<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;).start();<br> <br>    <span class="hljs-comment">// 主线程两秒后执行</span><br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        obj.notify(); <span class="hljs-comment">// 唤醒obj上一个线程</span><br>        <span class="hljs-comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-2-sleep-long-n-和-wait-long-n-的区别"><a href="#7-2-sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="7.2 sleep(long n)  和  wait(long n)  的区别"></a>7.2 sleep(long n)  和  wait(long n)  的区别</h3><ol>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</li>
<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>
<li>它们的状态都是 TIMED_WAITING</li>
</ol>
<h3 id="7-3-wait-notify-原理"><a href="#7-3-wait-notify-原理" class="headerlink" title="7.3 wait notify 原理"></a>7.3 wait notify 原理</h3><p><img src="/img/blogs/java/jvm-juc/juc.3.8.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li>
</ol>
<h2 id="8-同步模式之保护性暂停"><a href="#8-同步模式之保护性暂停" class="headerlink" title="8. 同步模式之保护性暂停"></a>8. 同步模式之保护性暂停</h2><h3 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1 定义"></a>8.1 定义</h3><p>Guarded Suspension，用在<strong>一个线程等待另一个线程的执行结果</strong></p>
<ul>
<li>有一个<strong>结果需要从一个线程传递到另一个线程</strong>，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为<strong>要等待另一方的结果</strong>，因此归类到同步模式</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.3.9.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="8-2-join原理"><a href="#8-2-join原理" class="headerlink" title="8.2 join原理"></a>8.2 join原理</h3><p>join <strong>体现的是【保护性暂停】模式</strong><br>调用者<strong>轮询检查线程 alive 状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">t1.join();<br><span class="hljs-comment">//等价于下面的代码：</span><br><span class="hljs-keyword">synchronized</span> (t1) &#123;<br>    <span class="hljs-comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span><br>    <span class="hljs-keyword">while</span> (t1.isAlive()) &#123;<br>        t1.wait(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-3-多任务版-GuardedObject"><a href="#8-3-多任务版-GuardedObject" class="headerlink" title="8.3 多任务版 GuardedObject"></a>8.3 多任务版 GuardedObject</h3><p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理</p>
<p><img src="/img/blogs/java/jvm-juc/juc.3.10.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="9-异步模式之生产者-消费者"><a href="#9-异步模式之生产者-消费者" class="headerlink" title="9. 异步模式之生产者&#x2F;消费者"></a>9. 异步模式之生产者&#x2F;消费者</h2><ul>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li><strong>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</strong></li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.3.11.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="10-Park-Unpark"><a href="#10-Park-Unpark" class="headerlink" title="10. Park &amp; Unpark"></a>10. Park &amp; Unpark</h2><p>是LockSupport 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暂停当前线程</span><br>LockSupport.park(); <br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark(暂停线程对象)<br></code></pre></td></tr></table></figure>

<p><strong>与 Object 的 wait &amp; notify 相比</strong></p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
<li><strong>可以先Park再unpark;也可以先unpark再park</strong></li>
</ul>
<h2 id="11-重新理解线程状态转换"><a href="#11-重新理解线程状态转换" class="headerlink" title="11. 重新理解线程状态转换"></a>11. 重新理解线程状态转换</h2><p>假设有线程  Thread t</p>
<p><img src="/img/blogs/java/jvm-juc/juc.3.12.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><strong>NEW –&gt; RUNNABLE</strong></li>
</ol>
<ul>
<li>当调用  <strong>t.start()</strong>  方法时，由  NEW –&gt; RUNNABLE</li>
</ul>
<ol start="2">
<li><strong>RUNNABLE &lt;–&gt; WAITING</strong><br>t 线程用  synchronized(obj)  获取了对象锁后<ul>
<li>调用  <strong>obj.wait()</strong>  方法时，t 线程从  RUNNABLE –&gt; WAITING</li>
<li>调用  <strong>obj.notify() ， obj.notifyAll() ， t.interrupt()</strong>  时<ul>
<li>竞争锁成功，t 线程从   WAITING –&gt; RUNNABLE  </li>
<li>竞争锁失败，t 线程从   WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; WAITING</strong>  <ul>
<li>当前线程调用  <strong>t.join()</strong>  方法时，当前线程从  RUNNABLE –&gt; WAITING</li>
<li>t 线程运行结束，或调用了当前线程的  <strong>interrupt()</strong>  时，当前线程从  WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; WAITING</strong>  <ul>
<li>当前线程调用  <strong>LockSupport.park()</strong>  方法会让当前线程从  RUNNABLE –&gt; WAITING</li>
<li>调用  <strong>LockSupport.unpark(目标线程)</strong>  或调用了线程的 <strong>interrupt()</strong>，会让目标线程从  WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><br>t 线程用  synchronized(obj)  获取了对象锁后<ul>
<li>调用  <strong>obj.wait(long n)</strong>  方法时，t 线程从  RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用  obj.notify() ， obj.notifyAll() ， t.interrupt()  时<ul>
<li>竞争锁成功，t 线程从   TIMED_WAITING –&gt; RUNNABLE  </li>
<li>竞争锁失败，t 线程从   TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong>  <ul>
<li>当前线程调用  <strong>t.join(long n)</strong>  方法时，当前线程从  RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的  <strong>interrupt()</strong>  时，当前线程从TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong>  <ul>
<li>当前线程调用  <strong>Thread.sleep(long n)</strong> ，当前线程从  RUNNABLE –&gt; TIMED_WAITING  </li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong>  <ul>
<li>当前线程调用  <strong>LockSupport.parkNanos(long nanos)  或  LockSupport.parkUntil(long millis)</strong>  时，当前线程从  RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用  <strong>LockSupport.unpark(目标线程) 或调用了线程的interrupt()</strong> ，或是等待超时，会让目标线程从TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; BLOCKED</strong>  <ul>
<li>t 线程用   <strong>synchronized(obj)</strong>  获取了对象锁时<strong>如果竞争失败</strong>，从   RUNNABLE –&gt; BLOCKED  </li>
<li>持 obj 锁线程的同步代码块执行完毕，会<strong>唤醒该对象上所有  BLOCKED   的线程重新竞争</strong>，如果其中 t 线程竞争<strong>成功</strong>，从  BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然   BLOCKED</li>
</ul>
</li>
<li><strong>RUNNABLE &lt;–&gt; TERMINATED</strong>  <ul>
<li>当前线程所有代码<strong>运行完毕</strong>，进入 TERMINATED</li>
</ul>
</li>
</ol>
<h2 id="12-多把锁"><a href="#12-多把锁" class="headerlink" title="12. 多把锁"></a>12. 多把锁</h2><p>如果一把锁锁在一个很大的共享单元(粗粒度)的时候，那么并发度就会很低</p>
<ul>
<li>解决方法是准备多个房间（<strong>多个对象锁</strong>）</li>
</ul>
<p>将锁的粒度细分</p>
<ul>
<li>好处，是可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<h2 id="13-活跃性"><a href="#13-活跃性" class="headerlink" title="13. 活跃性"></a>13. 活跃性</h2><h3 id="13-1-死锁"><a href="#13-1-死锁" class="headerlink" title="13.1 死锁"></a>13.1 死锁</h3><p>一个线程需要同时获取多把锁，这时就容易发生<strong>死锁</strong></p>
<ul>
<li>t1 线程获得A对象锁，接下来想获取B对象的锁  </li>
<li>t2 线程获得B对象锁，接下来想获取A对象的锁</li>
</ul>
<p><strong>避免死锁的方法</strong>:</p>
<ul>
<li>在线程使用锁对象时，<strong>顺序加锁</strong>即可避免死锁</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.3.13.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="13-2-定位死锁"><a href="#13-2-定位死锁" class="headerlink" title="13.2 定位死锁"></a>13.2 定位死锁</h3><p>检测死锁可以使用 <strong>jconsole工具</strong>，或者使用 jps 定位进程 id，再用 <strong>jstack</strong> 定位死锁</p>
<h3 id="13-3-哲学家就餐问题"><a href="#13-3-哲学家就餐问题" class="headerlink" title="13.3 哲学家就餐问题"></a>13.3 哲学家就餐问题</h3><p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 。<br>当每个哲学家即线程<strong>持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁</strong>。</p>
<h3 id="13-4-活锁"><a href="#13-4-活锁" class="headerlink" title="13.4 活锁"></a>13.4 活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件，最后谁也无法结束</strong></p>
<ul>
<li><strong>避免活锁的方法</strong>： 在线程执行时，中途给予不同的<strong>间隔时间</strong>即可。</li>
</ul>
<p><strong>死锁与活锁的区别</strong></p>
<ul>
<li>死锁是因为线程互相持有对象想要的锁，并且<strong>都不释放</strong>，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li>
<li>活锁是因为线程间修改了对方的结束条件，而导致<strong>代码一直在运行，却一直运行不完</strong>的现象。</li>
</ul>
<h3 id="13-5-饥饿"><a href="#13-5-饥饿" class="headerlink" title="13.5 饥饿"></a>13.5 饥饿</h3><ul>
<li>一个线程由于<strong>优先级太低，始终得不到 CPU 调度执行</strong>，也不能够结束</li>
<li>某些线程因为优先级太低，导致一直无法获得资源的现象。</li>
<li>在使用<strong>顺序加锁</strong>时，可能会出现饥饿现象</li>
</ul>
<h2 id="14-ReentrantLock"><a href="#14-ReentrantLock" class="headerlink" title="14. ReentrantLock"></a>14. ReentrantLock</h2><p>相对于 synchronized 它具备如下特点:</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁(防止饥饿)</li>
<li>支持多个条件变量</li>
<li>与 synchronized 一样，都支持可重入</li>
</ul>
<h3 id="14-1-基本语法"><a href="#14-1-基本语法" class="headerlink" title="14.1 基本语法"></a>14.1 基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-2-可重入"><a href="#14-2-可重入" class="headerlink" title="14.2 可重入"></a>14.2 可重入</h3><ul>
<li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method1();<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>        method2();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>        method3();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>method1、method2、method3都得到执行，说明是可重入的</p>
<h3 id="14-3-可打断"><a href="#14-3-可打断" class="headerlink" title="14.3 可打断"></a>14.3 可打断</h3><p>可打断需要使用**lockInterruptibly()**方法<br>处于阻塞状态的线程，被打断了就不用阻塞了，<strong>直接停止运行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-comment">// 加锁，可打断锁</span><br>				lock.lockInterruptibly();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>                <span class="hljs-comment">// 被打断，返回，不再向下执行</span><br>				<span class="hljs-keyword">return</span>;<br>			&#125;<span class="hljs-keyword">finally</span> &#123;<br>				<span class="hljs-comment">// 释放锁</span><br>				lock.unlock();<br>			&#125;<br><br>		&#125;);<br><br>		lock.lock();<br>		<span class="hljs-keyword">try</span> &#123;<br>			t1.start();<br>			Thread.sleep(<span class="hljs-number">1000</span>);<br>			<span class="hljs-comment">// 打断</span><br>			t1.interrupt();<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			lock.unlock();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-4-锁超时"><a href="#14-4-锁超时" class="headerlink" title="14.4 锁超时"></a>14.4 锁超时</h3><p>使用**tryLock()**方法，可返回超时失败<br>设置超时时间，如果超时了，就返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>		<span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-comment">// 判断获取锁是否成功，最多等待1秒</span><br>				<span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>					System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br>					<span class="hljs-comment">// 获取失败，不再向下执行，直接返回</span><br>					<span class="hljs-keyword">return</span>;<br>				&#125;<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>				<span class="hljs-comment">// 被打断，不再向下执行，直接返回</span><br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br>			<span class="hljs-comment">// 释放锁</span><br>			lock.unlock();<br>		&#125;);<br><br><br>		lock.lock();<br>		<span class="hljs-keyword">try</span>&#123;<br>			t1.start();<br>			<span class="hljs-comment">// 打断等待</span><br>			t1.interrupt();<br>			Thread.sleep(<span class="hljs-number">3000</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			lock.unlock();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用 tryLock 可以解决哲学家就餐问题</li>
</ul>
<h3 id="14-5-公平锁"><a href="#14-5-公平锁" class="headerlink" title="14.5 公平锁"></a>14.5 公平锁</h3><ul>
<li>线程先入先得，防止饥饿</li>
<li>在线程获取锁失败，进入阻塞队列时，<strong>先进入的会在锁被释放后先获得锁</strong>。这样的获取方式就是公平的。</li>
<li>ReentrantLock 默认是不公平的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认是不公平锁，需要在创建时指定为公平锁</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<h3 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h3><ul>
<li>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet等待。</li>
<li>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是<strong>支持多个条件变量</strong>的，这就好比<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
</li>
</ul>
<ol>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ol>
<h2 id="15-同步模式之顺序控制"><a href="#15-同步模式之顺序控制" class="headerlink" title="15. 同步模式之顺序控制"></a>15. 同步模式之顺序控制</h2><h3 id="15-1-固定运行顺序"><a href="#15-1-固定运行顺序" class="headerlink" title="15.1 固定运行顺序"></a>15.1 固定运行顺序</h3><p>比如，必须先 2 后 1 打印</p>
<p><strong>wait notify 版</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来同步的对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// t2 运行标记， 代表 t2 是否执行过</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2runed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 如果 t2 没有执行过</span><br>            <span class="hljs-keyword">while</span> (!t2runed) &#123; <br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// t1 先等一会</span><br>                    obj.wait(); <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125;);<br> <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 修改运行标记</span><br>            t2runed = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll）</span><br>            obj.notifyAll();<br>        &#125;<br>    &#125;);<br> <br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>也可以使用<strong>park 和 unpark 方法</strong></li>
</ul>
<h3 id="15-2-交替输出"><a href="#15-2-交替输出" class="headerlink" title="15.2 交替输出"></a>15.2 交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p>
<p><strong>Wait&#x2F;Notify</strong> 实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_32_Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitAndNotify</span> <span class="hljs-variable">waitAndNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitAndNotify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitAndNotify.run(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitAndNotify.run(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitAndNotify.run(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitAndNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> nextFlag)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (flag != <span class="hljs-built_in">this</span>.flag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-comment">// 设置下一个运行的线程标记</span><br>                <span class="hljs-built_in">this</span>.flag = nextFlag;<br>                <span class="hljs-comment">// 唤醒所有线程</span><br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitAndNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>park&#x2F;unpary</strong> 实现</li>
<li><strong>await&#x2F;signal</strong> 实现</li>
</ul>
<h2 id="16-本章总结"><a href="#16-本章总结" class="headerlink" title="16. 本章总结"></a>16. 本章总结</h2><p>本章我们需要重点掌握的是</p>
<ul>
<li>分析多线程访问共享资源时，哪些代码片段属于临界区</li>
<li>使用 synchronized 互斥解决临界区的线程安全问题<ul>
<li>掌握 synchronized 锁对象语法</li>
<li>掌握 synchronzied 加载成员方法和静态方法语法</li>
<li>掌握 wait&#x2F;notify 同步方法</li>
</ul>
</li>
<li>使用 lock 互斥解决临界区的线程安全问题 <ul>
<li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li>
</ul>
</li>
<li>了解线程活跃性问题：死锁、活锁、饥饿</li>
<li><strong>应用方面</strong><ul>
<li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果，实现原子性效果，保证线程安全。</li>
<li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果。</li>
</ul>
</li>
<li><strong>原理方面</strong><ul>
<li>monitor、synchronized 、wait&#x2F;notify 原理</li>
<li>synchronized 进阶原理</li>
<li>park &amp; unpark 原理</li>
</ul>
</li>
<li><strong>模式方面</strong><ul>
<li>同步模式之保护性暂停</li>
<li>异步模式之生产者消费者</li>
<li>同步模式之顺序控制</li>
</ul>
</li>
</ul>
<h1 id="四-共享模型之内存-JMM"><a href="#四-共享模型之内存-JMM" class="headerlink" title="四. 共享模型之内存(JMM)"></a>四. 共享模型之内存(JMM)</h1><h2 id="1-Java-内存模型（JMM）"><a href="#1-Java-内存模型（JMM）" class="headerlink" title="1. Java 内存模型（JMM）"></a>1. Java 内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。<br>JMM 体现在以下几个方面:</p>
<ul>
<li><strong>原子性</strong> - 保证指令不会受到线程上下文切换的影响</li>
<li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响</li>
<li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(run) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;t1 Stop&quot;</span>);<br>        run = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>原因分析</strong>：</p>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.4.1.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至<strong>自己工作内存中的高速缓存</strong>中，减少对主存中 run 的访问，提高效率</li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.4.2.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>使用 <strong>volatile</strong> （易变关键字）</li>
<li>它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他<strong>可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值</strong>，线程操作 volatile 变量都是<strong>直接操作主存</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 保证内存的可见性</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-可见性和原子性"><a href="#2-2-可见性和原子性" class="headerlink" title="2.2 可见性和原子性"></a>2.2 可见性和原子性</h3><ul>
<li>可见性保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见，<strong>不能保证原子性</strong></li>
<li><strong>volatile</strong>： 仅用在<strong>一个写线程，多个读线程</strong>的情况。</li>
<li><strong>synchronized</strong>语句块：<strong>既可以保证代码块的原子性</strong>，<strong>也同时保证代码块内变量的可见性</strong>。但缺点是synchronized 是属于重量级操作，<strong>性能相对更低</strong></li>
</ul>
<h2 id="3-模式之两阶段终止"><a href="#3-模式之两阶段终止" class="headerlink" title="3. 模式之两阶段终止"></a>3. 模式之两阶段终止</h2><p>使用 <strong>volatile</strong> 关键字来实现两阶段终止模式</p>
<ul>
<li>停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</li>
<li>我们的例子中，即主线程把它修改为 true 对 t1 线程可见</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;<br>	Thread monitor;<br>	<span class="hljs-comment">// 设置标记，用于判断是否被终止了</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 启动监控器线程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// 设置线控器线程，用于监控线程状态</span><br>		monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>				<span class="hljs-comment">// 开始不停的监控</span><br>				<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>					<span class="hljs-keyword">if</span>(stop) &#123;<br>						System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>						<span class="hljs-keyword">break</span>;<br>					&#125;<br>					System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">// 线程休眠</span><br>						Thread.sleep(<span class="hljs-number">1000</span>);<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;;<br>		monitor.start();<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 	用于停止监控器线程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// 修改标记</span><br>		stop = <span class="hljs-literal">true</span>;<br>		<span class="hljs-comment">// 打断线程</span><br>		monitor.interrupt();        <br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-同步模式之-Balking"><a href="#4-同步模式之-Balking" class="headerlink" title="4. 同步模式之 Balking"></a>4. 同步模式之 Balking</h2><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p>
<ul>
<li>用一个标记来判断该任务是否已经被执行过了</li>
<li>需要避免线程安全问题</li>
<li>加锁的代码块要尽量的小，以保证性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br> <br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它还经常用来实现线程安全的单例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-有序性"><a href="#5-有序性" class="headerlink" title="5. 有序性"></a>5. 有序性</h2><h3 id="5-1-指令重排"><a href="#5-1-指令重排" class="headerlink" title="5.1 指令重排"></a>5.1 指令重排</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> j;<br> <br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <br>j = ...;<br></code></pre></td></tr></table></figure>

<p><strong>指令重排</strong>：可能先执行i，再执行j；也可能先执行j，再执行i</p>
<ul>
<li>指令重排：在程序结果不受影响的前提下，可以调整指令语句执行顺序</li>
<li>多线程下『指令重排』会影响正确性</li>
</ul>
<h3 id="5-2-解决方法"><a href="#5-2-解决方法" class="headerlink" title="5.2 解决方法"></a>5.2 解决方法</h3><p><strong>volatile</strong>修饰的变量，可以禁用指令重排，禁止的是<strong>加 volatile 关键字变量之前的代码</strong>重排序</p>
<h2 id="6-volatile-原理"><a href="#6-volatile-原理" class="headerlink" title="6. volatile 原理"></a>6. volatile 原理</h2><p>volatile 的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的<strong>写指令后</strong>会加入写屏障</li>
<li>对 volatile 变量的<strong>读指令前</strong>会加入读屏障</li>
</ul>
<h3 id="6-1-如何保证可见性"><a href="#6-1-如何保证可见性" class="headerlink" title="6.1 如何保证可见性"></a>6.1 如何保证可见性</h3><p>写屏障（sfence）保证在<strong>该屏障之前的</strong>，对共享变量的<strong>改动，都同步到主存</strong>当中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>     num = <span class="hljs-number">2</span>;<br>     ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是被 volatile 修饰的，赋值带写屏障</span><br>     <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>而读屏障（lfence）保证在<strong>该屏障之后</strong>，对共享变量的<strong>读取，加载的是主存中最新数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">// ready是被 volatile 修饰的，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> 	r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> 	r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/blogs/java/jvm-juc/juc.4.3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="6-2-如何保证有序性"><a href="#6-2-如何保证有序性" class="headerlink" title="6.2 如何保证有序性"></a>6.2 如何保证有序性</h3><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是被 volatile 修饰的，赋值带写屏障</span><br> <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">// ready 是被 volatile 修饰的，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> 	r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> 	r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/blogs/java/jvm-juc/juc.4.4.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>volatile不能解决指令交错<ul>
<li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是<strong>保证了本线程内相关代码不被重排序</strong></li>
</ul>
</li>
</ul>
<h2 id="7-double-checked-locking"><a href="#7-double-checked-locking" class="headerlink" title="7. double-checked locking"></a>7. double-checked locking</h2><p><strong>问题</strong>：会出现指令重排的现象，从而导致出现有序性问题</p>
<p><strong>解决方案</strong>：加上volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                    <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可见性<ul>
<li>写屏障保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li>
<li>而读屏障保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li>
</ul>
</li>
<li>有序性<ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li>
</ul>
</li>
</ul>
<h2 id="8-happens-before"><a href="#8-happens-before" class="headerlink" title="8. happens-before"></a>8. happens-before</h2><p>happens-before <strong>规定了对共享变量的写操作对其它线程的读操作可见</strong>，它是<strong>可见性与有序性的一套规则总结</strong>，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<ul>
<li>线程<strong>解锁 m 之前</strong>对变量的写，对于<strong>接下来对 m 加锁</strong>的其它线程对该变量的<strong>读可见</strong></li>
<li>线程对 <strong>volatile 变量的写</strong>，对接下来其它线程对该变量的<strong>读可见</strong></li>
<li>线程 <strong>start 前对变量的写</strong>，对该线程开始后对该变量的<strong>读可见</strong></li>
<li>线程<strong>结束前对变量的写</strong>，对其它线程<strong>得知它结束后的读可见</strong>（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li>
<li><strong>线程 t1 打断 t2（interrupt）前对变量的写</strong>，对于其他线程得知 t2 被打断后对变量的<strong>读可见</strong>（通过 t2.interrupted 或 t2.isInterrupted）</li>
<li>对变量<strong>默认值</strong>（0，false，null）的写，对其它线程对该变量的<strong>读可见</strong></li>
<li><strong>具有传递性</strong>，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排</li>
</ul>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><ul>
<li><p><strong>synchronized</strong>能保证代码的<strong>原子性、可见性、有序性</strong></p>
</li>
<li><p><strong>volatile</strong>能保证代码的<strong>可见性和有序性</strong></p>
</li>
<li><p>可见性 - 由 <strong>JVM 缓存优化</strong>引起</p>
</li>
<li><p>有序性 - 由 <strong>JVM 指令重排序优化</strong>引起</p>
</li>
</ul>
<h1 id="五-共享模型之无锁"><a href="#五-共享模型之无锁" class="headerlink" title="五. 共享模型之无锁"></a>五. 共享模型之无锁</h1><p>通过<strong>非阻塞式的乐观锁</strong>的来实现并发控制</p>
<h2 id="1-CAS与volatile"><a href="#1-CAS与volatile" class="headerlink" title="1. CAS与volatile"></a>1. CAS与volatile</h2><h3 id="1-1-CAS-compareAndSet"><a href="#1-1-CAS-compareAndSet" class="headerlink" title="1.1 CAS(compareAndSet)"></a>1.1 CAS(compareAndSet)</h3><p><strong>compareAndSet</strong>，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 需要不断尝试，直到成功为止</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">        compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span><br><span class="hljs-comment">        - 不一致了，next 作废，返回 false 表示失败</span><br><span class="hljs-comment">           比如，别的线程已经做了减法，当前值已经被减成了 990</span><br><span class="hljs-comment">           那么本线程的这次 990 就作废了，进入 while 下次循环重试</span><br><span class="hljs-comment">        - 一致，以 next 设置为新值，返回 true 表示成功</span><br><span class="hljs-comment">        */</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/blogs/java/jvm-juc/juc.5.1.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>CAS 的底层是  lock cmpxchg  指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性</li>
</ul>
<h3 id="1-2-volatile"><a href="#1-2-volatile" class="headerlink" title="1.2 volatile"></a>1.2 volatile</h3><ul>
<li>为了保证该变量的可见性，需要使用 volatile 修饰。</li>
<li><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></li>
</ul>
<h3 id="1-3-为什么无锁效率高"><a href="#1-3-为什么无锁效率高" class="headerlink" title="1.3 为什么无锁效率高"></a>1.3 为什么无锁效率高</h3><ul>
<li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇</li>
<li>而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li>
</ul>
<h3 id="1-4-CAS-的特点"><a href="#1-4-CAS-的特点" class="headerlink" title="1.4 CAS 的特点"></a>1.4 CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，<strong>适用于线程数少、多核 CPU</strong> 的场景下。</p>
<ul>
<li>CAS 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>synchronized 是基于<strong>悲观锁</strong>的思想：最悲观的估计，<strong>得防着其它线程来修改共享变量</strong>，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
<li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong><ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="2-原子整数"><a href="#2-原子整数" class="headerlink" title="2. 原子整数"></a>2. 原子整数</h2><p>J.U.C 并发包提供了：</p>
<ul>
<li>AtomicBoolean：布尔型原子类</li>
<li>AtomicInteger ： 整型原子类</li>
<li>AtomicLong：长整型原子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>    System.out.println(i.getAndIncrement());<br>    <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>    System.out.println(i.incrementAndGet());<br>    <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>    System.out.println(i.decrementAndGet());<br>    <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>    System.out.println(i.getAndDecrement());<br>    <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>    System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br>    <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>    System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br>    <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>    <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>    System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-原子引用"><a href="#3-原子引用" class="headerlink" title="3. 原子引用"></a>3. 原子引用</h2><p>保证<strong>引用类型</strong>的共享变量是线程安全的</p>
<ul>
<li>AtomicReference: 引用类型原子类</li>
<li>AtomicMarkableReference: 原子更新带有标记的引用类型</li>
<li>AtomicStampedReference； 原子更新带有版本号的引用类型</li>
</ul>
<h3 id="3-1-AtomicReference"><a href="#3-1-AtomicReference" class="headerlink" title="3.1 AtomicReference"></a>3.1 AtomicReference</h3><p>使用无锁的方式 CAS 来解决，解决方式是用 AtomicReference 原子引用解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">nextVal</span> <span class="hljs-operator">=</span> preVal.subtract(amount);<br>            <span class="hljs-keyword">if</span>(balance.compareAndSet(preVal, nextVal)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-ABA问题"><a href="#3-2-ABA问题" class="headerlink" title="3.2 ABA问题"></a>3.2 ABA问题</h3><p>ABA问题：主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种<strong>从 A 改为 B 又 改回 A 的情况</strong></p>
<h3 id="3-3-AtomicStampedReference"><a href="#3-3-AtomicStampedReference" class="headerlink" title="3.3 AtomicStampedReference"></a>3.3 AtomicStampedReference</h3><p>如果主线程希望只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong><br>使用 AtomicStampedReference 加 stamp （版本号或者时间戳）的方式解决 ABA 问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两个参数，第一个：变量的值 第二个：版本号初始值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> ref.getReference();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.info(<span class="hljs-string">&quot;main 拿到的版本号 &#123;&#125;&quot;</span>,stamp);<br>        other();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;修改后的版本号 &#123;&#125;&quot;</span>,ref.getStamp());<br>        log.info(<span class="hljs-string">&quot;change A-&gt;C:&#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);<br>            log.info(<span class="hljs-string">&quot;change A-&gt;B:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>,stamp,stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-4-AtomicMarkableReference"><a href="#3-4-AtomicMarkableReference" class="headerlink" title="3.4 AtomicMarkableReference"></a>3.4 AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，<strong>通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次</strong>。</p>
<p>但是有时候，并不关心引用变量更改了几次，只是<strong>单纯的关心是否更改过</strong>，所以就有了AtomicMarkableReference</p>
<h2 id="4-原子数组"><a href="#4-原子数组" class="headerlink" title="4. 原子数组"></a>4. 原子数组</h2><p>使用原子的方式更新数组里的某个元素，使用原子数组可以保证<strong>数组元素</strong>的线程安全。</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_10_AtomicArrayTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 结果如下：</span><br><span class="hljs-comment">         * [9934, 9938, 9940, 9931, 9935, 9933, 9944, 9942, 9939, 9940]</span><br><span class="hljs-comment">         * [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br><span class="hljs-comment">         */</span><br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>                (array) -&gt; array.length,<br>                (array, index) -&gt; array[index]++,<br>                (array) -&gt; System.out.println(Arrays.toString(array))<br>        );<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                (array) -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">            Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; printConsumer)</span> &#123;<br>        ArrayList&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 创建集合</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get(); <span class="hljs-comment">// 获取数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array); <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach((thread) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        printConsumer.accept(array);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-字段更新器"><a href="#5-字段更新器" class="headerlink" title="5. 字段更新器"></a>5. 字段更新器</h2><p>利用字段更新器，可以针对<strong>对象的某个域</strong>（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p>
<ul>
<li><p>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域  字段</p>
</li>
<li><p>AtomicIntegerFieldUpdater</p>
</li>
<li><p>AtomicLongFieldUpdater</p>
</li>
<li><p>字段更新器就是为了<strong>保证类中某个属性</strong>线程安全问题。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> <br>        AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="hljs-string">&quot;field&quot;</span>);<br> <br>        <span class="hljs-type">Test5</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test5</span>();<br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br> <br>        <span class="hljs-comment">// 修改成功 field = 10</span><br>        System.out.println(test5.field);<br> <br>        <span class="hljs-comment">// 修改成功 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(test5.field);<br> <br>        <span class="hljs-comment">// 修改失败 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>        System.out.println(test5.field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="6-原子累加器"><a href="#6-原子累加器" class="headerlink" title="6. 原子累加器"></a>6. 原子累加器</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>AtomicLong Vs <strong>LongAdder</strong><br>执行代码后，发现使用 <strong>LongAdder</strong> 比 AtomicLong 快2，3倍，使用 LongAdder 性能提升</p>
<h3 id="6-2-原理"><a href="#6-2-原理" class="headerlink" title="6.2 原理"></a>6.2 原理</h3><p>性能提升的原因很简单，就是在有竞争时，<strong>设置多个累加单元</strong>，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… <strong>最后将结果汇总</strong>。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</p>
<h3 id="6-3-LongAdder源码"><a href="#6-3-LongAdder源码" class="headerlink" title="6.3  LongAdder源码"></a>6.3  LongAdder源码</h3><p>LongAdder 类有几个关键域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br> <br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br> <br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure>

<h2 id="7-Unsafe"><a href="#7-Unsafe" class="headerlink" title="7. Unsafe"></a>7. Unsafe</h2><p>Unsafe 对象提供了非常底层的，<strong>操作内存、线程的方法</strong>，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p>
<p><strong>通过反射获取Unsafe 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>		<span class="hljs-comment">// Unsafe 使用了单例模式，unsafe 对象是类中的一个私有的变量 </span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)theUnsafe.get(<span class="hljs-literal">null</span>);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>Unsafe 模拟实现 cas 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_14_UnsafeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br><br>        <span class="hljs-comment">// 创建 unsafe 对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)theUnsafe.get(<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 拿到偏移量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>        <span class="hljs-comment">// 进行 cas 操作</span><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        unsafe.compareAndSwapLong(teacher, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        unsafe.compareAndSwapObject(teacher, nameOffset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        System.out.println(teacher);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-本章总结"><a href="#8-本章总结" class="headerlink" title="8. 本章总结"></a>8. 本章总结</h2><ul>
<li>CAS 与 volatile</li>
<li>juc 包下 API<ul>
<li>原子整数</li>
<li>原子引用</li>
<li>原子数组</li>
<li>字段更新器</li>
<li>原子累加器</li>
</ul>
</li>
<li>Unsafe</li>
</ul>
<h1 id="六-共享模型之不可变"><a href="#六-共享模型之不可变" class="headerlink" title="六. 共享模型之不可变"></a>六. 共享模型之不可变</h1><p>不可变类的对象，因为无法修改共享成员的状态，所以不会有线程安全问题</p>
<ul>
<li>不可变类的使用</li>
<li>不可变类设计</li>
<li>无状态类设计</li>
</ul>
<h2 id="1-不可变类的使用"><a href="#1-不可变类的使用" class="headerlink" title="1. 不可变类的使用"></a>1. 不可变类的使用</h2><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的<br>在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> dtf.parse(<span class="hljs-string">&quot;2018-10-01&quot;</span>, LocalDate::from);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-不可变类的设计-以String类为例"><a href="#2-不可变类的设计-以String类为例" class="headerlink" title="2. 不可变类的设计(以String类为例)"></a>2. 不可变类的设计(以String类为例)</h2><p>String 类是不可变的</p>
<h3 id="2-1-final-的使用"><a href="#2-1-final-的使用" class="headerlink" title="2.1 final 的使用"></a>2.1 final 的使用</h3><p>发现该类、类中所有属性都是 final 的</p>
<ul>
<li>属性用 final 修饰保证了<strong>该属性是只读的</strong>，不能修改</li>
<li>类用 final 修饰,<strong>没有子类继承</strong>，保证了该类中的<strong>方法不能被覆盖</strong>，防止子类无意间破坏不可变性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br> <br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-保护性拷贝"><a href="#2-2-保护性拷贝" class="headerlink" title="2.2 保护性拷贝"></a>2.2 保护性拷贝</h3><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> value.length - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong><br>构造新字符串对象时，会生成新的 char[] value，对内容进行<strong>复制</strong> 。这种通过<strong>创建副本对象来避免共享</strong>的手段称之为【保护性拷贝，defensive copy】</p>
<h2 id="3-享元模式"><a href="#3-享元模式" class="headerlink" title="3. 享元模式"></a>3. 享元模式</h2><p>Flyweight pattern. 当需要重用数量有限的同一类对象时</p>
<h3 id="3-1-体现"><a href="#3-1-体现" class="headerlink" title="3.1 体现"></a>3.1 体现</h3><p><strong>包装类</strong>、<strong>String 串池</strong>、<strong>BigDecimal BigInteger</strong></p>
<ul>
<li>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会<strong>缓存 -128~127 之间的 Long 对象</strong>，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Byte, Short, Long 缓存的范围都是 -128~127</li>
<li>Character 缓存的范围是 0~127</li>
<li>Integer的默认范围是 -128~127</li>
<li>Boolean 缓存了 TRUE 和 FALSE</li>
</ul>
<h3 id="3-2-DIY-实现简单的数据库连接池"><a href="#3-2-DIY-实现简单的数据库连接池" class="headerlink" title="3.2 DIY 实现简单的数据库连接池"></a>3.2 DIY 实现简单的数据库连接池</h3><p>一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_17_DatabaseConnectionPoolTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(connection);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br><br>    <span class="hljs-comment">// 连接池的大小, 因为没有实现连接池大小的扩容, 用 final 表示池的大小是一个固定值。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-comment">// 连接池</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 表示连接状态, 如果是 0 表示没连接, 1 表示有连接</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray status;<br>    <span class="hljs-comment">// 初始化连接池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从连接池中获取连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == status.get(i)) &#123;<br>                    <span class="hljs-keyword">if</span>(status.compareAndSet(i,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.info(<span class="hljs-string">&quot;获取连接:&#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;wait ...&quot;</span>);<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从连接池中释放指定的连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection connection)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span>(connections[i] == connection) &#123;<br>                status.set(i, <span class="hljs-number">0</span>);<br>                log.info(<span class="hljs-string">&quot;释放连接:&#123;&#125;&quot;</span>, connections[i]);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockConnection</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-final的原理"><a href="#4-final的原理" class="headerlink" title="4. final的原理"></a>4. final的原理</h2><h3 id="4-1-设置-final-变量的原理"><a href="#4-1-设置-final-变量的原理" class="headerlink" title="4.1 设置 final 变量的原理"></a>4.1 设置 final 变量的原理</h3><p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFinal</span> &#123;<br>	<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会<strong>加入写屏障</strong>，保证在其它线程读到它的值时不会出现为 0 的情况</p>
<h3 id="4-2-获取-final-变量的原理"><a href="#4-2-获取-final-变量的原理" class="headerlink" title="4.2 获取 final 变量的原理"></a>4.2 获取 final 变量的原理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42651904/article/details/87708198?ops_request_misc=%257B%2522request%255Fid%2522%253A%252203d3d48b5d881880308676771f04918a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=03d3d48b5d881880308676771f04918a&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-87708198-null-null.nonecase&utm_term=%E6%B7%B1%E5%85%A5final%E5%85%B3%E9%94%AE%E5%AD%97&spm=1018.2226.3001.4450">深入理解final关键字</a></p>
<h2 id="5-无状态"><a href="#5-无状态" class="headerlink" title="5. 无状态"></a>5. 无状态</h2><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种<strong>没有任何成员变量的类</strong>是线程安全的</p>
<ul>
<li>因为成员变量保存的数据也可以称为状态信息，因此<strong>没有成员变量</strong>就称之为【<strong>无状态</strong>】</li>
</ul>
<h1 id="七-共享模型之工具"><a href="#七-共享模型之工具" class="headerlink" title="七. 共享模型之工具"></a>七. 共享模型之工具</h1><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>池化技术的思想主要是为了<strong>减少每次获取资源的消耗，提高对资源的利用率</strong>。<br>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="1-1-自定义线程池"><a href="#1-1-自定义线程池" class="headerlink" title="1.1 自定义线程池"></a>1.1 自定义线程池</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.1.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li>先初始化线程池、阻塞队列大小</li>
<li>开几个线程通过线程池对象调用方法执行任务，线程池中的线程会执行任务</li>
<li>如果<strong>任务过多，会添加到阻塞队列</strong>中，执行完任务再从阻塞队列中取值继续执行</li>
<li>当执行的<strong>线程数大于线程池和阻塞队列的大小</strong>，我们可以定义<strong>拒绝策略</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义线程池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_01_TestPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_01_ThreadPoolTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">1</span>,<br>                (queue, task) -&gt; &#123;<br>                    <span class="hljs-comment">// 1. 阻塞等待。</span><br><span class="hljs-comment">//                    queue.put(task);</span><br>                    <span class="hljs-comment">// 2. 带超时的等待</span><br><span class="hljs-comment">//                    queue.offer(task, 500, TimeUnit.MILLISECONDS);</span><br>                    <span class="hljs-comment">// 3. 调用者放弃</span><br><span class="hljs-comment">//                    log.info(&quot;放弃 &#123;&#125;&quot;, task);</span><br>                    <span class="hljs-comment">// 4. 调用者抛出异常</span><br><span class="hljs-comment">//                    throw new RuntimeException(&quot;任务执行失败&quot; + task);</span><br>                    <span class="hljs-comment">// 5. 调用者自己执行任务</span><br>                    task.run();<br>                &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            threadPool.executor(() -&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 拒绝策略</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现线程池</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> Set&lt;Worker&gt; works = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Worker&gt;();<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程池的核心数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">// 获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit unit;<br>    <span class="hljs-comment">// 使用策略模式。</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit unit, <span class="hljs-type">int</span> queueCapacity,</span><br><span class="hljs-params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.unit = unit;<br>        taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executor</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">// 如果线程池满了. 就将任务加入到任务队列, 否则执行任务</span><br>        <span class="hljs-keyword">synchronized</span> (works) &#123;<br>            <span class="hljs-keyword">if</span>(works.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.info(<span class="hljs-string">&quot;新增 worker &#123;&#125; ，任务 &#123;&#125;&quot;</span>, worker, task);<br>                works.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//                taskQueue.put(task);</span><br>                <span class="hljs-comment">// 1）死等</span><br>                <span class="hljs-comment">// 2）带超时等待</span><br>                <span class="hljs-comment">// 3）让调用者放弃任务执行</span><br>                <span class="hljs-comment">// 4）让调用者抛出异常</span><br>                <span class="hljs-comment">// 5）让调用者自己执行任务</span><br><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-comment">// 执行任务</span><br>        <span class="hljs-comment">// 1）当 task 不为空，执行任务</span><br>        <span class="hljs-comment">// 2）当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//            while (task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, unit)) != <span class="hljs-literal">null</span>) &#123;<br>                 <span class="hljs-keyword">try</span> &#123; <br>                     log.info(<span class="hljs-string">&quot;正在执行 &#123;&#125;&quot;</span>, task);<br>                     task.run();<br>                 &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                 &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     task = <span class="hljs-literal">null</span>;<br>                 &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (works) &#123;<br>                log.info(<span class="hljs-string">&quot;worker 被移除 &#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                works.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现阻塞队列</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">// 阻塞队列的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">// 双端链表, 从头取, 从尾加</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue;<br>    <span class="hljs-comment">// 定义锁</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock;<br>    <span class="hljs-comment">// 当阻塞队列满了时候, 去 fullWaitSet 休息, 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition fullWaitSet;<br>    <span class="hljs-comment">// 当阻塞队列空了时候，去 emptyWaitSet 休息, 消费者小件变量</span><br>    <span class="hljs-keyword">private</span> Condition emptyWaitSet;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(capacity);<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        fullWaitSet = lock.newCondition();<br>        emptyWaitSet = lock.newCondition();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 带有超时时间的获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 同一时间单位</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 防止虚假唤醒, 返回的是所剩时间</span><br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125;&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 带有超时时间的添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.info(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125;&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断判断是否满</span><br>            <span class="hljs-keyword">if</span>(queue.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有空闲</span><br>                log.info(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.2.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-2-1-线程池状态"><a href="#1-2-1-线程池状态" class="headerlink" title="1.2.1 线程池状态"></a>1.2.1 线程池状态</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态</strong>，低 29 位表示线程数量</p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>高3位的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>这些信息存储在<strong>一个</strong>原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以<strong>用一次 cas 原子操作</strong>进行赋值</p>
<h4 id="1-2-2-构造方法"><a href="#1-2-2-构造方法" class="headerlink" title="1.2.2 构造方法"></a>1.2.2 构造方法</h4><p>ThreadPoolExecutor 类参数最多、最全的有参构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数目 (最多保留的线程数)</li>
<li>maximumPoolSize 最大线程数目</li>
<li>keepAliveTime 生存时间 - 针对救急线程</li>
<li>unit 时间单位 - 针对救急线程</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li>
<li>handler 拒绝策略</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.3.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当核心线程被用完了，并且任务太多了，阻塞队列放不下，这个时候<strong>救急线程就会被启用来处理任务</strong>。</li>
<li><strong>核心线程</strong>永远不会超时，一直运行；<strong>救急线程</strong>会超时，超时被关闭</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</li>
<li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li>
<li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。</li>
<li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制</li>
</ol>
<p><strong>拒绝策略</strong>：<br>jdk 提供了 4 种实现，其它著名框架也提供了实现</p>
<ol>
<li><strong>AbortPolicy</strong> 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li><strong>CallerRunsPolicy</strong> 让调用者运行任务</li>
<li><strong>DiscardPolicy</strong> 放弃本次任务</li>
<li><strong>DiscardOldestPolicy</strong> 放弃队列中最早的任务，本任务取而代之</li>
</ol>
<ul>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty 的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.4.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="1-2-3-newFixedThreadPool"><a href="#1-2-3-newFixedThreadPool" class="headerlink" title="1.2.3  newFixedThreadPool"></a>1.2.3  newFixedThreadPool</h4><p>适用于<strong>任务量已知，相对耗时</strong>的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>核心线程数 &#x3D;&#x3D; 最大线程数</strong>（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
<h4 id="1-2-4-newCachedThreadPool"><a href="#1-2-4-newCachedThreadPool" class="headerlink" title="1.2.4  newCachedThreadPool"></a>1.2.4  newCachedThreadPool</h4><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 <strong>适合任务数比较密集，但每个任务执行时间较短</strong>的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>核心线程数是 0</strong>， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<strong>全部都是救急线程</strong>（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>
</ul>
<h4 id="1-2-5-newSingleThreadExecutor"><a href="#1-2-5-newSingleThreadExecutor" class="headerlink" title="1.2.5  newSingleThreadExecutor"></a>1.2.5  newSingleThreadExecutor</h4><p>适用于<strong>多个任务排队执行（串行）</strong>。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li>
<li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ul>
</li>
<li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul>
<li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li>
</ul>
</li>
</ul>
<h4 id="1-2-6-提交任务"><a href="#1-2-6-提交任务" class="headerlink" title="1.2.6 提交任务"></a>1.2.6 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure>

<h4 id="1-2-7-关闭线程池"><a href="#1-2-7-关闭线程池" class="headerlink" title="1.2.7 关闭线程池"></a>1.2.7 关闭线程池</h4><h5 id="1-2-7-1-shutdown"><a href="#1-2-7-1-shutdown" class="headerlink" title="1.2.7.1 shutdown"></a>1.2.7.1 shutdown</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment"> - 不会接收新任务</span><br><span class="hljs-comment"> - 但已提交任务会执行完</span><br><span class="hljs-comment"> - 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<h5 id="1-2-7-2-shutdownNow"><a href="#1-2-7-2-shutdownNow" class="headerlink" title="1.2.7.2 shutdownNow"></a>1.2.7.2 shutdownNow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment"> - 不会接收新任务</span><br><span class="hljs-comment"> - 会将队列中的任务返回</span><br><span class="hljs-comment"> - 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<h5 id="1-2-7-3-其他方法"><a href="#1-2-7-3-其他方法" class="headerlink" title="1.2.7.3 其他方法"></a>1.2.7.3 其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure>

<h4 id="1-2-8-任务调度线程池"><a href="#1-2-8-任务调度线程池" class="headerlink" title="1.2.8 任务调度线程池"></a>1.2.8 任务调度线程池</h4><p>线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来<strong>执行延迟或反复执行的任务</strong></p>
<ul>
<li>ScheduledExecutorService 中 scheduleAtFixedRate 方法的使用，是 一段时间 的 期间。</li>
<li>ScheduledExecutorService 中 scheduleWithFixedDelay 方法的使用，是 一段时间 的 间隔。</li>
</ul>
<h4 id="1-2-9-正确处理执行任务异常"><a href="#1-2-9-正确处理执行任务异常" class="headerlink" title="1.2.9 正确处理执行任务异常"></a>1.2.9 正确处理执行任务异常</h4><ul>
<li>方法1：主动捉异常,try catch</li>
<li>方法2：使用 Future，错误信息都被封装进submit方法的返回方法中</li>
</ul>
<h4 id="1-2-10-Tomcat-线程池"><a href="#1-2-10-Tomcat-线程池" class="headerlink" title="1.2.10  Tomcat 线程池"></a>1.2.10  Tomcat 线程池</h4><p><img src="/img/blogs/java/jvm-juc/juc.7.5.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的  Semaphore 后面再讲</li>
<li>Acceptor 只负责【接收新的 socket 连接】</li>
<li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li>
<li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li>
<li>Executor 线程池中的工作线程最终负责【处理请求】</li>
</ul>
<p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p>
<ul>
<li><p>如果总线程数达到 maximumPoolSize</p>
<ul>
<li>这时不会立刻抛 RejectedExecutionException 异常</li>
<li>而是再次<strong>尝试将任务放入队列</strong>，如果还失败，才抛出 RejectedExecutionException 异常</li>
</ul>
</li>
<li><p>当添加新的任务时，如果提交的任务大于核心线程数，小于最大线程数就创建救急线程，否则就加入任务队列中：</p>
</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.6.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="1-3-异步模式之工作线程"><a href="#1-3-异步模式之工作线程" class="headerlink" title="1.3 异步模式之工作线程"></a>1.3 异步模式之工作线程</h3><h4 id="1-3-1-定义"><a href="#1-3-1-定义" class="headerlink" title="1.3.1 定义"></a>1.3.1 定义</h4><p>让<strong>有限的工作线程来轮流异步处理无限多的任务</strong>。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p>
<ul>
<li>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</li>
</ul>
<p>注意，<strong>不同任务类型应该使用不同的线程池</strong>，这样能够<strong>避免饥饿</strong>，并能提升效率</p>
<ul>
<li>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</li>
</ul>
<h4 id="1-3-2-饥饿"><a href="#1-3-2-饥饿" class="headerlink" title="1.3.2 饥饿"></a>1.3.2 饥饿</h4><ul>
<li>固定大小线程池会有饥饿现象<ul>
<li>两个工人是同一个线程池中的两个线程</li>
<li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作</li>
<li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li>
<li>后厨做菜：没啥说的，做就是了</li>
<li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</li>
<li>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li>
</ul>
</li>
</ul>
<h4 id="1-3-3-创建多少线程池合适"><a href="#1-3-3-创建多少线程池合适" class="headerlink" title="1.3.3 创建多少线程池合适"></a>1.3.3 创建多少线程池合适</h4><ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li>
<li>过大会导致更多的线程上下文切换，占用更多内存</li>
</ul>
<h5 id="1-3-3-1-CPU-密集型运算"><a href="#1-3-3-1-CPU-密集型运算" class="headerlink" title="1.3.3.1 CPU 密集型运算"></a>1.3.3.1 CPU 密集型运算</h5><p>通常采用  <code>cpu 核数 + 1</code>  能够实现<strong>最优的 CPU 利用率</strong>，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p>
<h5 id="1-3-3-2-I-O-密集型运算"><a href="#1-3-3-2-I-O-密集型运算" class="headerlink" title="1.3.3.2 I&#x2F;O 密集型运算"></a>1.3.3.2 I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p>
<p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p>
<ul>
<li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式<br><code>4 * 100% * 100% / 10% = 40</code></li>
</ul>
<h3 id="1-4-Fork-Join-线程池"><a href="#1-4-Fork-Join-线程池" class="headerlink" title="1.4 Fork&#x2F;Join 线程池"></a>1.4 Fork&#x2F;Join 线程池</h3><h4 id="1-4-1-概念"><a href="#1-4-1-概念" class="headerlink" title="1.4.1 概念"></a>1.4.1 概念</h4><ul>
<li>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种<strong>分治思想</strong>，<strong>适用于能够进行任务拆分的 cpu 密集型运算</strong></li>
<li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</li>
<li>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</li>
<li>Fork&#x2F;Join 默认会<strong>创建与 cpu 核心数大小相同</strong>的线程池</li>
</ul>
<h4 id="1-4-2-使用"><a href="#1-4-2-使用" class="headerlink" title="1.4.2 使用"></a>1.4.2 使用</h4><p>提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.7.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-J-U-C-java-util-concurrent"><a href="#2-J-U-C-java-util-concurrent" class="headerlink" title="2. J.U.C(java.util.concurrent)"></a>2. J.U.C(java.util.concurrent)</h2><h3 id="2-1-AQS-原理"><a href="#2-1-AQS-原理" class="headerlink" title="2.1 AQS 原理"></a>2.1 AQS 原理</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁</span><br><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br>    <span class="hljs-comment">// 入队, 可以选择阻塞当前线程  park unpark</span><br>&#125;<br><br><span class="hljs-comment">//释放锁</span><br><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-ReentrantLock-原理"><a href="#2-2-ReentrantLock-原理" class="headerlink" title="2.2 ReentrantLock 原理"></a>2.2 ReentrantLock 原理</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.8.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-2-1-非公平锁实现原理"><a href="#2-2-1-非公平锁实现原理" class="headerlink" title="2.2.1 非公平锁实现原理"></a>2.2.1 非公平锁实现原理</h4><p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>       sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<span class="hljs-comment">//NonfairSync 继承自 AQS</span><br>   &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>没有竞争时</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.9.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>第一个竞争出现时</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.10.png" srcset="/img/loading.gif" lazyload></p>
<p>Thread-1 执行了</p>
<ol>
<li>CAS 尝试将 state 由 0 改为 1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li>
<li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul>
<li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li>
<li>Node 的创建是懒惰的</li>
<li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li>
</ul>
</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.7.11.png" srcset="/img/loading.gif" lazyload></p>
<p>当前线程进入 acquireQueued 逻辑</p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.7.12.png" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.7.13.png" srcset="/img/loading.gif" lazyload></p>
<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.14.png" srcset="/img/loading.gif" lazyload></p>
<p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p>
<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state &#x3D; 0</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.15.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程</li>
<li>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为Thread-1</li>
<li>回到 Thread-1 的 acquireQueued 流程</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.16.png" srcset="/img/loading.gif" lazyload></p>
<p>如果加锁成功（没有竞争），会设置</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收<br>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.17.png" srcset="/img/loading.gif" lazyload></p>
<p>如果不巧又被 Thread-4 占了先</p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<h4 id="2-2-2-可重入原理"><a href="#2-2-2-可重入原理" class="headerlink" title="2.2.2 可重入原理"></a>2.2.2 可重入原理</h4><ul>
<li>加锁时：每增加一个锁，状态加一，state++</li>
<li>解锁时：解锁一层，state–；直到为0才释放锁</li>
</ul>
<h4 id="2-2-3-可打断原理"><a href="#2-2-3-可打断原理" class="headerlink" title="2.2.3 可打断原理"></a>2.2.3 可打断原理</h4><ul>
<li>不可打断模式： 在此模式下，即使它被打断，仍<strong>会驻留在 AQS 队列</strong>中，一直要等到获得锁后方能得知自己被打断了</li>
<li>可打断模式： 在 park 过程中如果被 interrupt ，这时候<strong>抛出异常</strong>, 而不会再次进入 for (;;)</li>
</ul>
<h4 id="2-2-4-公平锁实现原理"><a href="#2-2-4-公平锁实现原理" class="headerlink" title="2.2.4 公平锁实现原理"></a>2.2.4 公平锁实现原理</h4><p>公平锁： 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</p>
<h4 id="2-2-5-条件变量实现原理"><a href="#2-2-5-条件变量实现原理" class="headerlink" title="2.2.5 条件变量实现原理"></a>2.2.5 条件变量实现原理</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<h5 id="2-2-5-1-await-流程"><a href="#2-2-5-1-await-流程" class="headerlink" title="2.2.5.1 await 流程"></a>2.2.5.1 await 流程</h5><ul>
<li>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</li>
<li>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.18.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.19.png" srcset="/img/loading.gif" lazyload></p>
<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.20.png" srcset="/img/loading.gif" lazyload></p>
<p>park 阻塞 Thread-0</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.21.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-2-5-2-signal-流程"><a href="#2-2-5-2-signal-流程" class="headerlink" title="2.2.5.2 signal 流程"></a>2.2.5.2 signal 流程</h5><p>假设 Thread-1 要来唤醒 Thread-0</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.22.png" srcset="/img/loading.gif" lazyload></p>
<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.23.png" srcset="/img/loading.gif" lazyload></p>
<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.24.png" srcset="/img/loading.gif" lazyload></p>
<p>Thread-1 释放锁，进入 unlock 流程，略</p>
<h3 id="2-3-读写锁"><a href="#2-3-读写锁" class="headerlink" title="2.3 读写锁"></a>2.3 读写锁</h3><h4 id="2-3-1-ReentrantReadWriteLock"><a href="#2-3-1-ReentrantReadWriteLock" class="headerlink" title="2.3.1 ReentrantReadWriteLock"></a>2.3.1 ReentrantReadWriteLock</h4><p>当读操作远远高于写操作时，这时候<strong>使用读写锁让读-读可以并发</strong>，提高性能。 类似于数据库中的  <code>select ...from ... lock in share mode</code></p>
<ul>
<li>读锁<strong>不支持条件变量</strong></li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
<h4 id="2-3-2-应用之缓存"><a href="#2-3-2-应用之缓存" class="headerlink" title="2.3.2 应用之缓存"></a>2.3.2 应用之缓存</h4><h5 id="2-3-2-1-缓存更新策略"><a href="#2-3-2-1-缓存更新策略" class="headerlink" title="2.3.2.1 缓存更新策略"></a>2.3.2.1 缓存更新策略</h5><p>更新时，是先清缓存还是先更新数据库？</p>
<ul>
<li>先清除缓存:</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.25.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>先更新数据库(推荐)</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.26.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="2-3-2-2-读写锁实现一致性缓存"><a href="#2-3-2-2-读写锁实现一致性缓存" class="headerlink" title="2.3.2.2 读写锁实现一致性缓存"></a>2.3.2.2 读写锁实现一致性缓存</h5><p>使用读写锁可以实现一个简单的按需加载缓存，保证缓存和数据库的一致性</p>
<h4 id="2-3-3-StampedLock"><a href="#2-3-3-StampedLock" class="headerlink" title="2.3.3 StampedLock"></a>2.3.3 StampedLock</h4><p>该类自 JDK 8 加入，是为了<strong>进一步优化读性能</strong>，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<p><strong>加解读锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure>

<p><strong>加解写锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure>

<p><strong>乐观读</strong>: StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br> <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
<h3 id="2-4-读写锁原理"><a href="#2-4-读写锁原理" class="headerlink" title="2.4 读写锁原理"></a>2.4 读写锁原理</h3><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p>
<h4 id="2-4-1-t1-w-lock，t2-r-lock"><a href="#2-4-1-t1-w-lock，t2-r-lock" class="headerlink" title="2.4.1 t1 w.lock，t2 r.lock"></a>2.4.1 t1 w.lock，t2 r.lock</h4><ol>
<li>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.7.27.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</li>
</ol>
<ul>
<li>tryAcquireShared 返回值表示<ul>
<li>-1 表示失败</li>
<li>0 表示成功，但后继节点不会继续唤醒</li>
<li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li>
</ul>
</li>
</ul>
<p><img src="/img/blogs/java/jvm-juc/juc.7.28.png" srcset="/img/loading.gif" lazyload></p>
<ol start="3">
<li>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.7.29.png" srcset="/img/loading.gif" lazyload></p>
<ol start="4">
<li>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</li>
<li>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</li>
</ol>
<p><img src="/img/blogs/java/jvm-juc/juc.7.30.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-4-2-t3-r-lock，t4-w-lock"><a href="#2-4-2-t3-r-lock，t4-w-lock" class="headerlink" title="2.4.2 t3 r.lock，t4 w.lock"></a>2.4.2 t3 r.lock，t4 w.lock</h4><p>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.31.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="2-4-3-t1-w-unlock"><a href="#2-4-3-t1-w-unlock" class="headerlink" title="2.4.3 t1 w.unlock"></a>2.4.3 t1 w.unlock</h4><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.32.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行<br>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.33.png" srcset="/img/loading.gif" lazyload></p>
<p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.34.png" srcset="/img/loading.gif" lazyload></p>
<p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在doAcquireShared 内parkAndCheckInterrupt() 处恢复运行</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.35.png" srcset="/img/loading.gif" lazyload></p>
<p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.36.png" srcset="/img/loading.gif" lazyload></p>
<p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.37.png" srcset="/img/loading.gif" lazyload></p>
<p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p>
<h4 id="2-4-4-t2-r-unlock，t3-r-unlock"><a href="#2-4-4-t2-r-unlock，t3-r-unlock" class="headerlink" title="2.4.4 t2 r.unlock，t3 r.unlock"></a>2.4.4 t2 r.unlock，t3 r.unlock</h4><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.38.png" srcset="/img/loading.gif" lazyload></p>
<p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.39.png" srcset="/img/loading.gif" lazyload></p>
<p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.40.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-5-Semaphore"><a href="#2-5-Semaphore" class="headerlink" title="2.5 Semaphore"></a>2.5 Semaphore</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><p>信号量，<strong>用来限制能同时访问共享资源的线程上限</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建一个对象</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 2. 开 10 个线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">// 获取一个许可</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;start ...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.info(<span class="hljs-string">&quot;end ....&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;t&quot;</span> + (i + <span class="hljs-number">1</span>)).start();;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-5-2-semaphore应用"><a href="#2-5-2-semaphore应用" class="headerlink" title="2.5.2 semaphore应用"></a>2.5.2 semaphore应用</h4><p><strong>限制对共享资源的使用</strong></p>
<ul>
<li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数</li>
<li>用  Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中<strong>线程数和数据库连接数是相等的</strong></li>
</ul>
<h4 id="2-5-3-Semaphore-原理"><a href="#2-5-3-Semaphore-原理" class="headerlink" title="2.5.3 Semaphore 原理"></a>2.5.3 Semaphore 原理</h4><p><strong>加锁解锁流程</strong><br><strong>Semaphore 有点像一个停车场</strong>，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一<br>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.41.png" srcset="/img/loading.gif" lazyload></p>
<p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.42.png" srcset="/img/loading.gif" lazyload></p>
<p>这时 Thread-4 释放了 permits，状态如下</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.43.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p>
<p><img src="/img/blogs/java/jvm-juc/juc.7.44.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="2-6-CountdownLatch"><a href="#2-6-CountdownLatch" class="headerlink" title="2.6 CountdownLatch"></a>2.6 CountdownLatch</h3><p><strong>倒计时锁</strong></p>
<ul>
<li>CountDownLatch 允许多线程<strong>阻塞在一个地方</strong>，<strong>直至所有线程的任务都执行完毕</strong>。</li>
<li>用来进行线程同步协作，等待所有线程完成倒计时。</li>
<li>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</li>
<li>直至最后一个线程调用了 countDown ，使得 state &#x3D;&#x3D; 0，于是阻塞的线程便判断成功，全部往下执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br> <br>    log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    latch.await();<br>    log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>应用之同步等待多线程准备完毕</li>
<li>应用之同步等待多个远程调用结束</li>
</ul>
<h3 id="2-7-CyclicBarrier"><a href="#2-7-CyclicBarrier" class="headerlink" title="2.7 CyclicBarrier"></a>2.7 CyclicBarrier</h3><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<ul>
<li>跟 CountdownLatch 一样，但<strong>这个可以重用</strong>。</li>
</ul>
<h3 id="2-8-线程安全集合类概述"><a href="#2-8-线程安全集合类概述" class="headerlink" title="2.8 线程安全集合类概述"></a>2.8 线程安全集合类概述</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.45.png" srcset="/img/loading.gif" lazyload></p>
<p>线程安全集合类可以分为三大类：</p>
<ol>
<li>遗留的线程安全集合如  Hashtable ， Vector</li>
<li>使用 Collections 装饰的线程安全集合，如：<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
<li>Collections.synchronizedNavigableSet    </li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet</li>
</ul>
</li>
<li>java.util.concurrent.*</li>
</ol>
<p>重点介绍 java.util.concurrent.*  下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<strong>Blocking、CopyOnWrite、Concurrent</strong></p>
<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li>
<li>CopyOnWrite 之类容器修改开销相对较重</li>
<li>Concurrent 类型的容器<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p>
<h3 id="2-9-ConcurrentHashMap原理"><a href="#2-9-ConcurrentHashMap原理" class="headerlink" title="2.9 ConcurrentHashMap原理"></a>2.9 ConcurrentHashMap原理</h3><p>对HashMap的原子化类</p>
<p><strong>JDK 8 ConcurrentHashMap</strong>：<br><strong>重要属性和内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认为 0</span><br><span class="hljs-comment">// 当初始化时, 为 -1</span><br><span class="hljs-comment">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="hljs-comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br> <br><span class="hljs-comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// hash 表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br> <br><span class="hljs-comment">// 扩容时的 新 hash 表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br> <br><span class="hljs-comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReservationNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><strong>重要方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Node[] 中第 i 个 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span><br>    <br><span class="hljs-comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br>    <br><span class="hljs-comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span><br></code></pre></td></tr></table></figure>

<p>Java 8 <strong>数组（Node） +（ 链表 Node | 红黑树 TreeNode</strong> ） 以下数组简称（table），链表简称（bin）</p>
<ul>
<li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li>
<li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</li>
<li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li>
<li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li>
<li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1&#x2F;6 的节点会把复制到新 table 中</li>
<li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</li>
</ul>
<h3 id="2-10-LinkedBlockingQueue"><a href="#2-10-LinkedBlockingQueue" class="headerlink" title="2.10 LinkedBlockingQueue"></a>2.10 LinkedBlockingQueue</h3><h4 id="2-10-1-基本的入队出队"><a href="#2-10-1-基本的入队出队" class="headerlink" title="2.10.1 基本的入队出队"></a>2.10.1 基本的入队出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * One of:</span><br><span class="hljs-comment">         * - the real successor Node(真正的后继节点)</span><br><span class="hljs-comment">         * - this Node, meaning the successor is head.next(自己, 发生在出队的时候)</span><br><span class="hljs-comment">         * - null, meaning there is no successor (this is the last node)(null, 表示没有后继节点, 是最后了)</span><br><span class="hljs-comment">         */</span><br>        Node&lt;E&gt; next;<br><br>        Node(E x) &#123; item = x; &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;<br>      <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span><br>      <span class="hljs-comment">// assert last.next == null;</span><br>      last = last.next = node;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-10-2-加锁分析"><a href="#2-10-2-加锁分析" class="headerlink" title="2.10.2 加锁分析"></a>2.10.2 加锁分析</h4><p>高明之处在于<strong>用了两把锁和 dummy 节点</strong></p>
<ul>
<li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li>
<li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul>
<li>消费者与消费者线程仍然串行</li>
<li>生产者与生产者线程仍然串行</li>
</ul>
</li>
</ul>
<p><strong>线程安全分析</strong></p>
<ul>
<li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li>
<li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li>
<li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 用户 take(阻塞) poll(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure>

<h4 id="2-10-3-性能比较"><a href="#2-10-3-性能比较" class="headerlink" title="2.10.3 性能比较"></a>2.10.3 性能比较</h4><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p>
<ul>
<li>Linked 支持有界，Array 强制有界</li>
<li>Linked 实现是链表，Array 实现是数组</li>
<li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li>
<li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li>
<li>Linked 两把锁，Array 一把锁</li>
</ul>
<h3 id="2-11-ConcurrentLinkedQueue"><a href="#2-11-ConcurrentLinkedQueue" class="headerlink" title="2.11 ConcurrentLinkedQueue"></a>2.11 ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p>
<ul>
<li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li>
<li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li>
<li>只是这【锁】使用了 cas 来实现<br>事实上，ConcurrentLinkedQueue 应用还是非常广泛的<br>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时<br>,正是采用了ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</li>
</ul>
<h3 id="2-12-CopyOnWriteArrayList"><a href="#2-12-CopyOnWriteArrayList" class="headerlink" title="2.12 CopyOnWriteArrayList"></a>2.12 CopyOnWriteArrayList</h3><p>CopyOnWriteArraySet  是它的马甲底层实现采用了  <strong>写入时拷贝</strong>  的思想，<strong>增删改操作会将底层数组拷贝一份</strong>，更改操作在新数组上执行，这时不影响其它线程的<strong>并发读，读写分离</strong>。</p>
<ul>
<li>适合『读多写少』的应用场景</li>
</ul>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JAVA/" class="category-chain-item">JAVA</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="print-no-link">#学习</a>
      
        <a href="/tags/JAVA/" class="print-no-link">#JAVA</a>
      
        <a href="/tags/JUC/" class="print-no-link">#JUC</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/12/JAVA/JVM/" title="JVM学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/08/JAVA/redis/" title="Redis学习笔记及面试问题分析">
                        <span class="hidden-mobile">Redis学习笔记及面试问题分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sj2tGuxMGSDhkN5hNuOIVta1-gzGzoHsz","appKey":"ysR5OTuTzoby2oNvNyGOtXFQ","path":"window.location.pathname","placeholder":"如有问题，欢迎指正~","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>AI</span> <i class="iconfont icon-love"></i> <span>CPP</span> <i class="iconfont icon-love"></i> <span>JAVA</span> <i class="iconfont icon-love"></i> <span>CyberSec</span> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script>
<script src="/js/bubble.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/js/backgroundize.js"></script><!-- hexo injector body_end end --></body>
</html>
