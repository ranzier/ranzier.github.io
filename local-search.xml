<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetcodeHOT100刷题笔记</title>
    <link href="/2025/05/09/Algorithm/Hot100/"/>
    <url>/2025/05/09/Algorithm/Hot100/</url>
    
    <content type="html"><![CDATA[<h1 align="center">LeetcodeHOT100刷题笔记</h1><h1 id="0-算法思想总结"><a href="#0-算法思想总结" class="headerlink" title="0. 算法思想总结"></a>0. 算法思想总结</h1><ol><li><a href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">两数之和</a> 1<ul><li>使用HashMap存储数组元素，查询map中是否存在<code>target-nums[i]</code></li></ul></li><li><a href="#2-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84">字母异位词分组</a> 1<ul><li>转换为字符数组使用Arrays.sort()进行排序，排序后查询哈希表，放入<code>HashMap&lt;String,List&lt;String&gt;&gt;</code>中，键为排序后字符串，值为原始字符串的集合</li></ul></li><li><a href="#3-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97">最长连续序列</a> ⭐ 1<ul><li>使用HashSet去重后，遍历HashSet</li><li>当<code>nums[i]-1</code>不存在时，开始从<code>nums[i]</code>往后查询</li><li>不断查询<code>nums[i]+1,nums[i]+2...</code></li></ul></li><li><a href="#4-%E7%A7%BB%E5%8A%A8%E9%9B%B6">移动零</a> 1<ul><li>第一遍遍历： j初始为0，j 作为非零元素的插入位置，把所有 非零元素 依次填入 <code>nums[j]</code></li><li>第二遍遍历： 把 j 之后的元素全部填 0。</li></ul></li><li><a href="#5-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8">盛最多水的容器</a> 1<ul><li>left从左，right从右向中间移动，计算区间面积，每次计算后<strong>移动高度较小的指针</strong>，向中间靠拢</li></ul></li><li><a href="#6-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">三数之和</a> ⭐ 1<ul><li><strong>先排序</strong>，三个指针：<ul><li>i : 从0到nums.length-2遍历</li><li>left: 从i+1往后遍历</li><li>right：从nums.length-1往前遍历</li></ul></li><li>如果sum&#x3D;0: left++,right–; 如果sum&gt;0: right–; 如果sum&lt;0: left++;</li><li>i 在遍历时，跳过相同的 <code>nums[i]</code>;  left 和 right 指针移动时，也要跳过重复值。</li></ul></li><li><a href="#7-%E6%8E%A5%E9%9B%A8%E6%B0%B4">接雨水</a> 1<ul><li><strong>水的面积&#x3D;全部面积-柱子的面积</strong><ul><li>全部面积 +&#x3D; 每一层的长度*1</li></ul></li></ul></li><li><a href="#8-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2">无重复字符的最长字串</a> 1 ⭐⭐⭐⭐<ul><li>用一个<strong>集合ArrayList维护当前的无重复子串</strong>,遍历字符串，如果当前字符已在list集合中重复，记录当前最大值，删除list中重复元素及以前的元素，添加当前元素</li></ul></li><li><a href="#9-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">找到字符串中所有字母异位词</a> 1<ul><li><strong>滑动窗口 + 频率数组</strong>比较；维护两个长度为26的数组来比较窗口内的字符频率是否和 p 匹配，每次移除窗口左边的元素，添加新字符到窗口的右侧</li></ul></li><li><a href="#10-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">和为K的子数组</a> 1<ul><li><strong>前缀和 + 哈希表</strong><ul><li>哈希表：Key存储前缀和，Value存储这个前缀和出现的次数</li><li>通过 prefixSum - k 计算是否有之前的前缀和能构成和 k 的子数组</li><li>preSum - k &#x3D; (前面一个preSum索引,当前索引)的子数组之和</li><li>加上之前的前缀和出现的次数即可</li><li><strong>注意</strong>：哈希表要添加： <code>map.put(0,1)</code></li></ul></li></ul></li><li><a href="#11-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC">滑动窗口最大值</a> 1<ul><li><strong>单调双端队列</strong>：使用双端队列(Deque)存储<strong>索引</strong>，在遍历数组时始终保持队列中元素对应的值<strong>单调递减</strong>，并在每次滑动窗口形成后，通过<strong>队头索引</strong>快速获取当前窗口的最大值，同时<strong>移除队头已滑出窗口范围的元素</strong>和<strong>队尾比当前元素小的元素</strong></li><li><strong>如何更新队头的最大值？</strong><ul><li>当新元素来的时候，从队尾往队头移动，把小于新元素的元素全部出队，然后从队尾入队</li></ul></li></ul></li><li><a href="#12-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">最小覆盖子串</a> ⭐⭐ 1<ul><li><strong>滑动窗口+哈希表</strong><ul><li><strong>一个哈希表记录t</strong>的字符出现的次数，<strong>另一个哈希表记录s</strong>当前窗口的字符出现的次数</li><li>右指针<strong>right先往右移动</strong>，<strong>直到包含t所有的字符</strong>(借助valid记录窗口内满足条件的字符数)，记录当前最短子串的右边界</li><li>左指针<strong>left收缩窗口</strong>，尝试寻找更短的子串，记录当前最短子串的左边界</li></ul></li></ul></li><li><a href="#13-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">最大子数组和</a> 1<ul><li><strong>局部最优 -&gt; 推导全局最优</strong> sum+&#x3D;当前元素，如果sum&gt;max，更新max；如果sum&lt;0，将sum重置为0(因为前面的子数组对后续没有正向贡献)</li></ul></li><li><a href="#14-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">合并区间</a> ⭐⭐⭐ 1<ul><li><strong>先根据start排序</strong>：</li><li><strong>初始化</strong>结果集合，<strong>加入第一个区间</strong></li><li>遍历剩余区间：<ul><li>如果<strong>当前区间和结果中的最后一个区间有重叠</strong>（即：上一个区间的 end &gt;&#x3D; 当前区间的 start）<ul><li>→ 合并两个区间（<strong>更新 end 为两者最大值</strong>）</li></ul></li><li>否则<strong>直接加入结果集合</strong>（无重叠）</li></ul></li></ul></li><li><a href="#15-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84">轮转数组</a> 1<ul><li><strong>三次翻转法</strong>：<ul><li>先整体翻转数组；再翻转前 k 个元素；最后翻转后 n-k个元素；</li></ul></li><li><strong>注意：</strong> k可能大于数组长度，所以要先对数组长度取模(k%&#x3D;nums.length;)</li></ul></li><li><a href="#16-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF">除自身以外数组的乘积</a> 1<ul><li><strong>前缀积和后缀积</strong>：第一次从前往后遍历，构建结果数组每个位置前缀乘积，第二次从后往前遍历乘上后缀乘积</li></ul></li><li><a href="#17-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">缺失的第一个正数</a> ⭐ 1<ul><li>将<code>[8,2,0,1,3,4]</code>遍历转换为<code>[1,2,3,4,0,8]</code>,通过原地<strong>交换</strong>的方式将正整数放到对应的位置上，然后从头遍历找到第一个不符合的正数</li></ul></li><li><a href="#18-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6">矩阵置零</a> 1<ul><li>利用<strong>矩阵的第一行和第一列作为标记位</strong>来记录哪一行、哪一列需要被置 0  <strong>注意：</strong> 标记记录的过程中应该跳过第一行和第一列</li></ul></li><li><a href="#19-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">螺旋矩阵</a> ⭐ 1<ul><li>定义top, bottom, left, right<strong>四个边界变量</strong>控制遍历范围</li><li>按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素</li><li><strong>注意：最后两个遍历(往左和往上)要判断是否还有行或列剩下</strong></li></ul></li><li><a href="#20-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">旋转图像</a> 1<ul><li><strong>旋转&#x3D;转置+翻转</strong><ul><li>先转置：将 <code>matrix[i][j]</code> 变成 <code>matrix[j][i]</code>。</li><li>再水平翻转：让 <code>matrix[j][i]</code> 变成 <code>matrix[j][n-1-i]</code>。</li></ul></li></ul></li><li><a href="#21-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii">搜索二维矩阵-ii</a> 1<ul><li>从右上角出发，向下或向左移动，相等时返回true</li></ul></li><li><a href="#22-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">相交链表</a> 1<ul><li><strong>双指针一块走</strong>，当 pA 走到尾巴 null，它就切换到 headB 重新开始。当 pB 走到尾巴 null，它就切换到 headA 重新开始。如果两个链表有交点，那么两个指针<strong>一定会在交点相遇</strong>。如果没有交点，最终两个指针<strong>都会走到 null</strong></li></ul></li><li><a href="#23-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a> ⭐ 1</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">原链表:1→2→3→4</span><br><span class="hljs-attr">1:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1</span> <span class="hljs-number">2</span><span class="hljs-string">→3→4</span><br><span class="hljs-attr">2:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2</span> <span class="hljs-number">3</span><span class="hljs-string">→4</span><br><span class="hljs-attr">3:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3</span> <span class="hljs-number">4</span><br><span class="hljs-attr">4:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3←4</span><br></code></pre></td></tr></table></figure><ol start="24"><li><a href="#24-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">回文链表</a> 1<ul><li>先用<strong>快慢指针找中点</strong>，把<strong>中点以后的链表反转</strong>，<strong>再比较</strong>反转后的一半链表和原链表的前一半</li></ul></li><li><a href="#25-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">环形链表</a> 1<ul><li><strong>快慢指针找环</strong>：如果相遇了返回true</li></ul></li><li><a href="#26-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii">环形链表-ii</a> 1 ⭐<ul><li>当快慢指针相遇时：定义<strong>一个指针从相遇点开始走</strong>；<strong>另一个指针从链表头开始走</strong>，他们<strong>会在环的入口点相遇</strong></li></ul></li><li><a href="#27-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">合并两个有序链表</a> ⭐⭐⭐ 1<ul><li>使用<strong>虚拟头结点</strong>，双指针遍历两个链表；<strong>谁的值小，就连接谁</strong>；遍历完一个，直接连接另一个</li></ul></li><li><a href="#28-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0">两数相加</a> 1<ul><li>创建一个新链表记录两个链表之和，<strong>注意进位</strong></li></ul></li><li><a href="#29-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9">删除链表的倒数第n个结点</a> 1⭐⭐⭐⭐⭐<ul><li>创建一个dummy,<strong>快慢指针指向dummy</strong>；<strong>快指针先走n+1步</strong>，然后<strong>快慢指针一起移动直到快指针为null</strong>，此时慢指针的位置就是要删除结点的前一个结点位置</li></ul></li><li><a href="#30-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">两两交换链表中的节点</a> 1<ul><li>模拟即可</li></ul></li><li><a href="#31-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8">k个一组翻转链表</a> ⭐⭐<ul><li><strong>反转</strong>+<strong>找到K个结点一组</strong>即可，每次记录开始结点和终止结点</li></ul></li><li><a href="#32-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">随机链表的复制</a> 1<ul><li>使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制</li></ul></li><li><a href="#33-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8">排序链表</a>  1<ul><li><strong>插入排序</strong>&#x2F;<strong>归并排序</strong><ul><li>使用<strong>快慢指针找到链表中点</strong>，将链表以中点<strong>拆分</strong>成左右链表递归排序，将两个链表<strong>合并</strong>成有序链表</li></ul></li></ul></li><li><a href="#34-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8">合并k个升序链表</a> 1<ul><li>使用<strong>最小堆</strong>(优先级队列)维护k个链表的当前最小节点，每次<strong>出队最小结点</strong>，<strong>入队最小结点的下一个结点</strong>，直到队列为空</li></ul></li><li><a href="#35-lru%E7%BC%93%E5%AD%98">lru缓存</a><ul><li>定义<strong>双向链表</strong>维护缓存队列，定义<strong>哈希表</strong>维护当前队列的键和值，并提供快速查找结点</li></ul></li><li><a href="#36-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的中序遍历</a> 1<ul><li><strong>左根右递归</strong></li></ul></li><li><a href="#37-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a><ul><li>当前节点为空返回0，递归计算左右子树的深度，取左右子树的较大值加1</li></ul></li><li><a href="#38-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">翻转二叉树</a> 1<ul><li>递归交换左右子树即可</li></ul></li><li><a href="#39-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">对称二叉树</a> 1 ⭐<ul><li>两个子树<strong>都为空则对称</strong></li><li>如果<strong>左右子树都不为空且值相等</strong>，同时<strong>左树的右子树和右树的左子树对称</strong>，同时<strong>左树的左子树和右树的右子树对称</strong>，则对称</li></ul></li><li><a href="#40-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">二叉树的直径</a> 1<ul><li>递归计算每个节点的<strong>左右子树的最大深度</strong>，<strong>当前节点的直径&#x3D;左子树深度+右子树深度</strong>，<strong>更新</strong>最大直径</li></ul></li><li><a href="#41-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的层序遍历</a><ul><li>使用队列存储每层的结点，使用size记录当前层结点的个数，循环<strong>出队</strong>层中的结点，<strong>入队下一层左右子树的结点</strong>，直到队空为止</li></ul></li><li><a href="#42-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">将有序数组转换为二叉搜索树</a><ul><li>以数组的中间元素作为root结点，左区间递归构造左子树root.left,右区间递归构造右子树root.right，直到数组区间索引left&gt;right终止</li></ul></li><li><a href="#43-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">验证二叉搜索树</a><ul><li><strong>构建子树的大小边界</strong>，左右子树的值在边界外返回false，递归遍历左右子树</li></ul></li><li><a href="#44-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">二叉搜索树中第k小的元素</a><ul><li>二叉搜索树用<strong>中序遍历</strong>即为一个升序的数组，<strong>直接计数</strong>到第k个遍历的结点时，返回当前元素即可</li></ul></li><li><a href="#45-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE">二叉树的右视图</a> ⭐<ul><li>使用队列进行<strong>层序遍历</strong>，找到每层最右边的结点即可</li></ul></li><li><a href="#46-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8">二叉树展开为链表</a><ul><li>创建一个新结点，使用<strong>新结点的右子树连接当前root结点</strong>，然后<strong>前序遍历</strong>递归连接root的左子树、root的右子树</li></ul></li><li><a href="#47-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">从前序与中序遍历序列构造二叉树</a><ul><li><strong>哈希表</strong>存储中序数组便于查找索引，前序数组第一个元素就是根节点，使用<strong>中序数组划分左右子树</strong>后进行递归构建左右子树</li></ul></li><li><a href="#48-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii">路径总和-iii</a><ul><li>使用<strong>哈希表存储前缀和</strong>出现次数，</li><li>backtracking(){终止条件{在哈希表找到(<strong>当前路径总和-目标值</strong>)的次数加到结果}，在哈希表<strong>添加当前路径总和</strong>，<strong>递归</strong>左右子树，<strong>回溯撤销</strong>哈希表添加的当前路径总和}</li></ul></li><li><a href="#49-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉树的最近公共祖先</a> ⭐<ul><li>先判断当前结点是否是p或q，再递归判断左右子树，分为左右子树都找到了结点，左右子树只有一个找到了，左右子树都没找到四种情况</li></ul></li><li><a href="#50-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">二叉树中的最大路径和</a> ⭐<ul><li>用一个全局变量记录最大值，<strong>递归记录左右子树的最大贡献</strong>，更新最大值，返回当前结点能为父节点的最大路径值(<strong>只能选左右子树的其中一个贡献大的子树</strong>)</li></ul></li><li><a href="#51-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">岛屿数量</a> 1 ⭐<ul><li>若当前元素为’1’则计数加1，并递归的感染周围的元素为’2’，防止重复计数</li></ul></li><li><a href="#52-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90">腐烂的橘子</a> 1<ul><li>先把当前状态转换替代成其他值，用<strong>时间标记当前腐烂的橘子</strong>，下一轮腐烂的橘子&#x3D;当前time+1，直到没有新橘子被感染跳出循环</li></ul></li><li><a href="#53-%E8%AF%BE%E7%A8%8B%E8%A1%A8">课程表</a><ul><li>判断一个有向图是否有环，不会….</li></ul></li><li><a href="#54-%E5%AE%9E%E7%8E%B0trie%E5%89%8D%E7%BC%80%E6%A0%91">实现trie前缀树</a><ul><li>面试会考吗？不会》….</li></ul></li><li><a href="#55-%E5%85%A8%E6%8E%92%E5%88%97">全排列</a><ul><li>用一个boolean<strong>数组visited</strong>保存已经访问的元素，下次循环直接跳过；回溯三部曲：<strong>终止条件，for循环递归，回溯撤销</strong></li></ul></li><li><a href="#56-%E5%AD%90%E9%9B%86">子集</a> 1<ul><li>收集子集，for(){收集元素，递归到下一层元素，回溯撤销}</li></ul></li><li><a href="#57-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88">电话号码的字母组合</a><ul><li>通过回溯法依次遍历输入数字串 digits，从第一个数字开始，根据数字映射的字母表，逐个尝试<strong>每个字母，将其加入当前路径</strong> path，然后<strong>递归处理下一个数字</strong>。当遍历到<strong>路径长度等于输入长度</strong>时，说明已生成一个完整组合，将其拼接成字符串<strong>加入结果列表</strong> result，随后<strong>回退</strong>（撤销最后一个字符）继续尝试其它可能，直到穷尽所有组合。</li></ul></li><li><a href="#58-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C">组合总和</a> 1 ⭐<ul><li>当前缀和等于target时，终止递归；for(){添加当前元素，递归进入下一层，回溯撤销}</li></ul></li><li><a href="#59-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90">括号生成</a> 1<ul><li>当<strong>左右括号用完了</strong>终止递归加入结果(left&#x3D;&#x3D;0&amp;&amp;right&#x3D;&#x3D;0)</li><li>当<strong>左括号数量大于0</strong>可以选择左括号</li><li>当<strong>右括号剩余数量大于左括号剩余数量</strong>，可以选择右括号，然后<strong>添加递归回溯</strong></li></ul></li><li><a href="#60-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2">单词搜索</a> 1<ul><li>通过双重循环遍历二维字符数组的每个元素，<strong>找到与单词首字符相同的位置后</strong>，调用递归函数<strong>向上下左右四个方向查找下一个字符</strong>，每访问一个字符就将其暂时<strong>标记为已访问</strong>（用 <code>#</code> 替换），<strong>防止重复</strong>走回头路，递归如果找到完整单词则返回 true，<strong>未找到则恢复该位置原字符</strong>，继续尝试其他路径，直到所有可能都搜索完毕。</li></ul></li><li><a href="#61-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2">分割回文串</a> 1<ul><li>通过从字符串的起始位置开始，用循环<strong>依次截取不同长度的子串</strong>，判断当前子串是否是回文串，如果是则将其加入路径列表，并<strong>递归继续处理剩余部分</strong>，直到遍历完整个字符串，将完整路径加入结果列表，递归返回时通过 removeLast() 撤销上一次添加的子串，继续尝试下一种截取方式。</li></ul></li><li><a href="#62-n%E7%9A%87%E5%90%8E">n皇后</a> 1<ul><li>循环尝试在棋盘的<strong>每一行每一列放置皇后</strong>，遇到<strong>符合条件的位置</strong>就将皇后<strong>放下</strong>，并<strong>递归进入下一行</strong>继续放置，直到所有行都放置完毕时将当前棋盘状态转换成字符串列表加入结果集中，递归返回时通过将皇后位置<strong>回溯复原</strong>，继续尝试下一列的位置，最终遍历出所有可能的皇后摆放方案。</li></ul></li><li><a href="#63-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE">搜索插入位置</a> 1<ul><li>二分查找</li></ul></li><li><a href="#64-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5">搜索二维矩阵</a><ul><li>二分查找：从右上角元素向下或向左移动</li></ul></li><li><a href="#65-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE">在排序数组中查找元素的第一个和最后一个位置</a><ul><li>二分查找<strong>先查找第一个位置，再查找结束位置</strong></li><li>查找左边位置时，当<code>nums[mid] == target</code>，<code>right = mid - 1</code>不断向左收缩</li><li>查找右边位置时，当<code>nums[mid] == target</code>，<code>left = mid + 1</code>不断向右收缩</li></ul></li><li><a href="#66-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">搜索旋转排序数组</a> 1<ul><li>直接对数组进行二分，其中一定有一个子区间是<strong>有序的</strong>，另一个<strong>部分有序</strong></li><li>判断哪个区间是有序的，然后继续进行逻辑判断</li></ul></li><li><a href="#67-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">寻找旋转排序数组的最小值</a> ⭐<ul><li>如果 <code>nums[mid] &gt; nums[right]</code>，最小值一定在右边，left&#x3D;mid+1</li><li>如果 <code>nums[mid] &lt;= nums[right]</code>，最小值在左边，right&#x3D;mid</li><li>退出循环时，left &#x3D;&#x3D; right，正是最小值的位置</li></ul></li><li><a href="#68-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">寻找两个正序数组的中位数</a> 1<ul><li>暴力依次从前往后走 mid 步，此时是O(m+n)</li></ul></li><li><a href="#69-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7">有效的括号</a><ul><li>遇到左括号入栈，右括号如果能与栈顶左括号匹配则正确，不匹配返回false</li></ul></li><li><a href="#70-%E6%9C%80%E5%B0%8F%E6%A0%88">最小栈</a> 1<ul><li>用一个<strong>链表</strong>包含val和min两个成员变量，min用来保存最小值，入栈就是链表头结点<strong>头插一个新元素</strong>，出栈就是指向头结点下一个结点</li></ul></li><li><a href="#71-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81">字符串解码</a><ul><li>难，使用两个栈</li></ul></li><li><a href="#72-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6">每日温度</a> 1<ul><li>使用一个单调<strong>递减</strong>的栈，栈用来<strong>存储索引</strong></li><li>如果当前温度小于等于栈顶温度则入栈</li><li>当前温度大于栈顶元素，栈顶元素的天数更新并出栈</li></ul></li><li><a href="#73-%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱形图中最大的矩形</a><ul><li><strong>双指针暴力</strong>，以当前柱子<strong>向左向右</strong>，找比自己高度大(大于等于)的柱子，计算当前面积并更新</li></ul></li><li><a href="#74-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">数组中的第k个最大元素</a> 1 ⭐⭐⭐<ul><li>使用<strong>小顶堆</strong>，堆顶元素始终是最小的元素，如果当前元素大于堆顶元素，堆顶元素出堆，当前元素入堆，最后堆顶元素就是第k个大的元素；<strong>换句话说就是用小顶堆把k-1个小的元素挤出去</strong></li></ul></li><li><a href="#75-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">前k个高频元素</a><ul><li><strong>哈希表统计频率</strong>，用<strong>小根堆</strong>维护前k个高频元素</li><li><code>PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;(k,(l1, l2) -&gt; l1.getValue() - l2.getValue());</code></li><li><code>for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {}</code></li></ul></li><li><a href="#76-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">数据流的中位数</a> ⭐<ul><li>利用两个堆（<strong>大根堆+小根堆</strong>），</li><li>添加元素<strong>先添加到小顶堆</strong>，再把小顶堆的<strong>堆顶元素添加到大顶堆</strong>，</li><li>如果小顶堆大小小于大顶堆大小(<code>minHeap.size() &lt; maxHeap.size()</code>)，把<strong>大顶堆的堆顶元素添加到小顶堆</strong></li></ul></li><li><a href="#77-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">买卖股票的最佳时机</a><ul><li>要想卖的时候利润最多，就要在之前<strong>最便宜的时候买入</strong>，因此维护之前的<strong>最小值</strong>即可。</li></ul></li><li><a href="#78-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">跳跃游戏</a> 1<ul><li>维护一个 farthest 变量，记录能跳到的最远距离</li><li>如果<strong>当前索引超过了能跳到的最远距离，则跳不到终点</strong></li></ul></li><li><a href="#79-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii">跳跃游戏-ii</a><ul><li>局部最优，找到<strong>下一个能跳的最远的位置</strong>，找最大的(<strong>下一个位置索引加上下一个位置最大跳跃距离</strong>)</li><li>如果当前位置已经能到达终点，count++,跳出循环</li></ul></li><li><a href="#80-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4">划分字母区间</a><ul><li>使用<strong>哈希表</strong>保存每个字符的最后出现位置</li><li>若发现<strong>某个字符的最后出现位置超出了当前片段范围，则更新 nextIndex</strong></li></ul></li><li><a href="#81-%E7%88%AC%E6%A5%BC%E6%A2%AF">爬楼梯</a> ⭐<ul><li><code>dp[i]</code>： 爬到第i层楼梯，有<code>dp[i]</code>种方法</li></ul></li><li><a href="#82-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">杨辉三角</a><ul><li><code>dp[i][j]</code> 代表第i行第j列元素的值</li><li><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></li></ul></li><li><a href="#83-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">打家劫舍</a> 1<ul><li><code>dp[i]</code>：盗窃到第i间房间所获得的最高金额</li><li><code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code></li></ul></li><li><a href="#84-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">完全平方数</a><ul><li>转换为<strong>完全背包问题</strong><ul><li><code>dp[i][j]</code> 表示使用前 i 个完全平方数（1^2, 2^2, …, i^2）凑出 j 需要的最少个数。</li><li>不选当前平方数 i^2：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行）。</li><li>选择当前平方数 i^2：<code>dp[i][j] = dp[i][j - square] + 1</code>（选 i^2 之后，继续凑 j - i^2）</li></ul></li></ul></li><li><a href="#85-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">零钱兑换</a><ul><li>转换为<strong>完全背包问题</strong></li><li><code>dp[i][j]</code>：用前 i 种硬币，凑成金额 j 所需的最少硬币数量</li></ul></li><li><a href="#86-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">单词拆分</a> 1<ul><li><code>dp[i]</code> 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成</li><li><code>dp[i]</code>的值依赖于i<strong>之前某个 dp[j] &#x3D;&#x3D; true</strong>，说明 <code>s[0 ~ j-1]</code>可以用字典单词拼接。 s.substring(j, i) 必须在 wordDict 里面，说明 <strong>j~i-1 这一段是一个合法单词</strong></li></ul></li><li><a href="#87-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列</a><ul><li><code>dp[i]</code> 表示<strong>以 <code>nums[i]</code> 结尾的最长递增子序列的长度</strong></li><li>两次遍历：第一次遍历求每个以 nums[i] 结尾的最长递增子序列，第二次遍历i之前的元素，比较元素是否加入当前元素的后面作为结尾</li></ul></li><li><a href="#88-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84">乘积最大子数组</a> ⭐<ul><li>用max和min维护遍历到当前元素时的最大值和最小值</li><li>如果当前元素是<strong>负数</strong>，那么会导致<strong>最大的变最小的，最小的变最大的</strong>。因此交换两个的值。</li><li><code>max = Math.max(max * nums[i], nums[i])</code><ul><li>对于每一个 <code>nums[i]</code>，最大乘积有两种选择： </li><li>1️⃣ <strong>继续累乘</strong>：<code>max * nums[i]</code> —— 把前面的乘积继续乘上这个 nums[i]，不切断子数组。</li><li>2️⃣ <strong>重新开始</strong>：<code>nums[i]</code> —— 从当前位置 i 开始一个新的乘积子数组。</li></ul></li></ul></li><li><a href="#89-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">分割等和子集</a><ul><li><strong>转换为0-1背包问题</strong></li><li><code>dp[i][j]</code>：从前 i 个数里，能否选出一些数，使它们的和接近j</li></ul></li><li><a href="#90-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7">最长有效括号</a> ⭐<ul><li><code>dp[i]</code> 表示以下标 i <strong>结尾</strong>的最长有效括号子串的长度，主要在于分情况讨论</li><li>当 <code>s[i] == &#39;(&#39;</code> 时</li><li>当 <code>s[i] == &#39;)&#39;</code> 时<ul><li>如果 <code>s[i-1] == &#39;(&#39;</code></li><li>如果 <code>s[i-1] == &#39;)&#39;</code></li><li>如果 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code></li></ul></li></ul></li><li><a href="#91-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">不同路径</a> 1<ul><li><code>dp[i][j]</code>代表到达第i行第j列的不同路径有多少个</li></ul></li><li><a href="#92-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">最小路径和</a> 1<ul><li><code>dp[i][j]</code>:走到第i行第j列时的最小总和</li></ul></li><li><a href="#93-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">最长回文子串</a> ⭐⭐<ul><li>定义 <code>dp[i][j]</code> 表示字符串<strong>从索引 i 到 j 的子串是否是回文子串</strong></li><li>更长的子串，<code>s[i] == s[j]</code> 时，它是否回文取决于 <code>s[i+1:j-1]</code> 是否回文串</li><li><strong>外层循环 i 递减</strong>（从后往前遍历）,内层循环 j 递增（从左到右遍历）,因为 <code>dp[i][j]</code> 依赖于 <code>dp[i+1][j-1]</code></li></ul></li><li><a href="#94-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">最长公共子序列</a> ⭐⭐⭐ 1<ul><li><code>dp[i][j]</code>: text1前i个字符串和text2前j个字符串的最长公共子序列长度</li><li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>如果i和j的字符不相同，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li></ul></li><li><a href="#95-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">编辑距离</a> 1 ⭐<ul><li><code>dp[i][j]</code> 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符的最小操作数</li><li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] </code></li><li>如果i和j的字符不相同<ul><li>替换操作：dp[i-1][j-1] + 1</li><li>删除操作：dp[i-1][j] + 1</li><li>插入操作：dp[i][j-1] + 1</li></ul></li></ul></li><li><a href="#96-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">只出现一次的数字</a><ul><li>使用<strong>异或</strong>运算符(^)，a^a&#x3D;0,a^0&#x3D;a</li></ul></li><li><a href="#97-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0">多数元素</a><ul><li>res&#x3D;当前元素，用一个计数器，当<strong>出现自己时，计数+1</strong>，<strong>不是自己计数-1</strong>，当<strong>计数器&#x3D;0时，重新把res置为当前元素</strong></li></ul></li><li><a href="#98-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB">颜色分类</a><ul><li><strong>两个指针</strong>：一个指针<strong>指向0位置</strong>，依次存储0元素，一个指针<strong>指向数组结尾位置</strong>，依次存储2元素</li></ul></li><li><a href="#99-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">下一个排列</a> 1<ul><li><code>2, 6, 3, 5, 4, 1 --&gt; 2, 6, 4, 1, 3, 5</code> 分为以下几步：<ol><li>从后往前找到3</li><li>从后往前找，找到第一个大于3的数：4</li><li><code>swap(3,4)</code>，此时：<code>2, 6, 4, 5, 3, 1</code></li><li>最后<strong>反转5，3，1</strong>即可得到<code>2, 6, 4, 1, 3, 5</code></li></ol></li></ul></li><li><a href="#100-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0">寻找重复数</a> 1<ul><li><strong>快慢指针找环</strong>，相遇之后，将fast重新置为0，两个指针每次移动一步，再次相遇就是重复数所在位置</li><li><code>fast = nums[nums[fast]]</code> &#x2F;&#x2F; 快指针每次移动两步</li><li><code>slow = nums[slow]</code> &#x2F;&#x2F; 慢指针每次移动一步</li></ul></li></ol><hr><ol start="201"><li><a href="#201-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">合并两个有序数组</a> ⭐<ul><li><strong>双指针从后往前合并</strong>，避免覆盖还没处理的数据</li></ul></li><li><a href="#202-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0">字符串相加</a> ⭐⭐<ul><li>从 num1 和 num2 的末尾开始，一位一位相加,记得进位</li></ul></li><li><a href="#203-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0">最小k个数</a> ⭐<ul><li>使用<strong>大顶堆</strong>（PriorityQueue）来筛选数组中最小的 k 个数</li></ul></li><li><a href="#204-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii">买卖股票的最佳时机-ii</a><ul><li>贪心：<strong>只要今天比昨天大，就卖出</strong></li></ul></li><li><a href="#205-%E6%9C%80%E5%A4%A7%E6%95%B0">最大数</a><ul><li>使用<strong>自定义排序规则</strong>：<code>Arrays.sort(strNums,(a,b)-&gt;(b+a).compareTo(a+b));</code></li></ul></li><li><a href="#206-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80">最长公共前缀</a><ul><li>用第一个字符串的每个字符，依次与后面所有字符串的相应字符进行比较即可</li></ul></li><li><a href="#207-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">重排链表</a> ⭐⭐⭐⭐⭐<ul><li><strong>重排链表&#x3D;找链表中点+反转链表+合并链表</strong></li></ul></li><li><a href="#208-%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80">复原ip地址</a><ul><li><strong>回溯算法</strong></li></ul></li><li><a href="#209-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">排序数组</a><ul><li><strong>快速排序</strong>：O(nlogn)</li></ul></li><li><a href="#210-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0ab">多线程交替打印ab</a><ul><li>synchronized+wait()&#x2F;notify()</li></ul></li></ol><hr><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><ul><li><strong>一句话总结</strong>：使用HashMap存储数组元素，查询map中是否存在target-nums[i]</li></ul><h2 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a>1.1 题目描述</h2><ul><li>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</li><li>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素</li><li>你可以按任意顺序返回答案。</li></ul><h2 id="1-2-算法思想和代码实现"><a href="#1-2-算法思想和代码实现" class="headerlink" title="1.2 算法思想和代码实现"></a>1.2 算法思想和代码实现</h2><h3 id="1-2-1-暴力枚举法"><a href="#1-2-1-暴力枚举法" class="headerlink" title="1.2.1 暴力枚举法"></a>1.2.1 暴力枚举法</h3><p>通过<strong>两层循环遍历数组</strong>的每一对元素，判断它们的和是否等于目标值 target。如果找到符合条件的两个数，你就将它们的下标保存在结果数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;<br>                    result[<span class="hljs-number">0</span>] = i;<br>                    result[<span class="hljs-number">1</span>] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-2-哈希表实现"><a href="#1-2-2-哈希表实现" class="headerlink" title="1.2.2 哈希表实现"></a>1.2.2 哈希表实现</h3><p>使用 哈希表（HashMap） 来实现 O(n) 的时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(target - nums[i])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;<br>        &#125;<br>        map.put(nums[i], i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2. 字母异位词分组"></a>2. 字母异位词分组</h1><ul><li><strong>一句话总结</strong>：转换为字符数组使用Arrays.sort()进行排序，排序后查询哈希表，放入<code>HashMap&lt;String,List&lt;String&gt;&gt;</code>中，键为排序后字符串，值为原始字符串的集合</li></ul><h2 id="2-1-题目描述"><a href="#2-1-题目描述" class="headerlink" title="2.1 题目描述"></a>2.1 题目描述</h2><ul><li>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</li><li><strong>字母异位词</strong>： 是由重新排列源单词的所有字母得到的一个新单词。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><h2 id="2-2-算法思想和代码实现"><a href="#2-2-算法思想和代码实现" class="headerlink" title="2.2 算法思想和代码实现"></a>2.2 算法思想和代码实现</h2><h3 id="2-2-1-方法1"><a href="#2-2-1-方法1" class="headerlink" title="2.2.1 方法1"></a>2.2.1 方法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 将第一个元素放入第一个分组</span><br>    List&lt;String&gt; firstGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    firstGroup.add(strs[<span class="hljs-number">0</span>]);<br>    ans.add(firstGroup);<br><br>    <span class="hljs-comment">// 遍历剩余的字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 标记是否找到匹配的分组</span><br><br>        <span class="hljs-keyword">for</span> (List&lt;String&gt; group : ans) &#123;<br>            <span class="hljs-keyword">if</span> (isSameWords(strs[i], group.get(<span class="hljs-number">0</span>))) &#123; <span class="hljs-comment">// 和已有分组的第一个元素比较</span><br>                group.add(strs[i]);<br>                found = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到匹配的分组后跳出</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有找到匹配的分组，则创建新的分组</span><br>        <span class="hljs-keyword">if</span> (!found) &#123;<br>            List&lt;String&gt; newList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            newList.add(strs[i]);<br>            ans.add(newList);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">// 判断两个字符串是否是异位词</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameWords</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (str1.length() != str2.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>[] ch1 = str1.toCharArray();<br>    <span class="hljs-type">char</span>[] ch2 = str2.toCharArray();<br>    Arrays.sort(ch1);<br>    Arrays.sort(ch2);<br><br>    <span class="hljs-keyword">return</span> Arrays.equals(ch1, ch2);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-方法2"><a href="#2-2-2-方法2" class="headerlink" title="2.2.2 方法2"></a>2.2.2 方法2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 为空判断</span><br>        <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br><br>        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            <span class="hljs-comment">// 转换为字符数组并对其排序</span><br>            <span class="hljs-type">char</span>[] chars = strs[i].toCharArray();<br>            Arrays.sort(chars);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sortedChars</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br><br>            <span class="hljs-comment">// 在哈希表中查询是否存在，存在则添加到集合中，不存在创建一个新的键值对，值为集合列表</span><br>            <span class="hljs-keyword">if</span> (map.containsKey(sortedChars)) &#123;<br>                map.get(sortedChars).add(strs[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                map.put(sortedChars, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                map.get(sortedChars).add(strs[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 将哈希表中的值添加到结果集合中</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : map.entrySet()) &#123;<br>            res.add(entry.getValue());<br>        &#125;<br><br><span class="hljs-comment">//        //返回遍历map的所有值</span><br><span class="hljs-comment">//        return new ArrayList&lt;&gt;(map.values());</span><br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="3-最长连续序列"><a href="#3-最长连续序列" class="headerlink" title="3. 最长连续序列"></a>3. 最长连续序列</h1><ul><li><strong>一句话总结</strong>：使用HashSet去重后，遍历HashSet,当<code>nums[i]-1</code>不存在时开始从<code>nums[i]</code>往后查询，不断查询<code>nums[i]+1,nums[i]+2...</code></li></ul><h2 id="3-1-题目描述"><a href="#3-1-题目描述" class="headerlink" title="3.1 题目描述"></a>3.1 题目描述</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">200</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><h2 id="3-2-算法思想和代码实现"><a href="#3-2-算法思想和代码实现" class="headerlink" title="3.2 算法思想和代码实现"></a>3.2 算法思想和代码实现</h2><h3 id="3-2-1-HashSet-去重-排序-遍历"><a href="#3-2-1-HashSet-去重-排序-遍历" class="headerlink" title="3.2.1  HashSet 去重 + 排序 + 遍历"></a>3.2.1  HashSet 去重 + 排序 + 遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//使用HashSet去重</span><br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-type">int</span>[] nums1=  set.stream().mapToInt(i -&gt; i).toArray();<br><br>    <span class="hljs-comment">//对数组元素排序</span><br>    Arrays.sort(nums1);<br><br>    <span class="hljs-comment">//遍历数组，对符合的最长序列进行计数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums1.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums1[i]==nums1[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>)&#123;<br>            max++;<br>            <span class="hljs-keyword">if</span>(max&gt;res)<br>                res = max;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            max=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-使用-哈希表（HashSet）-贪心"><a href="#3-2-2-使用-哈希表（HashSet）-贪心" class="headerlink" title="3.2.2 使用 哈希表（HashSet）+ 贪心"></a>3.2.2 使用 哈希表（HashSet）+ 贪心</h3><ol><li>先用 HashSet 存储所有数字，去重并提供 O(1) 时间复杂度的查询。</li><li>遍历数组中的每个数字 num：<ul><li>如果 num-1 不在 set 中，说明它是一个连续序列的起点，开始寻找最长的连续序列。</li><li>依次检查 num+1, num+2，直到找不到为止，更新最长序列的长度。</li></ul></li><li>遍历完数组后，返回最长的连续序列长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        set.add(num); <span class="hljs-comment">// 添加到 HashSet 去重</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>        <span class="hljs-comment">// 只有当 num-1 不在集合中时，才从 num 开始找</span><br>        <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currNum</span> <span class="hljs-operator">=</span> num;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 不断查找 num+1，num+2...</span><br>            <span class="hljs-keyword">while</span> (set.contains(currNum + <span class="hljs-number">1</span>)) &#123;<br>                currNum++;<br>                currLen++;<br>            &#125;<br><br>            maxLen = Math.max(maxLen, currLen);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-移动零"><a href="#4-移动零" class="headerlink" title="4. 移动零"></a>4. 移动零</h1><p><strong>一句话总结：</strong></p><ul><li>第一遍遍历： j初始为0，j 作为非零元素的插入位置，把所有 非零元素 依次填入 <code>nums[j]</code></li><li>第二遍遍历： 把 j 之后的元素全部填 0</li></ul><h2 id="4-1-题目描述"><a href="#4-1-题目描述" class="headerlink" title="4.1 题目描述"></a>4.1 题目描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><ul><li>请注意：必须在不复制数组的情况下原地对数组进行操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br><br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">0</span>]<br>输出: [<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="4-2-算法思想和代码实现"><a href="#4-2-算法思想和代码实现" class="headerlink" title="4.2 算法思想和代码实现"></a>4.2 算法思想和代码实现</h2><h3 id="4-2-1-双指针"><a href="#4-2-1-双指针" class="headerlink" title="4.2.1 双指针"></a>4.2.1 双指针</h3><ol><li>维护一个指针 j，表示当前应当放置非零元素的位置（即 左侧应保持所有的非零元素）</li><li>遍历整个数组：<ul><li>遇到 非零元素：让 j 右移一位，并将该非零元素与 j 位置的元素交换。</li><li>遇到 零元素：继续遍历，不执行任何操作（即 j 不变）。</li></ul></li><li>最终所有 0 会被推到数组末尾，而所有非零元素保持相对顺序不变。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>            j++;  <span class="hljs-comment">// j 指向当前应存放非零元素的位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i]; <span class="hljs-comment">// 交换 nums[i] 和 nums[j]</span><br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-双指针-方法2"><a href="#4-2-2-双指针-方法2" class="headerlink" title="4.2.2 双指针(方法2)"></a>4.2.2 双指针(方法2)</h3><p>第一遍遍历： j 作为非零元素的插入位置，把所有 非零元素 依次填入 nums[j] 。<br>第二遍遍历： 把 j 之后的元素全部填 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// j 记录非零元素该存放的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span>) &#123;<br>            nums[j++] = nums[i]; <span class="hljs-comment">// 把非零元素依次放入左侧</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将剩余的部分填充 0</span><br>    <span class="hljs-keyword">while</span> (j &lt; nums.length) &#123;<br>        nums[j++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-盛最多水的容器"><a href="#5-盛最多水的容器" class="headerlink" title="5. 盛最多水的容器"></a>5. 盛最多水的容器</h1><ul><li><strong>一句话总结：</strong> left从左，right从右向中间移动，计算区间面积，每次计算后<strong>移动高度较小的指针</strong>，向中间靠拢</li></ul><h2 id="5-1-题目描述"><a href="#5-1-题目描述" class="headerlink" title="5.1 题目描述"></a>5.1 题目描述</h2><ul><li>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</li><li>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</li><li>返回容器可以储存的最大水量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><h2 id="5-2-算法思想和代码实现"><a href="#5-2-算法思想和代码实现" class="headerlink" title="5.2 算法思想和代码实现"></a>5.2 算法思想和代码实现</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><ol><li>双指针初始化：<ul><li>用 left 指向数组的起始位置（左端）。</li><li>用 right 指向数组的末尾（右端）。</li><li>计算当前双指针围成的水容量 currentWater &#x3D; (right - left) * Math.min(height[left], height[right])，并更新 maxWater。</li></ul></li><li>双指针移动策略：<ul><li>移动高度较小的指针，向中间靠拢：</li><li>如果 height[left] &lt; height[right]，则 left++，因为移动较矮的边可能会遇到更高的边，使得最小高度变大，从而可能获得更大面积。</li><li>否则 right–，类似地希望遇到更高的柱子增加容积。</li></ul></li><li>终止条件：<ul><li>当 left &gt;&#x3D; right 时，搜索结束，返回 maxWater。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentArea</span> <span class="hljs-operator">=</span> (right - left) * Math.min(height[left], height[right]);<br><br>        maxArea = Math.max(maxArea, currentArea);<br><br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right])<br>            left++;<br>        <span class="hljs-keyword">else</span> right--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6. 三数之和"></a>6. 三数之和</h1><p><strong>一句话总结：</strong> </p><ul><li>先排序，三个指针：<ul><li>i : 从0到nums.length-2遍历</li><li>left: 从i+1往后遍历</li><li>right：从nums.length-1往前遍历</li></ul></li><li>如果sum&#x3D;0: left++,right–; 如果sum&gt;0: right–; 如果sum&lt;0: left++;</li><li>i 在遍历时，跳过相同的 nums[i];  left 和 right 指针移动时，也要跳过重复值</li></ul><h2 id="6-1-题目描述"><a href="#6-1-题目描述" class="headerlink" title="6.1 题目描述"></a>6.1 题目描述</h2><ul><li>给你一个整数数组 nums </li><li>判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k </li><li>同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 </li><li>请你返回所有和为 0 且不重复的三元组。</li></ul><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>]<br>输出：[[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>解释：<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] = (-<span class="hljs-number">1</span>) + <span class="hljs-number">0</span> + <span class="hljs-number">1</span> = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span> + <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>) = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">3</span>] + nums[<span class="hljs-number">4</span>] = (-<span class="hljs-number">1</span>) + <span class="hljs-number">2</span> + (-<span class="hljs-number">1</span>) = <span class="hljs-number">0</span> 。<br>不同的三元组是 [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><h2 id="6-2-算法思想和代码实现"><a href="#6-2-算法思想和代码实现" class="headerlink" title="6.2 算法思想和代码实现"></a>6.2 算法思想和代码实现</h2><h3 id="双指针法-排序"><a href="#双指针法-排序" class="headerlink" title="双指针法+排序"></a>双指针法+排序</h3><ol><li>对 nums 进行排序：这样可以方便地跳过重复元素，并且利用双指针寻找目标值。</li><li>遍历 nums 作为第一个元素：<ul><li>设 nums[i] 作为三元组中的 第一个数。</li><li>采用 双指针 方法，在 nums[i] 右侧找到 两个数 使得 nums[i] + nums[left] + nums[right] &#x3D; 0。</li></ul></li><li>使用左右双指针 (left 和 right)：<ul><li>初始 left &#x3D; i + 1，right &#x3D; nums.length - 1。</li><li>如果 sum &gt; 0，说明 right 选得过大，右指针 right–。</li><li>如果 sum &lt; 0，说明 left 选得过小，左指针 left++。</li><li>如果 sum &#x3D;&#x3D; 0，找到一组解，存入结果集。</li></ul></li><li>避免重复解：<ul><li>i 在遍历时，跳过相同的 nums[i] 。</li><li>left 和 right 指针移动时，也要跳过重复值。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Arrays.sort(nums); <span class="hljs-comment">// 先排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-comment">// 跳过重复的 `nums[i]`</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br><br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                result.add(Arrays.asList(nums[i], nums[left], nums[right]));<br><br>                <span class="hljs-comment">// 跳过重复的 `left` 和 `right`</span><br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br><br>                left++;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                left++; <span class="hljs-comment">// 和太小，移动左指针</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right--; <span class="hljs-comment">// 和太大，移动右指针</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-接雨水"><a href="#7-接雨水" class="headerlink" title="7. 接雨水"></a>7. 接雨水</h1><ul><li><strong>一句话描述：</strong></li></ul><h2 id="7-1-题目描述"><a href="#7-1-题目描述" class="headerlink" title="7.1 题目描述"></a>7.1 题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：height = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><h2 id="7-2-算法思想和代码实现"><a href="#7-2-算法思想和代码实现" class="headerlink" title="7.2 算法思想和代码实现"></a>7.2 算法思想和代码实现</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul><li>左右指针从两端往中间移动，记录左右最大高度</li><li>当左低右高时，左位置接水量由左最大高度决定</li><li>当左高右低时，右位置接水量由右最大高度决定</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sumOfWater</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 更新左右最大高度</span><br>        leftMax = Math.max(leftMax, height[left]);<br>        rightMax = Math.max(rightMax, height[right]);<br><br>        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>            <span class="hljs-comment">// 左低右高，左位置接水量由左最大高度决定</span><br>            sumOfWater += leftMax - height[left];<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 左高右低，右位置接水量由右最大高度决定</span><br>            sumOfWater += rightMax - height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sumOfWater;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全部面积-柱子的面积-水的面积"><a href="#全部面积-柱子的面积-水的面积" class="headerlink" title="全部面积-柱子的面积&#x3D;水的面积"></a>全部面积-柱子的面积&#x3D;水的面积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">sumHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">maxHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br>          sumHeight += height[i];<br>          maxHeight = Math.max(maxHeight, height[i]);<br>      &#125;<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">sumAll</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = height.length - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= maxHeight; i++) &#123;<br>          <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; height[l] &lt; i) l++;<br>          <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; height[r] &lt; i) r--;<br>          sumAll += r - l + <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> sumAll - sumHeight;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="8-无重复字符的最长字串"><a href="#8-无重复字符的最长字串" class="headerlink" title="8. 无重复字符的最长字串"></a>8. 无重复字符的最长字串</h1><ul><li><strong>一句话总结：</strong> 用一个集合ArrayList维护当前的无重复子串,遍历字符串，如果当前字符已在list集合中重复，记录当前最大值，删除list中重复元素及以前的元素，添加当前元素</li></ul><h2 id="8-1-题目描述"><a href="#8-1-题目描述" class="headerlink" title="8.1 题目描述"></a>8.1 题目描述</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;abcabcbb&quot;</span><br>输出: <span class="hljs-number">3</span> <br>解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;abc&quot;</span>，所以其长度为 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><h2 id="8-2-算法思想和代码实现"><a href="#8-2-算法思想和代码实现" class="headerlink" title="8.2 算法思想和代码实现"></a>8.2 算法思想和代码实现</h2><h3 id="滑动窗口（基于列表维护的窗口）"><a href="#滑动窗口（基于列表维护的窗口）" class="headerlink" title="滑动窗口（基于列表维护的窗口）"></a>滑动窗口（基于列表维护的窗口）</h3><p>该算法用于求解无重复字符的最长子串长度，使用了滑动窗口的思想，通过一个 <code>List&lt;Character&gt;</code> 维护当前的无重复子串。</p><ol><li>初始化<ul><li>维护 maxSubstringLength 记录最长无重复子串的长度。</li><li>用 <code>List&lt;Character&gt;</code> 作为滑动窗口，初始时加入 <code>s[0]</code>。</li></ul></li><li>遍历字符串<ul><li>若 <code>s[i]</code> 已在窗口中，说明出现重复：</li><li>更新 maxSubstringLength。</li><li>删除窗口内重复字符及其之前的字符，确保窗口无重复。</li><li>将 <code>s[i]</code> 加入窗口，继续扩展子串。</li></ul></li><li>遍历结束后，检查 chars 长度是否比 maxSubstringLength 更大，取最大值返回。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">1</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>       List&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>           <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br><br>           <span class="hljs-comment">// 当前字符已存在，记录最大值，删除list中重复元素及以前的元素</span><br>           <span class="hljs-keyword">if</span> (list.contains(c)) &#123;<br>               max = Math.max(max, list.size());<br>               <br>               <span class="hljs-keyword">while</span> (list.get(<span class="hljs-number">0</span>) != c) &#123;<br>                   list.remove(<span class="hljs-number">0</span>);<br>               &#125;<br>               list.remove(<span class="hljs-number">0</span>);<br>           &#125;<br><br>           <span class="hljs-comment">// 无论重复不重复，list最后加上当前元素</span><br>           list.add(c);<br>       &#125;<br>       max = Math.max(max, list.size());<br>       <span class="hljs-keyword">return</span> max;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="9-找到字符串中所有字母异位词"><a href="#9-找到字符串中所有字母异位词" class="headerlink" title="9. 找到字符串中所有字母异位词"></a>9. 找到字符串中所有字母异位词</h1><ul><li><strong>一句话总结：</strong> 滑动窗口 + 频率数组比较；维护两个长度为26的数组来比较窗口内的字符频率是否和 p 匹配，每次移除窗口左边的元素，添加新字符到窗口的右侧</li></ul><h2 id="9-1-题目描述"><a href="#9-1-题目描述" class="headerlink" title="9.1 题目描述"></a>9.1 题目描述</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, p = <span class="hljs-string">&quot;abc&quot;</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]<br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><h2 id="9-2-算法思想和代码实现"><a href="#9-2-算法思想和代码实现" class="headerlink" title="9.2 算法思想和代码实现"></a>9.2 算法思想和代码实现</h2><h3 id="9-2-1-方法1"><a href="#9-2-1-方法1" class="headerlink" title="9.2.1 方法1"></a>9.2.1 方法1</h3><ol><li>首先对 p 字符串进行排序，并将其存储在 ch2 中。</li><li>遍历字符串 s 的每个子字符串，长度与 p 相同。</li><li>每次取出子字符串并对其进行排序，与 ch2 比较是否相同，如果相同，则说明该子字符串是 p 的异位词，记录其起始位置。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    List&lt;Integer&gt; result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//排除特殊情况：s&lt;p的长度等</span><br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span>||p==<span class="hljs-literal">null</span>||s.length()&lt;p.length()||s.length()==<span class="hljs-number">0</span>||p.length()==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-type">char</span>[] ch1=s.toCharArray();<br>    <span class="hljs-type">char</span>[] ch2=p.toCharArray();<br><br>    Arrays.sort(ch2); <span class="hljs-comment">//对字符数组p进行排序</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ch1.length-ch2.length+<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-comment">//创建一个新的数组存储</span><br>        <span class="hljs-type">char</span>[] ch3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[ch2.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;ch2.length;j++)&#123;<br>            ch3[j]=ch1[i+j];<br>        &#125;<br>        Arrays.sort(ch3);<br>        <span class="hljs-keyword">if</span>(Arrays.equals(ch2,ch3))&#123;<span class="hljs-comment">//证明二者是异位词</span><br>            result.add(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-2-2-滑动窗口-频率数组比较"><a href="#9-2-2-滑动窗口-频率数组比较" class="headerlink" title="9.2.2 滑动窗口 + 频率数组比较"></a>9.2.2 滑动窗口 + 频率数组比较</h3><ol><li>使用两个长度为 26 的频率数组，charP 存储 p 的字符频率，charS 存储当前滑动窗口中字符的频率。</li><li>滑动窗口从左到右逐字符遍历 s：<ul><li>每次将窗口右边界的字符加入 charS。</li><li>如果窗口的大小超过 p 的长度，则移除窗口左边界的字符。</li></ul></li><li>每次窗口调整后，比较 charP 和 charS，如果相等，则说明当前窗口是 p 的异位词。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    <span class="hljs-comment">// 如果主串 s 的长度小于模式串 p，直接返回空列表（不可能有异位词）</span><br>    <span class="hljs-keyword">if</span> (s.length() &lt; p.length())<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 用两个数组统计字符出现次数，长度为26代表26个小写字母</span><br>    <span class="hljs-type">int</span>[] charS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 用于滑动窗口中当前子串的字符计数</span><br>    <span class="hljs-type">int</span>[] charP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 用于模式串 p 的字符计数</span><br><br>    <span class="hljs-comment">// 统计模式串 p 中每个字符出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charP[index]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化滑动窗口，统计 s 的前 p.length() 个字符的频率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charS[index]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 滑动窗口开始滑动，从索引 p.length() 开始，直到 s 的结尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length(); i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">// 如果当前窗口的字符频率和目标频率相同，则记录起始索引</span><br>        <span class="hljs-keyword">if</span> (Arrays.equals(charS, charP)) &#123;<br>            list.add(i - p.length());<br>        &#125;<br>        <span class="hljs-comment">// 将窗口左边的字符移除</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> s.charAt(i - p.length()) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charS[index]--;<br>        <span class="hljs-comment">// 加入窗口右边的新字符</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">curI</span> <span class="hljs-operator">=</span> s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        charS[curI]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查最后一个窗口是否匹配</span><br>    <span class="hljs-keyword">if</span> (Arrays.equals(charS, charP)) &#123;<br>        list.add(s.length() - p.length());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="10-和为K的子数组"><a href="#10-和为K的子数组" class="headerlink" title="10. 和为K的子数组"></a>10. 和为K的子数组</h1><ul><li><strong>一句话总结：</strong> </li><li><strong>前缀和 + 哈希表</strong><ul><li>哈希表：Key存储前缀和，Value存储这个前缀和出现的次数</li><li>通过 prefixSum - k 计算是否有之前的前缀和能构成和 k 的子数组</li><li>加上之前的前缀和出现的次数即可</li></ul></li></ul><h2 id="10-1-题目描述"><a href="#10-1-题目描述" class="headerlink" title="10.1 题目描述"></a>10.1 题目描述</h2><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的连续非空序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br><br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="10-2-算法思想和代码实现"><a href="#10-2-算法思想和代码实现" class="headerlink" title="10.2 算法思想和代码实现"></a>10.2 算法思想和代码实现</h2><h3 id="10-2-1-暴力遍历"><a href="#10-2-1-暴力遍历" class="headerlink" title="10.2.1 暴力遍历"></a>10.2.1 暴力遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>||nums.length==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-type">int</span> sum=nums[i];<br>        <span class="hljs-keyword">if</span>(sum==k)&#123;<br>            result++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.length;j++)&#123;<br>            sum+=nums[j];<br>            <span class="hljs-keyword">if</span>(sum==k)&#123;<br>                result++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(nums[nums.length-<span class="hljs-number">1</span>]==k)<br>        result++;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2-2-前缀和-哈希表（O-n-）-前缀和-前面的某个前缀和-这段区间的和"><a href="#10-2-2-前缀和-哈希表（O-n-）-前缀和-前面的某个前缀和-这段区间的和" class="headerlink" title="10.2.2 前缀和 + 哈希表（O(n)）|| 前缀和 - 前面的某个前缀和 &#x3D; 这段区间的和"></a>10.2.2 前缀和 + 哈希表（O(n)）|| 前缀和 - 前面的某个前缀和 &#x3D; 这段区间的和</h3><ul><li>前缀和：利用 prefixSum[j] - prefixSum[i] &#x3D; k 的性质，我们可以快速判断子数组 [i+1, j] 是否符合要求。</li><li>哈希表：用 HashMap 存储前缀和的出现次数，避免重复计算，达到 O(n) 的时间复杂度。</li></ul><ol><li>维护前缀和，计算 prefixSum &#x3D; sum(0…j)。</li><li>通过 prefixSum - k 计算是否有之前的前缀和能构成和 k 的子数组。</li><li>使用 HashMap 记录 prefixSum 出现的次数，以便快速查找是否存在满足条件的子数组。</li></ol><ul><li>但是答案中为什么是查找 pre - k? pre - k 又代表了什么？</li><li>这里要做个公式转换：<ul><li>preSum[j] - preSum[i] &#x3D; k &#x3D;&gt; preSum[j] - k &#x3D; preSum[i]</li><li>当前下标为 j，要寻找另一个下标i，他的前缀和与j的前缀和差值为k！！</li></ul></li><li>所以map中应该存储的就是下标为i时，其前缀和。</li><li>这样就好理解为什么在map中寻找的是 preSum[j] - k。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">prefixSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 处理从索引0开始的子数组</span><br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>           prefixSum += num;  <span class="hljs-comment">// 计算前缀和</span><br>           <br>           <span class="hljs-comment">// 检查是否存在 prefixSum - k</span><br>           <span class="hljs-keyword">if</span> (map.containsKey(prefixSum - k)) &#123;<br>               count += map.get(prefixSum - k); <span class="hljs-comment">// 统计满足条件的子数组个数</span><br>           &#125;<br>           <br>           <span class="hljs-comment">// 记录当前前缀和出现的次数</span><br>           map.put(prefixSum, map.getOrDefault(prefixSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>       &#125;<br>       <br>       <span class="hljs-keyword">return</span> count;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="11-滑动窗口最大值"><a href="#11-滑动窗口最大值" class="headerlink" title="11. 滑动窗口最大值"></a>11. 滑动窗口最大值</h1><ul><li><strong>一句话描述：</strong> <strong>单调双端队列</strong>：使用双端队列(Deque)存储<strong>索引</strong>，在遍历数组时始终保持队列中元素对应的值<strong>单调递减</strong>，并在每次滑动窗口形成后，通过<strong>队头索引</strong>快速获取当前窗口的最大值，同时<strong>移除队头已滑出窗口范围的元素</strong>和<strong>队尾比当前元素小的元素</strong></li></ul><h2 id="11-1-题目描述"><a href="#11-1-题目描述" class="headerlink" title="11.1 题目描述"></a>11.1 题目描述</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。<br>你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[<span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span>] -<span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span> [<span class="hljs-number">3</span>  -<span class="hljs-number">1</span>  -<span class="hljs-number">3</span>] <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">3</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span> [-<span class="hljs-number">1</span>  -<span class="hljs-number">3</span>  <span class="hljs-number">5</span>] <span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span> [-<span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>] <span class="hljs-number">6</span>  <span class="hljs-number">7</span>       <span class="hljs-number">5</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span>  -<span class="hljs-number">3</span> [<span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>] <span class="hljs-number">7</span>       <span class="hljs-number">6</span><br> <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  -<span class="hljs-number">1</span>  -<span class="hljs-number">3</span>  <span class="hljs-number">5</span> [<span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]      <span class="hljs-number">7</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="11-2-算法思想和代码实现"><a href="#11-2-算法思想和代码实现" class="headerlink" title="11.2 算法思想和代码实现"></a>11.2 算法思想和代码实现</h2><h3 id="单调双端队列"><a href="#单调双端队列" class="headerlink" title="单调双端队列"></a>单调双端队列</h3><ul><li>队头存放的是最大值</li><li>每次从队尾入队</li><li><strong>如何更新队头的最大值？</strong><ul><li>当新元素来的时候，从队尾往队头移动，把小于新元素的元素全部出队，然后从队尾入队</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] maxSlidingWindow2(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n - k + <span class="hljs-number">1</span>];<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 移除超出窗口范围的元素</span><br>        <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + <span class="hljs-number">1</span>) &#123;<br>            deque.pollFirst();<br>        &#125;<br><br>        <span class="hljs-comment">// 维持队列单调递减，移除队尾小于当前元素的索引</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<br>            deque.pollLast();<br>        &#125;<br><br>        <span class="hljs-comment">// 添加当前元素索引</span><br>        deque.offerLast(i);<br><br>        <span class="hljs-comment">// 记录窗口最大值</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            result[i - k + <span class="hljs-number">1</span>] = nums[deque.peekFirst()];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="12-最小覆盖子串"><a href="#12-最小覆盖子串" class="headerlink" title="12. 最小覆盖子串"></a>12. 最小覆盖子串</h1><ul><li><strong>一句话总结：</strong> </li><li><strong>滑动窗口+哈希表</strong><ul><li><strong>一个哈希表记录t</strong>的字符出现的次数，<strong>另一个哈希表记录s</strong>当前窗口的字符出现的次数</li><li>右指针right先往右移动，直到包含t所有的字符(借助valid记录窗口内满足条件的字符数)，记录当前最短子串的右边界</li><li>左指针left收缩窗口，尝试寻找更短的子串，记录当前最短子串的左边界</li></ul></li></ul><h2 id="12-1-题目描述"><a href="#12-1-题目描述" class="headerlink" title="12.1 题目描述"></a>12.1 题目描述</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。<br>如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><ul><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, t = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br>解释：最小覆盖子串 <span class="hljs-string">&quot;BANC&quot;</span> 包含来自字符串 t 的 <span class="hljs-string">&#x27;A&#x27;</span>、<span class="hljs-string">&#x27;B&#x27;</span> 和 <span class="hljs-string">&#x27;C&#x27;</span>。<br></code></pre></td></tr></table></figure><h2 id="12-2-算法思想和代码实现"><a href="#12-2-算法思想和代码实现" class="headerlink" title="12.2 算法思想和代码实现"></a>12.2 算法思想和代码实现</h2><h3 id="滑动窗口-哈希表"><a href="#滑动窗口-哈希表" class="headerlink" title="滑动窗口+哈希表"></a>滑动窗口+哈希表</h3><p>我们维护一个窗口 [left, right]，在窗口中寻找包含 t 所有字符的最小子串。</p><ol><li>使用 need 哈希表 记录 t 中所有字符及其出现的次数。</li><li>使用 window 哈希表 记录当前窗口内的字符出现次数。</li><li>右指针 right 扩展窗口，直到窗口包含 t 中所有字符。</li><li>左指针 left 收缩窗口，尝试寻找更短的子串，同时保证窗口仍然有效。</li><li>记录当前最短子串的 start 和 length，最终返回结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s.length() &lt; t.length()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">// 记录 t 中的字符及其数量</span><br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t.toCharArray()) &#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 滑动窗口左右指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录窗口内满足条件的字符数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, minLen = Integer.MAX_VALUE;  <span class="hljs-comment">// 记录最小子串的位置和长度</span><br><br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right); <span class="hljs-comment">// 右侧字符进入窗口</span><br>        right++; <span class="hljs-comment">// 右指针扩展窗口</span><br><br>        <span class="hljs-comment">// 如果是 t 需要的字符，则更新窗口数据</span><br>        <span class="hljs-keyword">if</span> (need.containsKey(c)) &#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (window.get(c).equals(need.get(c))) &#123;<br>                valid++;  <span class="hljs-comment">// 该字符的数量达标</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 当窗口包含 t 的所有字符时，尝试收缩窗口</span><br>        <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>            <span class="hljs-comment">// 记录最小子串</span><br>            <span class="hljs-keyword">if</span> (right - left &lt; minLen) &#123;<br>                start = left;<br>                minLen = right - left;<br>            &#125;<br><br>            <span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> s.charAt(left); <span class="hljs-comment">// 左侧字符即将移出窗口</span><br>            left++; <span class="hljs-comment">// 左指针收缩窗口</span><br><br>            <span class="hljs-keyword">if</span> (need.containsKey(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window.get(d).equals(need.get(d))) &#123;<br>                    valid--;  <span class="hljs-comment">// 该字符不再满足要求</span><br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + minLen);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="13-最大子数组和"><a href="#13-最大子数组和" class="headerlink" title="13. 最大子数组和"></a>13. 最大子数组和</h1><ul><li><strong>一句话总结：</strong> <strong>局部最优 -&gt; 推导全局最优</strong> sum+&#x3D;当前元素，如果sum&gt;max，更新max；如果sum&lt;0，将sum重置为0(因为前面的子数组对后续没有正向贡献)</li></ul><h2 id="13-1-题目描述"><a href="#13-1-题目描述" class="headerlink" title="13.1 题目描述"></a>13.1 题目描述</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">6</span><br>解释：连续子数组 [<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span> 。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="13-2-算法思想和代码实现"><a href="#13-2-算法思想和代码实现" class="headerlink" title="13.2 算法思想和代码实现"></a>13.2 算法思想和代码实现</h2><p>如果 sum 大于 max，说明找到了一个更大的子数组和，将 max 更新为 sum。如果 sum 小于等于 0，说明当前子数组对后续的和没有正向贡献，将 sum 重置为 0，从下一个元素开始重新考虑新的子数组。</p><ol><li>遍历数组 nums，更新 sum：</li><li>将 nums[i] 加入当前 sum，表示扩展当前子数组。</li><li>如果 sum &gt; max，更新 max，记录新的最大和。</li><li>如果 sum 变成负数（sum &lt;&#x3D; 0），说明当前子数组对后续部分无贡献，需要重新开始新的子数组（即 sum &#x3D; 0）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        sum += nums[i];<br><br>        <span class="hljs-comment">//如果 sum &gt; max，更新 max，记录新的最大和。</span><br>        max = Math.max(max, sum);<br><br>        <span class="hljs-comment">//如果 sum 变成负数（sum &lt;= 0），说明当前子数组对后续部分无贡献，需要重新开始新的子数组（即 sum = 0）。</span><br>        sum = Math.max(sum, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="14-合并区间"><a href="#14-合并区间" class="headerlink" title="14. 合并区间"></a>14. 合并区间</h1><ul><li><strong>一句话总结</strong>：</li><li>先根据start排序：<ul><li>上一个end小于下一个start：直接加入结果集，continue;</li><li>上一个end 大于等于下一个start: 有重复进行合并</li></ul></li></ul><h2 id="14-1-题目描述"><a href="#14-1-题目描述" class="headerlink" title="14.1 题目描述"></a>14.1 题目描述</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br><br>示例 <span class="hljs-number">2</span>：<br>输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><h2 id="14-2-算法思想和代码实现"><a href="#14-2-算法思想和代码实现" class="headerlink" title="14.2 算法思想和代码实现"></a>14.2 算法思想和代码实现</h2><h3 id="排序-遍历合并"><a href="#排序-遍历合并" class="headerlink" title="排序+遍历合并"></a>排序+遍历合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>      Arrays.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);<br>      List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      list.add(intervals[<span class="hljs-number">0</span>]);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;<br>          <span class="hljs-keyword">if</span> (list.getLast()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> list.getLast()[<span class="hljs-number">0</span>];<br>              <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> Math.max(list.getLast()[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>              list.removeLast();<br>              list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;first, last&#125;);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              list.add(intervals[i]);<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[list.size()][<span class="hljs-number">2</span>]);<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="15-轮转数组"><a href="#15-轮转数组" class="headerlink" title="15. 轮转数组"></a>15. 轮转数组</h1><ul><li><strong>一句话总结：</strong> </li><li><strong>三次翻转法</strong>：<ul><li>先整体翻转数组；再翻转前 k 个元素；最后翻转后 n-k个元素；</li></ul></li><li><strong>注意：</strong> k可能大于数组长度，所以要先对数组长度取模(k%&#x3D;nums.length;)</li></ul><h2 id="15-1-题目描述"><a href="#15-1-题目描述" class="headerlink" title="15.1 题目描述"></a>15.1 题目描述</h2><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>解释:<br>向右轮转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>向右轮转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>向右轮转 <span class="hljs-number">3</span> 步: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="15-2-算法思想和代码实现"><a href="#15-2-算法思想和代码实现" class="headerlink" title="15.2 算法思想和代码实现"></a>15.2 算法思想和代码实现</h2><h3 id="三次翻转法-时间复杂度-O-n-，空间复杂度-O-1"><a href="#三次翻转法-时间复杂度-O-n-，空间复杂度-O-1" class="headerlink" title="三次翻转法 时间复杂度 O(n)，空间复杂度 O(1)"></a>三次翻转法 时间复杂度 O(n)，空间复杂度 O(1)</h3><ol><li>先整体翻转数组，得到 [7, 6, 5, 4, 3, 2, 1]</li><li>再翻转前 k&#x3D;3 个元素，变成 [5, 6, 7, 4, 3, 2, 1]</li><li>最后翻转后 n-k&#x3D;4 个元素，得到 [5, 6, 7, 1, 2, 3, 4]</li></ol><p>三次翻转的过程可以理解为：</p><ul><li>整体翻转 → 把右边 k 个元素移动到前面，但顺序错了</li><li>前 k 个元素翻转 → 让被移动到前面的元素恢复正确的顺序</li><li>后 n-k 个元素翻转 → 让剩余元素恢复正确的顺序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    k = k % n; <span class="hljs-comment">// 避免 k 超过数组长度</span><br><br>    reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 翻转整个数组</span><br>    reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 翻转前 k 个元素</span><br>    reverse(nums, k, n - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 翻转剩下的元素</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>        left++;<br>        right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="16-除自身以外数组的乘积"><a href="#16-除自身以外数组的乘积" class="headerlink" title="16. 除自身以外数组的乘积"></a>16. 除自身以外数组的乘积</h1><ul><li><strong>一句话描述</strong>：<strong>前缀积和后缀积</strong>：第一次从前往后遍历，构建结果数组每个位置前缀乘积，第二次从后往前遍历乘上后缀乘积</li></ul><h2 id="16-1-题目描述"><a href="#16-1-题目描述" class="headerlink" title="16.1 题目描述"></a>16.1 题目描述</h2><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出: [<span class="hljs-number">24</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="16-2-算法思想和代码实现"><a href="#16-2-算法思想和代码实现" class="headerlink" title="16.2 算法思想和代码实现"></a>16.2 算法思想和代码实现</h2><h3 id="前缀积和后缀积"><a href="#前缀积和后缀积" class="headerlink" title="前缀积和后缀积"></a>前缀积和后缀积</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, suf = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        res[i] = pre;<br>        pre *= nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        res[i] *= suf;<br>        suf *= nums[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="17-缺失的第一个正数"><a href="#17-缺失的第一个正数" class="headerlink" title="17. 缺失的第一个正数"></a>17. 缺失的第一个正数</h1><ul><li><strong>一句话总结：</strong> 将<code>[8,2,0,1,3,4]</code>遍历转换为<code>[1,2,3,4,0,8]</code>,通过原地<strong>交换</strong>的方式将正整数放到对应的位置上，然后从头遍历找到第一个不符合的正数</li></ul><h2 id="17-1-题目描述"><a href="#17-1-题目描述" class="headerlink" title="17.1 题目描述"></a>17.1 题目描述</h2><p>给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。<br>请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">示例 <span class="hljs-number">1</span>：<br>输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">3</span><br>解释：范围 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 中的数字都在数组中。<br><br>示例 <span class="hljs-number">2</span>：<br>输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">1</span> 在数组中，但 <span class="hljs-number">2</span> 没有。<br></code></pre></td></tr></table></figure><h2 id="17-2-算法思想和代码实现"><a href="#17-2-算法思想和代码实现" class="headerlink" title="17.2 算法思想和代码实现"></a>17.2 算法思想和代码实现</h2><h3 id="原地哈希"><a href="#原地哈希" class="headerlink" title="原地哈希"></a>原地哈希</h3><ul><li>由于缺失的最小正整数一定在 [1, N+1] 之间（其中 N 是 nums.length），我们可以利用数组本身作为哈希表，将每个元素放到正确的位置（即 nums[i] &#x3D;&#x3D; i + 1）。</li><li>然后再遍历数组，找到第一个 nums[i] !&#x3D; i + 1 的索引 i，即 i + 1 为缺失的最小正整数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">// 将每个数放到正确的位置上，即 nums[i] = i + 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>                swap(nums, nums[i] - <span class="hljs-number">1</span>, i);<br>                i--;  <span class="hljs-comment">// 退一步，重新检查交换过来的那个值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找到第一个 nums[i] != i + 1 的位置，返回 i + 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若数组是 [1,2,3,4] 这样完整的，则返回 n+1</span><br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = temp;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="18-矩阵置零"><a href="#18-矩阵置零" class="headerlink" title="18. 矩阵置零"></a>18. 矩阵置零</h1><ul><li><strong>一句话总结：</strong> 利用<strong>矩阵的第一行和第一列作为标记位</strong>来记录哪一行、哪一列需要被置 0  <strong>注意：</strong> 标记记录的过程中应该跳过第一行和第一列</li></ul><h2 id="18-1-题目描述"><a href="#18-1-题目描述" class="headerlink" title="18.1 题目描述"></a>18.1 题目描述</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><h2 id="18-2-算法思想和代码实现"><a href="#18-2-算法思想和代码实现" class="headerlink" title="18.2 算法思想和代码实现"></a>18.2 算法思想和代码实现</h2><h3 id="18-2-1-方法1"><a href="#18-2-1-方法1" class="headerlink" title="18.2.1 方法1"></a>18.2.1 方法1</h3><ol><li>第一遍遍历：使用 HashSet 记录包含 0 的行索引 setRow 和列索引 setColumn。</li><li>第二遍遍历：将所有 setColumn 中的列全部置 0。</li><li>第三遍遍历：将所有 setRow 中的行全部置 0。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">//创建两个哈希表用来存储为0的行和列值</span><br>    HashSet&lt;Integer&gt; setRow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br>    HashSet&lt;Integer&gt; setColumn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br><br>    <span class="hljs-comment">//遍历矩阵，找到为0的元素的行和列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)&#123;<br>                setRow.add(i);<br>                setColumn.add(j);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-comment">//将有0的列都置为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)<br>        <span class="hljs-keyword">for</span>(Integer j:setColumn)<br>            matrix[i][j]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//将有0的行都置为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        <span class="hljs-keyword">for</span>(Integer i:setRow)<br>            matrix[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18-2-2-方法2（O-1-空间复杂度）"><a href="#18-2-2-方法2（O-1-空间复杂度）" class="headerlink" title="18.2.2 方法2（O(1) 空间复杂度）"></a>18.2.2 方法2（O(1) 空间复杂度）</h3><p>我们可以 利用矩阵的第一行和第一列作为标记位 来记录哪一行、哪一列需要被置 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRowZero</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, firstColZero = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 1. 检查第一列是否有 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            firstColZero = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 检查第一行是否有 0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>            firstRowZero = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 使用第一行和第一列记录需要置 0 的行和列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录该行需要清零</span><br>                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录该列需要清零</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 置 0（根据第一行和第一列的标记）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 处理第一列</span><br>    <span class="hljs-keyword">if</span> (firstColZero) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 处理第一行</span><br>    <span class="hljs-keyword">if</span> (firstRowZero) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="19-螺旋矩阵"><a href="#19-螺旋矩阵" class="headerlink" title="19. 螺旋矩阵"></a>19. 螺旋矩阵</h1><ul><li><strong>一句话描述：</strong> </li><li>定义top, bottom, left, right<strong>四个边界变量</strong>控制遍历范围</li><li>按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素</li><li><strong>注意：最后两个遍历(往左和往上)要判断是否还有行或列剩下</strong></li></ul><h2 id="19-1-题目描述"><a href="#19-1-题目描述" class="headerlink" title="19.1 题目描述"></a>19.1 题目描述</h2><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="19-2-算法思想和代码实现"><a href="#19-2-算法思想和代码实现" class="headerlink" title="19.2 算法思想和代码实现"></a>19.2 算法思想和代码实现</h2><h3 id="按照-右-→-下-→-左-→-上-的顺序依次遍历矩阵的元素。"><a href="#按照-右-→-下-→-左-→-上-的顺序依次遍历矩阵的元素。" class="headerlink" title="按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素。"></a>按照 右 → 下 → 左 → 上 的顺序依次遍历矩阵的元素。</h3><p>我们可以使用 四个边界变量 控制遍历范围：</p><ul><li>top：当前未遍历的上边界</li><li>bottom：当前未遍历的下边界</li><li>left：当前未遍历的左边界</li><li>right：当前未遍历的右边界<br>在遍历过程中，每遍历完一圈，就收缩对应的边界，直到所有元素都被访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>     List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>     <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length, n = matrix[<span class="hljs-number">0</span>].length;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bottom = m - <span class="hljs-number">1</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br><br>     <span class="hljs-keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;<br>         <span class="hljs-comment">// 从左到右</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left; j &lt;= right; j++) &#123;<br>             result.add(matrix[top][j]);<br>         &#125;<br>         top++; <span class="hljs-comment">// 上边界收缩</span><br><br>         <span class="hljs-comment">// 从上到下</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom; i++) &#123;<br>             result.add(matrix[i][right]);<br>         &#125;<br>         right--; <span class="hljs-comment">// 右边界收缩</span><br><br>         <span class="hljs-comment">// 判断是否还有行需要遍历</span><br>         <span class="hljs-keyword">if</span> (top &lt;= bottom) &#123;<br>             <span class="hljs-comment">// 从右到左</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right; j &gt;= left; j--) &#123;<br>                 result.add(matrix[bottom][j]);<br>             &#125;<br>             bottom--; <span class="hljs-comment">// 下边界收缩</span><br>         &#125;<br><br>         <span class="hljs-comment">// 判断是否还有列需要遍历</span><br>         <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>             <span class="hljs-comment">// 从下到上</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top; i--) &#123;<br>                 result.add(matrix[i][left]);<br>             &#125;<br>             left++; <span class="hljs-comment">// 左边界收缩</span><br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> result;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="20-旋转图像"><a href="#20-旋转图像" class="headerlink" title="20. 旋转图像"></a>20. 旋转图像</h1><ul><li><strong>一句话总结：</strong> </li><li><strong>旋转&#x3D;转置+翻转</strong><ol><li>先转置：将 <code>matrix[i][j]</code> 变成 <code>matrix[j][i]</code>。</li><li>再水平翻转：让 <code>matrix[j][i]</code> 变成 <code>matrix[j][n-1-i]</code>。</li></ol></li></ul><h2 id="20-1-题目描述"><a href="#20-1-题目描述" class="headerlink" title="20.1 题目描述"></a>20.1 题目描述</h2><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>输出：[[<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure><h2 id="20-2-算法思想和代码实现"><a href="#20-2-算法思想和代码实现" class="headerlink" title="20.2 算法思想和代码实现"></a>20.2 算法思想和代码实现</h2><h3 id="转置-翻转"><a href="#转置-翻转" class="headerlink" title="转置+翻转"></a>转置+翻转</h3><ol><li>转置矩阵（行变列，列变行）</li><li>翻转每一行（实现 90° 旋转）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">假设 matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]：<br><br>第一步：转置矩阵<br>转置后（行变列，列变行）：<br><span class="hljs-number">1</span>  <span class="hljs-number">4</span>  <span class="hljs-number">7</span><br><span class="hljs-number">2</span>  <span class="hljs-number">5</span>  <span class="hljs-number">8</span><br><span class="hljs-number">3</span>  <span class="hljs-number">6</span>  <span class="hljs-number">9</span><br><br>第二步：翻转每一行<br>左右翻转后：<br><span class="hljs-number">7</span>  <span class="hljs-number">4</span>  <span class="hljs-number">1</span><br><span class="hljs-number">8</span>  <span class="hljs-number">5</span>  <span class="hljs-number">2</span><br><span class="hljs-number">9</span>  <span class="hljs-number">6</span>  <span class="hljs-number">3</span><br>最终结果符合要求！<br></code></pre></td></tr></table></figure><h4 id="为什么旋转-转置-翻转？"><a href="#为什么旋转-转置-翻转？" class="headerlink" title="为什么旋转&#x3D;转置+翻转？"></a>为什么旋转&#x3D;转置+翻转？</h4><p>旋转的最终的目标公式 matrix[i][j] → matrix[j][n-1-i]<br>拆解成两步：</p><ol><li>先转置：将 matrix[i][j] 变成 matrix[j][i]。</li><li>再水平翻转：让 matrix[j][i] 变成 matrix[j][n-1-i]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br><br>    <span class="hljs-comment">//先转置矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[j][i];<br>            matrix[j][i] = temp;<br>        &#125;<br><br>    <span class="hljs-comment">//在反转每一行(左右翻转)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n/<span class="hljs-number">2</span>;j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[i][n-<span class="hljs-number">1</span>-j];<br>            matrix[i][n-<span class="hljs-number">1</span>-j] = temp;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="21-搜索二维矩阵-II"><a href="#21-搜索二维矩阵-II" class="headerlink" title="21. 搜索二维矩阵 II"></a>21. 搜索二维矩阵 II</h1><ul><li><strong>一句话总结：</strong> 从右上角出发，向下或向左移动，或返回true</li></ul><h2 id="21-1-题目描述"><a href="#21-1-题目描述" class="headerlink" title="21.1 题目描述"></a>21.1 题目描述</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">19</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">22</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">23</span>,<span class="hljs-number">26</span>,<span class="hljs-number">30</span>]], target = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="21-2-算法思想和代码实现"><a href="#21-2-算法思想和代码实现" class="headerlink" title="21.2 算法思想和代码实现"></a>21.2 算法思想和代码实现</h2><h3 id="从右上角出发"><a href="#从右上角出发" class="headerlink" title="从右上角出发"></a>从右上角出发</h3><p>就是要选择一个点，使得横向和纵向移动，martix能够有不同的变化</p><ul><li>左上角：往右往下移动，martix值都变大，无法区分，不可用</li><li>右上角：往左martix变小，往下martix变大，可区分，可用</li><li>左下角：往右martix变大，往上martix变小，可区分，可用</li><li>右下角：往左往上移动，martix都变小，不可区分，不可用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">//从矩阵的右上角出发</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//如果相等返回true</span><br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果大于target，往左移动</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target)<br>            j--;<br>            <span class="hljs-comment">//如果小于target，往下移动</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target)<br>            i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="22-相交链表"><a href="#22-相交链表" class="headerlink" title="22. 相交链表"></a>22. 相交链表</h1><ul><li><strong>一句话总结：</strong> 双指针一块走，当 pA 走到尾巴 null，它就切换到 headB 重新开始。当 pB 走到尾巴 null，它就切换到 headA 重新开始。如果两个链表有交点，那么两个指针<strong>一定会在交点相遇</strong>。如果没有交点，最终两个指针<strong>都会走到 null</strong></li></ul><h2 id="22-1-题目描述"><a href="#22-1-题目描述" class="headerlink" title="22.1 题目描述"></a>22.1 题目描述</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。</p><h2 id="22-2-算法思想和代码实现"><a href="#22-2-算法思想和代码实现" class="headerlink" title="22.2 算法思想和代码实现"></a>22.2 算法思想和代码实现</h2><h3 id="22-2-1-暴力遍历-O-m-n"><a href="#22-2-1-暴力遍历-O-m-n" class="headerlink" title="22.2.1 暴力遍历(O(m*n))"></a>22.2.1 暴力遍历(O(m*n))</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempA</span> <span class="hljs-operator">=</span> headA;<br>    <span class="hljs-keyword">while</span> (tempA != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tempB</span> <span class="hljs-operator">=</span> headB; <span class="hljs-comment">// **每次遍历 headA 的一个节点，都要重新遍历 headB**</span><br>        <span class="hljs-keyword">while</span> (tempB != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (tempA == tempB) <span class="hljs-keyword">return</span> tempA; <span class="hljs-comment">// **找到相交点**</span><br>            tempB = tempB.next;<br>        &#125;<br>        tempA = tempA.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// **如果没有相交节点**</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="22-2-2-双指针法（O-m-n-）"><a href="#22-2-2-双指针法（O-m-n-）" class="headerlink" title="22.2.2 双指针法（O(m + n)）"></a>22.2.2 双指针法（O(m + n)）</h3><p>双指针法通过两个指针分别遍历 headA 和 headB，当一个指针到达链表尾部时，切换到另一个链表的头部，这样可以在 一次遍历 中找到相交节点。</p><ul><li>思路：拼接链表分别得到 A + B 和 B + A。双指针遍历找到地址相同节点</li><li>证明：假设 A &#x3D; a + m, B &#x3D; b + m (m 是相交之后的长度，相交之后剩下的长度一样)。</li><li>那么双指针同时遍历 A + B 和 B + A 会在 a + m + b 和 b + m + a的位置（长度一致了！）找到相交节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pA</span> <span class="hljs-operator">=</span> headA, pB = headB;<br><br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        <span class="hljs-keyword">if</span> (pA == <span class="hljs-literal">null</span>)<br>            pA = headB;<br>        <span class="hljs-keyword">else</span><br>            pA = pA.next;<br><br>        <span class="hljs-keyword">if</span> (pB == <span class="hljs-literal">null</span>)<br>            pB = headA;<br>        <span class="hljs-keyword">else</span><br>            pB = pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="23-反转链表"><a href="#23-反转链表" class="headerlink" title="23. 反转链表"></a>23. 反转链表</h1><ul><li><strong>一句话描述：</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">原链表:1→2→3→4</span><br><span class="hljs-attr">1:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1</span> <span class="hljs-number">2</span><span class="hljs-string">→3→4</span><br><span class="hljs-attr">2:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2</span> <span class="hljs-number">3</span><span class="hljs-string">→4</span><br><span class="hljs-attr">3:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3</span> <span class="hljs-number">4</span><br><span class="hljs-attr">4:</span> <span class="hljs-literal">null</span><span class="hljs-string">←1←2←3←4</span><br></code></pre></td></tr></table></figure><h2 id="23-1-题目描述"><a href="#23-1-题目描述" class="headerlink" title="23.1 题目描述"></a>23.1 题目描述</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="23-2-算法思想和代码实现"><a href="#23-2-算法思想和代码实现" class="headerlink" title="23.2 算法思想和代码实现"></a>23.2 算法思想和代码实现</h2><h3 id="迭代反转-时间复杂度-O-n"><a href="#迭代反转-时间复杂度-O-n" class="headerlink" title="迭代反转 时间复杂度 O(n)"></a>迭代反转 时间复杂度 O(n)</h3><ul><li>使用 p 指针 记录前一个节点（初始为 null）。</li><li>使用 curr 指针 遍历链表，并逐个反转指针方向。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 反转后的链表头</span><br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// 当前遍历的节点</span><br><br>       <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextTemp</span> <span class="hljs-operator">=</span> curr.next; <span class="hljs-comment">// 记录下一个节点</span><br>           curr.next = p; <span class="hljs-comment">// 反转当前节点指针</span><br>           p = curr; <span class="hljs-comment">//前进</span><br>           curr = nextTemp; <span class="hljs-comment">// `curr` 前进</span><br>       &#125;<br><br>       <span class="hljs-keyword">return</span> p; <span class="hljs-comment">// 反转后的头节点</span><br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="24-回文链表"><a href="#24-回文链表" class="headerlink" title="24. 回文链表"></a>24. 回文链表</h1><ul><li><strong>一句话总结：</strong> 先用<strong>快慢指针找中点</strong>，把<strong>中点以后的链表反转</strong>，<strong>再比较</strong>反转后的一半链表和原链表的前一半</li></ul><h2 id="24-1-题目描述"><a href="#24-1-题目描述" class="headerlink" title="24.1 题目描述"></a>24.1 题目描述</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="24-2-算法思想和代码实现"><a href="#24-2-算法思想和代码实现" class="headerlink" title="24.2 算法思想和代码实现"></a>24.2 算法思想和代码实现</h2><h3 id="24-2-1-利用额外空间存储链表元素，然后双指针比较是否为回文"><a href="#24-2-1-利用额外空间存储链表元素，然后双指针比较是否为回文" class="headerlink" title="24.2.1 利用额外空间存储链表元素，然后双指针比较是否为回文"></a>24.2.1 利用额外空间存储链表元素，然后双指针比较是否为回文</h3><ol><li>遍历链表，将所有节点值存入 ArrayList。</li><li>使用双指针，一个从 list 末尾 开始，一个从链表 头部 开始，逐个比较值是否相等。</li><li>若所有对应元素相等，则链表是 回文链表，否则返回 false。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-comment">//创建一个集合保存链表元素</span><br>    List&lt;Integer&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)&#123;<br>        list.add(p.val);<br>        p=p.next;<br>    &#125;<br><br>    p=head;<br><br>    <span class="hljs-comment">//集合元素从后往前与链表元素从前往后进行比较</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=list.size()-<span class="hljs-number">1</span>;i&gt;=list.size()/<span class="hljs-number">2</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(list.get(i)!=p.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        p=p.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="24-2-2-快慢指针找中点-反转链表（O-n-O-1-）"><a href="#24-2-2-快慢指针找中点-反转链表（O-n-O-1-）" class="headerlink" title="24.2.2 快慢指针找中点 + 反转链表（O(n),O(1)）"></a>24.2.2 快慢指针找中点 + 反转链表（O(n),O(1)）</h3><ol><li>使用快慢指针 找到链表的 中点。</li><li>反转后半部分链表。</li><li>从头和反转后的部分进行对比，判断是否为回文。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 1. 使用快慢指针找到链表的中点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 反转后半部分链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">secondHalf</span> <span class="hljs-operator">=</span> reverseList(slow);<br><br>    <span class="hljs-comment">// 3. 进行回文判断</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head, p2 = secondHalf;<br>    <span class="hljs-keyword">while</span> (p2 != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 只需要比较后半部分</span><br>        <span class="hljs-keyword">if</span> (p1.val != p2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        p1 = p1.next;<br>        p2 = p2.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 可选：恢复链表</span><br>    reverseList(secondHalf);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = prev;<br>        prev = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="25-环形链表"><a href="#25-环形链表" class="headerlink" title="25. 环形链表"></a>25. 环形链表</h1><ul><li><strong>一句话总结：</strong> <strong>快慢指针找环</strong>：如果相遇了返回true</li></ul><h2 id="25-1-题目描述"><a href="#25-1-题目描述" class="headerlink" title="25.1 题目描述"></a>25.1 题目描述</h2><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], pos = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><h2 id="25-2-算法思想和代码实现"><a href="#25-2-算法思想和代码实现" class="headerlink" title="25.2 算法思想和代码实现"></a>25.2 算法思想和代码实现</h2><p><a href="https://blog.csdn.net/2301_80344616/article/details/136419017">为什么快慢指针一定会相遇</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//定义快慢指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span>head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>    <br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//慢的一次走一步</span><br>        slow = slow.next;<br>        <span class="hljs-comment">//快的一次走两步</span><br>        fast = fast.next.next;<br>        <span class="hljs-comment">//如果他们能相遇，就一定是有环的</span><br>        <span class="hljs-keyword">if</span>(slow==fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="26-环形链表-II"><a href="#26-环形链表-II" class="headerlink" title="26. 环形链表 II"></a>26. 环形链表 II</h1><ul><li><strong>一句话总结：</strong> 当快慢指针相遇时：定义<strong>一个指针从相遇点开始走</strong>；<strong>另一个指针从链表头开始走</strong>，他们<strong>会在环的入口点相遇</strong></li></ul><h2 id="26-1-题目描述"><a href="#26-1-题目描述" class="headerlink" title="26.1 题目描述"></a>26.1 题目描述</h2><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], pos = <span class="hljs-number">1</span><br>输出：返回索引为 <span class="hljs-number">1</span> 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><h2 id="26-2-算法思想和代码实现"><a href="#26-2-算法思想和代码实现" class="headerlink" title="26.2 算法思想和代码实现"></a>26.2 算法思想和代码实现</h2><p><a href="https://blog.csdn.net/2301_80344616/article/details/136419017">为什么快慢指针一定会相遇</a></p><p><strong>定义一个指针从相遇点开始走；另一个指针从链表头开始走，他们会在环的入口点相遇</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">//快慢指针判断是否有环</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span>head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>    <br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span>&amp;&amp;fast.next!=<span class="hljs-literal">null</span>)&#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <br>        <span class="hljs-comment">//如果有环</span><br>        <span class="hljs-keyword">if</span>(slow==fast)&#123;<br>            <span class="hljs-comment">//定义两个指针，一个从相遇点slow出发，另一个从head头出发</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">meet</span> <span class="hljs-operator">=</span>slow;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>            <br>            <span class="hljs-comment">//当二者相遇时，此结点就是环起点</span><br>            <span class="hljs-keyword">while</span>(p!=meet)&#123;<br>                p = p.next;<br>                meet = meet.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> meet;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="27-合并两个有序链表"><a href="#27-合并两个有序链表" class="headerlink" title="27. 合并两个有序链表"></a>27. 合并两个有序链表</h1><ul><li><strong>一句话描述：</strong> 使用<strong>虚拟头结点</strong>，双指针遍历两个链表；<strong>谁的值小，就连接谁</strong>；遍历完一个，直接连接另一个</li></ul><h2 id="27-1-题目描述"><a href="#27-1-题目描述" class="headerlink" title="27.1 题目描述"></a>27.1 题目描述</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], l2 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="27-2-算法思想和代码实现"><a href="#27-2-算法思想和代码实现" class="headerlink" title="27.2 算法思想和代码实现"></a>27.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            cur.next = list1;<br>            cur = cur.next;<br>            list1 = list1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.next = list2;<br>            cur = cur.next;<br>            list2 = list2.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = list1;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list2 != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = list2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="28-两数相加"><a href="#28-两数相加" class="headerlink" title="28. 两数相加"></a>28. 两数相加</h1><ul><li><strong>一句话总结：</strong> 创建一个新链表记录两个链表之和，<strong>注意进位</strong></li></ul><h2 id="28-1-题目描述"><a href="#28-1-题目描述" class="headerlink" title="28.1 题目描述"></a>28.1 题目描述</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：l1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], l2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>]<br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807.</span><br></code></pre></td></tr></table></figure><h2 id="28-2-算法思想和代码实现"><a href="#28-2-算法思想和代码实现" class="headerlink" title="28.2 算法思想和代码实现"></a>28.2 算法思想和代码实现</h2><p>创建一个新的链表存储最终的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-comment">// 创建一个新的链表用来保存最终结果</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> l3; <span class="hljs-comment">// 记录结果链表的头部</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历两个链表，直到两个链表都遍历完</span><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> || l2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>; <br>        <br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            x = l1.val;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            y = l2.val;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算当前位的和与进位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br>        carry = sum / <span class="hljs-number">10</span>; <br><br>        <span class="hljs-comment">// 取当前位的数字，创建新节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum % <span class="hljs-number">10</span>);<br>        l3.next = newNode; <br>        l3 = l3.next; <br><br>        <span class="hljs-comment">// 继续遍历 l1 和 l2</span><br>        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;<br>            l1 = l1.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;<br>            l2 = l2.next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果最后还有进位，创建一个新的节点</span><br>    <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        l3.next = newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.next; <span class="hljs-comment">// 返回头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="29-删除链表的倒数第N个结点"><a href="#29-删除链表的倒数第N个结点" class="headerlink" title="29. 删除链表的倒数第N个结点"></a>29. 删除链表的倒数第N个结点</h1><ul><li><strong>一句话总结：</strong> 创建一个dummy,<strong>快慢指针指向dummy</strong>；<strong>快指针先走n+1步</strong>，然后<strong>快慢指针一起移动直到快指针为null</strong>，此时慢指针的位置就是要删除结点的前一个结点位置</li></ul><h2 id="29-1-题目描述"><a href="#29-1-题目描述" class="headerlink" title="29.1 题目描述"></a>29.1 题目描述</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="29-2-算法思想和代码实现"><a href="#29-2-算法思想和代码实现" class="headerlink" title="29.2 算法思想和代码实现"></a>29.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">// 创建虚拟头结点，避免删除头节点时判断麻烦</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> dummy;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-comment">// fast先走n+1步，保持间距</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        fast = fast.next;<br>    &#125;<br><br>    <span class="hljs-comment">// fast 和 slow 同时移动，直到 fast 到达链表末尾</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除倒数第n个节点</span><br>    slow.next = slow.next.next;<br><br>    <span class="hljs-comment">// 返回新的头结点</span><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="30-两两交换链表中的节点"><a href="#30-两两交换链表中的节点" class="headerlink" title="30. 两两交换链表中的节点"></a>30. 两两交换链表中的节点</h1><ul><li><strong>一句话描述：</strong> 模拟即可</li></ul><h2 id="30-1-题目描述"><a href="#30-1-题目描述" class="headerlink" title="30.1 题目描述"></a>30.1 题目描述</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h2 id="30-2-算法思想和代码实现"><a href="#30-2-算法思想和代码实现" class="headerlink" title="30.2 算法思想和代码实现"></a>30.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>     <span class="hljs-comment">// 创建虚拟头节点，方便处理头节点交换的问题</span><br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>     dummy.next = head;<br>     <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy; <span class="hljs-comment">// cur用来遍历链表</span><br>     <br>     <span class="hljs-keyword">while</span>(cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// node1是第一个结点，node2是第二个结点</span><br>         <span class="hljs-type">ListNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> cur.next;<br>         <span class="hljs-type">ListNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> cur.next.next;<br><br>         <span class="hljs-comment">// 交换节点</span><br>         cur.next = node2;<br>         node1.next = node2.next;<br>         node2.next = node1;<br><br>         <span class="hljs-comment">// cur 移动到下一对节点前的位置</span><br>         cur = node1;<br>     &#125;<br>     <br>     <span class="hljs-keyword">return</span> dummy.next;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="31-K个一组翻转链表"><a href="#31-K个一组翻转链表" class="headerlink" title="31. K个一组翻转链表"></a>31. K个一组翻转链表</h1><ul><li><strong>一句话总结：</strong> <strong>反转</strong>+<strong>找到K个结点一组</strong>即可，每次记录开始结点和终止结点</li></ul><h2 id="31-1-题目描述"><a href="#31-1-题目描述" class="headerlink" title="31.1 题目描述"></a>31.1 题目描述</h2><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], k = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="31-2-算法思想和代码实现"><a href="#31-2-算法思想和代码实现" class="headerlink" title="31.2 算法思想和代码实现"></a>31.2 算法思想和代码实现</h2><ol><li>找到 k 个节点，如果数量不足 k，直接返回 head。</li><li>翻转 k 个节点，并将翻转后的部分连接到新链表。</li><li>更新指针，继续处理下一个 k 组。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummy.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> cur.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> cur;<br><br>        <span class="hljs-comment">// 判断剩余长度是否 &gt;= k</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">null</span>; i++) &#123;<br>            end = end.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 不足k个，结束循环</span><br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>        end.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 截断k组</span><br>        cur.next = reverse(start);  <span class="hljs-comment">// 翻转k组</span><br>        start.next = next;  <span class="hljs-comment">// 接回链表</span><br>        cur = start;  <span class="hljs-comment">// cur 移动到下一组前</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br><span class="hljs-comment">//反转链表</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = cur;<br>        cur = head;<br>        head = nextNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="32-随机链表的复制"><a href="#32-随机链表的复制" class="headerlink" title="32. 随机链表的复制"></a>32. 随机链表的复制</h1><ul><li><strong>一句话总结：</strong> 使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制</li></ul><h2 id="32-1-题目描述"><a href="#32-1-题目描述" class="headerlink" title="32.1 题目描述"></a>32.1 题目描述</h2><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。<br>你的代码 只 接受原链表的头节点 head 作为传入参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br>输出：[[<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>],[<span class="hljs-number">13</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><h2 id="32-2-算法思想和代码实现"><a href="#32-2-算法思想和代码实现" class="headerlink" title="32.2 算法思想和代码实现"></a>32.2 算法思想和代码实现</h2><h3 id="使用-HashMap-存储旧节点与新节点的对应关系，并分两步完成链表复制："><a href="#使用-HashMap-存储旧节点与新节点的对应关系，并分两步完成链表复制：" class="headerlink" title="使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制："></a>使用 HashMap 存储旧节点与新节点的对应关系，并分两步完成链表复制：</h3><ol><li>复制 next 指针并建立映射关系<ul><li>遍历原链表，创建新链表的 next 结构，同时在 HashMap 中存储每个旧节点对应的新节点。</li><li>这样可以保证新链表的 next 结构和原链表一致。</li></ul></li><li>复制 random 指针<ul><li>再次遍历链表，通过 HashMap 查询旧链表的 random 指向的节点，并将其映射到新链表的 random 指针。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;<br>     <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 若链表为空，则直接返回 null</span><br><br>     <span class="hljs-comment">// 创建 HashMap，用于保存旧节点与新节点的对应关系</span><br>     Map&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>     <span class="hljs-comment">// 1. 通过 next 指针创建出新链表，并建立旧节点到新节点的映射关系</span><br>     <span class="hljs-type">Node</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(head.val); <span class="hljs-comment">// 复制头节点</span><br>     <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> newHead, oldNode = head.next; <span class="hljs-comment">// newNode 指向新链表，oldNode 遍历旧链表</span><br>     map.put(head, newHead); <span class="hljs-comment">// 记录头节点映射关系</span><br>     map.put(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 处理 random 指向 null 的情况</span><br><br>     <span class="hljs-keyword">while</span> (oldNode != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 遍历旧链表，复制所有节点</span><br>         <span class="hljs-type">Node</span> <span class="hljs-variable">tempNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(oldNode.val); <span class="hljs-comment">// 创建新节点</span><br>         newNode.next = tempNode; <span class="hljs-comment">// 连接新节点</span><br>         newNode = newNode.next; <span class="hljs-comment">// 移动新链表指针</span><br>         map.put(oldNode, newNode); <span class="hljs-comment">// 记录映射关系</span><br>         oldNode = oldNode.next; <span class="hljs-comment">// 继续遍历旧链表</span><br>     &#125;<br><br>     <span class="hljs-comment">// 2. 复制 random 指针</span><br>     oldNode = head;<br>     newNode = newHead;<br>     <span class="hljs-keyword">while</span> (oldNode != <span class="hljs-literal">null</span>) &#123;<br>         newNode.random = map.get(oldNode.random); <span class="hljs-comment">// 通过 map 获取对应的新节点并赋值</span><br>         newNode = newNode.next; <span class="hljs-comment">// 移动到下一个新节点</span><br>         oldNode = oldNode.next; <span class="hljs-comment">// 移动到下一个旧节点</span><br>     &#125;<br><br>     <span class="hljs-keyword">return</span> newHead; <span class="hljs-comment">// 返回新链表的头节点</span><br> &#125;<br></code></pre></td></tr></table></figure><h1 id="33-排序链表"><a href="#33-排序链表" class="headerlink" title="33. 排序链表"></a>33. 排序链表</h1><ul><li><strong>一句话总结：</strong></li><li><strong>归并排序</strong><ul><li>使用<strong>快慢指针找到链表中点</strong>，将链表以中点<strong>拆分</strong>成左右链表递归排序，将两个链表<strong>合并</strong>成有序链表</li></ul></li></ul><h2 id="33-1-题目描述"><a href="#33-1-题目描述" class="headerlink" title="33.1 题目描述"></a>33.1 题目描述</h2><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="33-2-算法思想和代码实现"><a href="#33-2-算法思想和代码实现" class="headerlink" title="33.2 算法思想和代码实现"></a>33.2 算法思想和代码实现</h2><ul><li>归并排序: 分治法，将链表递归拆分，然后合并排序</li></ul><ol><li>递归终止条件<ul><li>当链表为空（head &#x3D;&#x3D; null）或只有一个节点（head.next &#x3D;&#x3D; null），直接返回 head。</li></ul></li><li>找到链表中点（快慢指针法）<ul><li>使用 slow 和 fast 指针，让 fast 先走一步，保证 slow 取左中位数，防止死循环。</li></ul></li><li>拆分链表<ul><li>mid.next &#x3D; null 断开链表，分为左右两部分递归排序。</li></ul></li><li>合并有序链表<ul><li>使用双指针合并两个有序链表（归并排序的核心）</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> head;<br><br>    <span class="hljs-comment">//将链表从中间分割成两个链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> getMiddle(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">rightHead</span> <span class="hljs-operator">=</span> mid.next;<br>    mid.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//断开前一个链表</span><br><br>    <span class="hljs-comment">//递归排序分割后的两块链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(rightHead);<br><br>    <span class="hljs-comment">//将链表归并</span><br>    <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br><br><br><span class="hljs-comment">//找到链表中间结点</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">//归并两个链表</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>    <span class="hljs-comment">//依次比较两个链表的结点的大小，小的加上去</span><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;<br>            cur.next = l1;<br>            l1 = l1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur.next = l2;<br>            l2 = l2.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br><br>    <span class="hljs-comment">//看哪个链表有剩余的，加上去</span><br>    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) cur.next = l1;<br>    <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) cur.next = l2;<br><br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="34-合并K个升序链表"><a href="#34-合并K个升序链表" class="headerlink" title="34. 合并K个升序链表"></a>34. 合并K个升序链表</h1><ul><li><strong>一句话总结：</strong> 使用<strong>最小堆</strong>(优先级队列)维护k个链表的当前最小节点，每次<strong>出队最小结点</strong>，<strong>入队最小结点的下一个结点</strong>，直到队列为空</li></ul><h2 id="34-1-题目描述"><a href="#34-1-题目描述" class="headerlink" title="34.1 题目描述"></a>34.1 题目描述</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="34-2-算法思想和代码实现"><a href="#34-2-算法思想和代码实现" class="headerlink" title="34.2 算法思想和代码实现"></a>34.2 算法思想和代码实现</h2><ul><li>使用最小堆（优先队列）来维护 k 个链表的当前最小节点，每次取出最小值并推进链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>       <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> lists.length;<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> dummy;<br><br>       PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> &#123; <span class="hljs-comment">//重写比较器</span><br>               <span class="hljs-keyword">return</span> o1.val - o2.val;<br>           &#125;<br>       &#125;);<br><br>       <span class="hljs-comment">//先把k个链表的头结点放进优先级队列中</span><br>       <span class="hljs-keyword">for</span> (ListNode head : lists) &#123;<br>           <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>               pq.offer(head);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">//将最小的结点弹出来并连接到有序链表后，将弹出来的结点的下一个结点入队</span><br>       <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>           <span class="hljs-type">ListNode</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> pq.poll();<br>           cur.next = minNode;<br>           cur = cur.next;<br><br>           <span class="hljs-keyword">if</span> (minNode.next != <span class="hljs-literal">null</span>)<br>               pq.offer(minNode.next);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dummy.next;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="35-LRU缓存"><a href="#35-LRU缓存" class="headerlink" title="35. LRU缓存"></a>35. LRU缓存</h1><ul><li><strong>一句话描述：</strong> 定义<strong>双向链表</strong>维护缓存队列，定义<strong>哈希表</strong>维护当前队列的键和值，并提供快速查找结点</li></ul><h2 id="35-1-题目描述"><a href="#35-1-题目描述" class="headerlink" title="35.1 题目描述"></a>35.1 题目描述</h2><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><h2 id="35-2-算法思想和代码实现"><a href="#35-2-算法思想和代码实现" class="headerlink" title="35.2 算法思想和代码实现"></a>35.2 算法思想和代码实现</h2><h3 id="双向链表-HashMap"><a href="#双向链表-HashMap" class="headerlink" title="双向链表 + HashMap"></a>双向链表 + HashMap</h3><ul><li>双向链表维护缓存队列</li><li>哈希表：通过key快速查找Node</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">//哈希表保存结点的键和值</span><br>    HashMap&lt;Integer, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">//创建一个虚头结点和尾结点</span><br>    Node head, tail;<br><br>    <span class="hljs-comment">//使用双向链表模拟缓存队列</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node next, prev;<br><br>        Node() &#123;<br>        &#125;<br><br>        Node(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value) &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);<br><br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br><br>    <span class="hljs-comment">//使用缓存中的key，更新缓存队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-comment">//如果不存在，返回-1</span><br>        <span class="hljs-keyword">if</span> (!map.containsKey(key))<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//存在，将缓存中的当前结点移动到队头的后面，并删除当前位置的当前结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.get(key);<br>        removeNode(cur);<br>        moveToHead(cur);<br><br>        <span class="hljs-keyword">return</span> cur.value;<br>    &#125;<br><br>    <span class="hljs-comment">//添加缓存中的结点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">//已经存在了当前的key，删除原本的结点和哈希表中的key</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">olddNode</span> <span class="hljs-operator">=</span> map.get(key);<br>            removeNode(olddNode);<br>            map.remove(key);<br>        &#125;<br><br>        <span class="hljs-comment">//在哈希表和缓存队列中添加当前结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);<br>        map.put(key, newNode);<br>        moveToHead(newNode);<br><br>        <span class="hljs-comment">//如果哈希表中的结点大于容量，删除队尾的缓存结点和哈希表中的队尾结点元素</span><br>        <span class="hljs-keyword">if</span> (map.size() &gt; capacity) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">lastNode</span> <span class="hljs-operator">=</span> tail.prev;<br>            <span class="hljs-keyword">if</span> (lastNode != head) &#123;<br>                removeNode(lastNode);<br>                map.remove(lastNode.key);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//删除当前结点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br><br>    <span class="hljs-comment">//将当前结点添加到头结点的后面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToHead</span><span class="hljs-params">(Node node)</span> &#123;<br>        node.prev = head;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="36-二叉树的中序遍历"><a href="#36-二叉树的中序遍历" class="headerlink" title="36. 二叉树的中序遍历"></a>36. 二叉树的中序遍历</h1><ul><li><strong>一句话总结：</strong> <strong>左根右递归</strong></li></ul><h2 id="36-1-题目描述"><a href="#36-1-题目描述" class="headerlink" title="36.1 题目描述"></a>36.1 题目描述</h2><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="36-2-算法思想和代码实现"><a href="#36-2-算法思想和代码实现" class="headerlink" title="36.2 算法思想和代码实现"></a>36.2 算法思想和代码实现</h2><h3 id="递归：左根右"><a href="#递归：左根右" class="headerlink" title="递归：左根右"></a>递归：左根右</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> list;<br>    inorderTraversal(root.left);<br>    list.add(root.val);<br>    inorderTraversal(root.right);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="37-二叉树的最大深度"><a href="#37-二叉树的最大深度" class="headerlink" title="37. 二叉树的最大深度"></a>37. 二叉树的最大深度</h1><ul><li><strong>一句话总结：</strong> 当前节点为空返回0，递归计算左右子树的深度，取左右子树的较大值加1</li></ul><h2 id="37-1-题目描述"><a href="#37-1-题目描述" class="headerlink" title="37.1 题目描述"></a>37.1 题目描述</h2><p>给定一个二叉树 root ，返回其最大深度。</p><p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="37-2-算法思想和代码实现"><a href="#37-2-算法思想和代码实现" class="headerlink" title="37.2 算法思想和代码实现"></a>37.2 算法思想和代码实现</h2><p>递归计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 如果当前节点为空，则返回深度 0</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 递归计算左子树的最大深度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br><br>    <span class="hljs-comment">// 递归计算右子树的最大深度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>    <span class="hljs-comment">// 当前节点的深度为左右子树深度的较大值 + 1</span><br>    <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="38-翻转二叉树"><a href="#38-翻转二叉树" class="headerlink" title="38. 翻转二叉树"></a>38. 翻转二叉树</h1><ul><li><strong>一句话描述：</strong> 递归交换左右子树即可</li></ul><h2 id="38-1-题目描述"><a href="#38-1-题目描述" class="headerlink" title="38.1 题目描述"></a>38.1 题目描述</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="38-2-算法思想和代码实现"><a href="#38-2-算法思想和代码实现" class="headerlink" title="38.2 算法思想和代码实现"></a>38.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 如果当前节点为空，则直接返回 null</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 暂存当前节点的左子节点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br><br>    <span class="hljs-comment">// 递归反转右子树，并赋值给当前节点的左子节点</span><br>    root.left = invertTree(root.right);<br>    <span class="hljs-comment">// 递归反转左子树，并赋值给当前节点的右子节点</span><br>    root.right = invertTree(left);<br>    <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="39-对称二叉树"><a href="#39-对称二叉树" class="headerlink" title="39. 对称二叉树"></a>39. 对称二叉树</h1><ul><li><strong>一句话总结：</strong> </li><li>两个子树<strong>都为空则对称</strong></li><li>如果<strong>左右子树都不为空且值相等</strong>，同时<strong>左树的右子树和右树的左子树对称</strong>，同时<strong>左树的左子树和右树的右子树对称</strong>，则对称</li></ul><h2 id="39-1-题目描述"><a href="#39-1-题目描述" class="headerlink" title="39.1 题目描述"></a>39.1 题目描述</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="39-2-算法思想和代码实现"><a href="#39-2-算法思想和代码实现" class="headerlink" title="39.2 算法思想和代码实现"></a>39.2 算法思想和代码实现</h2><ol><li>怎么判断一棵树是不是对称二叉树？<br>答案：如果所给根节点，为空，那么是对称。如果不为空的话，当他的左子树与右子树对称时，他对称</li><li>那么怎么知道左子树与右子树对不对称呢？在这我直接叫为左树和右树<br>答案：如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>       <span class="hljs-keyword">return</span> fun(root.left, root.right);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>       <span class="hljs-comment">// 如果两个子树都为空，则对称</span><br>       <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>       <span class="hljs-comment">// 如果左右子树都不为空且值相等，</span><br>       <span class="hljs-comment">// 同时左树的右子树和右树的左子树对称，</span><br>       <span class="hljs-comment">// 同时左树的左子树和右树的右子树对称，则对称</span><br>       <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span> &amp;&amp; left.val == right.val &amp;&amp; fun(left.left, right.right)<br>               &amp;&amp; fun(left.right, right.left))<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>       <span class="hljs-comment">// 其他情况不对称</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="40-二叉树的直径"><a href="#40-二叉树的直径" class="headerlink" title="40. 二叉树的直径"></a>40. 二叉树的直径</h1><ul><li><strong>一句话描述：</strong> 递归计算每个节点的<strong>左右子树的最大深度</strong>，<strong>当前节点的直径&#x3D;左子树深度+右子树深度</strong>，<strong>更新</strong>最大直径</li></ul><h2 id="40-1-题目描述"><a href="#40-1-题目描述" class="headerlink" title="40.1 题目描述"></a>40.1 题目描述</h2><p>给你一棵二叉树的根节点，返回该树的 直径 。<br>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。<br>两节点之间路径的 长度 由它们之间边数表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> ，取路径 [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 或 [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 的长度。<br></code></pre></td></tr></table></figure><h2 id="40-2-算法思想和代码实现"><a href="#40-2-算法思想和代码实现" class="headerlink" title="40.2 算法思想和代码实现"></a>40.2 算法思想和代码实现</h2><ul><li>递归思想：计算每个节点的左右子树深度，并更新最大直径。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      maxDepth(root);<br>      <span class="hljs-keyword">return</span> max;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-comment">// 递归计算左右子树的最大深度</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> maxDepth(root.left);<br>      <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxDepth(root.right);<br><br>      <span class="hljs-comment">// 用左子树深度 + 右子树深度更新最大直径</span><br>      max = Math.max(max, left + right);<br><br>      <span class="hljs-comment">// 返回当前节点的最大深度 = 左右子树最大深度 + 1（算上当前节点）</span><br>      <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="41-二叉树的层序遍历"><a href="#41-二叉树的层序遍历" class="headerlink" title="41. 二叉树的层序遍历"></a>41. 二叉树的层序遍历</h1><ul><li><strong>一句话描述：</strong> 使用队列存储每层的结点，使用size记录当前层结点的个数，循环<strong>出队</strong>层中的结点，<strong>入队下一层左右子树的结点</strong>，直到队空为止</li></ul><h2 id="41-1-题目描述"><a href="#41-1-题目描述" class="headerlink" title="41.1 题目描述"></a>41.1 题目描述</h2><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]<br></code></pre></td></tr></table></figure><h2 id="41-2-算法思想和代码实现"><a href="#41-2-算法思想和代码实现" class="headerlink" title="41.2 算法思想和代码实现"></a>41.2 算法思想和代码实现</h2><p>使用<strong>队列</strong>（Queue） 作为辅助数据结构，按照层的顺序依次处理每个节点。</p><ol><li>先将 根节点入队，然后进入循环：<ul><li>记录当前层的节点个数 size。</li><li>遍历当前层的 size 个节点：<ul><li>弹出队列头部节点，并将其值存入当前层的列表中。</li><li>将该节点的左右子节点入队（若存在）。</li></ul></li></ul></li><li>遍历完整层后，将当前层的列表加入最终结果。</li><li>继续处理下一层，直至队列为空，即所有节点都被遍历完。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br><br>     <span class="hljs-comment">// 创建队列用于层序遍历</span><br>     Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>     <span class="hljs-comment">// 用于存储最终的层序遍历结果</span><br>     List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br><br>     queue.offer(root); <span class="hljs-comment">// 先将根节点入队</span><br><br>     <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size(); <span class="hljs-comment">// 记录当前层的节点数</span><br>         List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 用于存储当前层的节点值</span><br>         <br>         <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll(); <span class="hljs-comment">// 取出队列元素</span><br><br>             <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)<br>                 queue.offer(node.left); <span class="hljs-comment">// 左子节点入队</span><br>             <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)<br>                 queue.offer(node.right); <span class="hljs-comment">// 右子节点入队</span><br><br>             list.add(node.val); <br>             size--;<br>         &#125;<br><br>         res.add(list); <br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="42-将有序数组转换为二叉搜索树"><a href="#42-将有序数组转换为二叉搜索树" class="headerlink" title="42. 将有序数组转换为二叉搜索树"></a>42. 将有序数组转换为二叉搜索树</h1><ul><li><strong>一句话描述：</strong> 以数组的中间元素作为root结点，左区间递归构造左子树root.left,右区间递归构造右子树root.right，直到数组区间索引left&gt;right终止</li></ul><h2 id="42-1-题目描述"><a href="#42-1-题目描述" class="headerlink" title="42.1 题目描述"></a>42.1 题目描述</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [-<span class="hljs-number">10</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]<br>输出：[<span class="hljs-number">0</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,-<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>]<br>解释：[<span class="hljs-number">0</span>,-<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,-<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>] 也将被视为正确答案：<br></code></pre></td></tr></table></figure><h2 id="42-2-算法思想和代码实现"><a href="#42-2-算法思想和代码实现" class="headerlink" title="42.2 算法思想和代码实现"></a>42.2 算法思想和代码实现</h2><ul><li>将有序数组从中间分割，分为左区间和右区间</li><li>左区间用来构造左子树</li><li>右区间用来构造右子树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">return</span> sortTree(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">//构造当前结点</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br><br>    <span class="hljs-comment">//递归构造左子树和右子树</span><br>    root.left = sortTree(nums, left, mid - <span class="hljs-number">1</span>);<br>    root.right = sortTree(nums, mid + <span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="43-验证二叉搜索树"><a href="#43-验证二叉搜索树" class="headerlink" title="43. 验证二叉搜索树"></a>43. 验证二叉搜索树</h1><ul><li><strong>一句话描述：</strong> <strong>构建子树的大小边界</strong>，左右子树的值在边界外返回false，递归遍历左右子树</li></ul><h2 id="43-1-题目描述"><a href="#43-1-题目描述" class="headerlink" title="43.1 题目描述"></a>43.1 题目描述</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 小于 当前节点的数。</li><li>节点的右子树只包含 大于 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="43-2-算法思想和代码实现"><a href="#43-2-算法思想和代码实现" class="headerlink" title="43.2 算法思想和代码实现"></a>43.2 算法思想和代码实现</h2><h3 id="43-2-1-中序遍历-集合有序"><a href="#43-2-1-中序遍历-集合有序" class="headerlink" title="43.2.1 中序遍历+集合有序"></a>43.2.1 中序遍历+集合有序</h3><ul><li>中序遍历的结果如果是一个升序的，则返回true</li><li>用一个集合保存中序遍历结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个集合保存二叉树元素</span><br>List&lt;Integer&gt; list =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    inorderTraversal(root);<br>    <span class="hljs-comment">//中序遍历如果是一个升序的结果，则返回true</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size()-<span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(list.get(i)&gt;=list.get(i+<span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    inorderTraversal(root.left);<br>    list.add(root.val);<br>    inorderTraversal(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="43-2-2-递归检查"><a href="#43-2-2-递归检查" class="headerlink" title="43.2.2 递归检查"></a>43.2.2 递归检查</h3><ul><li>每个节点 root.val 必须在某个范围内，即：<ul><li>左子树的所有节点值必须 小于 root.val</li><li>右子树的所有节点值必须 大于 root.val</li></ul></li><li>递归过程中，维护 <strong>当前允许的最大值 max 和最小值 min</strong>，如果 root.val 超出范围，则不是 BST。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> min, <span class="hljs-type">long</span> max)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 检查当前节点是否在允许范围内</span><br>        <span class="hljs-keyword">if</span> (node.val &lt;= min || node.val &gt;= max) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 递归检查左右子树</span><br>        <span class="hljs-keyword">return</span> isValidBST(node.left, min, node.val) &amp;&amp; isValidBST(node.right, node.val, max);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="44-二叉搜索树中第K小的元素"><a href="#44-二叉搜索树中第K小的元素" class="headerlink" title="44. 二叉搜索树中第K小的元素"></a>44. 二叉搜索树中第K小的元素</h1><ul><li><strong>一句话描述：</strong> 二叉搜索树用<strong>中序遍历</strong>即为一个升序的数组，<strong>直接计数</strong>到第k个遍历的结点时，返回当前元素即可</li></ul><h2 id="44-1-题目描述"><a href="#44-1-题目描述" class="headerlink" title="44.1 题目描述"></a>44.1 题目描述</h2><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="44-2-算法思想和代码实现"><a href="#44-2-算法思想和代码实现" class="headerlink" title="44.2 算法思想和代码实现"></a>44.2 算法思想和代码实现</h2><ul><li>二叉搜索树的中序遍历是一个升序的数据</li><li>中序遍历，到第k个遍历的元素后，返回当前结点元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前访问的节点数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最终结果</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> k)</span> &#123;<br>    inorder(root, k);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    inorder(node.left, k); <span class="hljs-comment">// 递归左子树</span><br><br>    count++; <span class="hljs-comment">// 访问当前节点</span><br>    <span class="hljs-keyword">if</span> (count == k) &#123;<br>        result = node.val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    inorder(node.right, k); <span class="hljs-comment">// 递归右子树</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="45-二叉树的右视图"><a href="#45-二叉树的右视图" class="headerlink" title="45. 二叉树的右视图"></a>45. 二叉树的右视图</h1><ul><li><strong>一句话描述：</strong> 使用队列进行<strong>层序遍历</strong>，找到每层最右边的结点即可</li></ul><h2 id="45-1-题目描述"><a href="#45-1-题目描述" class="headerlink" title="45.1 题目描述"></a>45.1 题目描述</h2><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="45-2-算法思想和代码实现"><a href="#45-2-算法思想和代码实现" class="headerlink" title="45.2 算法思想和代码实现"></a>45.2 算法思想和代码实现</h2><ul><li>思想：找到层序遍历的每层最后一个结点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br><br>    <span class="hljs-comment">//层序遍历</span><br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br><br>        <span class="hljs-keyword">while</span>(size&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br><br>            <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)<br>                queue.offer(node.left);<br>            <span class="hljs-keyword">if</span>(node.right!=<span class="hljs-literal">null</span>)<br>                queue.offer(node.right);<br><br>            size--;<br>            <br>            <span class="hljs-comment">//返回每层的最后一个结果，也就是最右边的结点</span><br>            <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>) res.add(node.val);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="46-二叉树展开为链表"><a href="#46-二叉树展开为链表" class="headerlink" title="46. 二叉树展开为链表"></a>46. 二叉树展开为链表</h1><ul><li><strong>一句话描述：</strong> 创建一个新结点，使用<strong>新结点的右子树连接当前root结点</strong>，然后<strong>前序遍历</strong>递归连接root的左子树、root的右子树</li></ul><h2 id="46-1-题目描述"><a href="#46-1-题目描述" class="headerlink" title="46.1 题目描述"></a>46.1 题目描述</h2><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li><li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h2 id="46-2-算法思想和代码实现"><a href="#46-2-算法思想和代码实现" class="headerlink" title="46.2 算法思想和代码实现"></a>46.2 算法思想和代码实现</h2><ul><li>以 先序遍历（根-左-右） 的方式展开二叉树。</li><li>使用 cur 变量记录上一个访问的节点，并将 cur.right 指向当前节点 root，从而形成链表结构。</li><li>cur 变量始终存储着已经展开的最后一个节点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cur 记录上一个访问的节点</span><br><span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 先保存左、右子树（因为后面会修改 root.left 和 root.right）</span><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> root.left;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> root.right;<br><br>    <span class="hljs-comment">// 如果 cur 不为空，说明已经处理过前一个节点</span><br>    <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        cur.left = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 断开左子树</span><br>        cur.right = root; <span class="hljs-comment">// 让上一个节点的右子树指向当前节点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 更新 cur 为当前节点</span><br>    cur = root;<br><br>    <span class="hljs-comment">// 递归处理左右子树</span><br>    flatten(left);<br>    flatten(right);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="47-从前序与中序遍历序列构造二叉树"><a href="#47-从前序与中序遍历序列构造二叉树" class="headerlink" title="47. 从前序与中序遍历序列构造二叉树"></a>47. 从前序与中序遍历序列构造二叉树</h1><ul><li><strong>一句话描述：</strong> <strong>哈希表</strong>存储中序数组便于查找索引，前序数组第一个元素就是根节点，使用<strong>中序数组划分左右子树</strong>后进行递归构建左右子树</li></ul><h2 id="47-1-题目描述"><a href="#47-1-题目描述" class="headerlink" title="47.1 题目描述"></a>47.1 题目描述</h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]<br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><h2 id="47-2-算法思想和代码实现"><a href="#47-2-算法思想和代码实现" class="headerlink" title="47.2 算法思想和代码实现"></a>47.2 算法思想和代码实现</h2><h3 id="递归-哈希表优化查找"><a href="#递归-哈希表优化查找" class="headerlink" title="递归 + 哈希表优化查找"></a>递归 + 哈希表优化查找</h3><ul><li>先序遍历的第一个元素一定是当前子树的根节点</li><li>利用中序遍历划分左右子树<ul><li>中序遍历查找根节点的位置 rootIndex，从而确定 左子树的大小 (leftSize &#x3D; rootIndex - inLeft)</li><li>左子树的范围在 [inLeft, rootIndex - 1]，右子树的范围在 [rootIndex + 1, inRight]</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>       <span class="hljs-comment">//将中序遍历数组的元素作为key,索引作为value存储在哈希表中</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>           map.put(inorder[i], i);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> buildTree(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span> preLeft, <span class="hljs-type">int</span> preRight, <span class="hljs-type">int</span> inLeft, <span class="hljs-type">int</span> inRight)</span> &#123;<br>       <span class="hljs-comment">//递归终止条件</span><br>       <span class="hljs-keyword">if</span> (preLeft &gt; preRight || inLeft &gt; inRight) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-comment">//前序遍历第一个结点一定是根结点，记录此根结点在中序遍历的位置，计算左子树大小</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[preLeft]);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(preorder[preLeft]);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">leftSize</span> <span class="hljs-operator">=</span> rootIndex - inLeft;<br><br>       <span class="hljs-comment">//递归构造左右子树</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> buildTree(preorder, preLeft + <span class="hljs-number">1</span>, preLeft + leftSize, inLeft, rootIndex - <span class="hljs-number">1</span>);<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> buildTree(preorder, preLeft + leftSize + <span class="hljs-number">1</span>, preRight, rootIndex + <span class="hljs-number">1</span>, inRight);<br><br>       root.left = left;<br>       root.right = right;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="48-路径总和-III"><a href="#48-路径总和-III" class="headerlink" title="48. 路径总和 III"></a>48. 路径总和 III</h1><ul><li><strong>一句话描述：</strong> 使用<strong>哈希表存储前缀和</strong>出现次数，backtracking(){终止条件{在哈希表找到(<strong>当前路径总和-目标值</strong>)的次数加到结果}，在哈希表<strong>添加当前路径总和</strong>，<strong>递归</strong>左右子树，<strong>回溯撤销</strong>哈希表添加的当前路径总和}</li></ul><h2 id="48-1-题目描述"><a href="#48-1-题目描述" class="headerlink" title="48.1 题目描述"></a>48.1 题目描述</h2><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], targetSum = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">3</span><br>解释：和等于 <span class="hljs-number">8</span> 的路径有 <span class="hljs-number">3</span> 条，如图所示。<br></code></pre></td></tr></table></figure><h2 id="48-2-算法思想和代码实现"><a href="#48-2-算法思想和代码实现" class="headerlink" title="48.2 算法思想和代码实现"></a>48.2 算法思想和代码实现</h2><h3 id="48-2-1-递归遍历所有的子树"><a href="#48-2-1-递归遍历所有的子树" class="headerlink" title="48.2.1 递归遍历所有的子树"></a>48.2.1 递归遍历所有的子树</h3><ol><li>递归遍历<ul><li>以当前节点为起点计算符合条件的路径数（调用 dfs）。</li><li>分别递归左子树和右子树，继续以子树的根作为起点计算符合条件的路径数（调用 pathSum）。</li></ul></li><li>深度优先搜索（DFS）计算路径数<ul><li>dfs(root, target): 计算以 root 为起点的路径总数：<ul><li>若当前节点值 root.val 等于 target，则计数 count++。</li><li>递归计算 root.left 和 root.right，更新路径数。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> targetSum)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>       <span class="hljs-comment">//依次将当前根结点作为一个树，左子树作为一个树，右子树作为一个树进行递归</span><br>       <span class="hljs-keyword">return</span> dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);<br>   &#125;<br><br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">long</span> target)</span> &#123;<br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <br>       <span class="hljs-comment">//如果当前结点等于Target则为一个路径</span><br>       <span class="hljs-keyword">if</span> (root.val == target)<br>           count++;<br><br>       <span class="hljs-comment">//递归左子树和右子树，将target减去当前结点的值</span><br>       count += dfs(root.left, target - root.val) + dfs(root.right, target - root.val);<br>       <span class="hljs-keyword">return</span> count;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="48-2-2-前缀和-回溯"><a href="#48-2-2-前缀和-回溯" class="headerlink" title="48.2.2 前缀和+回溯"></a>48.2.2 前缀和+回溯</h3><ol><li>使用哈希表存储前缀和出现次数<ul><li>设 prefixSum 记录从根到当前节点的路径和：<ul><li>若 prefixSum[j] - prefixSum[i] &#x3D; targetSum，则说明从 i+1 到 j 的路径和为 targetSum。</li></ul></li><li>只需要查询 prefixSum[j] - targetSum 是否出现过。</li></ul></li><li>深度优先遍历 + 回溯<ul><li>使用 <code>HashMap&lt;Long, Integer&gt;</code> 记录遍历过程中所有的 prefixSum 及其出现次数。</li><li>在递归进入子节点时，更新前缀和哈希表；</li><li>递归完成后，回溯删除当前节点贡献的前缀和，避免影响其他路径计算。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>        HashMap&lt;Long, Integer&gt; prefixSumCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 初始化前缀和为 0 的路径数量为 1（空路径）</span><br>        prefixSumCount.put(<span class="hljs-number">0L</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>, targetSum, prefixSumCount);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">long</span> currSum, <span class="hljs-type">int</span> targetSum, HashMap&lt;Long, Integer&gt; prefixSumCount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 更新当前前缀和</span><br>        currSum += node.val;<br><br>        <span class="hljs-comment">// 检查是否存在从某个祖先节点到当前节点的路径和等于 targetSum</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> prefixSumCount.getOrDefault(currSum - targetSum, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 记录当前前缀和出现次数</span><br>        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归进入左右子树</span><br>        count += dfs(node.left, currSum, targetSum, prefixSumCount);<br>        count += dfs(node.right, currSum, targetSum, prefixSumCount);<br><br>        <span class="hljs-comment">// 回溯：撤销当前节点对前缀和的影响</span><br>        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="49-二叉树的最近公共祖先"><a href="#49-二叉树的最近公共祖先" class="headerlink" title="49. 二叉树的最近公共祖先"></a>49. 二叉树的最近公共祖先</h1><ul><li><strong>一句话描述：</strong> 先判断当前结点是否是p或q，再递归判断左右子树，分为左右子树都找到了结点，左右子树只有一个找到了，左右子树都没找到四种情况</li></ul><h2 id="49-1-题目描述"><a href="#49-1-题目描述" class="headerlink" title="49.1 题目描述"></a>49.1 题目描述</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], p = <span class="hljs-number">5</span>, q = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><h2 id="49-2-算法思想和代码实现"><a href="#49-2-算法思想和代码实现" class="headerlink" title="49.2 算法思想和代码实现"></a>49.2 算法思想和代码实现</h2><ol><li>终止条件：<ul><li>如果 root 为空，说明已经递归到了叶子节点的空子树，返回 null。</li><li>如果 root 等于 p 或 q，说明找到了其中一个目标节点，直接返回 root（可能是最近公共祖先）。</li></ul></li><li>递归查找：<ul><li>在左子树中递归查找 p 和 q 的最近公共祖先 (left)。</li><li>在右子树中递归查找 p 和 q 的最近公共祖先 (right)。</li></ul></li><li>回溯过程：<ul><li>如果 left 和 right 都不为空，说明 p 和 q 分别位于 root 的左右子树，root 就是它们的最近公共祖先。</li><li>如果 left 为空，说明 p 和 q 都在 root 的右子树，返回 right。</li><li>如果 right 为空，说明 p 和 q 都在 root 的左子树，返回 left。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>       <span class="hljs-comment">//先看根结点是不是祖先(理论上，一定是祖先，但不一定是最近的祖先)</span><br>       <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>||root==p||root==q)<br>           <span class="hljs-keyword">return</span> root;<br><br>       <span class="hljs-comment">//找找最近的祖先，先看左子树，再看右子树</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.left, p, q);<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> lowestCommonAncestor(root.right, p, q);<br><br>       <span class="hljs-comment">//左右子树都找到了，说明是root</span><br>       <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> root;<br>       <span class="hljs-comment">//左子树找到了右子树没找到，返回左子树</span><br>       <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">return</span> left;<br>       <span class="hljs-comment">//左子树没找到右子树找到了，返回右子树</span><br>       <span class="hljs-keyword">return</span> right;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="50-二叉树中的最大路径和"><a href="#50-二叉树中的最大路径和" class="headerlink" title="50. 二叉树中的最大路径和"></a>50. 二叉树中的最大路径和</h1><ul><li><strong>一句话总结：</strong> 用一个全局变量记录最大值，<strong>递归记录左右子树的最大贡献</strong>，更新最大值，返回当前结点能为父节点的最大路径值(<strong>只能选左右子树的其中一个贡献大的子树</strong>)</li></ul><h2 id="50-1-题目描述"><a href="#50-1-题目描述" class="headerlink" title="50.1 题目描述"></a>50.1 题目描述</h2><p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。<br>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">6</span><br>解释：最优路径是 <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> ，路径和为 <span class="hljs-number">2</span> + <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="50-2-算法思想和代码实现"><a href="#50-2-算法思想和代码实现" class="headerlink" title="50.2 算法思想和代码实现"></a>50.2 算法思想和代码实现</h2><ol><li><p>递归遍历整棵树：</p><ul><li>计算左右子树的最大贡献值（如果贡献值小于 0，则丢弃）。</li><li>计算当前节点作为路径顶点时的最大路径和，并更新全局 maxPathSum。</li><li>计算当前节点能提供的最大贡献值，并返回给上一层递归。</li></ul></li><li><p>分情况讨论：</p><ul><li>路径断裂：返回当前子树的最大贡献值（只能选左右子树之一）。</li><li>路径不断裂：更新全局最大路径和（包含左右子树和当前节点）。</li></ul></li></ol><p>1、那么，首先我们可以假设走到了某个节点，现在要面临的问题是路径的最大值问题，显然对于这种问题，每遍历到一个节点，我们都要求出包含该节点在内的此时的最大路径，并且在之后的遍历中更新这个最大值。对于该节点来说，它的最大路径currpath就等于左右子树的最大路径加上本身的值，也就是currpath &#x3D; left+right+node,val，但是有一个前提，我们要求的是最大路径，所以若是left或者right小于等于0了，那么我们就没有必要把这些值加上了，因为加上一个负数，会使得最大路径变小。这里的最大路径中的最其实就是一个限定条件，也就是我们常说的贪心算法，只取最大，最好，其余的直接丢弃。</p><p>2、好了，1中的主体我们已经明确了，但是还存在一个问题，那就是left和right具体应该怎么求，也就是left和right的递归形式。显然我们要把node.left和node.right再次传输到递归函数中，重复上述的操作。但如果到达了叶子节点，是不是需要往上一层返回了呢？那么返回值又是多少呢？<br>我们要明确left和right的基本含义，它们表示的是最大贡献，那么一个节点的最大贡献就等于node.val+max(left,right)，这个节点本身选上，然后从它的左右子树中选择最大的那个加上。<br>对于叶子节点也是这样，但是叶子节点的左右子树都为空，所以加上0，哎，注意看，此时是不是边界条件也出来了，但节点为空时，返回0 。 好了，至此循环的主体，返回值，边界条件都定义好了，那么整个递归的代码是不是就水到渠成了。这样一看递归也没什么了不起的！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, dfs(node.left)); <span class="hljs-comment">// 左子树最大贡献</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, dfs(node.right)); <span class="hljs-comment">// 右子树最大贡献</span><br><br>    <span class="hljs-comment">// 以当前节点为最高点的路径和</span><br>    maxSum = Math.max(maxSum, left + right + node.val);<br><br>    <span class="hljs-comment">// 返回当前节点能为父节点贡献的最大路径值</span><br>    <span class="hljs-keyword">return</span> Math.max(left, right) + node.val;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="51-岛屿数量"><a href="#51-岛屿数量" class="headerlink" title="51. 岛屿数量"></a>51. 岛屿数量</h1><ul><li><strong>一句话总结：</strong> 若当前元素为’1’则计数加1，并感染周围的元素为’2’，防止重复计数</li></ul><h2 id="51-1-题目描述"><a href="#51-1-题目描述" class="headerlink" title="51.1 题目描述"></a>51.1 题目描述</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="51-2-算法思想和代码实现"><a href="#51-2-算法思想和代码实现" class="headerlink" title="51.2 算法思想和代码实现"></a>51.2 算法思想和代码实现</h2><ul><li>遍历岛这个二维数组，如果当前数为1，则进入感染函数并将岛个数+1</li><li>感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。<ul><li>为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//遍历所有元素，找到所有的岛，并感染岛的上下左右</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                count++;<br>                infect(grid, i, j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">//将当前的岛的元素全部感染成2，上下左右的元素置为2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">infect</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] != <span class="hljs-string">&#x27;1&#x27;</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    grid[i][j] = <span class="hljs-string">&#x27;2&#x27;</span>;<br><br>    <span class="hljs-comment">//感染上下左右的元素</span><br>    infect(grid, i - <span class="hljs-number">1</span>, j);<br>    infect(grid, i + <span class="hljs-number">1</span>, j);<br>    infect(grid, i, j - <span class="hljs-number">1</span>);<br>    infect(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="52-腐烂的橘子"><a href="#52-腐烂的橘子" class="headerlink" title="52. 腐烂的橘子"></a>52. 腐烂的橘子</h1><ul><li><strong>一句话描述：</strong> 先把当前状态转换替代成其他值，用<strong>时间标记当前腐烂的橘子</strong>，下一轮腐烂的橘子&#x3D;当前time+1，直到没有新橘子被感染跳出循环</li></ul><h2 id="52-1-题目描述"><a href="#52-1-题目描述" class="headerlink" title="52.1 题目描述"></a>52.1 题目描述</h2><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p><ul><li>值 0 代表空单元格；</li><li>值 1 代表新鲜橘子；</li><li>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="52-2-算法思想和代码实现"><a href="#52-2-算法思想和代码实现" class="headerlink" title="52.2 算法思想和代码实现"></a>52.2 算法思想和代码实现</h2><ol><li>状态转换：<ul><li>空位 0 被标记为 -2; 新鲜橘子 1 被标记为 -1; 腐烂橘子 2 被标记为 0</li></ul></li><li>BFS 模拟腐烂过程：<ul><li>遍历整个网格，找到所有腐烂橘子（初始 0 值）。</li><li>在 while 循环中，每分钟所有<strong>当前腐烂的橘子尝试感染其四个方向的新鲜橘子</strong></li><li>被感染的橘子被赋值为 time + 1，即表示它在 time+1 分钟后变烂。</li></ul></li><li>终止条件：<ul><li>如果在某一轮遍历中没有橘子被感染，说明腐烂过程结束，跳出循环。</li></ul></li><li>检查是否仍有未腐烂的橘子：<ul><li>遍历网格，如果仍然存在 -1（新鲜橘子），则返回 -1，表示无法全部腐烂。</li><li>否则，返回 time，即腐烂传播所需的总时间。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orangesRotting</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录腐烂传播所需的分钟数</span><br><br>        <span class="hljs-comment">// -2 表示空位，-1 表示新鲜橘子，0 表示腐烂橘子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                grid[i][j] -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 模拟腐烂过程</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">finished</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] == time) &#123;<br>                        <span class="hljs-comment">// 当前腐烂的橘子，尝试感染四个方向的新鲜橘子</span><br>                        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i - <span class="hljs-number">1</span>][j] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i][j - <span class="hljs-number">1</span>] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; m &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i + <span class="hljs-number">1</span>][j] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == -<span class="hljs-number">1</span>) &#123;<br>                            grid[i][j + <span class="hljs-number">1</span>] = time + <span class="hljs-number">1</span>;<br>                            finished = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (finished)<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 如果没有橘子被感染，结束循环</span><br>            <span class="hljs-keyword">else</span><br>                time++;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历网格，如果仍然存在未腐烂的橘子，返回 -1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == -<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="53-课程表"><a href="#53-课程表" class="headerlink" title="53. 课程表"></a>53. 课程表</h1><ul><li><strong>一句话描述：</strong> 判断一个有向图是否有环，不会….</li></ul><h2 id="53-1-题目描述"><a href="#53-1-题目描述" class="headerlink" title="53.1 题目描述"></a>53.1 题目描述</h2><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p><p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。<br>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：numCourses = <span class="hljs-number">2</span>, prerequisites = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-literal">true</span><br>解释：总共有 <span class="hljs-number">2</span> 门课程。学习课程 <span class="hljs-number">1</span> 之前，你需要完成课程 <span class="hljs-number">0</span> 。这是可能的。<br></code></pre></td></tr></table></figure><h2 id="53-2-算法思想和代码实现"><a href="#53-2-算法思想和代码实现" class="headerlink" title="53.2 算法思想和代码实现"></a>53.2 算法思想和代码实现</h2><p>拓扑排序，用于判断一个有向图是否存在环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span>[][] prerequisites)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> prerequisites.length;<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">int</span>[] pointer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<span class="hljs-comment">// 每个课程被指向的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] p : prerequisites) ++pointer[p[<span class="hljs-number">1</span>]];<br>    <span class="hljs-type">boolean</span>[] removed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len];<span class="hljs-comment">// 标记prerequisites中的元素是否被移除</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 移除的元素数量</span><br>    <span class="hljs-keyword">while</span> (remove &lt; len) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currRemove</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 本轮移除的元素数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (removed[i]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 被移除的元素跳过</span><br>            <span class="hljs-type">int</span>[] p = prerequisites[i];<br>            <span class="hljs-keyword">if</span> (pointer[p[<span class="hljs-number">0</span>]] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 如果被安全课程指向</span><br>                --pointer[p[<span class="hljs-number">1</span>]];<span class="hljs-comment">// 被指向次数减1</span><br>                removed[i] = <span class="hljs-literal">true</span>;<br>                ++currRemove;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (currRemove == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 如果一轮跑下来一个元素都没移除，则没必要进行下一轮</span><br>        remove += currRemove;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="54-实现Trie-前缀树"><a href="#54-实现Trie-前缀树" class="headerlink" title="54. 实现Trie(前缀树)"></a>54. 实现Trie(前缀树)</h1><ul><li><strong>一句话描述：</strong> 面试会考吗？不会》….</li></ul><h2 id="54-1-题目描述"><a href="#54-1-题目描述" class="headerlink" title="54.1 题目描述"></a>54.1 题目描述</h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">输入<br>[<span class="hljs-string">&quot;Trie&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>, <span class="hljs-string">&quot;startsWith&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, <span class="hljs-string">&quot;search&quot;</span>]<br>[[], [<span class="hljs-string">&quot;apple&quot;</span>], [<span class="hljs-string">&quot;apple&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>], [<span class="hljs-string">&quot;app&quot;</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>]<br><br>解释<br><span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();<br>trie.insert(<span class="hljs-string">&quot;apple&quot;</span>);<br>trie.search(<span class="hljs-string">&quot;apple&quot;</span>);   <span class="hljs-comment">// 返回 True</span><br>trie.search(<span class="hljs-string">&quot;app&quot;</span>);     <span class="hljs-comment">// 返回 False</span><br>trie.startsWith(<span class="hljs-string">&quot;app&quot;</span>); <span class="hljs-comment">// 返回 True</span><br>trie.insert(<span class="hljs-string">&quot;app&quot;</span>);<br>trie.search(<span class="hljs-string">&quot;app&quot;</span>);     <span class="hljs-comment">// 返回 True</span><br></code></pre></td></tr></table></figure><h2 id="54-2-算法思想和代码实现"><a href="#54-2-算法思想和代码实现" class="headerlink" title="54.2 算法思想和代码实现"></a>54.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    TrieNode[] children;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>        children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 假设只包含小写字母 a-z</span><br>        isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> searchPrefix(word);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; node.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-keyword">return</span> searchPrefix(prefix) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> TrieNode <span class="hljs-title function_">searchPrefix</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix.toCharArray()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node.children[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="55-全排列"><a href="#55-全排列" class="headerlink" title="55. 全排列"></a>55. 全排列</h1><ul><li><strong>一句话描述：</strong> 用一个boolean<strong>数组visited</strong>保存已经访问的元素，下次循环直接跳过；回溯三部曲：<strong>终止条件，for循环递归，回溯撤销</strong></li></ul><h2 id="55-1-题目描述"><a href="#55-1-题目描述" class="headerlink" title="55.1 题目描述"></a>55.1 题目描述</h2><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><h2 id="55-2-算法思想和代码实现"><a href="#55-2-算法思想和代码实现" class="headerlink" title="55.2 算法思想和代码实现"></a>55.2 算法思想和代码实现</h2><ul><li>用visited保存已经访问过的元素，下次循环直接跳过</li><li>终止条件：排列的长度等于数组长度</li><li>循环+递归：跳过已经访问过的元素，没有访问的元素加入排列结果</li><li>回溯：撤销当前选择的元素，并将visited改为true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution055</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// 存储最终的全排列结果</span><br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">// 存储当前排列的路径</span><br>    <span class="hljs-type">boolean</span>[] visited;<span class="hljs-comment">// 记录某个元素是否被使用</span><br>    <br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> result;<br><br>        <span class="hljs-comment">// 初始化 visited 数组，长度等于输入数组长度，初始值默认为 false</span><br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        <br>        permuteHelper(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归回溯函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permuteHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 终止条件：当前排列的长度等于输入数组长度</span><br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) &#123;<br>            <span class="hljs-comment">// 返回当前路径</span><br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历所有元素，尝试加入排列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 如果当前元素已被使用，则跳过</span><br>            <span class="hljs-keyword">if</span> (visited[i])<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// 选择当前元素</span><br>            path.add(nums[i]);<br>            visited[i] = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 递归进入下一层</span><br>            permuteHelper(nums);<br><br>            <span class="hljs-comment">// 撤销选择，进行回溯</span><br>            path.removeLast();<br>            visited[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="56-子集"><a href="#56-子集" class="headerlink" title="56. 子集"></a>56. 子集</h1><ul><li><strong>一句话描述：</strong> 收集子集，for(){收集元素，递归到下一层元素，回溯撤销}</li></ul><h2 id="56-1-题目描述"><a href="#56-1-题目描述" class="headerlink" title="56.1 题目描述"></a>56.1 题目描述</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure><h2 id="56-2-算法思想和代码实现"><a href="#56-2-算法思想和代码实现" class="headerlink" title="56.2 算法思想和代码实现"></a>56.2 算法思想和代码实现</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">                        <span class="hljs-comment">[]</span><br>           /            |            \<br>        <span class="hljs-comment">[1]</span>            <span class="hljs-comment">[2]</span>           <span class="hljs-comment">[3]</span><br>       /   \           /            /<br>   <span class="hljs-comment">[1,2]</span>  <span class="hljs-comment">[1,3]</span>     <span class="hljs-comment">[2,3]</span>        <br>    /                    <br><span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class="hljs-comment">//保存最终结果</span><br>List&lt;Integer&gt; path=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//保存当前路径下的结果</span><br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    subsetsHelper(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subsetsHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> start)</span>&#123;<br>    <span class="hljs-comment">//返回当前每一种情况的子集</span><br>    result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>    <br>    <span class="hljs-comment">//遍历完整个数组之后结束</span><br>    <span class="hljs-keyword">if</span>(start&gt;nums.length)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.length;i++)&#123;<br>        path.add(nums[i]);<br>        subsetsHelper(nums,i+<span class="hljs-number">1</span>);<br>        path.removeLast();<span class="hljs-comment">//撤销，回溯</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="57-电话号码的字母组合"><a href="#57-电话号码的字母组合" class="headerlink" title="57. 电话号码的字母组合"></a>57. 电话号码的字母组合</h1><ul><li><strong>一句话总结：</strong> </li><li>通过回溯法依次遍历输入数字串 digits，从第一个数字开始，根据数字映射的字母表，逐个尝试<strong>每个字母，将其加入当前路径</strong> path，然后<strong>递归处理下一个数字</strong>。当遍历到<strong>路径长度等于输入长度</strong>时，说明已生成一个完整组合，将其拼接成字符串<strong>加入结果列表</strong> result，随后<strong>回退</strong>（撤销最后一个字符）继续尝试其它可能，直到穷尽所有组合。</li></ul><h2 id="57-1-题目描述"><a href="#57-1-题目描述" class="headerlink" title="57.1 题目描述"></a>57.1 题目描述</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：digits = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="57-2-算法思想和代码实现"><a href="#57-2-算法思想和代码实现" class="headerlink" title="57.2 算法思想和代码实现"></a>57.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-comment">// 用于存储最终的组合结果</span><br>List&lt;Character&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-comment">// 用于存储当前递归路径上的字符</span><br><br><span class="hljs-comment">// 用于映射数字到对应的字母字符</span><br>String[] mapString = &#123;<br>        <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>    <span class="hljs-comment">// 如果输入为空，则直接返回空列表</span><br>    <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> result;<br><br>    <span class="hljs-comment">// 进行回溯搜索</span><br>    letterCombinationsHelper(digits, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">letterCombinationsHelper</span><span class="hljs-params">(String digits, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件：当索引等于字符串长度时，表示已经生成了一个完整的组合</span><br>    <span class="hljs-keyword">if</span> (index == digits.length()) &#123;<br>        <br>        <span class="hljs-comment">// 将 path 中的字符拼接成字符串并加入结果列表</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : path) &#123;<br>            sb.append(c);<br>        &#125;<br>        result.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 取出当前索引对应的数字，并找到其对应的字母字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> mapString[digits.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>];<br><br>    <span class="hljs-comment">// 遍历该数字对应的所有字母</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>        <span class="hljs-comment">// 选择当前字母，加入路径</span><br>        path.add(str.charAt(i));<br>        <span class="hljs-comment">// 递归处理下一个数字</span><br>        letterCombinationsHelper(digits, index + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择（回溯）</span><br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="58-组合总和"><a href="#58-组合总和" class="headerlink" title="58. 组合总和"></a>58. 组合总和</h1><ul><li><strong>一句话描述：</strong> 当前缀和等于target时，终止递归；for(){添加当前元素，递归进入下一层，回溯撤销}</li></ul><h2 id="58-1-题目描述"><a href="#58-1-题目描述" class="headerlink" title="58.1 题目描述"></a>58.1 题目描述</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], target = <span class="hljs-number">7</span><br>输出：[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>]]<br>解释：<br><span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 可以形成一组候选，<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">7</span> 。注意 <span class="hljs-number">2</span> 可以使用多次。<br><span class="hljs-number">7</span> 也是一个候选， <span class="hljs-number">7</span> = <span class="hljs-number">7</span> 。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><h2 id="58-2-算法思想和代码实现"><a href="#58-2-算法思想和代码实现" class="headerlink" title="58.2 算法思想和代码实现"></a>58.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>   <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>       <span class="hljs-comment">//先对整数数组进行排序</span><br>     <span class="hljs-comment">//  Arrays.sort(candidates);</span><br><br>       combinationSumHelper(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combinationSumHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> sum)</span> &#123;<br>       <span class="hljs-keyword">if</span> (sum == target) &#123;<br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; candidates.length; i++) &#123;<br>           <span class="hljs-comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span><br>           <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">break</span>;<br><br>           path.add(candidates[i]);<br>           combinationSumHelper(candidates, target, i, sum + candidates[i]);<br>           path.removeLast();<br>       &#125;<br><br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="59-括号生成"><a href="#59-括号生成" class="headerlink" title="59. 括号生成"></a>59. 括号生成</h1><ul><li><strong>一句话描述：</strong> </li><li>当<strong>左右括号用完了</strong>终止递归加入结果(left&#x3D;&#x3D;0&amp;&amp;right&#x3D;&#x3D;0)</li><li>当<strong>左括号数量大于0</strong>可以选择左括号</li><li>当<strong>右括号剩余数量大于左括号剩余数量</strong>，可以选择右括号，然后<strong>添加递归回溯</strong></li></ul><h2 id="59-1-题目描述"><a href="#59-1-题目描述" class="headerlink" title="59.1 题目描述"></a>59.1 题目描述</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="59-2-算法思想和代码实现"><a href="#59-2-算法思想和代码实现" class="headerlink" title="59.2 算法思想和代码实现"></a>59.2 算法思想和代码实现</h2><ul><li>只有剩余的左括号数量大于 0 时，才可以选择左括号</li><li>只有右括号剩余数量大于左括号时，才可以选择右括号</li><li>递归终止条件：如果左右括号都用完了，加入结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Character&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    generateParenthesisHelper(n, n);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateParenthesisHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件：如果左右括号都用完了，加入结果</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : path) &#123;<br>            sb.append(c);<br>        &#125;<br>        res.add(sb.toString());<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 只有剩余的左括号数量大于 0 时，才可以选择左括号</span><br>    <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>        path.add(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        generateParenthesisHelper(left - <span class="hljs-number">1</span>, right);<br>        path.removeLast();<br>    &#125;<br><br>    <span class="hljs-comment">// 只有右括号剩余数量大于左括号时，才可以选择右括号</span><br>    <span class="hljs-keyword">if</span> (right &gt; left) &#123;<br>        path.add(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        generateParenthesisHelper(left, right - <span class="hljs-number">1</span>);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="60-单词搜索"><a href="#60-单词搜索" class="headerlink" title="60. 单词搜索"></a>60. 单词搜索</h1><ul><li><strong>一句话描述：</strong> 通过双重循环遍历二维字符数组的每个元素，<strong>找到与单词首字符相同的位置后</strong>，调用递归函数<strong>向上下左右四个方向查找下一个字符</strong>，每访问一个字符就将其暂时<strong>标记为已访问</strong>（用 <code>#</code> 替换），<strong>防止重复</strong>走回头路，递归如果找到完整单词则返回 true，<strong>未找到则恢复该位置原字符</strong>，继续尝试其他路径，直到所有可能都搜索完毕。</li></ul><h2 id="60-1-题目描述"><a href="#60-1-题目描述" class="headerlink" title="60.1 题目描述"></a>60.1 题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="60-2-算法思想和代码实现"><a href="#60-2-算法思想和代码实现" class="headerlink" title="60.2 算法思想和代码实现"></a>60.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>              <span class="hljs-keyword">if</span> (isExist(board, word, i, j, <span class="hljs-number">0</span>)) &#123;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> num)</span> &#123;<br>      <span class="hljs-comment">// 递归终止条件：找到完整单词</span><br>      <span class="hljs-keyword">if</span> (num == word.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-comment">// 边界检查：是否超出范围</span><br>      <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || col &lt; <span class="hljs-number">0</span> || row &gt;= board.length || col &gt;= board[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-comment">// 检查当前字符是否匹配</span><br>      <span class="hljs-keyword">if</span> (board[row][col] != word.charAt(num)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      board[row][col] = <span class="hljs-string">&#x27;#&#x27;</span>; <span class="hljs-comment">// 标记已访问，防止重复使用</span><br><br>      <span class="hljs-comment">// 尝试向四个方向寻找下一个字符</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> isExist(board, word, row + <span class="hljs-number">1</span>, col, num + <span class="hljs-number">1</span>) ||<br>              isExist(board, word, row - <span class="hljs-number">1</span>, col, num + <span class="hljs-number">1</span>) ||<br>              isExist(board, word, row, col + <span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>) ||<br>              isExist(board, word, row, col - <span class="hljs-number">1</span>, num + <span class="hljs-number">1</span>);<br><br>      <span class="hljs-comment">// 恢复原来的字符</span><br>      board[row][col] = word.charAt(num);<br><br>      <span class="hljs-keyword">return</span> found;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="61-分割回文串"><a href="#61-分割回文串" class="headerlink" title="61. 分割回文串"></a>61. 分割回文串</h1><ul><li><strong>一句话描述：</strong> 通过从字符串的起始位置开始，用循环<strong>依次截取不同长度的子串</strong>，判断当前子串是否是回文串，如果是则将其加入路径列表，并<strong>递归继续处理剩余部分</strong>，直到遍历完整个字符串，将完整路径加入结果列表，递归返回时通过 removeLast() 撤销上一次添加的子串，继续尝试下一种截取方式。</li></ul><h2 id="61-1-题目描述"><a href="#61-1-题目描述" class="headerlink" title="61.1 题目描述"></a>61.1 题目描述</h2><p>给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><h2 id="61-2-算法思想和代码实现"><a href="#61-2-算法思想和代码实现" class="headerlink" title="61.2 算法思想和代码实现"></a>61.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储每个回文子串</span><br><br> <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;<br>     partitionHelper(s, <span class="hljs-number">0</span>);<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">partitionHelper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>     <span class="hljs-keyword">if</span> (start == s.length()) &#123;<br>         res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length(); i++) &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> s.substring(start, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取出子串【start,i+1),左闭区间，右开区间</span><br><br>         <span class="hljs-keyword">if</span> (isPalindrome(sub)) &#123;<br>             path.add(sub); <span class="hljs-comment">// 记录回文子串</span><br>             partitionHelper(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归</span><br>             path.removeLast(); <span class="hljs-comment">// 回溯，移除最后加入的子串</span><br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 回文判断</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>         <span class="hljs-keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>         &#125;<br>         left++;<br>         right--;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="62-N皇后"><a href="#62-N皇后" class="headerlink" title="62. N皇后"></a>62. N皇后</h1><ul><li><strong>一句话描述：</strong> 循环尝试在棋盘的<strong>每一行每一列放置皇后</strong>，遇到<strong>符合条件的位置</strong>就将皇后<strong>放下</strong>，并<strong>递归进入下一行</strong>继续放置，直到所有行都放置完毕时将当前棋盘状态转换成字符串列表加入结果集中，递归返回时通过将皇后位置<strong>回溯复原</strong>，继续尝试下一列的位置，最终遍历出所有可能的皇后摆放方案。</li></ul><h2 id="62-1-题目描述"><a href="#62-1-题目描述" class="headerlink" title="62.1 题目描述"></a>62.1 题目描述</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。<br>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">4</span><br>输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]<br>解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure><h2 id="62-2-算法思想和代码实现"><a href="#62-2-算法思想和代码实现" class="headerlink" title="62.2 算法思想和代码实现"></a>62.2 算法思想和代码实现</h2><ol><li><strong>递归搜索</strong><ul><li>按行进行搜索，每行尝试放置一个皇后。</li><li>当所有行都放置完皇后时，将当前棋盘加入 ans 结果集。</li></ul></li><li><strong>合法性检查</strong> <ul><li>在尝试放置皇后前，检查当前列、左上方 45° 对角线、右上方 135° 对角线是否已有皇后。</li><li>只有满足条件的位置才能放置皇后。</li></ul></li><li><strong>回溯</strong><ul><li>先尝试在当前行的某一列放置皇后。</li><li>递归处理下一行。</li><li>如果递归失败（即后续行无法放置皇后），撤销当前放置（回溯），尝试当前行的下一列。</li></ul></li><li><strong>终止条件</strong><ul><li>当 row &#x3D;&#x3D; n（即所有行都放置完皇后）时，表示找到了一种合法解法，存入 ans</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 存储所有可能的 N 皇后解法</span><br><br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">char</span>[][] chess = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n]; <span class="hljs-comment">// 创建 n × n 的棋盘</span><br>    <span class="hljs-comment">// 初始化棋盘，所有位置填充为 &#x27;.&#x27;（表示空位）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chess)<br>        Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br>    dfs(<span class="hljs-number">0</span>, n, chess); <span class="hljs-comment">// 递归回溯从第 0 行开始</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] chess)</span> &#123;<br>    <span class="hljs-comment">// 终止条件：所有行都已经放置了皇后</span><br>    <span class="hljs-keyword">if</span> (row == n) &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chess)  <span class="hljs-comment">// 将当前棋盘的每一行转换为字符串</span><br>            list.add(String.copyValueOf(c));<br>        ans.add(list);  <span class="hljs-comment">// 将这一种可行解加入结果集</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在当前行的每一列尝试放置皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-keyword">if</span> (isValid(row, col, n, chess)) &#123; <span class="hljs-comment">// 检查当前位置是否可以放置皇后</span><br>            chess[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;  <span class="hljs-comment">// 放置皇后</span><br>            dfs(row + <span class="hljs-number">1</span>, n, chess);  <span class="hljs-comment">// 递归放置下一行的皇后</span><br>            chess[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;  <span class="hljs-comment">// 回溯：撤销放置，尝试下一列</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] chess)</span> &#123;<br>    <span class="hljs-comment">// 1. 检查当前列是否已有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; row; i++)<br>        <span class="hljs-keyword">if</span> (chess[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 2. 检查左上方 45° 斜线是否已有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--)<br>        <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 3. 检查右上方 135° 斜线是否已有皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++)<br>        <span class="hljs-keyword">if</span> (chess[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 如果当前位置符合规则，则返回 true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="63-搜索插入位置"><a href="#63-搜索插入位置" class="headerlink" title="63. 搜索插入位置"></a>63. 搜索插入位置</h1><ul><li><strong>一句话描述：</strong> 二分查找</li></ul><h2 id="63-1-题目描述"><a href="#63-1-题目描述" class="headerlink" title="63.1 题目描述"></a>63.1 题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="63-2-算法思想和代码实现"><a href="#63-2-算法思想和代码实现" class="headerlink" title="63.2 算法思想和代码实现"></a>63.2 算法思想和代码实现</h2><p>二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当目标值不存在于数组中时，返回插入位置，即左指针的位置</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="64-搜索二维矩阵"><a href="#64-搜索二维矩阵" class="headerlink" title="64. 搜索二维矩阵"></a>64. 搜索二维矩阵</h1><ul><li><strong>一句话描述：</strong> 二分查找：从右上角元素向下或向左移动</li></ul><h2 id="64-1-题目描述"><a href="#64-1-题目描述" class="headerlink" title="64.1 题目描述"></a>64.1 题目描述</h2><p>给你一个满足下述两条属性的 m x n 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。<br>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">23</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">60</span>]], target = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="64-2-算法思想和代码实现"><a href="#64-2-算法思想和代码实现" class="headerlink" title="64.2 算法思想和代码实现"></a>64.2 算法思想和代码实现</h2><p>二分查找：从右上角元素向下或向左移动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-comment">//i和j分别记录右上角的元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (i &lt; matrix.length &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[i][j] == target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; target)<br>            j--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; target)<br>            i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="65-在排序数组中查找元素的第一个和最后一个位置"><a href="#65-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="65. 在排序数组中查找元素的第一个和最后一个位置"></a>65. 在排序数组中查找元素的第一个和最后一个位置</h1><ul><li><strong>一句话描述：</strong> </li><li>二分查找<strong>先查找第一个位置，再查找结束位置</strong></li><li>查找左边位置时，当<code>nums[mid] == target</code>，<code>right = mid - 1</code>不断向左收缩</li><li>查找右边位置时，当<code>nums[mid] == target</code>，<code>left = mid + 1</code>不断向右收缩</li></ul><h2 id="65-1-题目描述"><a href="#65-1-题目描述" class="headerlink" title="65.1 题目描述"></a>65.1 题目描述</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。<br>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">8</span><br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="65-2-算法思想和代码实现"><a href="#65-2-算法思想和代码实现" class="headerlink" title="65.2 算法思想和代码实现"></a>65.2 算法思想和代码实现</h2><p>分两次查找，第一次二分查找开始位置，第二次二分查找结束位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> findFirstPosition(nums, target);<br>    <span class="hljs-keyword">if</span> (first == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> findLastPosition(nums, target);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;first, last&#125;;<br>&#125;<br><br><span class="hljs-comment">//二分查找第一个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findFirstPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 不断收缩右边界，直到找到最左的target</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target) &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//二分查找最后一个位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLastPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 不断收缩左边界，直到找到最右的target</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (right &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[right] == target) &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="66-搜索旋转排序数组"><a href="#66-搜索旋转排序数组" class="headerlink" title="66. 搜索旋转排序数组"></a>66. 搜索旋转排序数组</h1><ul><li><strong>一句话描述：</strong> </li><li>直接对数组进行二分，其中一定有一个子区间是<strong>有序的</strong>，另一个<strong>部分有序</strong></li><li>判断哪个区间是有序的，然后继续进行逻辑判断</li></ul><h2 id="66-1-题目描述"><a href="#66-1-题目描述" class="headerlink" title="66.1 题目描述"></a>66.1 题目描述</h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><h2 id="66-2-算法思想和代码实现"><a href="#66-2-算法思想和代码实现" class="headerlink" title="66.2 算法思想和代码实现"></a>66.2 算法思想和代码实现</h2><ul><li>直接对数组进行二分，其中一定有一个子区间是有序的，另一个部分有序<ol><li>如果target在这个有序区间内：直接二分</li><li>如果target在另一个区间内：二分后仍得到一个有序和部分有序区间，不断往复。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br><br>     <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <br>         <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>         <span class="hljs-comment">// 如果中间元素就是目标值，则返回索引</span><br>         <span class="hljs-keyword">if</span> (nums[mid] == target) &#123; <br>             <span class="hljs-keyword">return</span> mid;<br>         &#125;<br><br>         <span class="hljs-comment">// 判断左半部分是否是有序的</span><br>         <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;<br>             <span class="hljs-comment">// 如果目标值在左半部分范围内，则缩小右边界</span><br>             <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123;<br>                 right = mid - <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则搜索右半部分</span><br>                 left = mid + <span class="hljs-number">1</span>;<br>             &#125;<br>         &#125;<br><br>         <span class="hljs-comment">// 如果右半部分是有序的</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &gt; nums[mid]) &#123;<br>             <span class="hljs-comment">// 如果目标值在右半部分范围内，则缩小左边界</span><br>             <span class="hljs-keyword">if</span> (target &lt;= nums[right] &amp;&amp; target &gt; nums[mid]) &#123;<br>                 left = mid + <span class="hljs-number">1</span>;<br>             &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则搜索左半部分</span><br>                 right = mid - <span class="hljs-number">1</span>;<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 未找到目标值，返回 -1</span><br> &#125;<br></code></pre></td></tr></table></figure><h1 id="67-寻找旋转排序数组的最小值"><a href="#67-寻找旋转排序数组的最小值" class="headerlink" title="67. 寻找旋转排序数组的最小值"></a>67. 寻找旋转排序数组的最小值</h1><ul><li><strong>一句话描述：</strong><ul><li>如果 <code>nums[mid] &gt; nums[right]</code>，最小值一定在右边，left&#x3D;mid+1</li><li>如果 <code>nums[mid] &lt;= nums[right]</code>，最小值在左边，right&#x3D;mid</li><li>退出循环时，left &#x3D;&#x3D; right，正是最小值的位置</li></ul></li></ul><h2 id="67-1-题目描述"><a href="#67-1-题目描述" class="headerlink" title="67.1 题目描述"></a>67.1 题目描述</h2><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：</p><ul><li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li><li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</li></ul><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">1</span><br>解释：原数组为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] ，旋转 <span class="hljs-number">3</span> 次得到输入数组。<br></code></pre></td></tr></table></figure><h2 id="67-2-算法思想和代码实现"><a href="#67-2-算法思想和代码实现" class="headerlink" title="67.2 算法思想和代码实现"></a>67.2 算法思想和代码实现</h2><ul><li>如果 <code>nums[mid] &gt; nums[right]</code>，最小值一定在右边，left&#x3D;mid+1</li><li>如果 <code>nums[mid] &lt;= nums[right]</code>，最小值在左边，right&#x3D;mid</li><li>退出循环时，left &#x3D;&#x3D; right，正是最小值的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<br>            <span class="hljs-comment">// 最小值在右半边</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 最小值在左半边（包含 mid）</span><br>            right = mid;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[left]; <span class="hljs-comment">// 或 nums[right]，此时 left == right</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="68-寻找两个正序数组的中位数"><a href="#68-寻找两个正序数组的中位数" class="headerlink" title="68. 寻找两个正序数组的中位数"></a>68. 寻找两个正序数组的中位数</h1><ul><li><strong>一句话描述：</strong> 难，，直接暴力吧</li></ul><h2 id="68-1-题目描述"><a href="#68-1-题目描述" class="headerlink" title="68.1 题目描述"></a>68.1 题目描述</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], nums2 = [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2.00000</span><br>解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] ，中位数 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="68-2-算法思想和代码实现"><a href="#68-2-算法思想和代码实现" class="headerlink" title="68.2 算法思想和代码实现"></a>68.2 算法思想和代码实现</h2><ul><li>将两个数组划分为左右两部分，确保：<ul><li>左半部分的所有元素 ≤ 右半部分的所有元素。</li><li>这样，左半部分的最大值是中位数（如果总数是奇数）。</li><li>如果总数是偶数，中位数是左半部分的最大值和右半部分的最小值的平均值。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br><br>        <span class="hljs-comment">// 保证 nums1 是较短的数组</span><br>        <span class="hljs-keyword">if</span> (m &gt; n) &#123;<br>            <span class="hljs-keyword">return</span> findMedianSortedArrays(nums2, nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = m, halfLen = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> halfLen - i;<br><br>            <span class="hljs-keyword">if</span> (i &lt; m &amp;&amp; nums1[i] &lt; nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                left = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// i 过小，需要右移</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[i - <span class="hljs-number">1</span>] &gt; nums2[j]) &#123;<br>                right = i - <span class="hljs-number">1</span>; <span class="hljs-comment">// i 过大，需要左移</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// i 是合适的切割位置</span><br>                <span class="hljs-type">int</span> maxLeft;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    maxLeft = nums2[j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>                    maxLeft = nums1[i - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxLeft = Math.max(nums1[i - <span class="hljs-number">1</span>], nums2[j - <span class="hljs-number">1</span>]);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> maxLeft; <span class="hljs-comment">// 奇数长度直接返回中位数</span><br>                &#125;<br><br>                <span class="hljs-type">int</span> minRight;<br>                <span class="hljs-keyword">if</span> (i == m) &#123;<br>                    minRight = nums2[j];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;<br>                    minRight = nums1[i];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    minRight = Math.min(nums1[i], nums2[j]);<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> (maxLeft + minRight) / <span class="hljs-number">2.0</span>; <span class="hljs-comment">// 偶数长度返回均值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="69-有效的括号"><a href="#69-有效的括号" class="headerlink" title="69. 有效的括号"></a>69. 有效的括号</h1><ul><li><strong>一句话描述：</strong> 遇到左括号入栈，右括号如果能与栈顶左括号匹配则正确，不匹配返回false</li></ul><h2 id="69-1-题目描述"><a href="#69-1-题目描述" class="headerlink" title="69.1 题目描述"></a>69.1 题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><h2 id="69-2-算法思想和代码实现"><a href="#69-2-算法思想和代码实现" class="headerlink" title="69.2 算法思想和代码实现"></a>69.2 算法思想和代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Character&gt;();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <br>        <span class="hljs-comment">//如果字符是左括号，则入栈</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>)<br>            stack.push(c);<br><br>        <span class="hljs-comment">//如果字符是右括号</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span> || c == <span class="hljs-string">&#x27;&#125;&#x27;</span> || c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-comment">//为空返回false</span><br>            <span class="hljs-keyword">if</span> (stack.isEmpty())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-comment">//如果此时字符和栈顶元素相同，则弹出栈顶元素，否则返回false</span><br>            <span class="hljs-keyword">if</span> (stack.peek() == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span> || stack.peek() == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span> || stack.peek() == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                stack.pop();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="70-最小栈"><a href="#70-最小栈" class="headerlink" title="70. 最小栈"></a>70. 最小栈</h1><ul><li><strong>一句话描述：</strong> 用一个链表包含val和min两个成员变量，min用来保存最小值，入栈就是链表头结点<strong>头插一个新元素</strong>，出栈就是指向头结点下一个结点</li></ul><h2 id="70-1-题目描述"><a href="#70-1-题目描述" class="headerlink" title="70.1 题目描述"></a>70.1 题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><ul><li>MinStack() 初始化堆栈对象。</li><li>void push(int val) 将元素val推入堆栈。</li><li>void pop() 删除堆栈顶部的元素。</li><li>int top() 获取堆栈顶部的元素。</li><li>int getMin() 获取堆栈中的最小元素。</li></ul><h2 id="70-2-算法思想和代码实现"><a href="#70-2-算法思想和代码实现" class="headerlink" title="70.2 算法思想和代码实现"></a>70.2 算法思想和代码实现</h2><ul><li>使用链表实现一个栈的操作</li><li>链表的头部始终指向栈顶元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">// 头节点，始终指向栈顶</span><br>    Node head;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        head = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 栈初始化为空</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 如果栈为空，则新节点的 min 值就是 val 本身</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果栈非空，新节点的 min 取当前值与前一个 min 的较小值</span><br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, Math.min(val, head.min), head);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        head = head.next; <span class="hljs-comment">// 直接指向下一个节点，删除当前栈顶</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head.min;<br>    &#125;<br>    <br>    <span class="hljs-comment">//创建一个链表内部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-type">int</span> min;<br>        Node next;<br><br>        <span class="hljs-comment">// 构造方法（用于创建栈底节点）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> min)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 构造方法（用于创建普通节点，包含 next 指针）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> min, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="71-字符串解码"><a href="#71-字符串解码" class="headerlink" title="71. 字符串解码"></a>71. 字符串解码</h1><ul><li><strong>一句话描述：</strong> 难，使用两个栈</li></ul><h2 id="71-1-题目描述"><a href="#71-1-题目描述" class="headerlink" title="71.1 题目描述"></a>71.1 题目描述</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;3[a]2[bc]&quot;</span><br>输出：<span class="hljs-string">&quot;aaabcbc&quot;</span><br></code></pre></td></tr></table></figure><h2 id="71-2-算法思想和代码实现"><a href="#71-2-算法思想和代码实现" class="headerlink" title="71.2 算法思想和代码实现"></a>71.2 算法思想和代码实现</h2><p>使用两个栈：</p><ul><li>一个存放重复次数（countStack）</li><li>一个存放之前的部分字符串（resStack）</li></ul><ol><li>当遇到 [ 时，意味着开始一个新的子串，需要把当前的 StringBuilder 存入栈，新的部分重新开始。</li><li>当遇到 ] 时，意味着这个子串已经结束，要取出 count 并重复添加到上一级字符串中。</li><li>当遇到数字字符时，计算对应的数字，因为数字取值在300以内，不一定是单个字符，可能为多个字符</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decodeString</span><span class="hljs-params">(String s)</span> &#123;<br>    Stack&lt;Integer&gt; countStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">//存放次数</span><br>    Stack&lt;StringBuilder&gt; resStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(); <span class="hljs-comment">//存放括号中的字符串</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">currentStr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>        <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>            <span class="hljs-comment">// 计算完整的数字</span><br>            k = k * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>            <br>            <span class="hljs-comment">// 将当前的字符串和次数入栈</span><br>            countStack.push(k);<br>            resStack.push(currentStr);<br>            <br>            <span class="hljs-comment">// 开始新的字符串</span><br>            currentStr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            k = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <br>            <span class="hljs-comment">// 结束当前字符串，取出对应的次数</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">decodedStr</span> <span class="hljs-operator">=</span> resStack.pop();<br>            <br>            <span class="hljs-type">int</span> <span class="hljs-variable">repeatTimes</span> <span class="hljs-operator">=</span> countStack.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; repeatTimes; i++) &#123;<br>                decodedStr.append(currentStr);<br>            &#125;<br>            <br>            currentStr = decodedStr;  <span class="hljs-comment">// 继续拼接上层字符串</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            currentStr.append(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> currentStr.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="72-每日温度"><a href="#72-每日温度" class="headerlink" title="72. 每日温度"></a>72. 每日温度</h1><ul><li><strong>一句话描述：</strong> </li><li>使用一个单调<strong>递减</strong>的栈，栈用来<strong>存储索引</strong></li><li>如果当前温度小于等于栈顶温度则入栈</li><li>当前温度大于栈顶元素，栈顶元素的天数更新并出栈</li></ul><h2 id="72-1-题目描述"><a href="#72-1-题目描述" class="headerlink" title="72.1 题目描述"></a>72.1 题目描述</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: temperatures = [<span class="hljs-number">73</span>,<span class="hljs-number">74</span>,<span class="hljs-number">75</span>,<span class="hljs-number">71</span>,<span class="hljs-number">69</span>,<span class="hljs-number">72</span>,<span class="hljs-number">76</span>,<span class="hljs-number">73</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="72-2-算法思想和代码实现"><a href="#72-2-算法思想和代码实现" class="headerlink" title="72.2 算法思想和代码实现"></a>72.2 算法思想和代码实现</h2><ol><li>初始化一个单调递减栈 stack，<strong>存储温度的索引</strong>。</li><li>遍历 temperatures 数组：<ul><li>当栈不为空，且当前温度大于栈顶索引对应的温度时：<ul><li>说明找到了栈顶元素的下一个更高温度，计算间隔天数并更新 res。</li><li>继续弹出栈顶，直到栈为空或栈顶温度大于当前温度。</li><li>将当前索引 i 入栈。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>     <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[temperatures.length]; <span class="hljs-comment">//res数组存储最终结果</span><br>     Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(); <span class="hljs-comment">//定义一个单调栈</span><br><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>         <span class="hljs-comment">//只有栈为空或者当前温度比栈顶温度小的时候，入栈</span><br>         <span class="hljs-keyword">if</span> (stack.isEmpty() || temperatures[i] &lt;= temperatures[stack.peek()]) &#123;<br>             stack.push(i);<br>         &#125;<br><br>         <span class="hljs-comment">//如果当前温度比栈顶温度大</span><br>         <span class="hljs-keyword">if</span> (temperatures[i] &gt; temperatures[stack.peek()]) &#123;<br>             <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[stack.peek()] &lt; temperatures[i]) &#123;<br>                 res[stack.peek()] = i - stack.peek();<br>                 stack.pop();<br>             &#125;<br>             stack.push(i);<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="73-柱形图中最大的矩形"><a href="#73-柱形图中最大的矩形" class="headerlink" title="73. 柱形图中最大的矩形"></a>73. 柱形图中最大的矩形</h1><ul><li><strong>一句话描述：</strong> <strong>双指针暴力</strong>，以当前柱子<strong>向左向右</strong>，找比自己高度大(大于等于)的柱子，计算当前面积并更新</li></ul><h2 id="73-1-题目描述"><a href="#73-1-题目描述" class="headerlink" title="73.1 题目描述"></a>73.1 题目描述</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：heights = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">10</span><br>解释：最大的矩形为图中红色区域，面积为 <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h2 id="73-2-算法思想和代码实现"><a href="#73-2-算法思想和代码实现" class="headerlink" title="73.2 算法思想和代码实现"></a>73.2 算法思想和代码实现</h2><ul><li>双指针暴力</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> heights.length;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> heights[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i, right = i;<br><br>        <span class="hljs-comment">// 向左扩展</span><br>        <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; heights[left - <span class="hljs-number">1</span>] &gt;= height) &#123;<br>            left--;<br>        &#125;<br><br>        <span class="hljs-comment">// 向右扩展</span><br>        <span class="hljs-keyword">while</span> (right &lt; n - <span class="hljs-number">1</span> &amp;&amp; heights[right + <span class="hljs-number">1</span>] &gt;= height) &#123;<br>            right++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> height * width;<br>        maxArea = Math.max(maxArea, area);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxArea;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>利用单调递增栈快速找到每个柱子的左右边界，计算出以该柱子为高的最大矩形面积</strong></p><ul><li><strong>对于每根柱子，如何快速找到其左右边界</strong>？<br>通常，我们关心 以某个柱子 <code>heights[i]</code> 为高的最大矩形：<ul><li>这个矩形的 宽度 由该柱子 左侧第一个小于该柱子的柱子 和 右侧第一个小于该柱子的柱子 决定。</li><li>这个矩形的 面积 &#x3D; 高度 × 宽度。<br><strong>如何快速找到左右边界</strong>?</li><li>用单调递增栈（从小到大存柱子的索引）来维护递增序列：</li><li>当当前柱子 <code>heights[i]</code> 大于等于栈顶柱子，说明矩形还可以扩展，入栈。</li><li>当当前柱子 <code>heights[i]</code> 小于栈顶柱子，说明矩形不能继续扩展了，<strong>栈顶柱子对应的最大矩形的宽度边界已经确定</strong>，可以计算面积。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>      <span class="hljs-comment">// 使用单调栈（存储柱子的索引）来计算最大矩形面积</span><br>      Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-comment">// 遍历数组，并在最后额外处理一次栈中剩余的元素</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= heights.length; i++) &#123;<br>          <span class="hljs-type">int</span> h;<br>          <span class="hljs-comment">// 当遍历到最后一个位置时，假设一个高度为 0 的柱子，以便清空栈</span><br>          <span class="hljs-keyword">if</span> (i == heights.length) &#123;<br>              h = <span class="hljs-number">0</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              h = heights[i];<br>          &#125;<br><br>          <span class="hljs-comment">// 维护单调递增栈（栈中存放的是索引）</span><br>          <span class="hljs-comment">// 如果当前柱子的高度 h 小于栈顶索引对应的柱子高度，则说明栈顶柱子的右边界确定</span><br>          <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; h &lt; heights[stack.peek()]) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> heights[stack.pop()]; <span class="hljs-comment">// 弹出栈顶元素，表示以该柱子为高的矩形结束</span><br>              <span class="hljs-type">int</span> width;<br><br>              <span class="hljs-comment">// 如果栈为空，说明当前弹出的柱子是所有柱子中最矮的，其宽度是 `i`</span><br>              <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                  width = i;<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">//宽度 = 右边界 i - 左边界 stack.peek() - 1</span><br>                  <span class="hljs-comment">// 否则，矩形的宽度是 `i - stack.peek() - 1`</span><br>                  <span class="hljs-comment">// 其中 `stack.peek()` 是左边第一个比它小的柱子</span><br>                  width = i - stack.peek() - <span class="hljs-number">1</span>;<br>              &#125;<br>              <br>              area = Math.max(area, width * height);<br>          &#125;<br><br>          <span class="hljs-comment">// 将当前柱子索引入栈，确保栈内索引对应的高度是递增的</span><br>          stack.push(i);<br>      &#125;<br>      <span class="hljs-keyword">return</span> area;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="74-数组中的第K个最大元素"><a href="#74-数组中的第K个最大元素" class="headerlink" title="74. 数组中的第K个最大元素"></a>74. 数组中的第K个最大元素</h1><ul><li><strong>一句话描述：</strong> 使用<strong>小顶堆</strong>，堆顶元素始终是最小的元素，如果当前元素大于堆顶元素，堆顶元素出堆，当前元素入堆，最后堆顶元素就是第k个大的元素；<strong>换句话说就是用小顶堆把k-1个小的元素挤出去</strong></li></ul><h2 id="74-1-题目描述"><a href="#74-1-题目描述" class="headerlink" title="74.1 题目描述"></a>74.1 题目描述</h2><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], k = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="74-2-算法思想和代码实现"><a href="#74-2-算法思想和代码实现" class="headerlink" title="74.2 算法思想和代码实现"></a>74.2 算法思想和代码实现</h2><ul><li>采用小顶堆维护前 k 大元素<ul><li>由于 Java 的 PriorityQueue 默认是小顶堆，所以堆顶元素（peek()）始终是堆中最小的元素。</li><li>这样，我们可以用大小为 k 的最小堆，确保堆中存储的是数组中前 k 大的元素。</li><li>最后栈顶元素就是数组第k个大的元素</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>       <span class="hljs-comment">// 使用小顶堆，用于维护前 k 大的元素</span><br>       PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><br>       <span class="hljs-comment">// 先将前 k 个元素加入堆中，建立一个大小为 k 的最小堆</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>           pq.offer(nums[i]);<br>       &#125;<br><br>       <span class="hljs-comment">// 遍历数组剩余元素，确保堆中始终保留 k 个最大的元素</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (nums[i] &gt; pq.peek()) &#123; <span class="hljs-comment">// 只有当前元素比堆顶元素大时，才进行替换</span><br>               pq.poll(); <span class="hljs-comment">// 最小的元素弹出堆顶</span><br>               pq.offer(nums[i]); <span class="hljs-comment">// 插入新元素，保证堆中始终有 k 个最大的元素</span><br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">// 堆顶元素就是整个数组中第 k 大的元素</span><br>       <span class="hljs-keyword">return</span> pq.peek();<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="75-前K个高频元素"><a href="#75-前K个高频元素" class="headerlink" title="75. 前K个高频元素"></a>75. 前K个高频元素</h1><ul><li><strong>一句话描述：</strong> </li><li><strong>哈希表统计频率</strong>，用<strong>小根堆</strong>维护前k个高频元素</li><li><code>PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;(k,(l1, l2) -&gt; l1.getValue() - l2.getValue());</code></li><li><code>for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {}</code></li></ul><h2 id="75-1-题目描述"><a href="#75-1-题目描述" class="headerlink" title="75.1 题目描述"></a>75.1 题目描述</h2><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="75-2-算法思想和代码实现"><a href="#75-2-算法思想和代码实现" class="headerlink" title="75.2 算法思想和代码实现"></a>75.2 算法思想和代码实现</h2><h3 id="小根堆-哈希表"><a href="#小根堆-哈希表" class="headerlink" title="小根堆 + 哈希表"></a>小根堆 + 哈希表</h3><ul><li>利用哈希表统计频率</li><li>然后用小根堆维护前 K 个高频元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 统计频率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        map.put(num, map.getOrDefault(num, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用最小堆，按频率排序</span><br>    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k,(l1, l2) -&gt; l1.getValue() - l2.getValue());<br><br>    <span class="hljs-comment">// 维护一个大小为 k 的小根堆</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (pq.size() &lt; k) &#123;<br>            pq.offer(entry);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (entry.getValue() &gt; pq.peek().getValue()) &#123;<br>            pq.poll();<br>            pq.offer(entry);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 取出堆中的 k 个元素</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        res[i] = pq.poll().getKey();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="76-数据流的中位数"><a href="#76-数据流的中位数" class="headerlink" title="76. 数据流的中位数"></a>76. 数据流的中位数</h1><ul><li><strong>一句话描述：</strong> </li><li>利用两个堆（<strong>大根堆+小根堆</strong>），</li><li>添加元素<strong>先添加到小顶堆</strong>，再把小顶堆的<strong>堆顶元素添加到大顶堆</strong>，</li><li>如果小顶堆大小小于大顶堆大小(<code>minHeap.size() &lt; maxHeap.size()</code>)，把<strong>大顶堆的堆顶元素添加到小顶堆</strong></li></ul><h2 id="76-1-题目描述"><a href="#76-1-题目描述" class="headerlink" title="76.1 题目描述"></a>76.1 题目描述</h2><p>中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 arr &#x3D; [2,3,4] 的中位数是 3 。</li><li>例如 arr &#x3D; [2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5 。<br>实现 MedianFinder 类:</li><li>MedianFinder() 初始化 MedianFinder 对象。</li><li>void addNum(int num) 将数据流中的整数 num 添加到数据结构中。</li><li>double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">输入<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;findMedian&quot;</span>, <span class="hljs-string">&quot;addNum&quot;</span>, <span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [<span class="hljs-number">3</span>], []]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1.5</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2.0</span>]<br><br>解释<br><span class="hljs-type">MedianFinder</span> <span class="hljs-variable">medianFinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MedianFinder</span>();<br>medianFinder.addNum(<span class="hljs-number">1</span>);    <span class="hljs-comment">// arr = [1]</span><br>medianFinder.addNum(<span class="hljs-number">2</span>);    <span class="hljs-comment">// arr = [1, 2]</span><br>medianFinder.findMedian(); <span class="hljs-comment">// 返回 1.5 ((1 + 2) / 2)</span><br>medianFinder.addNum(<span class="hljs-number">3</span>);    <span class="hljs-comment">// arr[1, 2, 3]</span><br>medianFinder.findMedian(); <span class="hljs-comment">// return 2.0</span><br></code></pre></td></tr></table></figure><h2 id="76-2-算法思想和代码实现"><a href="#76-2-算法思想和代码实现" class="headerlink" title="76.2 算法思想和代码实现"></a>76.2 算法思想和代码实现</h2><p><strong>利用两个堆（大根堆+小根堆）维护数据流的中位数</strong></p><ul><li>采用两个堆<ul><li>大根堆 maxHeap（存较小的一半）：堆顶是较小的一半数据中的 最大值。</li><li>小根堆 minHeap（存较大的一半）：堆顶是较大的一半数据中的 最小值。</li></ul></li><li>保证大根堆 maxHeap 的元素个数 不小于 小根堆 minHeap</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>      PriorityQueue&lt;Integer&gt; minHeap;<br>      PriorityQueue&lt;Integer&gt; maxHeap;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">MedianFinder</span><span class="hljs-params">()</span> &#123;<br>          minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>          <span class="hljs-comment">// 使用自定义比较器，降序排列</span><br>          maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>          <span class="hljs-comment">// 先将新元素添加到大根堆</span><br>          maxHeap.offer(num);<br>          <span class="hljs-comment">// 把大根堆的最大值移动到小根堆，保证 minHeap 存储较大的一半数据</span><br>          minHeap.offer(maxHeap.poll());<br><br>          <span class="hljs-comment">// 如果小根堆的大小大于大根堆，则需要调整，保持 maxHeap &gt;= minHeap</span><br>          <span class="hljs-keyword">if</span> (minHeap.size() &gt; maxHeap.size()) &#123;<br>              maxHeap.offer(minHeap.poll());<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedian</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">// 若两个堆大小相等，说明总元素个数是偶数，取两个堆顶元素的平均值</span><br>          <span class="hljs-keyword">if</span> (minHeap.size() == maxHeap.size()) &#123;<br>              <span class="hljs-keyword">return</span> (minHeap.peek() + maxHeap.peek()) / <span class="hljs-number">2.0</span>;<br>          &#125;<br>          <span class="hljs-comment">// 若大根堆元素较多，说明总数是奇数，中位数是大根堆的堆顶元素</span><br>          <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">return</span> maxHeap.peek();<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="77-买卖股票的最佳时机"><a href="#77-买卖股票的最佳时机" class="headerlink" title="77. 买卖股票的最佳时机"></a>77. 买卖股票的最佳时机</h1><ul><li><strong>一句话描述；</strong> 要想卖的时候利润最多，就要在之前<strong>最便宜的时候买入</strong>，因此维护之前的<strong>最小值</strong>即可。</li></ul><h2 id="77-1-题目描述"><a href="#77-1-题目描述" class="headerlink" title="77.1 题目描述"></a>77.1 题目描述</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span><br>解释：在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span>-<span class="hljs-number">1</span> = <span class="hljs-number">5</span> 。<br>     注意利润不能是 <span class="hljs-number">7</span>-<span class="hljs-number">1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><h2 id="77-2-算法思想和代码实现"><a href="#77-2-算法思想和代码实现" class="headerlink" title="77.2 算法思想和代码实现"></a>77.2 算法思想和代码实现</h2><p>要想卖的时候利润最多，就要在之前最便宜的时候买入，因此维护之前的最小值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//要想卖的时候利润最多，就要在之前最便宜的时候买入，因此维护之前的最小值即可。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxProfit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-comment">//维护之前的最小值</span><br>        <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) &#123;<br>            minPrice = prices[i];<br>        &#125;<br>        <br>        <span class="hljs-comment">//如果当前卖出的利润最多，则更新最大利润</span><br>        <span class="hljs-keyword">if</span> (prices[i] - minPrice &gt; maxProfit) &#123;<br>            maxProfit = prices[i] - minPrice;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxProfit;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="78-跳跃游戏"><a href="#78-跳跃游戏" class="headerlink" title="78. 跳跃游戏"></a>78. 跳跃游戏</h1><ul><li><strong>一句话描述：</strong> </li><li>维护一个 farthest 变量，记录能跳到的最远距离</li><li>如果<strong>当前索引超过了能跳到的最远距离，则跳不到终点</strong></li></ul><h2 id="78-1-题目描述"><a href="#78-1-题目描述" class="headerlink" title="78.1 题目描述"></a>78.1 题目描述</h2><p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：可以先跳 <span class="hljs-number">1</span> 步，从下标 <span class="hljs-number">0</span> 到达下标 <span class="hljs-number">1</span>, 然后再从下标 <span class="hljs-number">1</span> 跳 <span class="hljs-number">3</span> 步到达最后一个下标。<br></code></pre></td></tr></table></figure><h2 id="78-2-算法思想和代码实现"><a href="#78-2-算法思想和代码实现" class="headerlink" title="78.2 算法思想和代码实现"></a>78.2 算法思想和代码实现</h2><p>使用 贪心算法 维护一个 farthest 变量，记录能跳到的最远距离</p><ul><li>如果遍历到 i 时 farthest 不能再往前推进，则返回 false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">farthest</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 维护能跳到的最远距离</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; farthest) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果当前索引超过了能跳到的最远距离，则跳不到终点</span><br>        farthest = Math.max(farthest, i + nums[i]); <span class="hljs-comment">// 更新最远能到达的位置</span><br>        <span class="hljs-keyword">if</span> (farthest &gt;= nums.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果最远可以到达终点，则直接返回 true</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="79-跳跃游戏-II"><a href="#79-跳跃游戏-II" class="headerlink" title="79. 跳跃游戏 II"></a>79. 跳跃游戏 II</h1><ul><li><strong>一句话描述：</strong> </li><li>局部最优，找到<strong>下一个能跳的最远的位置</strong>，找最大的(<strong>下一个位置索引加上下一个位置最大跳跃距离</strong>)</li><li>如果当前位置已经能到达终点，count++,跳出循环</li></ul><h2 id="79-1-题目描述"><a href="#79-1-题目描述" class="headerlink" title="79.1 题目描述"></a>79.1 题目描述</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;&#x3D; j &lt;&#x3D; nums[i] </li><li>i + j &lt; n</li></ul><p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">2</span><br>解释: 跳到最后一个位置的最小跳跃数是 <span class="hljs-number">2</span>。<br>     从下标为 <span class="hljs-number">0</span> 跳到下标为 <span class="hljs-number">1</span> 的位置，跳 <span class="hljs-number">1</span> 步，然后跳 <span class="hljs-number">3</span> 步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><h2 id="79-2-算法思想和代码实现"><a href="#79-2-算法思想和代码实现" class="headerlink" title="79.2 算法思想和代码实现"></a>79.2 算法思想和代码实现</h2><p>维护当前跳跃的覆盖范围，更新最远可达位置<br>记录下一次能到达的最远位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; ) &#123;<br>        <span class="hljs-comment">//如果当前位置已经能到达终点，count++,跳出循环</span><br>        <span class="hljs-keyword">if</span> (nums[i] + i &gt;= nums.length - <span class="hljs-number">1</span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//局部最优，找到下一个能跳的最远的位置，找最大的(下一个位置索引加上下一个位置最大跳跃距离)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nextJump = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt;= i + nums[i]; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j + nums[j] &gt;= nextNum) &#123;<br>                nextJump = j;<br>                nextNum = j + nums[j];<br>            &#125;<br>        &#125;<br>        i = nextJump;<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="80-划分字母区间"><a href="#80-划分字母区间" class="headerlink" title="80. 划分字母区间"></a>80. 划分字母区间</h1><ul><li><strong>一句话描述：</strong></li><li>使用<strong>哈希表</strong>保存每个字符的最后出现位置</li><li>若发现<strong>某个字符的最后出现位置超出了当前片段范围，则更新 nextIndex</strong></li></ul><h2 id="80-1-题目描述"><a href="#80-1-题目描述" class="headerlink" title="80.1 题目描述"></a>80.1 题目描述</h2><p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 “ababcc” 能够被分为 [“abab”, “cc”]，但类似 [“aba”, “bcc”] 或 [“ab”, “ab”, “cc”] 的划分是非法的。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>、<span class="hljs-string">&quot;defegde&quot;</span>、<span class="hljs-string">&quot;hijhklij&quot;</span> 。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 这样的划分是错误的，因为划分的片段数较少。 <br></code></pre></td></tr></table></figure><h2 id="80-2-算法思想和代码实现"><a href="#80-2-算法思想和代码实现" class="headerlink" title="80.2 算法思想和代码实现"></a>80.2 算法思想和代码实现</h2><ol><li>使用哈希表保存每个字符的最后出现位置</li><li>划分字符串：<ul><li>遍历字符串，每次确定当前字符所在的片段范围（从 i 到 nextIndex）。</li><li>继续遍历该范围内的字符，若发现<strong>某个字符的最后出现位置超出了当前片段范围，则更新 nextIndex</strong>，以保证这个片段包含所有出现过的字符。</li><li>计算该片段的长度，并添加到结果列表中</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String s)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 记录每个字符的最后出现位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        map.put(s.charAt(i), i);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        nextIndex = Math.max(nextIndex, map.get(s.charAt(i)));<br>        <br>        <span class="hljs-keyword">if</span> (i == nextIndex) &#123;<br>            res.add(nextIndex - start + <span class="hljs-number">1</span>);<br>            start = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="81-爬楼梯"><a href="#81-爬楼梯" class="headerlink" title="81. 爬楼梯"></a>81. 爬楼梯</h1><ul><li><strong>一句话描述：</strong> <code>dp[i]</code>： 爬到第i层楼梯，有<code>dp[i]</code>种方法</li></ul><h2 id="81-1-题目描述"><a href="#81-1-题目描述" class="headerlink" title="81.1 题目描述"></a>81.1 题目描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：有两种方法可以爬到楼顶。<br><span class="hljs-number">1.</span> <span class="hljs-number">1</span> 阶 + <span class="hljs-number">1</span> 阶<br><span class="hljs-number">2.</span> <span class="hljs-number">2</span> 阶<br></code></pre></td></tr></table></figure><h2 id="81-2-算法思想和代码实现"><a href="#81-2-算法思想和代码实现" class="headerlink" title="81.2 算法思想和代码实现"></a>81.2 算法思想和代码实现</h2><ol><li>确定dp数组以及下标的含义<ul><li>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li></ul></li><li>确定递推公式<ul><li>dp[i] &#x3D; dp[i - 1] + dp[i - 2]</li></ul></li><li>dp数组如何初始化<ul><li>dp[1]&#x3D;1;dp[2]&#x3D;2;</li></ul></li><li>确定遍历顺序<ul><li>从前往后遍历</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">//确定递推公式</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="82-杨辉三角"><a href="#82-杨辉三角" class="headerlink" title="82. 杨辉三角"></a>82. 杨辉三角</h1><ul><li><strong>一句话描述：</strong> </li><li><code>dp[i][j]</code> 代表第i行第j列元素的值</li><li><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></li></ul><h2 id="82-1-题目描述"><a href="#82-1-题目描述" class="headerlink" title="82.1 题目描述"></a>82.1 题目描述</h2><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。<br>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: numRows = <span class="hljs-number">5</span><br>输出: [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><h2 id="82-2-算法思想和代码实现"><a href="#82-2-算法思想和代码实现" class="headerlink" title="82.2 算法思想和代码实现"></a>82.2 算法思想和代码实现</h2><ol><li>确定dp数组<ul><li>dp[i][j] 代表第i行第j列元素的值</li></ul></li><li>初始化dp数组<ul><li>dp[0][0]&#x3D;1;dp[i][0]&#x3D;1;dp[i][i]&#x3D;1;</li></ul></li><li>递推公式<ul><li><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>;</li></ul></li><li>遍历顺序<ul><li>从前往后，从上到下遍历二维数组</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numRows][numRows];<br><br>    <span class="hljs-comment">// 初始化第一行</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    List&lt;Integer&gt; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    first.add(<span class="hljs-number">1</span>);<br>    res.add(first);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; numRows; i++) &#123;<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        temp.add(dp[i][<span class="hljs-number">0</span>]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">//递推公式</span><br>            temp.add(dp[i][j]);<br>        &#125;<br><br>        dp[i][i] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 右边界元素也是1</span><br>        temp.add(dp[i][i]);<br><br>        res.add(temp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="83-打家劫舍"><a href="#83-打家劫舍" class="headerlink" title="83. 打家劫舍"></a>83. 打家劫舍</h1><ul><li><strong>一句话描述：</strong></li><li><code>dp[i]</code>：盗窃到第i间房间所获得的最高金额</li><li><code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code></li></ul><h2 id="83-1-题目描述"><a href="#83-1-题目描述" class="headerlink" title="83.1 题目描述"></a>83.1 题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">4</span><br>解释：偷窃 <span class="hljs-number">1</span> 号房屋 (金额 = <span class="hljs-number">1</span>) ，然后偷窃 <span class="hljs-number">3</span> 号房屋 (金额 = <span class="hljs-number">3</span>)。<br>     偷窃到的最高金额 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="83-2-算法思想和代码实现"><a href="#83-2-算法思想和代码实现" class="headerlink" title="83.2 算法思想和代码实现"></a>83.2 算法思想和代码实现</h2><ol><li>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</li><li>递推公式：<ul><li>决定dp[i]的因素就是第i房间偷还是不偷。</li><li>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i]</li><li>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考 虑i-1房</li><li>dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</li></ul></li><li>初始化：dp[1] &#x3D; max(nums[0], nums[1]);dp[0] 一定是 nums[0]</li><li>从前到后遍历</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>       <br>       <span class="hljs-comment">//dp数组：考虑是否偷dp[i]所得的最大值</span><br>       <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br><br>       <span class="hljs-comment">//是否偷dp[0]所得的最大值，这里肯定是要偷的，才能得到最大值</span><br>       dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>       dp[<span class="hljs-number">1</span>]=Math.max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]); <span class="hljs-comment">//dp[1]的最大值取决于nums[0]和nums[1]哪个大，偷哪个</span><br><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.length;i++)&#123;<br>           dp[i]=Math.max(dp[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+nums[i]); <span class="hljs-comment">//递推公式</span><br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="84-完全平方数"><a href="#84-完全平方数" class="headerlink" title="84. 完全平方数"></a>84. 完全平方数</h1><ul><li><strong>一句话描述：</strong> </li><li>转换为<strong>完全背包问题</strong><ul><li><code>dp[i][j]</code> 表示使用前 i 个完全平方数（1^2, 2^2, …, i^2）凑出 j 需要的最少个数。</li><li>不选当前平方数 i^2：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行）。</li><li>选择当前平方数 i^2：<code>dp[i][j] = dp[i][j - square] + 1</code>（选 i^2 之后，继续凑 j - i^2）</li></ul></li></ul><h2 id="84-1-题目描述"><a href="#84-1-题目描述" class="headerlink" title="84.1 题目描述"></a>84.1 题目描述</h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">12</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="84-2-算法思想和代码实现"><a href="#84-2-算法思想和代码实现" class="headerlink" title="84.2 算法思想和代码实现"></a>84.2 算法思想和代码实现</h2><h3 id="转换为完全背包问题"><a href="#转换为完全背包问题" class="headerlink" title="转换为完全背包问题"></a>转换为完全背包问题</h3><ol><li>状态定义<ul><li><code>dp[i][j]</code> 表示使用前 i 个完全平方数（1^2, 2^2, …, i^2）凑出 j 需要的最少个数。</li></ul></li><li>初始化<ul><li><code>dp[0][0] = 0</code>（凑出 0 需要 0 个数）。</li><li>其他 dp[i][j] 设为 Integer.MAX_VALUE，表示默认无法凑出。</li></ul></li><li>状态转移<ul><li>不选当前平方数 i^2：<code>dp[i][j] = dp[i-1][j]</code>（继承上一行）。</li><li>选择当前平方数 i^2：<code>dp[i][j] = dp[i][j - square] + 1</code>（选 i^2 之后，继续凑 j - i^2）。</li></ul></li><li>遍历方式<ul><li>外层循环 遍历所有可能的平方数 i^2。</li><li>内层循环 遍历目标值 j，尝试用 i^2 进行凑数。</li></ul></li><li>结果<br>最终 <code>dp[maxSqrt][n]</code> 即为凑出 n 所需的最少完全平方数个数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSqrt</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(n);<br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxSqrt + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化dp数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= maxSqrt; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            dp[i][j] = Integer.MAX_VALUE; <span class="hljs-comment">// 设为默认最大值</span><br>        &#125;<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 凑成 0 需要 0 个数</span><br>    <br>    <span class="hljs-comment">// 遍历平方数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= maxSqrt; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">square</span> <span class="hljs-operator">=</span> i * i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; square) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 不能选当前平方数，则继承上一行</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - square] + <span class="hljs-number">1</span>); <span class="hljs-comment">// 选或者不选</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[maxSqrt][n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="85-零钱兑换"><a href="#85-零钱兑换" class="headerlink" title="85. 零钱兑换"></a>85. 零钱兑换</h1><ul><li><strong>一句话描述：</strong> </li><li>转换为<strong>完全背包问题</strong></li><li><code>dp[i][j]</code>：用前 i 种硬币，凑成金额 j 所需的最少硬币数量</li></ul><h2 id="85-1-题目描述"><a href="#85-1-题目描述" class="headerlink" title="85.1 题目描述"></a>85.1 题目描述</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：coins = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], amount = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="85-2-算法思想和代码实现"><a href="#85-2-算法思想和代码实现" class="headerlink" title="85.2 算法思想和代码实现"></a>85.2 算法思想和代码实现</h2><h3 id="转换为完全背包问题-1"><a href="#转换为完全背包问题-1" class="headerlink" title="转换为完全背包问题"></a>转换为完全背包问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>    <span class="hljs-comment">// dp[i][j]：用前 i 种硬币，凑成金额 j 所需的最少硬币数量</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// 初始化：</span><br>    <span class="hljs-comment">// 金额为0时，不需要任何硬币</span><br>    <span class="hljs-comment">// 其余金额初始化为一个大数，表示暂时无法凑成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= amount; j++) &#123;<br>            dp[i][j] = Integer.MAX_VALUE - <span class="hljs-number">1</span>; <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; j++) &#123; <br>            <span class="hljs-keyword">if</span> (j &lt; coins[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 当前硬币面值大于目标金额，无法选，继承上一行的方案</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 可以选择当前硬币（无限次）</span><br>                <span class="hljs-comment">// 两种方案取较小值：</span><br>                <span class="hljs-comment">// 1️⃣ 不选当前硬币：dp[i-1][j]</span><br>                <span class="hljs-comment">// 2️⃣ 选当前硬币一次：dp[i][j - coins[i-1]] + 1</span><br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - coins[i - <span class="hljs-number">1</span>]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dp[n][amount] == Integer.MAX_VALUE - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> dp[n][amount];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="86-单词拆分"><a href="#86-单词拆分" class="headerlink" title="86. 单词拆分"></a>86. 单词拆分</h1><ul><li><strong>一句话总结：</strong> </li><li><code>dp[i]</code> 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成</li><li><code>dp[i]</code>的值依赖于i<strong>之前某个 dp[j] &#x3D;&#x3D; true</strong>，说明 <code>s[0 ~ j-1]</code>可以用字典单词拼接。 s.substring(j, i) 必须在 wordDict 里面，说明 <strong>j~i-1 这一段是一个合法单词</strong></li></ul><h2 id="86-1-题目描述"><a href="#86-1-题目描述" class="headerlink" title="86.1 题目描述"></a>86.1 题目描述</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: s = <span class="hljs-string">&quot;leetcode&quot;</span>, wordDict = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以由 <span class="hljs-string">&quot;leet&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> 拼接成。<br></code></pre></td></tr></table></figure><h2 id="86-2-算法思想和代码实现"><a href="#86-2-算法思想和代码实现" class="headerlink" title="86.2 算法思想和代码实现"></a>86.2 算法思想和代码实现</h2><ol><li>状态定义：<ul><li>dp[i] 表示字符串 s 的前 i 个字符是否可以由字典中的单词拼接而成。</li></ul></li><li>状态转移方程：<ul><li>dp[i] &#x3D; true 当且仅当 存在某个 j，满足：<ul><li>dp[j] &#x3D;&#x3D; true（表示 s[0:j] 可以被拆分）</li><li>s[j:i] 存在于 wordDict 中（表示 s[j:i] 是一个有效单词）</li></ul></li></ul></li><li>初始化：<ul><li>dp[0] &#x3D; true，表示空字符串可以被拆分</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(wordDict);<br>    <span class="hljs-type">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length() + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 空字符串可以组成</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>; <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.length()];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="87-最长递增子序列"><a href="#87-最长递增子序列" class="headerlink" title="87. 最长递增子序列"></a>87. 最长递增子序列</h1><ul><li><strong>一句话描述：</strong> </li><li><code>dp[i]</code> 表示<strong>以 <code>nums[i]</code> 结尾的最长递增子序列的长度</strong></li><li>两次遍历：第一次遍历求每个以 nums[i] 结尾的最长递增子序列，第二次遍历i之前的元素，比较元素是否加入当前元素的后面作为结尾</li></ul><h2 id="87-1-题目描述"><a href="#87-1-题目描述" class="headerlink" title="87.1 题目描述"></a>87.1 题目描述</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="87-2-算法思想和代码实现"><a href="#87-2-算法思想和代码实现" class="headerlink" title="87.2 算法思想和代码实现"></a>87.2 算法思想和代码实现</h2><ol><li>状态定义：<ul><li>设 dp[i] 表示 以 nums[i] 结尾的最长递增子序列的长度。</li></ul></li><li>状态转移方程：<ul><li>遍历 j（0 ≤ j &lt; i），检查所有可能的前一个元素：<ul><li>如果 nums[i] &gt; nums[j]，即 nums[i] 可以接在 nums[j] 之后形成更长的递增子序列：<ul><li><code>dp[i]=max(dp[i],dp[j]+1)</code></li></ul></li></ul></li><li>遍历完成后，更新 res 记录 全局最长递增子序列的长度。</li></ul></li><li>初始化：<ul><li>每个元素 单独作为子序列时，长度至少是 1，所以 dp[i] 初始为 1。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br><br>    <span class="hljs-comment">// 初始化 dp 数组，每个元素单独作为子序列时长度为 1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历数组，计算每个以 nums[i] 结尾的最长递增子序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 遍历 i 之前的元素 nums[j]，找到比 nums[i] 小的元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-comment">// 如果 nums[i] &gt; nums[j]，说明可以接在 nums[j] 之后形成递增子序列</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        res = Math.max(res, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="88-乘积最大子数组"><a href="#88-乘积最大子数组" class="headerlink" title="88. 乘积最大子数组"></a>88. 乘积最大子数组</h1><ul><li><strong>一句话描述：</strong> </li><li>用max和min维护遍历到当前元素时的最大值和最小值</li><li>如果当前元素是<strong>负数</strong>，那么会导致<strong>最大的变最小的，最小的变最大的</strong>。因此交换两个的值。</li><li><code>max = Math.max(max * nums[i], nums[i])</code><ul><li>对于每一个 <code>nums[i]</code>，最大乘积有两种选择： <ul><li>1️⃣ <strong>继续累乘</strong>：<code>max * nums[i]</code> —— 把前面的乘积继续乘上这个 nums[i]，不切断子数组。</li><li>2️⃣ <strong>重新开始</strong>：<code>nums[i]</code> —— 从当前位置 i 开始一个新的乘积子数组。</li></ul></li></ul></li></ul><h2 id="88-1-题目描述"><a href="#88-1-题目描述" class="headerlink" title="88.1 题目描述"></a>88.1 题目描述</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 32-位 整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br>输出: <span class="hljs-number">6</span><br>解释: 子数组 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 有最大乘积 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><h2 id="88-2-算法思想和代码实现"><a href="#88-2-算法思想和代码实现" class="headerlink" title="88.2 算法思想和代码实现"></a>88.2 算法思想和代码实现</h2><p>对于每个元素 nums[i]，有三种可能的情况：</p><ol><li>当前元素为正数：imax 可能增大，imin 可能减小。分别更新 imax 和 imin。</li><li>当前元素为负数：负数会导致最大乘积变成最小乘积，最小乘积变成最大乘积。此时，应该交换 imax 和 imin，然后根据当前元素更新这两个值。</li><li>当前元素为零：乘积会重置为零，可以跳过对最大和最小值的更新。</li></ol><ul><li>更新 max 为 max(imax, max)，记录当前的最大乘积。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, imax = <span class="hljs-number">1</span>, imin = <span class="hljs-number">1</span>; <span class="hljs-comment">//一个保存最大的，一个保存最小的。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//如果数组的数是负数，那么会导致最大的变最小的，最小的变最大的。因此交换两个的值。</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> imax;<br>            imax = imin;<br>            imin = tmp;<br>        &#125;<br><br>        imax = Math.max(imax * nums[i], nums[i]);<br>        imin = Math.min(imin * nums[i], nums[i]);<br><br>        max = Math.max(max, imax);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="89-分割等和子集"><a href="#89-分割等和子集" class="headerlink" title="89. 分割等和子集"></a>89. 分割等和子集</h1><ul><li><strong>一句话描述：</strong> </li><li><strong>转换为0-1背包问题</strong></li><li><code>dp[i][j]</code>：从前 i 个数里，能否选出一些数，使它们的和接近j</li></ul><h2 id="89-1-题目描述"><a href="#89-1-题目描述" class="headerlink" title="89.1 题目描述"></a>89.1 题目描述</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：数组可以分割成 [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>] 和 [<span class="hljs-number">11</span>] 。<br></code></pre></td></tr></table></figure><h2 id="89-2-算法思想和代码实现"><a href="#89-2-算法思想和代码实现" class="headerlink" title="89.2 算法思想和代码实现"></a>89.2 算法思想和代码实现</h2><h3 id="89-2-1-转换为0-1背包问题"><a href="#89-2-1-转换为0-1背包问题" class="headerlink" title="89.2.1 转换为0-1背包问题"></a>89.2.1 转换为0-1背包问题</h3><ol><li>如果<strong>当前背包容量小于当前物品容量</strong>，那就放不进，那就<strong>只能取同列上一行的价值</strong>(相同的背包，上一个物品时的最优价值)</li><li>在<strong>当前背包容量大于当前物品容量时</strong><ul><li>放入该物品得到一个价值，因为还有剩余容量(剩余容量等于当前背包容量减去当前放入物品容量)，然后到上一行去找这个剩余容量的价值(肯定是最优价值)</li><li>然后把<strong>新放入物品价值加上剩余容量价值的和</strong>与<strong>上一行同列的价值</strong>进行比较，价值较大者为最优解。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为最小背包问题</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 计算数组的总和,如果总和为奇数，无法分割成两个和相等的子集,目标是凑够总和/2</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>          sum += num;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>      <span class="hljs-comment">//dp[i][j]代表放入i时，大小为j的容量的最优解; 初始化：默认初始化为0</span><br>      <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++)<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>              <span class="hljs-keyword">if</span> (j &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>                  dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]] + nums[i - <span class="hljs-number">1</span>]);<br>              &#125;<br>          &#125;<br><br>      <span class="hljs-keyword">return</span> dp[nums.length][target] == target;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="89-2-2-方法2"><a href="#89-2-2-方法2" class="headerlink" title="89.2.2 方法2"></a>89.2.2 方法2</h3><ol><li><p>状态定义</p><ul><li>dp[i][j] 表示在前 i 个元素中，是否可以选出若干个数，使其和为 j。</li></ul></li><li><p>状态转移方程</p><ul><li>对于每个元素 nums[i-1]，可以选择“选它”或者“不选它”：<ul><li>不选 nums[i-1]：dp[i][j] &#x3D; dp[i-1][j]</li><li>选 nums[i-1]（前提 j &gt;&#x3D; nums[i-1]）：dp[i][j] &#x3D; dp[i-1][j] || dp[i-1][j - nums[i-1]]</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">// 计算数组的总和,如果总和为奇数，无法分割成两个和相等的子集,目标是凑够总和/2</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>           sum += num;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>       <span class="hljs-comment">// dp[i][j] 表示是否可以从前 i 个数中选出若干个数，使其和为 j</span><br>       <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br><br>       <span class="hljs-comment">// 初始化：当 j=0 时，即不选任何数，总和可以为 0</span><br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= nums.length; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; j++) &#123;<br>               <span class="hljs-comment">// 继承上一个状态：不选当前数时，是否能凑出 j</span><br>               dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br><br>               <span class="hljs-comment">// 选当前数：如果 j &gt;= nums[i-1]，则可以尝试选它</span><br>               <span class="hljs-keyword">if</span> (j &gt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>                   dp[i][j] = dp[i][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];<br>               &#125;<br><br>               <span class="hljs-comment">// 如果已经找到一个子集使其和为 target，提前返回 true</span><br>               <span class="hljs-keyword">if</span> (dp[i][target]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="90-最长有效括号"><a href="#90-最长有效括号" class="headerlink" title="90. 最长有效括号"></a>90. 最长有效括号</h1><ul><li><strong>一句话描述：</strong> </li><li><code>dp[i]</code> 表示以下标 i <strong>结尾</strong>的最长有效括号子串的长度，主要在于分情况讨论</li><li>当 <code>s[i] == &#39;(&#39;</code> 时</li><li>当 <code>s[i] == &#39;)&#39;</code> 时<ul><li>如果 <code>s[i-1] == &#39;(&#39;</code></li><li>如果 <code>s[i-1] == &#39;)&#39;</code><ul><li>如果 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code></li></ul></li></ul></li></ul><h2 id="90-1-题目描述"><a href="#90-1-题目描述" class="headerlink" title="90.1 题目描述"></a>90.1 题目描述</h2><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;(()&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span><br></code></pre></td></tr></table></figure><h2 id="90-2-算法思想和代码实现"><a href="#90-2-算法思想和代码实现" class="headerlink" title="90.2 算法思想和代码实现"></a>90.2 算法思想和代码实现</h2><p>定义 <code>dp[i]</code> 表示以下标 i 结尾的最长有效括号子串的长度。状态转移方程如下：</p><ol><li>当 <code>s[i] == &#39;(&#39;</code> 时，<code>dp[i] = 0</code>，因为以左括号结尾不可能是有效括号序列。</li><li>当 <code>s[i] == &#39;)&#39;</code> 时，需要考虑：<ul><li>如果 <code>s[i-1] == &#39;(&#39;</code>，那么 <code>dp[i] = dp[i-2] + 2</code>（前面已有的有效括号子串加上这对新匹配的括号）。</li><li>如果 <code>s[i-1] == &#39;)&#39;</code>，那么需要检查 <code>i - dp[i-1] - 1</code> 位置的字符是否是 ‘(‘：<ul><li>如果 <code>s[i - dp[i-1] - 1] == &#39;(&#39;</code>，那么 <code>dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]</code>（前一个有效括号子串加上新匹配的括号，再加上更前面的有效子串）。</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-comment">// dp[i] 表示以 s[i] 结尾的最长有效括号子串长度</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n]; <br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最长有效括号子串的长度</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            dp[i] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 只有当前字符是 &#x27;)&#x27; 时才有可能形成有效括号</span><br>        <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123; <br><br>            <span class="hljs-comment">// 情况1：前一个字符是 &#x27;(&#x27;，可以直接与它配对形成 &quot;()&quot;</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// 如果 i &gt;= 2，则需要加上 dp[i - 2]，表示连接前面的有效括号子串</span><br>                    dp[i] = dp[i - <span class="hljs-number">2</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果 i &lt; 2，说明 &quot;()&quot; 是当前能形成的唯一有效子串</span><br>                    dp[i] = <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 情况2：前一个字符是 &#x27;)&#x27;，需要看 i-dp[i-1]-1 是否是 &#x27;(&#x27;，才能形成有效括号</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 只有 i - dp[i - 1] - 1 在有效范围内且 s[i - dp[i - 1] - 1] == &#x27;(&#x27;，才能形成匹配</span><br>                <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br><br>                    <span class="hljs-comment">// 如果 i - dp[i - 1] - 1 前面还有有效括号子串，则需要加上它的长度</span><br>                    <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                        dp[i] += dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> - <span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 记录最大值</span><br>            maxLen = Math.max(maxLen, dp[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="91-不同路径"><a href="#91-不同路径" class="headerlink" title="91. 不同路径"></a>91. 不同路径</h1><ul><li><strong>一句话描述：</strong> <code>dp[i][j]</code>代表到达第i行第j列的不同路径有多少个</li></ul><h2 id="91-1-题目描述"><a href="#91-1-题目描述" class="headerlink" title="91.1 题目描述"></a>91.1 题目描述</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><h2 id="91-2-算法思想和代码实现"><a href="#91-2-算法思想和代码实现" class="headerlink" title="91.2 算法思想和代码实现"></a>91.2 算法思想和代码实现</h2><ul><li><code>dp[i][j]</code>代表到达第i行第j列的不同路径有多少个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]代表到达第i行第j列的不同路径有多少个</span><br>    <span class="hljs-type">int</span>[][] dp =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>    <span class="hljs-comment">//初始化dp</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)<br>        dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>        dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//从左往右，从上到下遍历</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-comment">//状态转移方程</span><br>            dp[i][j]=dp[i-<span class="hljs-number">1</span>][j]+dp[i][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="92-最小路径和"><a href="#92-最小路径和" class="headerlink" title="92. 最小路径和"></a>92. 最小路径和</h1><ul><li><strong>一句话描述：</strong> <code>dp[i][j]</code>:走到第i行第j列时的最小总和</li></ul><h2 id="92-1-题目描述"><a href="#92-1-题目描述" class="headerlink" title="92.1 题目描述"></a>92.1 题目描述</h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><h2 id="92-2-算法思想和代码实现"><a href="#92-2-算法思想和代码实现" class="headerlink" title="92.2 算法思想和代码实现"></a>92.2 算法思想和代码实现</h2><ul><li>本单元格的最小路径和依赖于上一行同列和上一列同行的路径和的最小值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br><br>        <span class="hljs-comment">//dp[i][j]:走到第i行第j列时的最小总和</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>        &#125;<br><br>        <span class="hljs-comment">//dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br><br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="93-最长回文子串"><a href="#93-最长回文子串" class="headerlink" title="93. 最长回文子串"></a>93. 最长回文子串</h1><ul><li><strong>一句话总结：</strong> </li><li>定义 <code>dp[i][j]</code> 表示字符串<strong>从索引 i 到 j 的子串是否是回文子串</strong></li><li>更长的子串，<code>s[i] == s[j]</code> 时，它是否回文取决于 <code>s[i+1:j-1]</code> 是否回文串</li><li><strong>外层循环 i 递减</strong>（从后往前遍历）,内层循环 j 递增（从左到右遍历）,因为 <code>dp[i][j]</code> 依赖于 <code>dp[i+1][j-1]</code></li></ul><h2 id="93-1-题目描述"><a href="#93-1-题目描述" class="headerlink" title="93.1 题目描述"></a>93.1 题目描述</h2><p>给你一个字符串 s，找到 s 中最长的 回文 子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><h2 id="93-2-算法思想和代码实现"><a href="#93-2-算法思想和代码实现" class="headerlink" title="93.2 算法思想和代码实现"></a>93.2 算法思想和代码实现</h2><p>与回文子串题目一样，只不过这里求了最长的(<a href="https://leetcode.cn/problems/palindromic-substrings/description/">回文子串</a>)</p><ul><li>定义 <code>dp[i][j]</code> 表示字符串 s 从索引 i 到 j 的子串是否是回文子串</li><li>当s[i]和s[j]不相同时，一定是false</li><li>当s[i]和s[j]相同时，分以下三种情况：<ul><li>单个字符一定是回文串，所以 dp[i][i] &#x3D; true</li><li>相邻字符相等时也是回文串，即 dp[i][i+1] &#x3D; (s[i] &#x3D;&#x3D; s[i+1])</li><li>更长的子串，s[i] &#x3D;&#x3D; s[j] 时，它是否回文取决于 s[i+1:j-1] 是否回文，即 dp[i][j] &#x3D; dp[i+1][j-1]。</li></ul></li><li>外层循环 i 递减（从后往前遍历）<ul><li>因为 dp[i][j] 依赖于 dp[i+1][j-1]，所以要先计算 dp[i+1][j-1] 再计算 dp[i][j]。</li></ul></li><li>内层循环 j 递增（从左到右遍历）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//dp[i][j]:从i到j的子串是不是回文的</span><br>       <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br><br>       <span class="hljs-comment">//i必须要从后往前遍历</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>           <span class="hljs-comment">//j从i开始往后遍历</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++) &#123;<br>               <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                   <span class="hljs-keyword">if</span> (j == i || j == i + <span class="hljs-number">1</span>) &#123;<br>                       dp[i][j] = <span class="hljs-literal">true</span>;<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">if</span> (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) &#123;<br>                           dp[i][j] = <span class="hljs-literal">true</span>;<br>                       &#125;<br>                   &#125;<br>               &#125;<br><br>               <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                   <span class="hljs-keyword">if</span> (j - i &gt; maxLen) &#123;<br>                       maxLen = j - i;<br>                       left = i;<br>                       right = j;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> s.substring(left, right + <span class="hljs-number">1</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="94-最长公共子序列"><a href="#94-最长公共子序列" class="headerlink" title="94. 最长公共子序列"></a>94. 最长公共子序列</h1><ul><li><strong>一句话描述：</strong> </li><li><code>dp[i][j]</code>: text1前i个字符串和text2前j个字符串的最长公共子序列长度</li><li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li><li>如果i和j的字符不相同，<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></li></ul><h2 id="94-1-题目描述"><a href="#94-1-题目描述" class="headerlink" title="94.1 题目描述"></a>94.1 题目描述</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：text1 = <span class="hljs-string">&quot;abcde&quot;</span>, text2 = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><h2 id="94-2-算法思想和代码实现"><a href="#94-2-算法思想和代码实现" class="headerlink" title="94.2 算法思想和代码实现"></a>94.2 算法思想和代码实现</h2><ul><li><code>dp[i][j]</code>：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</li><li>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</li><li>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。<ul><li>即：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>    <span class="hljs-comment">//dp[i][j]:text1在0~i子串和text2在0~j子串中的最长公共子序列长度</span><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[text1.length() + <span class="hljs-number">1</span>][text2.length() + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//从前往后，从上到下遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= text1.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= text2.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (text1.charAt(i - <span class="hljs-number">1</span>) == text2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[text1.length()][text2.length()];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="95-编辑距离"><a href="#95-编辑距离" class="headerlink" title="95. 编辑距离"></a>95. 编辑距离</h1><ul><li><strong>一句话描述:</strong></li><li><code>dp[i][j]</code> 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符的最小操作数</li><li>如果i和j的字符相同，<code>dp[i][j] = dp[i - 1][j - 1] </code></li><li>如果i和j的字符不相同<ul><li>替换操作：dp[i-1][j-1] + 1</li><li>删除操作：dp[i-1][j] + 1</li><li>插入操作：dp[i][j-1] + 1</li></ul></li></ul><h2 id="95-1-题目描述"><a href="#95-1-题目描述" class="headerlink" title="95.1 题目描述"></a>95.1 题目描述</h2><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>horse -&gt; rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br>rorse -&gt; rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br>rose -&gt; ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="95-2-算法思想和代码实现"><a href="#95-2-算法思想和代码实现" class="headerlink" title="95.2 算法思想和代码实现"></a>95.2 算法思想和代码实现</h2><ul><li><code>dp[i][j]</code> 表示 word1 的前 i 个字符转换成 word2 的前 j 个字符的最小操作数</li><li>初始化：<ul><li>dp[i][0] &#x3D; i：word1 变成空串，需要 i 次删除操作。</li><li>dp[0][j] &#x3D; j：空串变成 word2，需要 j 次插入操作。</li></ul></li><li>状态转移方程：<ul><li>若 word1[i-1] &#x3D;&#x3D; word2[j-1]，则 dp[i][j] &#x3D; dp[i-1][j-1]（当前字符相同，无需操作）。</li><li>否则，取三种操作的最小值：<ul><li>替换操作：dp[i-1][j-1] + 1</li><li>删除操作：dp[i-1][j] + 1</li><li>插入操作：dp[i][j-1] + 1</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-comment">// dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[word1.length() + <span class="hljs-number">1</span>][word2.length() + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 初始化 dp 数组</span><br>        <span class="hljs-comment">// 当 word2 为空时，word1 需要删除 i 个字符才能变成 word2</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word1.length(); i++)<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-comment">// 当 word1 为空时，word2 需要插入 i 个字符才能变成 word1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= word2.length(); i++)<br>            dp[<span class="hljs-number">0</span>][i] = i;<br><br>        <span class="hljs-comment">// 从左到右，从上到下遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= word1.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= word2.length(); j++) &#123;<br>                <span class="hljs-comment">// 如果当前字符相等，则不需要额外操作，继承前一个状态</span><br>                <span class="hljs-keyword">if</span> (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 三种操作：</span><br>                    <span class="hljs-comment">// 1. 替换（dp[i - 1][j - 1] + 1）</span><br>                    <span class="hljs-comment">// 2. 删除 word1 的字符（dp[i - 1][j] + 1）</span><br>                    <span class="hljs-comment">// 3. 插入 word2 的字符（dp[i][j - 1] + 1）</span><br>                    dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[word1.length()][word2.length()];<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="96-只出现一次的数字"><a href="#96-只出现一次的数字" class="headerlink" title="96. 只出现一次的数字"></a>96. 只出现一次的数字</h1><ul><li><strong>一句话描述：</strong> 使用<strong>异或</strong>运算符(^)，a^a&#x3D;0,a^0&#x3D;a</li></ul><h2 id="96-1-题目描述"><a href="#96-1-题目描述" class="headerlink" title="96.1 题目描述"></a>96.1 题目描述</h2><p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="96-2-算法思想和代码实现"><a href="#96-2-算法思想和代码实现" class="headerlink" title="96.2 算法思想和代码实现"></a>96.2 算法思想和代码实现</h2><h3 id="96-2-1-排序后遍历-O-nlogn"><a href="#96-2-1-排序后遍历-O-nlogn" class="headerlink" title="96.2.1 排序后遍历(O(nlogn))"></a>96.2.1 排序后遍历(O(nlogn))</h3><p>先排序，在遍历找到出现一次的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Arrays.sort(nums);<br><br>    <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i+=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i]!=nums[i-<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> nums[i-<span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[nums.length-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="96-2-2-位运算：异或"><a href="#96-2-2-位运算：异或" class="headerlink" title="96.2.2 位运算：异或"></a>96.2.2 位运算：异或</h3><p>异或：位运算时，相同为0，不同为1</p><ul><li>a ^ a &#x3D; 0（相同的数异或后变成 0）</li><li>a ^ 0 &#x3D; a（任何数与 0 异或还是它本身）</li><li>异或运算满足交换律和结合律，因此所有成对的数字都会变成 0，最终只剩下那个唯一的数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        result ^= num;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="97-多数元素"><a href="#97-多数元素" class="headerlink" title="97. 多数元素"></a>97. 多数元素</h1><ul><li><strong>一句话描述：</strong> res&#x3D;当前元素，用一个计数器，当出现自己时，计数+1，不是自己计数-1，当计数器&#x3D;0时，重新把res置为当前元素</li></ul><h2 id="97-1-题目描述"><a href="#97-1-题目描述" class="headerlink" title="97.1 题目描述"></a>97.1 题目描述</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="97-2-算法思想和代码实现"><a href="#97-2-算法思想和代码实现" class="headerlink" title="97.2 算法思想和代码实现"></a>97.2 算法思想和代码实现</h2><h3 id="97-2-1-先排序-取中位数"><a href="#97-2-1-先排序-取中位数" class="headerlink" title="97.2.1 先排序+取中位数"></a>97.2.1 先排序+取中位数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       Arrays.sort(nums);<br>       <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="97-2-2-摩尔投票法"><a href="#97-2-2-摩尔投票法" class="headerlink" title="97.2.2 摩尔投票法"></a>97.2.2 摩尔投票法</h3><p>核心就是对拼消耗。<br>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。<br>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。<br>最后能剩下的必定是自己人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; ++i) &#123;<br>           <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>               x = nums[i];<br>           &#125;<br>           <span class="hljs-keyword">if</span> (nums[i] == x) &#123;<br>               count++;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               count--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> x;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="98-颜色分类"><a href="#98-颜色分类" class="headerlink" title="98. 颜色分类"></a>98. 颜色分类</h1><ul><li><strong>一句话描述：</strong> </li><li>两个指针：一个指针指向0位置，依次存储0元素，一个指针指向数组结尾位置，依次存储2元素</li></ul><h2 id="98-1-题目描述"><a href="#98-1-题目描述" class="headerlink" title="98.1 题目描述"></a>98.1 题目描述</h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="98-2-算法思想和代码实现"><a href="#98-2-算法思想和代码实现" class="headerlink" title="98.2 算法思想和代码实现"></a>98.2 算法思想和代码实现</h2><p>0，1，2 排序。一次遍历，如果是0，则移动到表头，如果是2，则移动到表尾，不用考虑1。0和2处理完，1还会有错吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>     <span class="hljs-comment">//x,y记录0和2的位置</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, y = nums.length - <span class="hljs-number">1</span>;<br>     <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>         <span class="hljs-comment">//如果当前元素是0，把它放到数组开头位置</span><br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span> &amp;&amp; i &gt; x) &#123;<br>             nums[i] = nums[x];<br>             nums[x] = <span class="hljs-number">0</span>;<br>             x++;<br>             i--;<br>         &#125;<br>         <br>         <span class="hljs-comment">//如果当前元素是2，把它放到数组结尾位置</span><br>         <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">2</span> &amp;&amp; i &lt; y) &#123;<br>             nums[i] = nums[y];<br>             nums[y] = <span class="hljs-number">2</span>;<br>             y--;<br>             i--;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="99-下一个排列"><a href="#99-下一个排列" class="headerlink" title="99. 下一个排列"></a>99. 下一个排列</h1><ul><li><strong>一句话描述：</strong> </li><li><code>2, 6, 3, 5, 4, 1 --&gt; 2, 6, 4, 1, 3, 5</code> 分为以下几步：<ol><li>从后往前找到3</li><li>从后往前找，找到第一个大于3的数：4</li><li><code>swap(3,4)</code>，此时：<code>2, 6, 4, 5, 3, 1</code></li><li>最后<strong>反转5，3，1</strong>即可得到<code>2, 6, 4, 1, 3, 5</code></li></ol></li></ul><h2 id="99-1-题目描述"><a href="#99-1-题目描述" class="headerlink" title="99.1 题目描述"></a>99.1 题目描述</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li></ul><p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li><li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。</li><li>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。<br>必须 原地 修改，只允许使用额外常数空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="99-2-算法思想和代码实现"><a href="#99-2-算法思想和代码实现" class="headerlink" title="99.2 算法思想和代码实现"></a>99.2 算法思想和代码实现</h2><ol><li>从后往前找出数值下降的位置 i</li><li>交换 nums[i] 和 i之后比nums[i]大的最小数</li><li>让i+1位及其之后的排列最小即 递增（其实已经是递减的了，直接反转就行）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//从后往前遍历，找到第一个非递减的元素，该元素就是排列的起点start</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i + <span class="hljs-number">1</span>]) &#123;<br>            start = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果整个数组是降序排列，则直接反转它变成最小排列</span><br>    <span class="hljs-keyword">if</span> (start == -<span class="hljs-number">1</span>) &#123;<br>        reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//找到比start大的最小的元素,并与start交换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt; start; i--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[start]) &#123;<br>            swap(nums, i, start);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//反转从start+1到最后的数组元素</span><br>    reverse(nums, start + <span class="hljs-number">1</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//交换</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br><br><span class="hljs-comment">//反转</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        swap(nums, start, end);<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="100-寻找重复数"><a href="#100-寻找重复数" class="headerlink" title="100. 寻找重复数"></a>100. 寻找重复数</h1><ul><li><strong>一句话描述：</strong> </li><li><strong>快慢指针找环</strong>，相遇之后，将fast重新置为0，两个指针每次移动一步，再次相遇就是重复数所在位置</li><li><code>fast = nums[nums[fast]]</code> &#x2F;&#x2F; 快指针每次移动两步</li><li><code>slow = nums[slow]</code> &#x2F;&#x2F; 慢指针每次移动一步</li></ul><h2 id="100-1-题目描述"><a href="#100-1-题目描述" class="headerlink" title="100.1 题目描述"></a>100.1 题目描述</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="100-2-算法思想和代码实现"><a href="#100-2-算法思想和代码实现" class="headerlink" title="100.2 算法思想和代码实现"></a>100.2 算法思想和代码实现</h2><ol><li><p>数组大小为 n+1，其中的数字范围是 [1, n]，因此必然有一个数字重复</p></li><li><p>快慢指针判圈</p></li></ol><ul><li><p>定义两个指针：</p><ul><li>慢指针 (slow) 每次移动一步。</li><li>快指针 (fast) 每次移动两步。</li></ul></li><li><p>为什么存在环？</p><ul><li>由于 nums[i] 指向数组中的索引，这实际上形成了一个 链表 结构。</li><li>由于存在 重复元素，意味着<strong>至少有两个索引指向 同一位置</strong>，从而形成 环。</li></ul></li></ul><ol start="3"><li>找到环的入口（即重复数）<ul><li>当 slow &#x3D;&#x3D; fast 时，说明快慢指针相遇，表明存在环。</li><li>让 fast 指针回到 <strong>起点 (0)</strong>，然后 <strong>两个指针都每次移动一步</strong>。</li><li>他们再次相遇的地方，就是 环的入口（即重复的数字）。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 使用快慢指针寻找相遇点</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        fast = nums[nums[fast]]; <span class="hljs-comment">// 快指针每次移动两步</span><br>        slow = nums[slow]; <span class="hljs-comment">// 慢指针每次移动一步</span><br><br>        <span class="hljs-comment">// 当快慢指针相遇时，说明存在环</span><br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            fast = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重新将快指针置于起点</span><br><br>            <span class="hljs-comment">// 通过第二次相遇点确定重复的数字</span><br>            <span class="hljs-keyword">while</span> (nums[slow] != nums[fast]) &#123;<br>                fast = nums[fast]; <span class="hljs-comment">// 快指针每次移动一步</span><br>                slow = nums[slow]; <span class="hljs-comment">// 慢指针每次移动一步</span><br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> nums[slow]; <span class="hljs-comment">// 返回找到的重复数字</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><hr><hr><hr><h1 id="101-使用最小花费爬楼梯"><a href="#101-使用最小花费爬楼梯" class="headerlink" title="101. 使用最小花费爬楼梯"></a>101. 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">使用最小花费爬楼梯</a></p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-comment">//dp[i]代表爬到第i个台阶所花费的最小费用</span><br>    <span class="hljs-type">int</span>[] dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化dp</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=cost.length;i++)&#123;<br>        dp[i]=Math.min(dp[i-<span class="hljs-number">1</span>]+cost[i-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">2</span>]+cost[i-<span class="hljs-number">2</span>]); <span class="hljs-comment">//状态转移方程</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[cost.length];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="102-不同路径II"><a href="#102-不同路径II" class="headerlink" title="102. 不同路径II"></a>102. 不同路径II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/description/">不同路径II</a></p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br><br>       <span class="hljs-comment">//dp[i][j]：到达第i行第j列的不同路径个数</span><br>       <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br><br>       <span class="hljs-comment">//初始化</span><br>       <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>           <span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>               dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>           <span class="hljs-keyword">else</span><br>               dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>           <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>)<br>               dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">else</span><br>               dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-comment">//状态转移方程</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>               <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                   dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   dp[i][j] = <span class="hljs-number">0</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="103-整数拆分"><a href="#103-整数拆分" class="headerlink" title="103. 整数拆分"></a>103. 整数拆分</h1><p><a href="https://leetcode.cn/problems/integer-break/description/">整数拆分</a></p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//dp[i]代表i可以拆分的最大乘积</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//dp[i] = Math.max(dp[i],j*(i-j),j*dp[i-j]);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i/<span class="hljs-number">2</span>;j++)&#123;<br>            dp[i]=Math.max(Math.max(j*(i-j),j*dp[i-j]),dp[i]);<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="104-不同的二叉搜索树"><a href="#104-不同的二叉搜索树" class="headerlink" title="104. 不同的二叉搜索树"></a>104. 不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/">不同的二叉搜索树</a></p><p><code>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得G(n) = G(0)G(n-1)+G(1)(n-2)+...+G(n-1)*G(0)</code></p><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//dp[i]：由i个结点组成的二叉树的种类</span><br>    <span class="hljs-type">int</span>[] dp =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//dp[i]=dp[0]*dp[i-1]+dp[1]*dp[i-2]+...+dp[i]*dp[0]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>            dp[i]+=dp[j]*dp[i-j-<span class="hljs-number">1</span>];<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="105-最后一块石头的重量-II"><a href="#105-最后一块石头的重量-II" class="headerlink" title="105. 最后一块石头的重量 II"></a>105. 最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">最后一块石头的重量 II</a></p><p>转换为0-1背包问题：</p><ul><li>尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。</li><li>一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum &#x2F; 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum&#x2F;2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum &#x2F; 2的背包。</li></ul><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为01背包问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stones.length; i++)<br>        sum += stones[i];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[stones.length + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= stones.length; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; stones[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - stones[i - <span class="hljs-number">1</span>]] + stones[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> sum - <span class="hljs-number">2</span> * dp[stones.length][target];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="106-回文子串"><a href="#106-回文子串" class="headerlink" title="106. 回文子串"></a>106. 回文子串</h1><p><a href="https://leetcode.cn/problems/palindromic-substrings/">回文子串</a><br>该题目与最长回文子串类似(<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">最长回文子串</a>)</p><ul><li>dp定义：布尔类型的dp[i][j]：表示区间范围[i,j]的子串是否是回文子串，如果是dp[i][j]为true，否则为false</li><li>状态转移方程：<ul><li>当s[i]与s[j]不相等，dp[i][j]一定是false。</li><li>当s[i]与s[j]相等时，有如下三种情况<ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li></ul></li></ul></li></ul><p><strong>代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubstrings</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//dp[i][j]:从i到j的子串是不是回文的</span><br>    <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][s.length()];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 逆序遍历i</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; s.length(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<br>                <span class="hljs-keyword">if</span> (j == i || j == i + <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 单个字符 or 相邻字符</span><br>                    dp[i][j] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr><hr><h1 id="201-合并两个有序数组"><a href="#201-合并两个有序数组" class="headerlink" title="201. 合并两个有序数组"></a>201. <a href="https://leetcode.cn/problems/merge-sorted-array/description/">合并两个有序数组</a></h1><p><strong>双指针从后往前合并</strong>，避免覆盖还没处理的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;<br>            nums1[p] = nums1[p1];<br>            p1--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums1[p] = nums2[p2];<br>            p2--;<br>        &#125;<br>        p--;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 nums2 还有剩余元素，复制到 nums1</span><br>    <span class="hljs-keyword">while</span> (p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        nums1[p] = nums2[p2];<br>        p2--;<br>        p--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="202-字符串相加"><a href="#202-字符串相加" class="headerlink" title="202. 字符串相加"></a>202. <a href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></h1><p>1️⃣ 从 num1 和 num2 的末尾开始，一位一位相加。<br>2️⃣ 用一个 carry 保存进位，初始为 0。<br>3️⃣ 每次把当前位的和 sum &#x3D; digit1 + digit2 + carry 计算好，sum % 10 放入结果，sum &#x2F; 10 更新 carry。<br>4️⃣ 最后别忘了：如果 carry !&#x3D; 0，还要加到结果前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">addStrings</span><span class="hljs-params">(String num1, String num2)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num1.length() - <span class="hljs-number">1</span>, j = num2.length() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x + y + carry;<br><br>        sb.append(sum % <span class="hljs-number">10</span>);<br>        carry = sum / <span class="hljs-number">10</span>;<br><br>        i--;<br>        j--;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="203-最小K个数"><a href="#203-最小K个数" class="headerlink" title="203. 最小K个数"></a>203. <a href="https://leetcode.cn/problems/smallest-k-lcci/">最小K个数</a></h1><p>使用大顶堆（PriorityQueue）来筛选数组中最小的 k 个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] smallestK(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k, (l1, l2) -&gt; l2 - l1);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (pq.size() &lt; k) &#123;<br>            pq.offer(num);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; pq.peek()) &#123;<br>            pq.poll();<br>            pq.offer(num);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        res[i++] = pq.poll();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="204-买卖股票的最佳时机-II"><a href="#204-买卖股票的最佳时机-II" class="headerlink" title="204. 买卖股票的最佳时机 II"></a>204. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h1><p>贪心：<strong>只要今天比昨天大，就卖出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;<br>            res += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="205-最大数"><a href="#205-最大数" class="headerlink" title="205. 最大数"></a>205. <a href="https://leetcode.cn/problems/largest-number/description/">最大数</a></h1><p>使用<strong>自定义排序规则</strong>：<code>Arrays.sort(strNums,(a,b)-&gt;(b+a).compareTo(a+b));</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    String[] strNums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[nums.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        strNums[i] = String.valueOf(nums[i]);<br>    &#125;<br><br>    Arrays.sort(strNums, (a, b) -&gt; (b + a).compareTo(a + b));<br>    <span class="hljs-keyword">if</span> (strNums[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;0&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (String str : strNums) &#123;<br>        sb.append(str);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="206-最长公共前缀"><a href="#206-最长公共前缀" class="headerlink" title="206. 最长公共前缀"></a>206. <a href="https://leetcode.cn/problems/longest-common-prefix/description/">最长公共前缀</a></h1><p>用第一个字符串的每个字符，依次与后面所有字符串的相应字符进行比较即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs[<span class="hljs-number">0</span>].length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].charAt(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; strs.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= strs[j].length() || c != strs[j].charAt(i)) &#123;<br>                <span class="hljs-keyword">return</span> sb.toString();<br>            &#125;<br>        &#125;<br>        sb.append(c);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="207-重排链表"><a href="#207-重排链表" class="headerlink" title="207. 重排链表"></a>207. <a href="https://leetcode.cn/problems/reorder-list/">重排链表</a></h1><p><strong>重排链表&#x3D;找链表中点+反转链表+合并链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 找中点</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMid(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> reverse(mid.next);<br>    mid.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 切断前后链表</span><br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        cur.next = l1;<br>        l1 = l1.next;<br>        cur = cur.next;<br><br>        cur.next = l2;<br>        l2 = l2.next;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>)<br>        cur.next = l1; <span class="hljs-comment">// 补上尾巴</span><br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findMid</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>        head.next = cur;<br>        cur = head;<br>        head = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="208-复原-IP-地址"><a href="#208-复原-IP-地址" class="headerlink" title="208. 复原 IP 地址"></a>208. <a href="https://leetcode.cn/problems/restore-ip-addresses/description/">复原 IP 地址</a></h1><p><strong>回溯算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 用于存储 &quot;255&quot; 这种IP段</span><br>List&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;<br>    backtracking(s, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-comment">// 如果已经切了 4 段，并且刚好用完所有字符，说明找到一个合法的 IP</span><br>    <span class="hljs-keyword">if</span> (path.size() == <span class="hljs-number">4</span> &amp;&amp; start == s.length()) &#123;<br>        res.add(String.join(<span class="hljs-string">&quot;.&quot;</span>, path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 start 开始，尝试截取 1~3 位的子串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; s.length() &amp;&amp; i - start &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-comment">// 防止出现 &quot;01&quot; &quot;00&quot; 这种非法格式</span><br>        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; s.charAt(start) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 截取 startIdx 到 i 的子串，转成整数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(start, i + <span class="hljs-number">1</span>));<br>        <br>        <span class="hljs-keyword">if</span> (v &gt;= <span class="hljs-number">0</span> &amp;&amp; v &lt;= <span class="hljs-number">255</span>) &#123;<br>            path.add(s.substring(start, i + <span class="hljs-number">1</span>));<br>            backtracking(s, i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="209-排序数组"><a href="#209-排序数组" class="headerlink" title="209. 排序数组"></a>209. <a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a></h1><p><strong>快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low, j = high;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[(low + high) / <span class="hljs-number">2</span>];  <span class="hljs-comment">// 选取中间值作为基准</span><br><br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] &lt; pivot) i++;<br>        <span class="hljs-keyword">while</span> (nums[j] &gt; pivot) j--;<br>        <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>            swap(nums, i, j);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 递归左右两边</span><br>    quickSort(nums, low, j);<br>    quickSort(nums, i, high);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="210-多线程交替打印ab"><a href="#210-多线程交替打印ab" class="headerlink" title="210. 多线程交替打印ab"></a>210. 多线程交替打印ab</h1><p>使用synchronized和wait()&#x2F;notify()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">printA</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printA</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>          <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>              <span class="hljs-keyword">while</span> (!printA) &#123;<br>                  lock.wait();<br>              &#125;<br>              System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>              printA = <span class="hljs-literal">false</span>;<br>              lock.notify();<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printB</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>          <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>              <span class="hljs-keyword">while</span> (printA) &#123;<br>                  lock.wait();<br>              &#125;<br>              System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br>              printA = <span class="hljs-literal">true</span>;<br>              lock.notify();<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>          <span class="hljs-type">Solution000</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution000</span>();<br><br>          <span class="hljs-type">Thread</span> <span class="hljs-variable">threadA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) sl.printA();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>          &#125;);<br><br>          <span class="hljs-type">Thread</span> <span class="hljs-variable">threadB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) sl.printB();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;<br>          &#125;);<br><br>          threadA.start();<br>          threadB.start();<br>      &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
      <tag>hot100</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL原理学习笔记</title>
    <link href="/2025/04/18/JAVA/mysql/"/>
    <url>/2025/04/18/JAVA/mysql/</url>
    
    <content type="html"><![CDATA[<h1 align="center">MySQL原理学习笔记</h1><h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><h2 id="1-1-事务简介"><a href="#1-1-事务简介" class="headerlink" title="1.1 事务简介"></a>1.1 事务简介</h2><p><strong>事务</strong> 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系<br>统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败</strong></p><p><img src="/img/blogs/java/mysql/1.1.1.png"></p><h2 id="1-2-事务的四大特性"><a href="#1-2-事务的四大特性" class="headerlink" title="1.2 事务的四大特性"></a>1.2 事务的四大特性</h2><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p><strong>ACID</strong></p><h2 id="1-3-并发事务问题"><a href="#1-3-并发事务问题" class="headerlink" title="1.3 并发事务问题"></a>1.3 并发事务问题</h2><p><strong>事务并发问题</strong></p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据。</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现该行数据已经存在，好像出现了“幻影”。</td></tr></tbody></table><p><strong>事务隔离级别</strong></p><table><thead><tr><th>隔离级别</th><th>赃读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>事务隔离级别越高，数据越安全，但是性能越差</li></ul><h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h1><h2 id="2-1-MySQL体系结构"><a href="#2-1-MySQL体系结构" class="headerlink" title="2.1 MySQL体系结构"></a>2.1 MySQL体系结构</h2><p><img src="/img/blogs/java/mysql/2.1.1.png"></p><ol><li><strong>连接层</strong><br>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端&#x2F;服务端工具实现的类似于 TCP&#x2F;IP的通信。主要完成一些类似于<strong>连接处理、授权认证</strong>、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li><strong>服务层</strong><br>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成<strong>缓存的查询</strong>，<strong>SQL的分析和优化</strong>，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</li><li><strong>引擎层</strong><br>存储引擎层， 存储引擎真正的<strong>负责了MySQL中数据的存储和提取</strong>，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</li><li><strong>存储层</strong><br>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询<br>日志、慢查询日志等)<strong>存储在文件系统之上</strong>，并<strong>完成与存储引擎的交互</strong></li></ol><h2 id="2-2-存储引擎介绍"><a href="#2-2-存储引擎介绍" class="headerlink" title="2.2 存储引擎介绍"></a>2.2 存储引擎介绍</h2><p>存储引擎就是<strong>存储数据、建立索引、更新&#x2F;查询数据</strong>等技术的实现方式 。<strong>存储引擎是基于表的</strong>，而不是基于库的，所以存储引擎也可被称为表类型。</p><h2 id="2-3-InnoDB存储引擎特点"><a href="#2-3-InnoDB存储引擎特点" class="headerlink" title="2.3 InnoDB存储引擎特点"></a>2.3 InnoDB存储引擎特点</h2><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p><strong>特点</strong></p><ul><li>DML操作遵循ACID模型，<strong>支持事务</strong>；能<strong>保证事务安全</strong></li><li><strong>行级锁</strong>，提高并发访问性能；</li><li><strong>支持外键</strong>FOREIGN KEY约束，<strong>保证数据的完整性和正确性</strong>；</li></ul><p><strong>文件</strong></p><ul><li><code>xxx.ibd</code>：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结<br>构（frm-早期的 、sdi-新版的）、数据和索引</li></ul><p><strong>逻辑存储结构:</strong></p><p><img src="/img/blogs/java/mysql/2.3.1.png"></p><p>InnoDB引擎与MyISAM引擎的区别 ?</p><ul><li>InnoDB引擎, <strong>支持事务</strong>, 而MyISAM不支持。</li><li>InnoDB引擎, <strong>支持行锁和表锁</strong>, 而MyISAM仅支持表锁, 不支持行锁。</li><li>InnoDB引擎, <strong>支持外键</strong>, 而MyISAM是不支持的</li></ul><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><h2 id="3-1-索引概述"><a href="#3-1-索引概述" class="headerlink" title="3.1 索引概述"></a>3.1 索引概述</h2><p>索引（index）是帮助MySQL<strong>高效获取数据的数据结构</strong>(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li>无索引的情况：全表扫描</li><li>有索引：根据索引依次查询，提高效率</li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>优势</strong></td><td>提高数据检索的效率，降低数据库的IO成本。</td></tr><tr><td></td><td>通过索引对数据进行排序，降低数据排序的成本，减少CPU的消耗。</td></tr><tr><td><strong>劣势</strong></td><td>索引列会占用额外的存储空间。</td></tr><tr><td></td><td>虽然索引提高了查询效率，但会降低更新表的速度（如INSERT、UPDATE、DELETE操作）。</td></tr></tbody></table><h2 id="3-2-索引结构"><a href="#3-2-索引结构" class="headerlink" title="3.2 索引结构"></a>3.2 索引结构</h2><h3 id="3-2-1-有哪些索引结构"><a href="#3-2-1-有哪些索引结构" class="headerlink" title="3.2.1 有哪些索引结构"></a>3.2.1 有哪些索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引。</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询。</td></tr><tr><td>Full-text(全文索引)</td><td>通过建立倒排索引快速匹配文档的方式。类似于ES。</td></tr></tbody></table><h3 id="3-2-2-二叉树"><a href="#3-2-2-二叉树" class="headerlink" title="3.2.2 二叉树"></a>3.2.2 二叉树</h3><p><img src="/img/blogs/java/mysql/3.2.1.png"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会<strong>形成一个链表</strong>，查询性能大大降低。 </li><li>大数据量情况下，<strong>层级较深</strong>，检索速度慢。</li></ul><p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树</p><ul><li>即使如此，由于红黑树也是一颗<strong>二叉树</strong>，也会存在一个缺点：大数据量情况下，<strong>层级较深</strong>，检索速度慢</li></ul><h3 id="3-2-3-B树"><a href="#3-2-3-B树" class="headerlink" title="3.2.3 B树"></a>3.2.3 B树</h3><p>B树是一种多叉路平衡查找树，相对于二叉树，<strong>B树每个节点可以有多个分支</strong>，即多叉</p><h3 id="3-2-4-B-树"><a href="#3-2-4-B-树" class="headerlink" title="3.2.4 B+树"></a>3.2.4 B+树</h3><p>B+Tree 与 B-Tree相比，主要有以下三点区别：</p><ul><li>所有的<strong>数据都会出现在叶子节点</strong>。 </li><li>叶子节点形成一个单向链表。</li><li><strong>非叶子节点仅仅起到索引数据作用</strong>，具体的数据都是在叶子节点存放的</li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，<strong>增加一个指向相邻叶子节点的链表指针</strong>，<strong>形成双向链表，便于范围查询</strong>，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序</p><p><img src="/img/blogs/java/mysql/3.2.2.png"></p><h3 id="3-2-5-Hash"><a href="#3-2-5-Hash" class="headerlink" title="3.2.5 Hash"></a>3.2.5 Hash</h3><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中<br>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了<strong>hash冲突</strong>（也称为hash碰撞），可以通过链表来解决</p><p><img src="/img/blogs/java/mysql/3.2.3.png"></p><ul><li>Hash索引只能用于<strong>对等比较</strong>(&#x3D;，in)，<strong>不支持范围查询</strong>（between，&gt;，&lt; ，…）</li><li>无法利用索引完成<strong>排序</strong>操作</li><li>查询效率高，通常(不<strong>存在hash冲突</strong>的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</li></ul><h3 id="3-2-6-思考题"><a href="#3-2-6-思考题" class="headerlink" title="3.2.6 思考题"></a>3.2.6 思考题</h3><p>为什么InnoDB存储引擎选择使用B+tree索引结构?</p><ul><li>相对于<strong>二叉树</strong>，<strong>层级更少</strong>，搜索效率高；</li><li>对于<strong>B树</strong>，无论是<strong>叶子节点还是非叶子节点，都会保存数据</strong>，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li><li>相对<strong>Hash</strong>索引，B+tree<strong>支持范围匹配及排序操作</strong></li></ul><h2 id="3-3-索引分类"><a href="#3-3-索引分类" class="headerlink" title="3.3 索引分类"></a>3.3 索引分类</h2><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td><strong>主键索引</strong></td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td><strong>唯一索引</strong></td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td><strong>常规索引</strong></td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td><strong>全文索引</strong></td><td>查找文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：聚集索引&amp;二级索引</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td><strong>聚集索引</strong>(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td><strong>二级索引</strong>(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><p><img src="/img/blogs/java/mysql/3.3.1.png"></p><ul><li>聚集索引的叶子节点下挂的是这一行的数据 。</li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li><li><strong>回表查询</strong>： 这种<strong>先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值</strong>，获取数据的方式，就称之为回表查询。</li></ul><h2 id="3-4-SQL性能分析工具"><a href="#3-4-SQL性能分析工具" class="headerlink" title="3.4 SQL性能分析工具"></a>3.4 SQL性能分析工具</h2><h3 id="3-4-1-SQL执行频率"><a href="#3-4-1-SQL执行频率" class="headerlink" title="3.4.1 SQL执行频率"></a>3.4.1 SQL执行频率</h3><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信息。通过如下指令，可以<strong>查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</strong></p><p>通过上述指令，我们可以<strong>查看到当前数据库到底是以查询为主，还是以增删改为主</strong>，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 <strong>如果是以查询为主，那么就要考虑对数据库的索引进行优化了</strong></p><h3 id="3-4-2-慢查询日志"><a href="#3-4-2-慢查询日志" class="headerlink" title="3.4.2 慢查询日志"></a>3.4.2 慢查询日志</h3><p>慢查询日志<strong>记录了所有执行时间超过指定参数</strong>（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志</p><p>通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><h3 id="3-4-3-profile详情"><a href="#3-4-3-profile详情" class="headerlink" title="3.4.3 profile详情"></a>3.4.3 profile详情</h3><p><code>show profiles</code> 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了</p><h3 id="3-4-4-explain"><a href="#3-4-4-explain" class="headerlink" title="3.4.4 explain"></a>3.4.4 explain</h3><p><strong>EXPLAIN</strong> 或者 DESC命令获取 MySQL <strong>如何执行 SELECT 语句的信息</strong>，包括在 SELECT 语句执行<br>过程中<strong>表如何连接和连接的顺序</strong></p><p><img src="/img/blogs/java/mysql/3.4.1.png"></p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中<strong>执行select子句或操作表的顺序</strong>（id相同，执行顺序从上到下；id不同，值越大越先执行）。</td></tr><tr><td>select_type</td><td>表示<strong>SELECT类型</strong>，常见取值：<br>• SIMPLE（简单表，不使用表连接或子查询）<br>• PRIMARY（主查询，外层查询）<br>• UNION（UNION中第二个或后面的查询语句）<br>• SUBQUERY（SELECT&#x2F;WHERE后的子查询）</td></tr><tr><td>type</td><td>表示<strong>连接类型</strong>，性能由好到差为：NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</td></tr><tr><td>possible_keys</td><td>显示<strong>可能用到的索引</strong>，可能应用在这张表上的索引（一个或多个）。</td></tr><tr><td>key</td><td><strong>实际使用的索引</strong>，NULL表示未使用索引。</td></tr><tr><td>key_len</td><td>索引使用的字节数（最大可能长度，非实际长度），在保证精确性前提下越短越好。</td></tr><tr><td>rows</td><td>MySQL认为必须执行查询的行数（InnoDB引擎中是估计值，可能不准确）。</td></tr><tr><td>filtered</td><td>返回结果行数占需读取行数的百分比，值越大越好。</td></tr></tbody></table><h2 id="3-5-索引使用"><a href="#3-5-索引使用" class="headerlink" title="3.5 索引使用"></a>3.5 索引使用</h2><h3 id="3-5-1-最左前缀法则"><a href="#3-5-1-最左前缀法则" class="headerlink" title="3.5.1 最左前缀法则"></a>3.5.1 最左前缀法则</h3><p>联合索引：这个索引就叫联合索引，它包含了age和sex两个字段<br><code>CREATE INDEX idx_user_age_sex ON users (age, sex);</code></p><p>如果索引了多列（<strong>联合索引</strong>），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(<strong>后面的字段索引失效</strong>)</p><ul><li>对于最左前缀法则指的是，查询时，<strong>最左边的列必须存在，否则索引全部失效</strong>。 </li><li>而且中间不能跳过某一列，否则<strong>该列后面的字段索引将失效</strong></li></ul><p>联合索引中，<strong>出现范围查询</strong>(&gt;,&lt;)，<strong>范围查询右侧的列索引失效</strong></p><ul><li>当范围查询使用&gt;&#x3D; 或 &lt;&#x3D; 时，走联合索引了</li><li>所以，在业务允许的情况下，尽可能的使用类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类的范围查询，而避免使用 &gt; 或 &lt;</li></ul><h3 id="3-5-2-索引失效情况"><a href="#3-5-2-索引失效情况" class="headerlink" title="3.5.2 索引失效情况"></a>3.5.2 索引失效情况</h3><ol><li>索引列运算<ul><li><strong>不要在索引列上进行运算操作， 索引将失效</strong>。</li></ul></li><li>字符串不加引号<ul><li>字符串类型字段使用时，<strong>不加引号，索引将失效</strong></li></ul></li><li>模糊查询<ul><li>如果仅仅是尾部模糊匹配，索引不会失效。如果是<strong>头部模糊匹配，索引失效</strong>, <code>%工程</code></li></ul></li><li>or连接条件<ul><li>用or分割开的条件， <strong>如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</strong></li></ul></li><li>如果MySQL评估使用<strong>索引比全表更慢，则不使用索引</strong></li></ol><h3 id="3-5-3-覆盖索引"><a href="#3-5-3-覆盖索引" class="headerlink" title="3.5.3 覆盖索引"></a>3.5.3 覆盖索引</h3><p>覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到</p><ul><li>尽量使用覆盖索引，减少select *。</li></ul><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对<br>以下SQL语句进行优化, 该如何进行才是最优方案:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,username,password <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;itcast&#x27;</span>;<br></code></pre></td></tr></table></figure><p>答案: 针对于 <strong>username, password建立联合索引</strong>, sql为: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_user_name_pass <span class="hljs-keyword">on</span> tb_user(username,password); <br></code></pre></td></tr></table></figure><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。<strong>避免回表查询</strong></p><h3 id="3-5-4-前缀索引"><a href="#3-5-4-前缀索引" class="headerlink" title="3.5.4 前缀索引"></a>3.5.4 前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要<strong>索引很长的字符串</strong>，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以<strong>只将字符串的一部分前缀，建立索引</strong>，这样可以大大节约索引空间，从而提高索引效率</p><p><strong>前缀长度如何确定？</strong></p><ul><li>可以根据索引的选择性来决定，而选择性是指<strong>不重复的索引值（基数）和数据表的记录总数的比值</strong>，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的</li></ul><h3 id="3-5-5-单列索引与联合索引"><a href="#3-5-5-单列索引与联合索引" class="headerlink" title="3.5.5 单列索引与联合索引"></a>3.5.5 单列索引与联合索引</h3><ul><li>单列索引：即一个索引只包含单个列。</li><li>联合索引：即一个索引包含了多个列</li></ul><p>在业务场景中，<strong>如果存在多个查询条件</strong>，考虑<strong>针对于查询字段建立索引时，建议建立联合索引</strong>，而非单列索引</p><h2 id="3-6-索引设计原则"><a href="#3-6-索引设计原则" class="headerlink" title="3.6 索引设计原则"></a>3.6 索引设计原则</h2><ol><li>针对于<strong>数据量较大，且查询比较频繁的表</strong>建立索引。</li><li>针对于<strong>常作为查询条件</strong>（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择<strong>区分度高的列</strong>作为索引，尽量<strong>建立唯一索引</strong>，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，<strong>字段的长度较长</strong>，可以针对于字段的特点，<strong>建立前缀索引</strong>。</li><li><strong>尽量使用联合索引，减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含<br>NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h1 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h1><h2 id="4-1-锁的概述"><a href="#4-1-锁的概述" class="headerlink" title="4.1 锁的概述"></a>4.1 锁的概述</h2><p>锁是计算机协调<strong>多个进程或线程并发访问某一资源的机制</strong>。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li><strong>全局锁</strong>：锁定数据库中的<strong>所有表</strong>。</li><li><strong>表级锁</strong>：每次操作锁住<strong>整张表</strong>。</li><li><strong>行级锁</strong>：每次操作锁住对应的<strong>行数据</strong></li></ul><h2 id="4-2-全局锁"><a href="#4-2-全局锁" class="headerlink" title="4.2 全局锁"></a>4.2 全局锁</h2><h3 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h3><p>全局锁就是<strong>对整个数据库实例加锁</strong>，加锁后整个实例就处于<strong>只读状态</strong>，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><ul><li>其典型的使用场景是做<strong>全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</li></ul><p><img src="/img/blogs/java/mysql/4.2.1.png"></p><h3 id="4-2-2-特点"><a href="#4-2-2-特点" class="headerlink" title="4.2.2 特点"></a>4.2.2 特点</h3><ul><li>数据库中加全局锁，是一个比较重的操作，存在以下问题：<ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul></li></ul><h2 id="4-3-表级锁"><a href="#4-3-表级锁" class="headerlink" title="4.3 表级锁"></a>4.3 表级锁</h2><h3 id="4-3-1-介绍"><a href="#4-3-1-介绍" class="headerlink" title="4.3.1 介绍"></a>4.3.1 介绍</h3><p>表级锁，每次操作<strong>锁住整张表</strong>。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAMInnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><strong>表锁</strong></li><li><strong>元数据锁</strong>（meta data lock，MDL）</li><li><strong>意向锁</strong></li></ul><h3 id="4-3-2-表锁"><a href="#4-3-2-表锁" class="headerlink" title="4.3.2 表锁"></a>4.3.2 表锁</h3><p>对于表锁，分为两类：</p><ol><li>表共享<strong>读锁</strong>（read lock）</li><li>表独占<strong>写锁</strong>（write lock）</li></ol><p>语法：<br>加锁：lock tables 表名… read&#x2F;write。<br>释放锁：unlock tables &#x2F; 客户端断开连接</p><p><img src="/img/blogs/java/mysql/4.3.1.png"></p><ul><li><strong>读锁不会阻塞其他客户端的读，但是会阻塞写。</strong></li><li><strong>写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写</strong></li></ul><h3 id="4-3-3-元数据锁"><a href="#4-3-3-元数据锁" class="headerlink" title="4.3.3 元数据锁"></a>4.3.3 元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。 </p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，<strong>在表上有活动事务的时候，不可以对元数据进行写入操作</strong>。为了<strong>避免DML与DDL冲突</strong>，保证读写的正确性。</p><p>这里的<strong>元数据</strong>，大家可以简单理解为<strong>就是一张表的表结构</strong>。 也就是说，<strong>某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</strong></p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)</p><h3 id="4-3-4-意向锁"><a href="#4-3-4-意向锁" class="headerlink" title="4.3.4 意向锁"></a>4.3.4 意向锁</h3><p>为了<strong>避免DML在执行时，加的行锁与表锁的冲突</strong>，在InnoDB中引入了意向锁，<strong>使得表锁不用检查每行数据是否加锁</strong>，使用意向锁来减少表锁的检查</p><p>有了意向锁之后 :</p><ol><li>客户端一，在执行DML操作时，会对涉及的行<strong>加行锁</strong>，同时也会对该表<strong>加上意向锁</strong></li><li>而其他客户端，在对这张表<strong>加表锁</strong>的时候，<strong>会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</strong></li></ol><h2 id="4-4-行级锁"><a href="#4-4-行级锁" class="headerlink" title="4.4 行级锁"></a>4.4 行级锁</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>行级锁，每次操作<strong>锁住对应的行数据</strong>。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li><strong>行锁</strong>（Record Lock）：<strong>锁定单个行记录的锁</strong>，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li><strong>间隙锁</strong>（Gap Lock）：<strong>锁定索引记录间隙</strong>（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li><strong>临键锁</strong>（Next-Key Lock）：<strong>行锁和间隙锁组合</strong>，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ul><h3 id="4-4-2-行锁"><a href="#4-4-2-行锁" class="headerlink" title="4.4.2 行锁"></a>4.4.2 行锁</h3><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><strong>共享锁</strong>（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li><strong>排他锁</strong>（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ul><p><strong>两种行锁的兼容情况如下：</strong></p><table><thead><tr><th>当前锁类型\请求锁类型</th><th>S（共享锁）</th><th>X（排他锁）</th></tr></thead><tbody><tr><td>S（共享锁）</td><td>兼容</td><td>冲突</td></tr><tr><td>X（排他锁）</td><td>冲突</td><td>冲突</td></tr></tbody></table><p><strong>常见的SQL语句，在执行时，所加的行锁如下</strong>：</p><table><thead><tr><th>SQL 语句</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>无锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在 SELECT 之后加 LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在 SELECT 之后加 FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会<strong>自动优化为行锁</strong>。</li><li>InnoDB的行锁是针对于索引加的锁，<strong>不通过索引条件检索数据</strong>，那么InnoDB<strong>将对表中的所有记录加锁，此时就会升级为表锁</strong></li></ul><h3 id="4-4-3-间隙锁-临键锁"><a href="#4-4-3-间隙锁-临键锁" class="headerlink" title="4.4.3 间隙锁&amp;临键锁"></a>4.4.3 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，<strong>给不存在的记录加锁时, 优化为间隙锁</strong> </li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p>注意：<strong>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁</strong></p><h1 id="5-InnoDB引擎"><a href="#5-InnoDB引擎" class="headerlink" title="5. InnoDB引擎"></a>5. InnoDB引擎</h1><h2 id="5-1-逻辑存储结构"><a href="#5-1-逻辑存储结构" class="headerlink" title="5.1 逻辑存储结构"></a>5.1 逻辑存储结构</h2><p><img src="/img/blogs/java/mysql/2.3.1.png"></p><p><img src="/img/blogs/java/mysql/5.1.1.png"></p><ol><li><strong>表空间</strong><ul><li>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</li></ul></li><li><strong>段</strong><ul><li>段，分为<strong>数据段</strong>（Leaf node segment）、<strong>索引段</strong>（Non-leaf node segment）、<strong>回滚段</strong>（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</li></ul></li><li><strong>区</strong><ul><li>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li></ul></li><li><strong>页</strong><ul><li>页，<strong>是InnoDB 存储引擎磁盘管理的最小单元</strong>，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li></ul></li><li><strong>行</strong><ul><li>行，InnoDB <strong>存储引擎数据是按行进行存放的</strong></li><li>在行中，默认有两个隐藏字段： <ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的<strong>事务id</strong>赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列<strong>就相当于一个指针</strong>，可以通过它来找到该记录修改前的信息。</li></ul></li></ul></li></ol><h2 id="5-2-架构"><a href="#5-2-架构" class="headerlink" title="5.2 架构"></a>5.2 架构</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发<br>中使用非常广泛。下面是InnoDB架构图，<strong>左侧为内存结构，右侧为磁盘结构</strong>。</p><p><img src="/img/blogs/java/mysql/5.2.1.png"></p><h3 id="5-2-2-内存结构"><a href="#5-2-2-内存结构" class="headerlink" title="5.2.2 内存结构"></a>5.2.2 内存结构</h3><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p><h4 id="Buffer-Pool-缓冲区"><a href="#Buffer-Pool-缓冲区" class="headerlink" title="Buffer Pool 缓冲区"></a>Buffer Pool 缓冲区</h4><p>InnoDB存储引擎基于磁盘文件存储，<strong>访问物理硬盘和在内存中进行访问，速度相差很大</strong>，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要<strong>把经常使用的数据加载到缓冲池中</strong>，避免每次访问都进行磁盘I&#x2F;O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓<strong>存磁盘上经常操作的真实数据</strong>，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而<strong>减少磁盘IO，加快处理速度</strong>。</p><p>缓冲池以<strong>Page页为单位</strong>，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li></ul><h4 id="Change-Buffer-更改缓冲区"><a href="#Change-Buffer-更改缓冲区" class="headerlink" title="Change Buffer 更改缓冲区"></a>Change Buffer 更改缓冲区</h4><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p><strong>Change Buffer的意义是什么呢?</strong><br>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。<strong>有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO</strong></p><h4 id="Adaptive-Hash-Index自适应哈希索引"><a href="#Adaptive-Hash-Index自适应哈希索引" class="headerlink" title="Adaptive Hash Index自适应哈希索引"></a>Adaptive Hash Index自适应哈希索引</h4><p>自适应hash<strong>索引，用于优化对Buffer Pool数据的查询</strong>。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><h4 id="Log-Buffer日志缓冲区"><a href="#Log-Buffer日志缓冲区" class="headerlink" title="Log Buffer日志缓冲区"></a>Log Buffer日志缓冲区</h4><p>Log Buffer：日志缓冲区，用来<strong>保存要写入到磁盘中的log日志数据</strong>（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，<strong>增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</strong></p><h3 id="5-2-3-磁盘结构"><a href="#5-2-3-磁盘结构" class="headerlink" title="5.2.3 磁盘结构"></a>5.2.3 磁盘结构</h3><p>再来看看InnoDB体系结构的右边部分，也就是磁盘结构</p><h4 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h4><p><strong>系统表空间是更改缓冲区的存储区域</strong>。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><h4 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h4><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中</p><h4 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h4><p><strong>通用表空间</strong>，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><h4 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h4><p><strong>撤销表空间</strong>，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存undo log日志。</p><h4 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h4><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><h4 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h4><p><strong>双写缓冲区</strong>，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</p><h4 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h4><p><strong>重做日志</strong>，是<strong>用来实现事务的持久性</strong>。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用</p><h3 id="5-2-4-后台线程"><a href="#5-2-4-后台线程" class="headerlink" title="5.2.4 后台线程"></a>5.2.4 后台线程</h3><p>后台线程的作用是<strong>将缓冲区的数据写入到磁盘文件中的线程</strong></p><p><img src="/img/blogs/java/mysql/5.2.1.png"></p><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread</p><ol><li>Master Thread<br><strong>核心后台线程，负责调度其他线程</strong>，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。</li><li>IO Thread<br>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而<strong>IO Thread主要负责这些IO请求的回调</strong>。</li><li>Purge Thread<br>主要用于<strong>回收事务已经提交了的undo log</strong>，在事务提交之后，undo log可能不用了，就用它来回收。</li><li>Page Cleaner Thread<br><strong>协助 Master Thread 刷新脏页到磁盘的线程</strong>，它可以减轻 Master Thread 的工作压力，减少阻塞</li></ol><h2 id="5-3-事务原理"><a href="#5-3-事务原理" class="headerlink" title="5.3 事务原理"></a>5.3 事务原理</h2><h3 id="5-3-1-事务基础"><a href="#5-3-1-事务基础" class="headerlink" title="5.3.1 事务基础"></a>5.3.1 事务基础</h3><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><p><strong>ACID</strong></p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环<br>境下运行。<br>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p><img src="/img/blogs/java/mysql/5.3.1.png"></p><h3 id="5-3-2-redo-log"><a href="#5-3-2-redo-log" class="headerlink" title="5.3.2 redo log"></a>5.3.2 redo log</h3><p><img src="/img/blogs/java/mysql/5.3.2.png"></p><p><strong>重做日志</strong>，<strong>记录的是事务提交时数据页的物理修改</strong>，是<strong>用来实现事务的持久性</strong>。</p><p>该日志文件由两部分组成：<strong>重做日志缓冲</strong>（redo log buffer）以及<strong>重做日志文件</strong>（redo log file）,<strong>前者是在内存中，后者在磁盘中</strong>。<strong>当事务提交之后会把所有修改信息都存到该日志文件中</strong>, 用于在<strong>刷新脏页到磁盘,发生错误时, 进行数据恢复使用</strong></p><h3 id="5-3-3-undo-log"><a href="#5-3-3-undo-log" class="headerlink" title="5.3.3 undo log"></a>5.3.3 undo log</h3><p><strong>回滚日志</strong>，<strong>用于记录数据被修改前的信息</strong> , 作用包含两个 : <strong>提供回滚</strong>(保证事务的原子性) 和 <strong>MVCC</strong>(多版本并发控制) </p><p><strong>undo log和redo log记录物理日志不一样，它是逻辑日志</strong>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以<strong>从undo log中的逻辑记录读取到相应的内容并进行回滚</strong>。</p><ul><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并<strong>不会立即删除undo log</strong>，因为这些日志可能还用于MVCC。</li><li>Undo log存储：undo log采用段的方式进行管理和记录</li></ul><h2 id="5-4-MVCC"><a href="#5-4-MVCC" class="headerlink" title="5.4 MVCC"></a>5.4 MVCC</h2><h3 id="5-4-1-基本概念"><a href="#5-4-1-基本概念" class="headerlink" title="5.4.1 基本概念"></a>5.4.1 基本概念</h3><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p><strong>读取的是记录的最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p><strong>简单的select（不加锁）就是快照读</strong>，<strong>快照读，读取的是记录数据的可见版本</strong>，有可能是<strong>历史数据</strong>，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读</li></ul><p>在当前默认的RR隔离级别下，<strong>开启事务后第一个select语句才是快照读的地方</strong>，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就<strong>保证了可重复读</strong></p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>全称 Multi-Version Concurrency Control，<strong>多版本并发控制</strong>。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView</p><h3 id="5-4-2-隐藏字段"><a href="#5-4-2-隐藏字段" class="headerlink" title="5.4.2 隐藏字段"></a>5.4.2 隐藏字段</h3><p><img src="/img/blogs/java/mysql/5.4.1.png"></p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td><strong>最近修改事务ID</strong>，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td><strong>回滚指针</strong>，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td></tr><tr><td>DB_ROW_ID</td><td><strong>隐藏主键</strong>，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h3 id="5-4-3-undo-log"><a href="#5-4-3-undo-log" class="headerlink" title="5.4.3 undo log"></a>5.4.3 undo log</h3><p><strong>回滚日志</strong>，在insert、update、delete的时候产生的<strong>便于数据回滚的日志</strong>。</p><ul><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li><li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除</li></ul><p><img src="/img/blogs/java/mysql/5.4.2.png"></p><p><strong>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</strong></p><h3 id="5-4-4-readview"><a href="#5-4-4-readview" class="headerlink" title="5.4.4 readview"></a>5.4.4 readview</h3><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，<strong>记录并维护系统当前活跃的事务</strong>（未提交的）id</p><p>包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td><strong>最小活跃</strong>事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID（当前<strong>最大事务ID+1</strong>）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p><img src="/img/blogs/java/mysql/5.4.3.png"></p><p>具体判断逻辑大致是：</p><ul><li>如果行的trx_id &lt; min_trx_id，说明这个版本在当前事务开始前就提交了 → 可见 ✅。</li><li>如果行的trx_id在活跃事务列表中，说明这个版本是未提交的 → 不可见 ❌。</li><li>如果行的trx_id &gt; max_trx_id，说明这个版本来自未来事务 → 不可见 ❌。</li></ul><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，<strong>后续复用该ReadView</strong>，<strong>从而保证可重复读</strong></li></ul><h3 id="5-4-5-原理分析"><a href="#5-4-5-原理分析" class="headerlink" title="5.4.5 原理分析"></a>5.4.5 原理分析</h3><p>在MVCC（多版本并发控制）中，ReadView 主要的作用是：<br><strong>确定当前事务在可重复读快照下，应该“看到”哪些行版本。避免读到其他事务未提交或刚提交的数据。</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">事务开始 → 创建ReadView  <br>|<span class="hljs-string"></span><br><span class="hljs-string"></span>|<span class="hljs-string">→ 查询时，遍历记录版本链</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<br>|<span class="hljs-string">   </span>|<span class="hljs-string">→ 判断版本trx_id是否符合ReadView</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<br>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">→ 不符合，继续沿 undo log 向前找版本</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   </span>|<span class="hljs-string">→ 符合，返回数据</span><br><span class="hljs-string"></span>|<br>事务提交 → 不需要更新ReadView<br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/mysql/5.4.4.png"></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="/2025/04/12/JAVA/JVM/"/>
    <url>/2025/04/12/JAVA/JVM/</url>
    
    <content type="html"><![CDATA[<h1 align="center">JVM学习笔记</h1><h1 id="〇-什么是JVM"><a href="#〇-什么是JVM" class="headerlink" title="〇. 什么是JVM"></a>〇. 什么是JVM</h1><ol><li><p>定义<br>Java Virtual Machine ，Java 程序的运行环境（Java 二进制字节码的运行环境）。</p></li><li><p>好处</p><ul><li>一次编译，处处执行</li><li>自动的内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul></li><li><p>JVM、JRE、JDK 的关系</p></li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.0.1.png"></p><ol start="4"><li>JVM的执行流程</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.0.2.png"></p><h1 id="一-内存结构"><a href="#一-内存结构" class="headerlink" title="一. 内存结构"></a>一. 内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>Program Counter Register 程序计数器（寄存器）</p><ol><li>作用：记录下一条 jvm 指令的执行地址。</li><li>特点：<ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul></li></ol><h2 id="2-虚拟机栈-JVM-Stacks"><a href="#2-虚拟机栈-JVM-Stacks" class="headerlink" title="2. 虚拟机栈(JVM Stacks)"></a>2. 虚拟机栈(JVM Stacks)</h2><ul><li>栈：线程运行需要的内存空间</li><li>栈帧：每个方法运行时需要的内存，包括参数、局部变量和返回地址</li><li>每个栈由多个栈帧组成，对应着每次调用方法时所占用的内存</li></ul><h3 id="2-1-问题分析"><a href="#2-1-问题分析" class="headerlink" title="2.1 问题分析"></a>2.1 问题分析</h3><ol><li>垃圾回收是否涉及栈内存？<br> 不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</li><li>栈内存分配越大越好吗？<br> 不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是<strong>可执行的线程数就会越少</strong>。</li><li>方法内的局部变量是否线程安全？<ul><li><strong>共享的变量static</strong>需要考虑线程安全</li><li><strong>私有的变量是线程安全的</strong></li><li>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</li></ul></li></ol><h3 id="2-2-栈内存溢出-java-lang-stackOverflowError"><a href="#2-2-栈内存溢出-java-lang-stackOverflowError" class="headerlink" title="2.2 栈内存溢出(java.lang.stackOverflowError)"></a>2.2 栈内存溢出(java.lang.stackOverflowError)</h3><ol><li>栈帧过多导致栈内存溢出：<strong>无限递归调用</strong></li><li>栈帧过大导致栈内存溢出</li></ol><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>有些时候JAVA代码不能与操作系统直接进行操作，就需要一些C&#x2F;C++代码进行操作，这些C&#x2F;C++代码就是本地方法，存储在本地方法栈</p><h2 id="4-堆-Heap"><a href="#4-堆-Heap" class="headerlink" title="4. 堆(Heap)"></a>4. 堆(Heap)</h2><ul><li><p>通过<strong>new关键字创建</strong>的对象都会被放在堆内存</p></li><li><p>特点</p><ul><li>它是线程共享，堆内存中的对象<strong>都需要考虑线程安全</strong>问题</li><li>有垃圾回收机制</li></ul></li></ul><h3 id="4-1-堆内存溢出-java-lang-OutofMemoryError"><a href="#4-1-堆内存溢出-java-lang-OutofMemoryError" class="headerlink" title="4.1 堆内存溢出(java.lang.OutofMemoryError)"></a>4.1 堆内存溢出(java.lang.OutofMemoryError)</h3><p>源源不断产生对象，并且对象一直在被使用，导致无法被回收，从而导致堆内存溢出</p><h3 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h3><ol><li>jps 工具<br> 查看当前系统中有哪些 java 进程</li><li>jmap 工具<br> 查看堆内存占用情况 <code>jmap - heap 进程id</code></li><li>jconsole 工具<br> 图形界面的，多功能的监测工具，可以连续监测</li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-方法区的定义"><a href="#5-1-方法区的定义" class="headerlink" title="5.1 方法区的定义"></a>5.1 方法区的定义</h3><ul><li><strong>存储每个类的结构</strong>，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法</li><li>用于类和实例初始化以及接口初始化方法区域是<strong>在虚拟机启动时创建的</strong></li><li>方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它</li><li>方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.1.1.png"></p><h3 id="5-2-方法区内存溢出"><a href="#5-2-方法区内存溢出" class="headerlink" title="5.2 方法区内存溢出"></a>5.2 方法区内存溢出</h3><ul><li>1.8 之前会导致永久代内存溢出</li><li>1.8 之后会导致元空间内存溢出</li></ul><h3 id="5-3-运行时常量池"><a href="#5-3-运行时常量池" class="headerlink" title="5.3 运行时常量池"></a>5.3 运行时常量池</h3><ul><li>二进制字节码包含：（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）</li><li>常量池：就是一张<strong>常量表</strong>，虚拟机<strong>指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</strong></li><li>运行时常量池：<br>  常量池是 <em>.class 文件中的，当该类被加载以后，它的*<em>常量池信息就会被加载成运行时常量池</em></em>，并把里面的符号地址变为真实地址</li></ul><ol><li>常量池表中的地址可能对应着一个类名、方法名、参数类型等信息：</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.1.2.png"></p><ol start="2"><li>类方法的每条指令都会对应常量池表中一个地址：</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.1.3.png"></p><h3 id="5-4-StringTable-字符串常量池，串池"><a href="#5-4-StringTable-字符串常量池，串池" class="headerlink" title="5.4 StringTable(字符串常量池，串池)"></a>5.4 StringTable(字符串常量池，串池)</h3><h4 id="5-4-1-常量池和串池的关系"><a href="#5-4-1-常量池和串池的关系" class="headerlink" title="5.4.1 常量池和串池的关系"></a>5.4.1 常量池和串池的关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable[&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;] Hashtable 结构,不能扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">//常量池中的信息,都会被加载到运行时常量池中,这时a b ab 都是常量池中的符号,还没有变为java 字符串对象</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为“a”字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为“b&quot;字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为“ab&quot;字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-2-StringTable的特性"><a href="#5-4-2-StringTable的特性" class="headerlink" title="5.4.2 StringTable的特性"></a>5.4.2 StringTable的特性</h4><ul><li>常量池中的字符串<strong>仅是符号</strong>，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是StringBuilder</li><li>字符串<strong>常量</strong>拼接的原理是编译器优化</li><li>可以使用intern方法，主动<strong>将串池中还没有的字符串对象放入串池中</strong></li><li>new出来的放在堆里；直接赋值的放在串池里，虽然串池也在堆里，但是地址不同</li></ul><h4 id="5-4-3-intern-方法"><a href="#5-4-3-intern-方法" class="headerlink" title="5.4.3 intern()方法"></a>5.4.3 intern()方法</h4><p>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 &quot;ab&quot; ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 &quot;ab&quot; 是同一个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br><span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 &quot;ab&quot; ，则直接将串池中的内容返回</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 因为堆内存与串池中的 &quot;ab&quot; 是同一个对象，所以以下两条语句打印的都为 true</span><br>System.out.println(str == st2);<br>System.out.println(str == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 此处创建字符串对象 &quot;ab&quot; ，因为串池中还没有 &quot;ab&quot; ，所以将其放入串池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-comment">// &quot;a&quot; &quot;b&quot; 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，&quot;ab&quot; 已存在与串池中，所以放入失败，但是会返回串池中的 &quot;ab&quot; </span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>        <span class="hljs-comment">// false</span><br>System.out.println(str == str2);<br>        <span class="hljs-comment">// false</span><br>System.out.println(str == str3);<br>        <span class="hljs-comment">// true</span><br>System.out.println(str2 == str3);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</li></ul><h4 id="5-4-4-StringTable位置"><a href="#5-4-4-StringTable位置" class="headerlink" title="5.4.4 StringTable位置"></a>5.4.4 StringTable位置</h4><p>jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在<strong>堆中</strong>。</p><h4 id="5-4-5-StringTable垃圾回收"><a href="#5-4-5-StringTable垃圾回收" class="headerlink" title="5.4.5 StringTable垃圾回收"></a>5.4.5 StringTable垃圾回收</h4><p>如果内存不够了，StringTable会把无用的数据进行垃圾回收</p><h4 id="5-4-6-StringTable性能调优"><a href="#5-4-6-StringTable性能调优" class="headerlink" title="5.4.6 StringTable性能调优"></a>5.4.6 StringTable性能调优</h4><ul><li>因为StringTable是由<strong>HashTable实现</strong>的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</li><li><strong>当重复的字符串过多时</strong>，需要考虑是否需要将字符串对象入池：可以通过 <strong>intern</strong>方法减少重复入池</li></ul><h2 id="6-直接内存-操作系统的内存"><a href="#6-直接内存-操作系统的内存" class="headerlink" title="6. 直接内存(操作系统的内存)"></a>6. 直接内存(操作系统的内存)</h2><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><h3 id="6-1-使用直接内存的好处"><a href="#6-1-使用直接内存的好处" class="headerlink" title="6.1 使用直接内存的好处"></a>6.1 使用直接内存的好处</h3><p>直接内存是<strong>操作系统和 Java 代码都可以访问</strong>的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率:</p><p><img src="/img/blogs/java/jvm-juc/jvm.1.4.png"></p><h3 id="6-2-直接内存的回收机制"><a href="#6-2-直接内存的回收机制" class="headerlink" title="6.2 直接内存的回收机制"></a>6.2 直接内存的回收机制</h3><ul><li>直接内存的回收<strong>不是通过 JVM 的垃圾回收来释放</strong>的，而是通过unsafe.freeMemory 来手动释放。</li><li>直接内存的回收机制总结<ul><li>使用了 <strong>Unsafe 类来完成直接内存的分配回收</strong>，回收需要主动调用freeMemory 方法</li><li>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</li></ul></li></ul><h1 id="二-垃圾回收"><a href="#二-垃圾回收" class="headerlink" title="二. 垃圾回收"></a>二. 垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><p>当一个对象被引用时，就当引用对象的值+1，当值为 0 时，就表示该对象不被引用，可以被垃圾收集器回收。</p><ul><li>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放。</li></ul><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><ol><li>确定根对象(肯定不能被垃圾回收的对象)</li><li>每个对象是不是被根对象直接或间接的引用,如果是,则将来不能作为垃圾回收,反之则可以回收</li></ol><ul><li>JVM 中的垃圾回收器通过可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收</li></ul><h4 id="哪些对象可以作为GC-Root对象？"><a href="#哪些对象可以作为GC-Root对象？" class="headerlink" title="哪些对象可以作为GC Root对象？"></a>哪些对象可以作为GC Root对象？</h4><ol><li>系统类对象(System Class)</li><li>调用操作系统方法中引用的JAVA对象(Native Stack)</li><li>活动<strong>线程的对象</strong>(Thread)</li><li>被加锁的对象，正在加锁的对象</li></ol><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="/img/blogs/java/jvm-juc/jvm.2.1.png"></p><ol><li>强引用<ul><li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul></li><li>软引用<ul><li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时会再次出发垃圾回收，回收软引用对象</strong></li><li>可以配合引用队列来释放软引用自身</li></ul></li><li>弱引用<ul><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足，都会回收弱引用对象</strong></li><li>可以配合引用队列来释放弱引用自身</li></ul></li><li>虚引用<ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队</li><li>由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul></li><li>终结器引用<ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收）;再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</li></ul></li></ol><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><ol><li><strong>标记</strong>：标记没有被GC Root引用的对象</li><li><strong>清除</strong>：释放对象占用的内存空间</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.2.2.png"></p><ul><li>速度较快</li><li>会产生内存碎片</li></ul><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><ol><li><strong>标记</strong>：标记没有被GC Root引用的对象</li><li><strong>整理</strong>：释放对象空间，之后将内存碎片移动到一块，成为一段连续的空间</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.2.3.png"></p><ul><li>速度慢</li><li>没有内存碎片</li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><ol><li><strong>标记</strong>：标记没有被GC Root引用的对象</li><li><strong>复制</strong>：将内存空间复制到另一块内存地址中，然后再交换回来</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.2.4.png"></p><ul><li>不会有内存碎片</li><li>需要占用两倍内存空间</li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><ul><li>新生代频繁发生垃圾回收，老年代很少发生垃圾回收</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.2.5.png"></p><ol><li>新创建的对象首先分配在伊甸园区</li><li>新生代空间不足时，触发 minor GC，伊甸园区和 from 区存活的对象使用copy复制到to中，存活的对象年龄加一，然后交换 from to</li><li>minor GC会引发 stop the world：暂停其他用户线程，等垃圾回收结束后，恢复用户线程运行</li><li>当幸存区对象的寿命超过阈值时，会晋升到老年代，最大的寿命是 15（4bit）</li><li>当老年代空间不足时，会先触发 minor GC，如果空间仍然不足，那么就触发 full GC，stop the world停止的时间更长！</li></ol><ul><li>当新创建的对象比新生代还要大的时候，如果老年代大小能容下，则会直接放到老年代</li><li>当新创建的对象比新生代和老年代的大小总和都大时，会抛出内存溢出(OutOfMemoryError)</li></ul><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h3><ul><li>单线程</li><li>堆内存较少，适合个人电脑</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.2.6.png"></p><ul><li><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</li><li>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态</li></ul><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><ul><li>多线程</li><li>适用于堆内存较大，多核CPU</li><li>让单位时间内，STW(stop the world)的时间最短</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.2.7.png"></p><ul><li>当开始垃圾回收时，所有的CPU线程都会进行垃圾回收，此时CPU占有率达到100%</li></ul><p>两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis&#x3D;ms 控制最大的垃圾收集停顿时间（默认200ms）</li><li>XX:GCTimeRatio&#x3D;rario 直接设置吞吐量的大小</li></ul><h3 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h3><ul><li>多线程</li><li>适用于堆内存较大，多核CPU</li><li>尽可能让STW(stop the world)的单次时间最短</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.2.8.png"></p><h3 id="4-4-CMS-收集器"><a href="#4-4-CMS-收集器" class="headerlink" title="4.4 CMS 收集器"></a>4.4 CMS 收集器</h3><ul><li>CMS 收集器：Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的老年代收集器</li><li>CMS 收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的,有些阶段不需要stop the world，可以和用户阶段一起并发运行</li></ul><p>CMS 收集器的运行过程分为下列4步：</p><ol><li><strong>初始标记</strong>：标记 GC Roots 能直接到的对象。速度很快但是仍存在 Stop The World 问题。</li><li><strong>并发标记</strong>：进行 GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。</li><li><strong>重新标记</strong>：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在 Stop The World 问题</li><li><strong>并发清除</strong>：对标记的对象进行清除回收，清除的过程中，可能任然会有新的垃圾产生，这些垃圾就叫浮动垃圾，如果当用户需要存入一个很大的对象时，新生代放不下去，老年代由于浮动垃圾过多，就会退化为 serial Old 收集器，将老年代垃圾进行标记-整理，当然这也是很耗费时间的！</li></ol><h2 id="5-G1-Garbage-First"><a href="#5-G1-Garbage-First" class="headerlink" title="5. G1(Garbage First)"></a>5. G1(Garbage First)</h2><p>适用场景</p><ul><li>同时注重吞吐量和低延迟（响应时间），默认暂停目标是200ms</li><li>超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域</li><li><strong>整体上是标记-整理算法</strong>，<strong>两个区域之间是复制算法</strong></li></ul><h3 id="5-1-G1垃圾回收阶段"><a href="#5-1-G1垃圾回收阶段" class="headerlink" title="5.1 G1垃圾回收阶段"></a>5.1 G1垃圾回收阶段</h3><p><img src="/img/blogs/java/jvm-juc/jvm.2.9.png"></p><ul><li>Young Collection：对新生代垃圾收集</li><li>Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。</li><li>Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。</li></ul><h3 id="5-2-Young-Collection"><a href="#5-2-Young-Collection" class="headerlink" title="5.2 Young Collection"></a>5.2 Young Collection</h3><ul><li>存在STW</li></ul><ol><li>新生代的垃圾回收会将幸存的对象复制放到幸存区</li><li>当幸存区对象过多了，继续垃圾回收，会放到老年代</li></ol><h3 id="5-3-Young-Collection-CM"><a href="#5-3-Young-Collection-CM" class="headerlink" title="5.3 Young Collection + CM"></a>5.3 Young Collection + CM</h3><ul><li>在 Young GC 时会进行 GC Root 的初始化标记</li><li>老年代占用堆空间比例达到阈值时，进行并发标记（不会STW），由下面的 JVM 参数决定</li></ul><h3 id="5-3-Mixed-Collection"><a href="#5-3-Mixed-Collection" class="headerlink" title="5.3 Mixed Collection"></a>5.3 Mixed Collection</h3><p>会对 E、S、O 进行全面的回收</p><ul><li>最终标记 会STW</li><li>拷贝存活 会STW</li></ul><p>问：为什么有的老年代被拷贝了，有的没拷贝？</p><ul><li>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会回收最有价值的老年代（回收后，能够得到更多内存）</li></ul><h3 id="5-4-Full-GC"><a href="#5-4-Full-GC" class="headerlink" title="5.4 Full GC"></a>5.4 Full GC</h3><ul><li>G1 在老年代内存不足时（老年代所占内存超过阈值）<ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发 Full GC，还是并发地进行清理</li><li>如果<strong>垃圾产生速度快于垃圾回收速度，便会触发 Full GC</strong>，然后退化成 serial Old 收集器串行的收集，就会导致停顿的时候长。</li></ul></li></ul><h3 id="5-5-Young-Collection-跨代引用"><a href="#5-5-Young-Collection-跨代引用" class="headerlink" title="5.5 Young Collection 跨代引用"></a>5.5 Young Collection 跨代引用</h3><p>新生代回收的跨代引用（老年代引用新生代）问题</p><p><img src="/img/blogs/java/jvm-juc/jvm.2.10.png"></p><ul><li>脏卡：O 被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li><li>通过遍历脏卡找到老年代引用，从而加速找到引用标记</li></ul><h3 id="5-6-Remark-重新标记阶段"><a href="#5-6-Remark-重新标记阶段" class="headerlink" title="5.6 Remark(重新标记阶段)"></a>5.6 Remark(重新标记阶段)</h3><p>在垃圾回收时，收集器处理对象的过程中</p><ul><li>黑色：已被处理，需要保留的</li><li>灰色：正在处理中的</li><li>白色：还未处理的(如果没有黑色的强引用，则会被回收)</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.2.11.png"></p><h3 id="5-7-JDK-8u20-字符串去重"><a href="#5-7-JDK-8u20-字符串去重" class="headerlink" title="5.7 JDK 8u20 字符串去重"></a>5.7 JDK 8u20 字符串去重</h3><ol><li>将所有新分配的字符串（底层是 char[] ）放入一个队列</li><li>当新生代回收时，G1 并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们引用同一个字符串对象</li></ol><p>与 String.intern() 的区别</p><ul><li>String.intern() 关注的是字符串对象</li><li>字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串标</li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用 CPU</li></ul><h3 id="5-8-JDK-8u40-并发标记类卸载"><a href="#5-8-JDK-8u40-并发标记类卸载" class="headerlink" title="5.8 JDK 8u40 并发标记类卸载"></a>5.8 JDK 8u40 并发标记类卸载</h3><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h3 id="5-9-JDK-8u60-回收巨型对象"><a href="#5-9-JDK-8u60-回收巨型对象" class="headerlink" title="5.9 JDK 8u60 回收巨型对象"></a>5.9 JDK 8u60 回收巨型对象</h3><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li><strong>回收时被优先考虑</strong></li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.2.12.png"></p><h3 id="5-10-JDK-9-并发标记起始时间的调整"><a href="#5-10-JDK-9-并发标记起始时间的调整" class="headerlink" title="5.10 JDK 9 并发标记起始时间的调整"></a>5.10 JDK 9 并发标记起始时间的调整</h3><ul><li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li><li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li><li>JDK 9 可以动态调整<ul><li>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空挡空间</li></ul></li></ul><h2 id="6-GC调优"><a href="#6-GC调优" class="headerlink" title="6. GC调优"></a>6. GC调优</h2><h3 id="6-1-调优领域"><a href="#6-1-调优领域" class="headerlink" title="6.1 调优领域"></a>6.1 调优领域</h3><ul><li>内存</li><li>锁竞争</li><li>CPU占用</li><li>IO</li><li>GC</li></ul><h3 id="6-2-确定目标"><a href="#6-2-确定目标" class="headerlink" title="6.2 确定目标"></a>6.2 确定目标</h3><p>低延迟&#x2F;高吞吐量？ 选择合适的GC回收器</p><ul><li>CMS G1 ZGC ParallelGC</li></ul><h3 id="6-3-最快的GC是不发生GC"><a href="#6-3-最快的GC是不发生GC" class="headerlink" title="6.3 最快的GC是不发生GC"></a>6.3 最快的GC是不发生GC</h3><ul><li>数据是不是太多？<ul><li>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li>数据表示是否太臃肿</li><li>是否存在内存泄漏</li></ul><h3 id="6-4-新生代调优"><a href="#6-4-新生代调优" class="headerlink" title="6.4 新生代调优"></a>6.4 新生代调优</h3><ul><li>新生代的特点：所有的 new 操作分配内存都是非常廉价的</li><li>死亡对象的回收代价是0</li><li>大部分对象用过即死（朝生夕死）</li><li>Minor GC 所用时间远小于 Full GC</li></ul><h4 id="新生代内存越大越好么？"><a href="#新生代内存越大越好么？" class="headerlink" title="新生代内存越大越好么？"></a>新生代内存越大越好么？</h4><ul><li>新生代内存太小：<strong>小了回收频繁</strong>，频繁触发 Minor GC ，会 STW ，会使得吞吐量下降</li><li>新生代内存太大：<strong>空间大回收的时间过长</strong>，老年代内存占比有所降低，<strong>会更频繁地触发 Full GC</strong>。而且触发 Minor GC 时，清理新生代所花费的时间会更长</li></ul><p>调优方法：</p><ul><li>新生代内存设置【并发量*(请求-响应)】的数据为宜</li><li>幸存区需要能够保存 【当前活跃对象+需要晋升的对象】</li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h3 id="6-5-老年代调优"><a href="#6-5-老年代调优" class="headerlink" title="6.5 老年代调优"></a>6.5 老年代调优</h3><p>以 CMS 为例：</p><ul><li>CMS 的老年代内存越大越好</li><li>先尝试不做调优，如果没有 Full GC 那么已经可以了，否则先尝试调优新生代。</li><li>观察发现 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3</li></ul><h1 id="三-类加载与字节码技术"><a href="#三-类加载与字节码技术" class="headerlink" title="三. 类加载与字节码技术"></a>三. 类加载与字节码技术</h1><h2 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h2><p>根据JVM规范，类文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs s">ClassFile&#123;<br>u4    magic<br>u2             minor_version;    <br>u2             major_version;    <br>u2             constant_pool_count;    <br>cp_info        constant_pool[constant_pool_count-1];    <br>u2             access_flags;    <br>u2             this_class;    <br>u2             super_class;   <br>u2             interfaces_count;    <br>u2             interfaces[interfaces_count];   <br>u2             fields_count;    <br>field_info     fields[fields_count];   <br>u2             methods_count;    <br>method_info    methods[methods_count];    <br>u2             attributes_count;    <br>attribute_info attributes[attributes_count];<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>魔数：0~3个字节，表示是否为.class类型的文件</li><li>版本：4~7个字节，表示类的版本号</li><li>常量池</li></ol><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h2><h3 id="2-1-javap工具"><a href="#2-1-javap工具" class="headerlink" title="2.1 javap工具"></a>2.1 javap工具</h3><p>Java 中提供了 javap 工具来反编译 class 文件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">javap -v HelloWorld.<span class="hljs-built_in">class</span><br></code></pre></td></tr></table></figure><h3 id="2-2-图解方法执行流程"><a href="#2-2-图解方法执行流程" class="headerlink" title="2.2 图解方法执行流程"></a>2.2 图解方法执行流程</h3><ol><li>代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_1</span> &#123;    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;        <br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Short.MAX_VALUE + <span class="hljs-number">1</span>;        <br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;        <br>System.out.println(c);   <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>常量池载入运行时常量池</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.3.1.png"></p><ol start="3"><li>方法字节码载入方法区</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.3.2.png"></p><ol start="4"><li>main线程开始运行，分配栈帧内存</li></ol><p><img src="/img/blogs/java/jvm-juc/jvm.3.3.png"></p><h3 id="2-3-构造方法"><a href="#2-3-构造方法" class="headerlink" title="2.3 构造方法"></a>2.3 构造方法</h3><ul><li>私有、构造、被 final 修饰的方法，在调用时都使用 invokespecial 指令</li><li>普通成员方法在调用时，使用 invokevirtual 指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用 invokestatic 指令</li></ul><h3 id="2-4-多态原理"><a href="#2-4-多态原理" class="headerlink" title="2.4 多态原理"></a>2.4 多态原理</h3><p>在执行 invokevirtual 指令时：</p><ol><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的 Class</li><li>Class 结构中有 vtable</li><li>查询 vtable 找到方法的具体地址</li><li>执行方法的字节码</li></ol><h3 id="2-5-异常处理"><a href="#2-5-异常处理" class="headerlink" title="2.5 异常处理"></a>2.5 异常处理</h3><ul><li>try-catch；多出来一个 Exception table 的结构，通过查表进行异常处理</li><li>finally:<ul><li>看到 ﬁnally 中的代码<strong>被复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程</li><li>虽然从字节码指令看来，每个块中都有 finally 块，但是 finally 块中的代码<strong>只会被执行一次</strong></li><li>如果在 ﬁnally 中出现了 return，会吞掉异常</li></ul></li></ul><h2 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3. 编译期处理"></a>3. 编译期处理</h2><p>语法糖：其实就是指 java 编译器把 <strong>.java 源码编译为 .class 字节码</strong>的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><h3 id="3-1-自动拆装箱"><a href="#3-1-自动拆装箱" class="headerlink" title="3.1 自动拆装箱"></a>3.1 自动拆装箱</h3><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy2</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-泛型集合取值"><a href="#3-2-泛型集合取值" class="headerlink" title="3.2 泛型集合取值"></a>3.2 泛型集合取值</h3><p>java 在<strong>编译泛型代码后会执行泛型擦除</strong>的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理.</p><h3 id="3-3-可变参数"><a href="#3-3-可变参数" class="headerlink" title="3.3 可变参数"></a>3.3 可变参数</h3><p>可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy4</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String... args)</span> &#123;<br>      <span class="hljs-comment">// 将 args 赋值给 arr ，可以看出 String... 实际就是 String[]  </span><br>      String[] arr = args;<br>      System.out.println(arr.length);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-方法重写时的桥接方法"><a href="#3-4-方法重写时的桥接方法" class="headerlink" title="3.4 方法重写时的桥接方法"></a>3.4 方法重写时的桥接方法</h3><p>方法重写时对返回值分两种情况：</p><ul><li>父子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <br><span class="hljs-keyword">public</span> Number <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>&#125; <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; <br><span class="hljs-meta">@Override</span> <br><span class="hljs-comment">// 子类 m 方法的返回值是 Integer 是父类 m 方法返回值 Number 的子类 </span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>对于子类，java 编译器会做如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123; <br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; <br>&#125;<br><span class="hljs-comment">// 此方法才是真正重写了父类 public Number m() 方法 </span><br><span class="hljs-keyword">public</span> synthetic bridge Number <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-comment">// 调用 public Integer m() </span><br><span class="hljs-keyword">return</span> m(); <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h2><h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><ul><li>将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li><li>_super 即父类</li><li>_ﬁelds 即成员变量</li><li>_methods 即方法</li><li>_constants 即常量池</li><li>_class_loader 即类加载器</li><li>_vtable 虚方法表</li><li>_itable 接口方法表</li></ul></li><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li></ul><p><img src="/img/blogs/java/jvm-juc/jvm.3.4.png"></p><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><ol><li><strong>验证</strong>：验证类是否符合 JVM规范，安全性检查</li><li><strong>准备</strong>：为 static 变量分配空间，设置默认值<ul><li>static变量<strong>分配空间和赋值是两个步骤</strong>，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li><li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成将常量池中的符号引用解析为直接引用</li></ul></li><li><strong>解析</strong>：将常量池的符号引用解析为直接引用</li></ol><h3 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h3><ul><li><p><code>&lt;cinit&gt;()V</code>：初始化即调用 <code>&lt;cinit&gt;()V</code> ，虚拟机会保证这个类的『构造方法』的线程安全</p></li><li><p>发生的时机(<strong>类初始化是懒惰的，用到了才会初始化</strong>)</p><ul><li>会导致类初始化的：<ul><li><strong>main方法所在的类</strong>，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul></li><li>不会导致类初始化的：<ul><li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化</li><li>创建该类的数组不会触发初始化</li></ul></li></ul></li></ul><h2 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h2><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为Bootstrap，显示为null</td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h3 id="5-1-启动类加载器"><a href="#5-1-启动类加载器" class="headerlink" title="5.1 启动类加载器"></a>5.1 启动类加载器</h3><p>用Bootstrap类加载器加载类</p><h3 id="5-2-扩展类加载器"><a href="#5-2-扩展类加载器" class="headerlink" title="5.2 扩展类加载器"></a>5.2 扩展类加载器</h3><p>如果 classpath 和 JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下有同名类，加载时会使用拓展类加载器加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p><h3 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h3><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，<strong>查找类</strong>的规则。</p><h3 id="5-4-自定义类加载器"><a href="#5-4-自定义类加载器" class="headerlink" title="5.4 自定义类加载器"></a>5.4 自定义类加载器</h3><ul><li><p><strong>使用场景</strong></p><ul><li>想加载非 classpath 随意路径中的类文件</li><li>通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul></li><li><p><strong>步骤</strong></p><ul><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法</li><li>不是重写 loadClass 方法，否则不会走双亲委派机制</li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul></li></ul><h2 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6. 运行期优化"></a>6. 运行期优化</h2><h3 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>为什么代码循环运行时，遇到相同的代码块，运行的速度会越来越快？<br>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 即时编译器编译执行（不带 profiling）</li><li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>prfiling 是指在运行过程中收集一些程序执行状态的数据，例如【<strong>方法的调用次数</strong>】，【循环的回边次数】等</p><ul><li>即时编译器与解释器的区别<ul><li><strong>解释器</strong><ul><li>将字节码解释为机器码，下次即使<strong>遇到相同的字节码，仍会执行重复的解释</strong></li><li>是将字节码解释为针对所有平台都通用的机器码</li></ul></li><li><strong>即时编译器</strong><ul><li>将一些字节码编译为机器码，并存入 Code Cache，<strong>下次遇到相同的代码，直接执行，无需再编译</strong></li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul></li></ul><h3 id="6-2-反射优化"><a href="#6-2-反射优化" class="headerlink" title="6.2 反射优化"></a>6.2 反射优化</h3><ul><li>一开始if条件不满足，就会调用本地方法 invoke0</li><li>随着 numInvocation 的增大，当它大于 ReflectionFactory，inflationThreshold 的值 16 时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为正常调用，即直接调用 Reflect1.foo()</li></ul></li></ul><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发编程学习笔记</title>
    <link href="/2025/04/12/JAVA/JUC/"/>
    <url>/2025/04/12/JAVA/JUC/</url>
    
    <content type="html"><![CDATA[<h1 align="center">JUC并发编程学习笔记</h1><h1 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一. 基本概念"></a>一. 基本概念</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><ul><li><p><strong>进程</strong></p><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。<strong>进程就是用来加载指令、管理内存、管理 IO 的</strong>。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li><strong>进程就可以视为程序的一个实例</strong>。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul></li><li><p><strong>线程</strong></p><ul><li><strong>一个进程之内可以分为一到多个线程</strong>。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行。<strong>线程负责执行指令</strong>。</li><li>Java 中，<strong>线程作为最小调度单位，进程作为资源分配的最小单位</strong>。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul></li><li><p><strong>两者对比</strong></p><ul><li>进程基本上相互独立的，而<strong>线程存在于进程内，是进程的一个子集</strong> </li><li><strong>进程拥有共享的资源，如内存空间等，供其内部的线程共享</strong></li><li>进程间通信较为复杂 <ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 </li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul></li></ul><h2 id="2-并行和并发"><a href="#2-并行和并发" class="headerlink" title="2. 并行和并发"></a>2. 并行和并发</h2><ul><li>并发是一个CPU在不同的时间去不同线程中执行指令。<strong>线程轮流使用CPU的做法称为并发</strong></li><li>并行是多个CPU同时处理不同的线程。<strong>多核CPU下，每个核调度运行线程，这个时候线程是并行的</strong></li><li>并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li>并行： 单位时间内，多个任务<strong>同时执行</strong>。</li></ul><h2 id="3-同步和异步"><a href="#3-同步和异步" class="headerlink" title="3. 同步和异步"></a>3. 同步和异步</h2><p>从调用方的角度，如果</p><ul><li>同步：<strong>需要等待结果返回才能继续运行</strong>的话就是同步</li><li>异步：<strong>不需要等待</strong>就是异步</li></ul><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><ol><li><strong>单核cpu下，多线程不能实际提高程序运行效率</strong>，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，<strong>将任务拆分，并行执行，当然可以提高程序的运行效率。<strong>但</strong>不是所有计算任务都能拆分</strong></li><li><strong>也不是所有任务都需要拆分</strong>，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li><strong>IO 操作不占用 cpu</strong>，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。</li></ol><h1 id="二-Java线程"><a href="#二-Java线程" class="headerlink" title="二. Java线程"></a>二. Java线程</h1><h2 id="1-创建和运行线程"><a href="#1-创建和运行线程" class="headerlink" title="1. 创建和运行线程"></a>1. 创建和运行线程</h2><h3 id="1-1-直接使用Thread"><a href="#1-1-直接使用Thread" class="headerlink" title="1.1 直接使用Thread"></a>1.1 直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 匿名内部类方式创建 Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;t1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">//run方法内实现要执行的任务</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">//启动线程</span><br>        t.start();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-使用-Runnable-配合-Thread（推荐）"><a href="#1-2-使用-Runnable-配合-Thread（推荐）" class="headerlink" title="1.2 使用 Runnable 配合 Thread（推荐）"></a>1.2 使用 Runnable 配合 Thread（推荐）</h3><p>把线程和任务分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 要执行的任务</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br><span class="hljs-comment">// 启动线程</span><br>t.start();<br></code></pre></td></tr></table></figure><p>lambda 精简代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br> <br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task2, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><ul><li>Thread 与 Runnable 的关系<ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul></li></ul><h3 id="1-3-FutureTask-配合-Thread"><a href="#1-3-FutureTask-配合-Thread" class="headerlink" title="1.3 FutureTask 配合 Thread"></a>1.3 FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建任务对象</span><br>FutureTask&lt;Integer&gt; task3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;);<br> <br><span class="hljs-comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task3, <span class="hljs-string">&quot;t3&quot;</span>).start();<br></code></pre></td></tr></table></figure><h2 id="2-查看进程线程的方法"><a href="#2-查看进程线程的方法" class="headerlink" title="2. 查看进程线程的方法"></a>2. 查看进程线程的方法</h2><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist  查看进程</li><li>taskkill  杀死进程</li><li>jps  命令查看所有 Java 进程</li><li><code>jstack &lt;PID&gt;</code>  查看某个 Java 进程（PID）的所有线程状态 </li><li>jconsole  来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h2 id="3-线程运行的原理"><a href="#3-线程运行的原理" class="headerlink" title="3. 线程运行的原理"></a>3. 线程运行的原理</h2><h3 id="3-1-栈与栈帧"><a href="#3-1-栈与栈帧" class="headerlink" title="3.1 栈与栈帧"></a>3.1 栈与栈帧</h3><ul><li>JVM 中由堆、栈、方法区所组成</li><li>其中栈内存是给线程用的，每个<strong>线程启动后，虚拟机就会为其分配一块栈内存</strong>。<ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li><strong>每个线程只能有一个活动栈帧</strong>，对应着当前正在执行的那个方法</li></ul></li></ul><p><img src="/img/blogs/java/jvm-juc/juc.2.1.png"></p><h3 id="3-2-线程上下文切换"><a href="#3-2-线程上下文切换" class="headerlink" title="3.2 线程上下文切换"></a>3.2 线程上下文切换</h3><p>从使用CPU到不使用CPU就是线程切换</p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当上下文切换发生时，<strong>需要由操作系统保存当前线程的状态</strong>，并恢复另一个线程的状态，Java 中对应的概念</p><ul><li>程序计数器，它的作用是<strong>记住下一条 jvm 指令的执行地址</strong>，是线程私有的</li><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>上下文<strong>切换频繁发生会影响性能</strong></li></ul><h2 id="4-线程的常见方法"><a href="#4-线程的常见方法" class="headerlink" title="4. 线程的常见方法"></a>4. 线程的常见方法</h2><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th><th>注意</th></tr></thead><tbody><tr><td>start()</td><td></td><td>启动一个新线程，在新线程中运行 run 方法中的代码</td><td>start 方法只是让线程进入就绪状态，里面代码不一定立刻运行。每个线程的 start 方法只能调用一次。</td></tr><tr><td>run()</td><td></td><td>新线程启动会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法。</td></tr><tr><td>join()</td><td></td><td>等待线程运行结束</td><td></td></tr><tr><td>join(long n)</td><td></td><td>等待线程运行结束,最多等待 n 毫秒</td><td></td></tr><tr><td>getId()</td><td></td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>getName()</td><td></td><td>获取线程名</td><td></td></tr><tr><td>setName(String)</td><td></td><td>修改线程名</td><td></td></tr><tr><td>getPriority()</td><td></td><td>获取线程优先级</td><td></td></tr><tr><td>setPriority(int)</td><td></td><td>修改线程优先级</td><td>Java 中线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率。</td></tr><tr><td>getState()</td><td></td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED。</td></tr><tr><td>isInterrupted()</td><td></td><td>判断是否被打断</td><td>不会清除 打断标记</td></tr><tr><td>isAlive()</td><td></td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td>interrupt()</td><td></td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除 打断标记。</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是否被打断</td><td>会清除 打断标记</td></tr><tr><td>currentThread()</td><td>static</td><td>获取当前正在执行的线程</td><td></td></tr><tr><td>sleep(long n)</td><td>static</td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td><td></td></tr><tr><td>yield()</td><td>static</td><td>提示线程调度器让出当前线程对CPU的使用</td><td>主要是为了测试和调试</td></tr></tbody></table><h3 id="4-1-start-与-run"><a href="#4-1-start-与-run" class="headerlink" title="4.1  start 与 run"></a>4.1  start 与 run</h3><ul><li>必须<strong>要先调用start开启线程，再调用run运行</strong></li><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h3 id="4-2-sleep-与-yield"><a href="#4-2-sleep-与-yield" class="headerlink" title="4.2 sleep 与 yield"></a>4.2 sleep 与 yield</h3><h4 id="4-2-1-sleep-睡眠"><a href="#4-2-1-sleep-睡眠" class="headerlink" title="4.2.1 sleep (睡眠)"></a>4.2.1 sleep (睡眠)</h4><ol><li>调用 sleep 会让<strong>当前线程从 Running 运行状态 进入 Timed Waiting 睡眠状态</strong>（阻塞）</li><li>其它线程可以使用  <strong>interrupt 方法打断正在睡眠的线程</strong>，这时 sleep 方法会抛出  InterruptedException  </li><li>睡眠结束后的线程未必会立刻得到执行</li></ol><h4 id="4-2-2-yield-让出"><a href="#4-2-2-yield-让出" class="headerlink" title="4.2.2 yield (让出)"></a>4.2.2 yield (让出)</h4><ul><li>调用 yield 会<strong>让当前线程从 Running(运行状态) 进入 Runnable (就绪状态)</strong>，然后调度执行其它线程</li></ul><h4 id="4-2-3-线程优先级"><a href="#4-2-3-线程优先级" class="headerlink" title="4.2.3 线程优先级"></a>4.2.3 线程优先级</h4><ul><li>线程优先级会提示（hint）调度器<strong>优先调度该线程</strong>，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么<strong>优先级高的线程会获得更多的时间片</strong>，但 cpu 闲时，优先级几乎没作用</li></ul><h4 id="4-2-4-防止CPU占用100"><a href="#4-2-4-防止CPU占用100" class="headerlink" title="4.2.4 防止CPU占用100%"></a>4.2.4 防止CPU占用100%</h4><p>在没有利用cpu来计算时,不要让while(true)空转浪费cpu,这时可以使用yield或sleep来让出cpu的使用权给其他程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-join"><a href="#4-3-join" class="headerlink" title="4.3 join"></a>4.3 join</h3><p><strong>等待某个线程运行结束</strong><br>在<strong>同步应用</strong>要使用join</p><ul><li>需要等待结果返回，才能继续运行就是同步</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.2.2.png"></p><h3 id="4-4-interrupt"><a href="#4-4-interrupt" class="headerlink" title="4.4 interrupt"></a>4.4 interrupt</h3><p>调用interrupt方法可以打断当前运行的线程，并将打断状态置为true。</p><h4 id="4-4-1-打断-sleep，wait，join-的线程"><a href="#4-4-1-打断-sleep，wait，join-的线程" class="headerlink" title="4.4.1 打断 sleep，wait，join 的线程"></a>4.4.1 打断 sleep，wait，join 的线程</h4><p>这几个方法都会让线程进入阻塞状态</p><ul><li>打断 sleep 的线程, <strong>会清空打断状态</strong></li></ul><h4 id="4-4-2-打断正常运行的线程"><a href="#4-4-2-打断正常运行的线程" class="headerlink" title="4.4.2 打断正常运行的线程"></a>4.4.2 打断正常运行的线程</h4><p>打断正常运行的线程, 不会清空打断状态</p><h4 id="4-4-3-两阶段终止模式"><a href="#4-4-3-两阶段终止模式" class="headerlink" title="4.4.3 两阶段终止模式"></a>4.4.3 两阶段终止模式</h4><p><img src="/img/blogs/java/jvm-juc/juc.2.3.png"></p><h4 id="4-4-4-打断-park-线程"><a href="#4-4-4-打断-park-线程" class="headerlink" title="4.4.4 打断 park 线程"></a>4.4.4 打断 park 线程</h4><p>park也是让当前线程停下来<br>打断 park 线程, 不会清空打断状态</p><h3 id="4-5-不推荐的方法"><a href="#4-5-不推荐的方法" class="headerlink" title="4.5 不推荐的方法"></a>4.5 不推荐的方法</h3><p>这些方法已过时，容易破坏同步代码块，造成线程死锁</p><table><thead><tr><th>方法名</th><th>功能说明</th></tr></thead><tbody><tr><td>stop()</td><td>停止线程运行</td></tr><tr><td>suspend()</td><td>挂起（暂停）线程运行</td></tr><tr><td>resume()</td><td>恢复线程运行</td></tr></tbody></table><h2 id="5-主线程和守护线程"><a href="#5-主线程和守护线程" class="headerlink" title="5. 主线程和守护线程"></a>5. 主线程和守护线程</h2><ul><li>默认情况下，<strong>Java 进程需要等待所有线程都运行结束，才会结束</strong>。</li><li>有一种特殊的线程叫做守护线程，<strong>只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束</strong></li><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul><h2 id="6-线程的五种状态-操作系统层面"><a href="#6-线程的五种状态-操作系统层面" class="headerlink" title="6. 线程的五种状态(操作系统层面)"></a>6. 线程的五种状态(操作系统层面)</h2><p><img src="/img/blogs/java/jvm-juc/juc.2.4.png"></p><ul><li>【<strong>初始状态</strong>】仅是在语言层面<strong>创建了线程对象</strong>，还未与操作系统线程关联</li><li>【<strong>可运行状态</strong>】（就绪状态）指该线程<strong>已经被创建</strong>（与操作系统线程关联），<strong>可以由 CPU 调度执行，但还没有被分配时间片</strong></li><li>【<strong>运行状态</strong>】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【<strong>阻塞状态</strong>】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会<strong>导致线程上下文切换</strong>，进入【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说<strong>只要它们一直不唤醒，调度器就一直不会考虑调度它们</strong></li></ul></li><li>【<strong>终止状态</strong>】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h2 id="7-线程的六种状态-JAVA-API层面"><a href="#7-线程的六种状态-JAVA-API层面" class="headerlink" title="7. 线程的六种状态(JAVA API层面)"></a>7. 线程的六种状态(JAVA API层面)</h2><p>根据 Thread.State 枚举，分为六种状态</p><p><img src="/img/blogs/java/jvm-juc/juc.2.5.png"></p><ul><li><strong>NEW</strong>:  线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong>:  当调用了start() 方法之后，注意，Java API 层面的<strong>RUNNABLE 状态涵盖了操作系统 层面的【可运行状态】、【运行状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong>:  都是 Java API 层面对【阻塞状态】的细分</li><li><strong>TERMINATED</strong>:  当线程代码运行结束</li></ul><h1 id="三-共享模型之管程"><a href="#三-共享模型之管程" class="headerlink" title="三. 共享模型之管程"></a>三. 共享模型之管程</h1><h2 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1. 共享带来的问题"></a>1. 共享带来的问题</h2><p>多线程下，对共享资源访问带来的问题</p><h3 id="1-1-临界区-Critical-Section"><a href="#1-1-临界区-Critical-Section" class="headerlink" title="1.1 临界区 Critical Section"></a>1.1 临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在<strong>多个线程访问共享资源</strong><ul><li>多个线程<strong>读共享资源</strong>其实也没有问题</li><li>在多个线程<strong>对共享资源读写操作时发生指令交错</strong>，就会出现问题</li></ul></li><li>一段代码块内如果<strong>存在对共享资源的多线程读写</strong>操作，称<strong>这段代码块为临界区</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> <br><span class="hljs-comment">// 临界区</span><br>&#123;    <br>    counter++; <span class="hljs-comment">//counter就是共享资源</span><br>&#125;<br> <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> <br><span class="hljs-comment">// 临界区</span><br>&#123;    <br>    counter--; <span class="hljs-comment">//counter就是共享资源</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-竞态条件-Race-Condition"><a href="#1-2-竞态条件-Race-Condition" class="headerlink" title="1.2 竞态条件 Race Condition"></a>1.2 竞态条件 Race Condition</h3><p>多个线程在临界区内执行，由于<strong>代码的执行序列不同而导致结果无法预测</strong>，称之为发生了<strong>竞态条件</strong></p><h2 id="2-synchronized-解决方案"><a href="#2-synchronized-解决方案" class="headerlink" title="2. synchronized 解决方案"></a>2. synchronized 解决方案</h2><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>synchronized，俗称【对象锁】，它采用<strong>互斥</strong>的方式让<strong>同一时刻至多只有一个线程</strong>能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-1-synchronized语法"><a href="#2-1-synchronized语法" class="headerlink" title="2.1 synchronized语法"></a>2.1 synchronized语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) <span class="hljs-comment">// 线程1， 线程2(blocked)</span><br>&#123;<br>    临界区<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<span class="hljs-comment">//加锁</span><br>                counter++;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<span class="hljs-comment">//加锁</span><br>                counter--;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-synchronized的原子性"><a href="#2-2-synchronized的原子性" class="headerlink" title="2.2 synchronized的原子性"></a>2.2 synchronized的原子性</h3><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是<strong>不可分割的</strong>，不会被线程切换所打断。</p><h3 id="2-3-面向对象的改进"><a href="#2-3-面向对象的改进" class="headerlink" title="2.3 面向对象的改进"></a>2.3 面向对象的改进</h3><p>把需要保护的共享变量放入一个类，封装成一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              value++;<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              value--;<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>              <span class="hljs-keyword">return</span> value;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.increment();<br>                &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5000</span>; j++) &#123;<br>                room.decrement();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br> <br>        t1.join();<br>        t2.join();<br>        log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span> , room.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-方法上的-synchronized"><a href="#3-方法上的-synchronized" class="headerlink" title="3. 方法上的 synchronized"></a>3. 方法上的 synchronized</h2><ul><li>加在方法上的锁，不代表锁的是方法，而是锁的<strong>方法中的this对象</strong></li><li>加在静态方法(static)上的锁，不代表锁的是方法，而是锁的<strong>静态方法的类对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <br>    &#125;<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>        <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br> <br>    &#125;<br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Test.class) &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-变量的线程安全分析"><a href="#4-变量的线程安全分析" class="headerlink" title="4. 变量的线程安全分析"></a>4. 变量的线程安全分析</h2><h3 id="4-1-成员变量和静态变量是否线程安全？"><a href="#4-1-成员变量和静态变量是否线程安全？" class="headerlink" title="4.1 成员变量和静态变量是否线程安全？"></a>4.1 成员变量和静态变量是否线程安全？</h3><ul><li>如果它们<strong>没有共享，则线程安全</strong></li><li>如果它们被<strong>共享了</strong>，根据它们的状态是否能够改变，又分两种情况<ul><li>如果<strong>只有读操作</strong>，则线程安全</li><li>如果<strong>有读写操作</strong>，则这段代码是<strong>临界区</strong>，需要考虑线程安全</li></ul></li></ul><h3 id="4-2-局部变量是否线程安全？"><a href="#4-2-局部变量是否线程安全？" class="headerlink" title="4.2 局部变量是否线程安全？"></a>4.2 局部变量是否线程安全？</h3><ul><li>局部变量是线程安全的</li><li>但局部变量<strong>引用的对象</strong>则未必<ul><li>如果该对象<strong>没有逃离方法的作用访问</strong>，它是线程安全的</li><li>如果该对象<strong>逃离方法的作用范围，需要考虑线程安全</strong></li></ul></li><li>局部变量是线程安全的: 因为每个线程都会分配一块栈帧空间用来存放局部变量，<strong>是独立的，不会被其他线程所共享</strong></li></ul><h3 id="4-3-常见线程安全类"><a href="#4-3-常见线程安全类" class="headerlink" title="4.3 常见线程安全类"></a>4.3 常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法</strong>时，<strong>是线程安全</strong>的，它们的<strong>每个方法是原子的</strong><br>但注意它们<strong>多个方法的组合不是原子的</strong>，线程安全类方法的组合不一定是线程安全的</p><ul><li><strong>不可变类</strong>线程安全性 (<strong>只能读，不能改，所以线程安全</strong>)<ul><li>String、Integer 等都是不可变类，因为<strong>其内部的状态不可以改变</strong>，因此它们的方法都是线程安全的</li></ul></li></ul><h2 id="5-Monitor-锁"><a href="#5-Monitor-锁" class="headerlink" title="5. Monitor(锁)"></a>5. Monitor(锁)</h2><h3 id="5-1-Java-对象头"><a href="#5-1-Java-对象头" class="headerlink" title="5.1 Java 对象头"></a>5.1 Java 对象头</h3><p>普通对象的对象头：</p><p><img src="/img/blogs/java/jvm-juc/juc.3.1.png"></p><p>其中的Mark Word结构：</p><p><img src="/img/blogs/java/jvm-juc/juc.3.2.png"></p><h3 id="5-2-Monitor-原理"><a href="#5-2-Monitor-原理" class="headerlink" title="5.2 Monitor 原理"></a>5.2 Monitor 原理</h3><ul><li>Monitor 被翻译为监视器或者说<strong>管程</strong></li><li><strong>每个 java 对象都可以关联一个 Monitor</strong> ，如果使用 synchronized 给对象上锁（重量级），该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.3.3.png"></p><ol><li>刚开始时 Monitor 中的 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj){} 代码时就会将 Monitor 的所有者Owner 设置为 Thread-2，上锁成功，Monitor 中同一时刻只能有一个 Owner</li><li>当 Thread-2 占据锁时，如果线程 Thread-3 ，Thread-4 也来执行synchronized(obj){} 代码，就会进入 EntryList（阻塞队列） 中变成BLOCKED（阻塞） 状态</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li></ol><h2 id="6-synchronized-原理进阶"><a href="#6-synchronized-原理进阶" class="headerlink" title="6. synchronized 原理进阶"></a>6. synchronized 原理进阶</h2><h3 id="6-1-轻量级锁"><a href="#6-1-轻量级锁" class="headerlink" title="6.1 轻量级锁"></a>6.1 轻量级锁</h3><p>轻量级锁的使用场景</p><ul><li>如果一个对象虽然有多个线程要对它进行加锁，但是<strong>加锁的时间是错开的</strong>（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。</li><li>轻量级锁对使用者是透明的，即语法仍然是 synchronized</li></ul><ol><li>每次指向到 synchronized 代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的 Mark Word 和对象引用 reference</li><li>让锁记录中的 Object reference 指向对象，并且尝试用 cas(compare and sweep) 替换 Object 对象的 Mark Word ，将 Mark Word 的值存入锁记录中。</li><li>如果 cas 替换成功，那么对象的对象头储存的就是锁记录的地址和状态 00 表示轻量级锁</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.3.4.png"></p><ol start="4"><li>如果cas失败，有两种情况<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，那么表示有竞争，首先会进行自旋锁，自旋一定次数后，如果还是失败就进入锁膨胀阶段。</li><li>如果是自己的线程已经执行了 synchronized 进行加锁，那么再添加一条 Lock Record 作为重入的计数。</li></ul></li></ol><p><img src="/img/blogs/java/jvm-juc/juc.3.5.png"></p><ol start="5"><li>当线程退出 synchronized 代码块的时候，如果获取的是取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li><li>当线程退出 synchronized 代码块的时候，如果获取的锁记录取值不为 null，那么使用 cas 将 Mark Word 的值恢复给对象<ul><li>成功则解锁成功</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ol><h3 id="6-2-锁膨胀"><a href="#6-2-锁膨胀" class="headerlink" title="6.2 锁膨胀"></a>6.2 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，cas 操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要<strong>进行锁膨胀，将轻量级锁变成重量级锁</strong></p><p><img src="/img/blogs/java/jvm-juc/juc.3.6.png"></p><ol><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程，</li></ol><ul><li>即为对象申请Monitor锁，让Object指向重量级锁地址</li><li>然后自己进入Monitor 的EntryList 变成BLOCKED状态</li></ul><ol start="3"><li>当 Thread-0 退出 synchronized 同步块时，使用 cas 将 Mark Word 的值恢复给对象头，对象的对象头指向 Monitor，那么会进入重量级锁的解锁过程，即按照 Monitor 的地址找到 Monitor 对象，将 Owner 设置为 null ，唤醒 EntryList 中的 Thread-1 线程</li></ol><h3 id="6-3-自旋优化"><a href="#6-3-自旋优化" class="headerlink" title="6.3 自旋优化"></a>6.3 自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋（循环）来进行优化，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换就获得了锁</p><h3 id="6-4-偏向锁"><a href="#6-4-偏向锁" class="headerlink" title="6.4 偏向锁"></a>6.4 偏向锁</h3><p>在轻量级的锁中，如果同一个线程对同一个对象进行<strong>重入</strong>锁时，也需要执行 CAS 操作</p><ul><li>偏向锁：只有第一次使用 CAS 时将对象的 Mark Word 头设置为偏向线程 ID，之后这个入锁线程再进行重入锁时，发现线程 ID 是自己的，那么就不用再进行CAS了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(obj) &#123;<br><span class="hljs-comment">// 同步块 A</span><br>m2();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(obj) &#123;<br><span class="hljs-comment">// 同步块 B</span><br>m3();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span>(obj) &#123;<br><span class="hljs-comment">// 同步块 C</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/jvm-juc/juc.3.7.png"></p><h4 id="6-4-1-偏向状态"><a href="#6-4-1-偏向状态" class="headerlink" title="6.4.1 偏向状态"></a>6.4.1 偏向状态</h4><p>一个对象的创建过程</p><ul><li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，<strong>Mark Word 最后三位的值101</strong>，并且这是它的 Thread，epoch，age 都是 0 ，在加锁的时候进行设置这些的值.</li><li><strong>偏向锁默认是延迟的</strong>，不会在程序启动的时候立刻生效</li></ul><h4 id="6-4-2-撤销偏向"><a href="#6-4-2-撤销偏向" class="headerlink" title="6.4.2 撤销偏向"></a>6.4.2 撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的 hashCode 方法</li><li>多个线程使用该对象</li><li>调用了 wait&#x2F;notify 方法（调用wait方法会导致锁膨胀而使用重量级锁）</li></ul><h4 id="6-4-3-批量重偏向"><a href="#6-4-3-批量重偏向" class="headerlink" title="6.4.3 批量重偏向"></a>6.4.3 批量重偏向</h4><p>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时<strong>偏向 t1 的对象仍有机会重新偏向 t2</strong></p><ul><li>重偏向会重置Thread ID<br>当撤销超过20次后（<strong>超过阈值</strong>），JVM 会觉得是不是偏向错了，这时会在给对象加锁时，<strong>重新偏向至加锁线程</strong>。</li></ul><h4 id="6-4-4-批量撤销"><a href="#6-4-4-批量撤销" class="headerlink" title="6.4.4 批量撤销"></a>6.4.4 批量撤销</h4><p>当撤销偏向锁的<strong>阈值超过 40 以后</strong>，就会将<strong>整个类</strong>的对象<strong>都改为不可偏向的</strong></p><h2 id="7-wait-notify"><a href="#7-wait-notify" class="headerlink" title="7. wait notify"></a>7. wait notify</h2><h3 id="7-1-wait-notify-API介绍"><a href="#7-1-wait-notify-API介绍" class="headerlink" title="7.1 wait notify API介绍"></a>7.1 wait notify API介绍</h3><ul><li>obj.wait()  让进入 object 监视器的线程到 waitSet 等待</li><li>obj.notify()  在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li><li>obj.notifyAll()  让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。<strong>必须获得此对象的锁，才能调用这几个方法</strong></p><ul><li>wait()  方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</li><li>wait(long n)  有时限的等待, 到 n 毫秒后结束等待，或是被 notify</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;).start();<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            log.debug(<span class="hljs-string">&quot;执行....&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                obj.wait(); <span class="hljs-comment">// 让线程在obj上一直等待下去</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;其它代码....&quot;</span>);<br>        &#125;<br>    &#125;).start();<br> <br>    <span class="hljs-comment">// 主线程两秒后执行</span><br>    sleep(<span class="hljs-number">2</span>);<br>    log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        obj.notify(); <span class="hljs-comment">// 唤醒obj上一个线程</span><br>        <span class="hljs-comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-sleep-long-n-和-wait-long-n-的区别"><a href="#7-2-sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="7.2 sleep(long n)  和  wait(long n)  的区别"></a>7.2 sleep(long n)  和  wait(long n)  的区别</h3><ol><li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li><li>它们的状态都是 TIMED_WAITING</li></ol><h3 id="7-3-wait-notify-原理"><a href="#7-3-wait-notify-原理" class="headerlink" title="7.3 wait notify 原理"></a>7.3 wait notify 原理</h3><p><img src="/img/blogs/java/jvm-juc/juc.3.8.png"></p><ol><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ol><h2 id="8-同步模式之保护性暂停"><a href="#8-同步模式之保护性暂停" class="headerlink" title="8. 同步模式之保护性暂停"></a>8. 同步模式之保护性暂停</h2><h3 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1 定义"></a>8.1 定义</h3><p>Guarded Suspension，用在<strong>一个线程等待另一个线程的执行结果</strong></p><ul><li>有一个<strong>结果需要从一个线程传递到另一个线程</strong>，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为<strong>要等待另一方的结果</strong>，因此归类到同步模式</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.3.9.png"></p><h3 id="8-2-join原理"><a href="#8-2-join原理" class="headerlink" title="8.2 join原理"></a>8.2 join原理</h3><p>join <strong>体现的是【保护性暂停】模式</strong><br>调用者<strong>轮询检查线程 alive 状态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">t1.join();<br><span class="hljs-comment">//等价于下面的代码：</span><br><span class="hljs-keyword">synchronized</span> (t1) &#123;<br>    <span class="hljs-comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span><br>    <span class="hljs-keyword">while</span> (t1.isAlive()) &#123;<br>        t1.wait(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3-多任务版-GuardedObject"><a href="#8-3-多任务版-GuardedObject" class="headerlink" title="8.3 多任务版 GuardedObject"></a>8.3 多任务版 GuardedObject</h3><p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理</p><p><img src="/img/blogs/java/jvm-juc/juc.3.10.png"></p><h2 id="9-异步模式之生产者-消费者"><a href="#9-异步模式之生产者-消费者" class="headerlink" title="9. 异步模式之生产者&#x2F;消费者"></a>9. 异步模式之生产者&#x2F;消费者</h2><ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li><strong>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</strong></li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.3.11.png"></p><h2 id="10-Park-Unpark"><a href="#10-Park-Unpark" class="headerlink" title="10. Park &amp; Unpark"></a>10. Park &amp; Unpark</h2><p>是LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//暂停当前线程</span><br>LockSupport.park(); <br><span class="hljs-comment">// 恢复某个线程的运行</span><br>LockSupport.unpark(暂停线程对象)<br></code></pre></td></tr></table></figure><p><strong>与 Object 的 wait &amp; notify 相比</strong></p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li><li><strong>可以先Park再unpark;也可以先unpark再park</strong></li></ul><h2 id="11-重新理解线程状态转换"><a href="#11-重新理解线程状态转换" class="headerlink" title="11. 重新理解线程状态转换"></a>11. 重新理解线程状态转换</h2><p>假设有线程  Thread t</p><p><img src="/img/blogs/java/jvm-juc/juc.3.12.png"></p><ol><li><strong>NEW –&gt; RUNNABLE</strong></li></ol><ul><li>当调用  <strong>t.start()</strong>  方法时，由  NEW –&gt; RUNNABLE</li></ul><ol start="2"><li><strong>RUNNABLE &lt;–&gt; WAITING</strong><br>t 线程用  synchronized(obj)  获取了对象锁后<ul><li>调用  <strong>obj.wait()</strong>  方法时，t 线程从  RUNNABLE –&gt; WAITING</li><li>调用  <strong>obj.notify() ， obj.notifyAll() ， t.interrupt()</strong>  时<ul><li>竞争锁成功，t 线程从   WAITING –&gt; RUNNABLE  </li><li>竞争锁失败，t 线程从   WAITING –&gt; BLOCKED</li></ul></li></ul></li><li><strong>RUNNABLE &lt;–&gt; WAITING</strong>  <ul><li>当前线程调用  <strong>t.join()</strong>  方法时，当前线程从  RUNNABLE –&gt; WAITING</li><li>t 线程运行结束，或调用了当前线程的  <strong>interrupt()</strong>  时，当前线程从  WAITING –&gt; RUNNABLE</li></ul></li><li><strong>RUNNABLE &lt;–&gt; WAITING</strong>  <ul><li>当前线程调用  <strong>LockSupport.park()</strong>  方法会让当前线程从  RUNNABLE –&gt; WAITING</li><li>调用  <strong>LockSupport.unpark(目标线程)</strong>  或调用了线程的 <strong>interrupt()</strong>，会让目标线程从  WAITING –&gt; RUNNABLE</li></ul></li><li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong><br>t 线程用  synchronized(obj)  获取了对象锁后<ul><li>调用  <strong>obj.wait(long n)</strong>  方法时，t 线程从  RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用  obj.notify() ， obj.notifyAll() ， t.interrupt()  时<ul><li>竞争锁成功，t 线程从   TIMED_WAITING –&gt; RUNNABLE  </li><li>竞争锁失败，t 线程从   TIMED_WAITING –&gt; BLOCKED</li></ul></li></ul></li><li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong>  <ul><li>当前线程调用  <strong>t.join(long n)</strong>  方法时，当前线程从  RUNNABLE –&gt; TIMED_WAITING</li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的  <strong>interrupt()</strong>  时，当前线程从TIMED_WAITING –&gt; RUNNABLE</li></ul></li><li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong>  <ul><li>当前线程调用  <strong>Thread.sleep(long n)</strong> ，当前线程从  RUNNABLE –&gt; TIMED_WAITING  </li><li>当前线程等待时间超过了 n 毫秒，当前线程从TIMED_WAITING –&gt; RUNNABLE</li></ul></li><li><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong>  <ul><li>当前线程调用  <strong>LockSupport.parkNanos(long nanos)  或  LockSupport.parkUntil(long millis)</strong>  时，当前线程从  RUNNABLE –&gt; TIMED_WAITING</li><li>调用  <strong>LockSupport.unpark(目标线程) 或调用了线程的interrupt()</strong> ，或是等待超时，会让目标线程从TIMED_WAITING–&gt; RUNNABLE</li></ul></li><li><strong>RUNNABLE &lt;–&gt; BLOCKED</strong>  <ul><li>t 线程用   <strong>synchronized(obj)</strong>  获取了对象锁时<strong>如果竞争失败</strong>，从   RUNNABLE –&gt; BLOCKED  </li><li>持 obj 锁线程的同步代码块执行完毕，会<strong>唤醒该对象上所有  BLOCKED   的线程重新竞争</strong>，如果其中 t 线程竞争<strong>成功</strong>，从  BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然   BLOCKED</li></ul></li><li><strong>RUNNABLE &lt;–&gt; TERMINATED</strong>  <ul><li>当前线程所有代码<strong>运行完毕</strong>，进入 TERMINATED</li></ul></li></ol><h2 id="12-多把锁"><a href="#12-多把锁" class="headerlink" title="12. 多把锁"></a>12. 多把锁</h2><p>如果一把锁锁在一个很大的共享单元(粗粒度)的时候，那么并发度就会很低</p><ul><li>解决方法是准备多个房间（<strong>多个对象锁</strong>）</li></ul><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li></ul><h2 id="13-活跃性"><a href="#13-活跃性" class="headerlink" title="13. 活跃性"></a>13. 活跃性</h2><h3 id="13-1-死锁"><a href="#13-1-死锁" class="headerlink" title="13.1 死锁"></a>13.1 死锁</h3><p>一个线程需要同时获取多把锁，这时就容易发生<strong>死锁</strong></p><ul><li>t1 线程获得A对象锁，接下来想获取B对象的锁  </li><li>t2 线程获得B对象锁，接下来想获取A对象的锁</li></ul><p><strong>避免死锁的方法</strong>:</p><ul><li>在线程使用锁对象时，<strong>顺序加锁</strong>即可避免死锁</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.3.13.png"></p><h3 id="13-2-定位死锁"><a href="#13-2-定位死锁" class="headerlink" title="13.2 定位死锁"></a>13.2 定位死锁</h3><p>检测死锁可以使用 <strong>jconsole工具</strong>，或者使用 jps 定位进程 id，再用 <strong>jstack</strong> 定位死锁</p><h3 id="13-3-哲学家就餐问题"><a href="#13-3-哲学家就餐问题" class="headerlink" title="13.3 哲学家就餐问题"></a>13.3 哲学家就餐问题</h3><p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 。<br>当每个哲学家即线程<strong>持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁</strong>。</p><h3 id="13-4-活锁"><a href="#13-4-活锁" class="headerlink" title="13.4 活锁"></a>13.4 活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件，最后谁也无法结束</strong></p><ul><li><strong>避免活锁的方法</strong>： 在线程执行时，中途给予不同的<strong>间隔时间</strong>即可。</li></ul><p><strong>死锁与活锁的区别</strong></p><ul><li>死锁是因为线程互相持有对象想要的锁，并且<strong>都不释放</strong>，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致<strong>代码一直在运行，却一直运行不完</strong>的现象。</li></ul><h3 id="13-5-饥饿"><a href="#13-5-饥饿" class="headerlink" title="13.5 饥饿"></a>13.5 饥饿</h3><ul><li>一个线程由于<strong>优先级太低，始终得不到 CPU 调度执行</strong>，也不能够结束</li><li>某些线程因为优先级太低，导致一直无法获得资源的现象。</li><li>在使用<strong>顺序加锁</strong>时，可能会出现饥饿现象</li></ul><h2 id="14-ReentrantLock"><a href="#14-ReentrantLock" class="headerlink" title="14. ReentrantLock"></a>14. ReentrantLock</h2><p>相对于 synchronized 它具备如下特点:</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁(防止饥饿)</li><li>支持多个条件变量</li><li>与 synchronized 一样，都支持可重入</li></ul><h3 id="14-1-基本语法"><a href="#14-1-基本语法" class="headerlink" title="14.1 基本语法"></a>14.1 基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取锁</span><br>reentrantLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    reentrantLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-2-可重入"><a href="#14-2-可重入" class="headerlink" title="14.2 可重入"></a>14.2 可重入</h3><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    method1();<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>        method2();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>        method3();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>method1、method2、method3都得到执行，说明是可重入的</p><h3 id="14-3-可打断"><a href="#14-3-可打断" class="headerlink" title="14.3 可打断"></a>14.3 可打断</h3><p>可打断需要使用**lockInterruptibly()**方法<br>处于阻塞状态的线程，被打断了就不用阻塞了，<strong>直接停止运行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 加锁，可打断锁</span><br>lock.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>                <span class="hljs-comment">// 被打断，返回，不再向下执行</span><br><span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 释放锁</span><br>lock.unlock();<br>&#125;<br><br>&#125;);<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>t1.start();<br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 打断</span><br>t1.interrupt();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-4-锁超时"><a href="#14-4-锁超时" class="headerlink" title="14.4 锁超时"></a>14.4 锁超时</h3><p>使用**tryLock()**方法，可返回超时失败<br>设置超时时间，如果超时了，就返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 判断获取锁是否成功，最多等待1秒</span><br><span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>System.out.println(<span class="hljs-string">&quot;获取失败&quot;</span>);<br><span class="hljs-comment">// 获取失败，不再向下执行，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br><span class="hljs-comment">// 被打断，不再向下执行，直接返回</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;得到了锁&quot;</span>);<br><span class="hljs-comment">// 释放锁</span><br>lock.unlock();<br>&#125;);<br><br><br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>t1.start();<br><span class="hljs-comment">// 打断等待</span><br>t1.interrupt();<br>Thread.sleep(<span class="hljs-number">3000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 tryLock 可以解决哲学家就餐问题</li></ul><h3 id="14-5-公平锁"><a href="#14-5-公平锁" class="headerlink" title="14.5 公平锁"></a>14.5 公平锁</h3><ul><li>线程先入先得，防止饥饿</li><li>在线程获取锁失败，进入阻塞队列时，<strong>先进入的会在锁被释放后先获得锁</strong>。这样的获取方式就是公平的。</li><li>ReentrantLock 默认是不公平的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认是不公平锁，需要在创建时指定为公平锁</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h3 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h3><ul><li>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet等待。</li><li>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是<strong>支持多个条件变量</strong>的，这就好比<ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul></li></ul><ol><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ol><h2 id="15-同步模式之顺序控制"><a href="#15-同步模式之顺序控制" class="headerlink" title="15. 同步模式之顺序控制"></a>15. 同步模式之顺序控制</h2><h3 id="15-1-固定运行顺序"><a href="#15-1-固定运行顺序" class="headerlink" title="15.1 固定运行顺序"></a>15.1 固定运行顺序</h3><p>比如，必须先 2 后 1 打印</p><p><strong>wait notify 版</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用来同步的对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// t2 运行标记， 代表 t2 是否执行过</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2runed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 如果 t2 没有执行过</span><br>            <span class="hljs-keyword">while</span> (!t2runed) &#123; <br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// t1 先等一会</span><br>                    obj.wait(); <br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                    &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-number">1</span>);<br>    &#125;);<br> <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-comment">// 修改运行标记</span><br>            t2runed = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll）</span><br>            obj.notifyAll();<br>        &#125;<br>    &#125;);<br> <br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>也可以使用<strong>park 和 unpark 方法</strong></li></ul><h3 id="15-2-交替输出"><a href="#15-2-交替输出" class="headerlink" title="15.2 交替输出"></a>15.2 交替输出</h3><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><p><strong>Wait&#x2F;Notify</strong> 实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_32_Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitAndNotify</span> <span class="hljs-variable">waitAndNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitAndNotify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitAndNotify.run(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitAndNotify.run(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            waitAndNotify.run(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitAndNotify</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> nextFlag)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (flag != <span class="hljs-built_in">this</span>.flag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-comment">// 设置下一个运行的线程标记</span><br>                <span class="hljs-built_in">this</span>.flag = nextFlag;<br>                <span class="hljs-comment">// 唤醒所有线程</span><br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitAndNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>park&#x2F;unpary</strong> 实现</li><li><strong>await&#x2F;signal</strong> 实现</li></ul><h2 id="16-本章总结"><a href="#16-本章总结" class="headerlink" title="16. 本章总结"></a>16. 本章总结</h2><p>本章我们需要重点掌握的是</p><ul><li>分析多线程访问共享资源时，哪些代码片段属于临界区</li><li>使用 synchronized 互斥解决临界区的线程安全问题<ul><li>掌握 synchronized 锁对象语法</li><li>掌握 synchronzied 加载成员方法和静态方法语法</li><li>掌握 wait&#x2F;notify 同步方法</li></ul></li><li>使用 lock 互斥解决临界区的线程安全问题 <ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li></ul></li><li>了解线程活跃性问题：死锁、活锁、饥饿</li><li><strong>应用方面</strong><ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果，实现原子性效果，保证线程安全。</li><li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量来达到线程间通信效果。</li></ul></li><li><strong>原理方面</strong><ul><li>monitor、synchronized 、wait&#x2F;notify 原理</li><li>synchronized 进阶原理</li><li>park &amp; unpark 原理</li></ul></li><li><strong>模式方面</strong><ul><li>同步模式之保护性暂停</li><li>异步模式之生产者消费者</li><li>同步模式之顺序控制</li></ul></li></ul><h1 id="四-共享模型之内存-JMM"><a href="#四-共享模型之内存-JMM" class="headerlink" title="四. 共享模型之内存(JMM)"></a>四. 共享模型之内存(JMM)</h1><h2 id="1-Java-内存模型（JMM）"><a href="#1-Java-内存模型（JMM）" class="headerlink" title="1. Java 内存模型（JMM）"></a>1. Java 内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。<br>JMM 体现在以下几个方面:</p><ul><li><strong>原子性</strong> - 保证指令不会受到线程上下文切换的影响</li><li><strong>可见性</strong> - 保证指令不会受 cpu 缓存的影响</li><li><strong>有序性</strong> - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h2><h3 id="2-1-退不出的循环"><a href="#2-1-退不出的循环" class="headerlink" title="2.1 退不出的循环"></a>2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(run) &#123;<br><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        t1.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;t1 Stop&quot;</span>);<br>        run = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>原因分析</strong>：</p><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.4.1.png"></p><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至<strong>自己工作内存中的高速缓存</strong>中，减少对主存中 run 的访问，提高效率</li><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.4.2.png"></p><p><strong>解决方法</strong>：</p><ul><li>使用 <strong>volatile</strong> （易变关键字）</li><li>它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他<strong>可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值</strong>，线程操作 volatile 变量都是<strong>直接操作主存</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 保证内存的可见性</span><br></code></pre></td></tr></table></figure><h3 id="2-2-可见性和原子性"><a href="#2-2-可见性和原子性" class="headerlink" title="2.2 可见性和原子性"></a>2.2 可见性和原子性</h3><ul><li>可见性保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见，<strong>不能保证原子性</strong></li><li><strong>volatile</strong>： 仅用在<strong>一个写线程，多个读线程</strong>的情况。</li><li><strong>synchronized</strong>语句块：<strong>既可以保证代码块的原子性</strong>，<strong>也同时保证代码块内变量的可见性</strong>。但缺点是synchronized 是属于重量级操作，<strong>性能相对更低</strong></li></ul><h2 id="3-模式之两阶段终止"><a href="#3-模式之两阶段终止" class="headerlink" title="3. 模式之两阶段终止"></a>3. 模式之两阶段终止</h2><p>使用 <strong>volatile</strong> 关键字来实现两阶段终止模式</p><ul><li>停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</li><li>我们的例子中，即主线程把它修改为 true 对 t1 线程可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monitor</span> &#123;<br>Thread monitor;<br><span class="hljs-comment">// 设置标记，用于判断是否被终止了</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">if</span>(stop) &#123;<br>System.out.println(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 线程休眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;被打断了&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.start();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 修改标记</span><br>stop = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 打断线程</span><br>monitor.interrupt();        <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-同步模式之-Balking"><a href="#4-同步模式之-Balking" class="headerlink" title="4. 同步模式之 Balking"></a>4. 同步模式之 Balking</h2><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回</p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题</li><li>加锁的代码块要尽量的小，以保证性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br> <br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它还经常用来实现线程安全的单例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>        <br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-有序性"><a href="#5-有序性" class="headerlink" title="5. 有序性"></a>5. 有序性</h2><h3 id="5-1-指令重排"><a href="#5-1-指令重排" class="headerlink" title="5.1 指令重排"></a>5.1 指令重排</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> j;<br> <br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...; <br>j = ...;<br></code></pre></td></tr></table></figure><p><strong>指令重排</strong>：可能先执行i，再执行j；也可能先执行j，再执行i</p><ul><li>指令重排：在程序结果不受影响的前提下，可以调整指令语句执行顺序</li><li>多线程下『指令重排』会影响正确性</li></ul><h3 id="5-2-解决方法"><a href="#5-2-解决方法" class="headerlink" title="5.2 解决方法"></a>5.2 解决方法</h3><p><strong>volatile</strong>修饰的变量，可以禁用指令重排，禁止的是<strong>加 volatile 关键字变量之前的代码</strong>重排序</p><h2 id="6-volatile-原理"><a href="#6-volatile-原理" class="headerlink" title="6. volatile 原理"></a>6. volatile 原理</h2><p>volatile 的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的<strong>写指令后</strong>会加入写屏障</li><li>对 volatile 变量的<strong>读指令前</strong>会加入读屏障</li></ul><h3 id="6-1-如何保证可见性"><a href="#6-1-如何保证可见性" class="headerlink" title="6.1 如何保证可见性"></a>6.1 如何保证可见性</h3><p>写屏障（sfence）保证在<strong>该屏障之前的</strong>，对共享变量的<strong>改动，都同步到主存</strong>当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>     num = <span class="hljs-number">2</span>;<br>     ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是被 volatile 修饰的，赋值带写屏障</span><br>     <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而读屏障（lfence）保证在<strong>该屏障之后</strong>，对共享变量的<strong>读取，加载的是主存中最新数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">// ready是被 volatile 修饰的，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/jvm-juc/juc.4.3.png"></p><h3 id="6-2-如何保证有序性"><a href="#6-2-如何保证有序性" class="headerlink" title="6.2 如何保证有序性"></a>6.2 如何保证有序性</h3><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br> num = <span class="hljs-number">2</span>;<br> ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是被 volatile 修饰的，赋值带写屏障</span><br> <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br> <span class="hljs-comment">// 读屏障</span><br> <span class="hljs-comment">// ready 是被 volatile 修饰的，读取值带读屏障</span><br> <span class="hljs-keyword">if</span>(ready) &#123;<br> r.r1 = num + num;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br> r.r1 = <span class="hljs-number">1</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/jvm-juc/juc.4.4.png"></p><ul><li>volatile不能解决指令交错<ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是<strong>保证了本线程内相关代码不被重排序</strong></li></ul></li></ul><h2 id="7-double-checked-locking"><a href="#7-double-checked-locking" class="headerlink" title="7. double-checked locking"></a>7. double-checked locking</h2><p><strong>问题</strong>：会出现指令重排的现象，从而导致出现有序性问题</p><p><strong>解决方案</strong>：加上volatile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                    <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> INSTANCE;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>可见性<ul><li>写屏障保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li></ul><h2 id="8-happens-before"><a href="#8-happens-before" class="headerlink" title="8. happens-before"></a>8. happens-before</h2><p>happens-before <strong>规定了对共享变量的写操作对其它线程的读操作可见</strong>，它是<strong>可见性与有序性的一套规则总结</strong>，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程<strong>解锁 m 之前</strong>对变量的写，对于<strong>接下来对 m 加锁</strong>的其它线程对该变量的<strong>读可见</strong></li><li>线程对 <strong>volatile 变量的写</strong>，对接下来其它线程对该变量的<strong>读可见</strong></li><li>线程 <strong>start 前对变量的写</strong>，对该线程开始后对该变量的<strong>读可见</strong></li><li>线程<strong>结束前对变量的写</strong>，对其它线程<strong>得知它结束后的读可见</strong>（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li><li><strong>线程 t1 打断 t2（interrupt）前对变量的写</strong>，对于其他线程得知 t2 被打断后对变量的<strong>读可见</strong>（通过 t2.interrupted 或 t2.isInterrupted）</li><li>对变量<strong>默认值</strong>（0，false，null）的写，对其它线程对该变量的<strong>读可见</strong></li><li><strong>具有传递性</strong>，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><ul><li><p><strong>synchronized</strong>能保证代码的<strong>原子性、可见性、有序性</strong></p></li><li><p><strong>volatile</strong>能保证代码的<strong>可见性和有序性</strong></p></li><li><p>可见性 - 由 <strong>JVM 缓存优化</strong>引起</p></li><li><p>有序性 - 由 <strong>JVM 指令重排序优化</strong>引起</p></li></ul><h1 id="五-共享模型之无锁"><a href="#五-共享模型之无锁" class="headerlink" title="五. 共享模型之无锁"></a>五. 共享模型之无锁</h1><p>通过<strong>非阻塞式的乐观锁</strong>的来实现并发控制</p><h2 id="1-CAS与volatile"><a href="#1-CAS与volatile" class="headerlink" title="1. CAS与volatile"></a>1. CAS与volatile</h2><h3 id="1-1-CAS-compareAndSet"><a href="#1-1-CAS-compareAndSet" class="headerlink" title="1.1 CAS(compareAndSet)"></a>1.1 CAS(compareAndSet)</h3><p><strong>compareAndSet</strong>，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 需要不断尝试，直到成功为止</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">        compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span><br><span class="hljs-comment">        - 不一致了，next 作废，返回 false 表示失败</span><br><span class="hljs-comment">           比如，别的线程已经做了减法，当前值已经被减成了 990</span><br><span class="hljs-comment">           那么本线程的这次 990 就作废了，进入 while 下次循环重试</span><br><span class="hljs-comment">        - 一致，以 next 设置为新值，返回 true 表示成功</span><br><span class="hljs-comment">        */</span><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/jvm-juc/juc.5.1.png"></p><ul><li>CAS 的底层是  lock cmpxchg  指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性</li></ul><h3 id="1-2-volatile"><a href="#1-2-volatile" class="headerlink" title="1.2 volatile"></a>1.2 volatile</h3><ul><li>为了保证该变量的可见性，需要使用 volatile 修饰。</li><li><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></li></ul><h3 id="1-3-为什么无锁效率高"><a href="#1-3-为什么无锁效率高" class="headerlink" title="1.3 为什么无锁效率高"></a>1.3 为什么无锁效率高</h3><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇</li><li>而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</li></ul><h3 id="1-4-CAS-的特点"><a href="#1-4-CAS-的特点" class="headerlink" title="1.4 CAS 的特点"></a>1.4 CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，<strong>适用于线程数少、多核 CPU</strong> 的场景下。</p><ul><li>CAS 是基于<strong>乐观锁</strong>的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于<strong>悲观锁</strong>的思想：最悲观的估计，<strong>得防着其它线程来修改共享变量</strong>，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong><ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="2-原子整数"><a href="#2-原子整数" class="headerlink" title="2. 原子整数"></a>2. 原子整数</h2><p>J.U.C 并发包提供了：</p><ul><li>AtomicBoolean：布尔型原子类</li><li>AtomicInteger ： 整型原子类</li><li>AtomicLong：长整型原子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>    System.out.println(i.getAndIncrement());<br>    <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>    System.out.println(i.incrementAndGet());<br>    <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>    System.out.println(i.decrementAndGet());<br>    <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>    System.out.println(i.getAndDecrement());<br>    <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>    System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br>    <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>    System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br>    <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>    <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>    System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）</span><br>    <span class="hljs-comment">// 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用</span><br>    System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-原子引用"><a href="#3-原子引用" class="headerlink" title="3. 原子引用"></a>3. 原子引用</h2><p>保证<strong>引用类型</strong>的共享变量是线程安全的</p><ul><li>AtomicReference: 引用类型原子类</li><li>AtomicMarkableReference: 原子更新带有标记的引用类型</li><li>AtomicStampedReference； 原子更新带有版本号的引用类型</li></ul><h3 id="3-1-AtomicReference"><a href="#3-1-AtomicReference" class="headerlink" title="3.1 AtomicReference"></a>3.1 AtomicReference</h3><p>使用无锁的方式 CAS 来解决，解决方式是用 AtomicReference 原子引用解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">nextVal</span> <span class="hljs-operator">=</span> preVal.subtract(amount);<br>            <span class="hljs-keyword">if</span>(balance.compareAndSet(preVal, nextVal)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-ABA问题"><a href="#3-2-ABA问题" class="headerlink" title="3.2 ABA问题"></a>3.2 ABA问题</h3><p>ABA问题：主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种<strong>从 A 改为 B 又 改回 A 的情况</strong></p><h3 id="3-3-AtomicStampedReference"><a href="#3-3-AtomicStampedReference" class="headerlink" title="3.3 AtomicStampedReference"></a>3.3 AtomicStampedReference</h3><p>如果主线程希望只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong><br>使用 AtomicStampedReference 加 stamp （版本号或者时间戳）的方式解决 ABA 问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两个参数，第一个：变量的值 第二个：版本号初始值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">preVal</span> <span class="hljs-operator">=</span> ref.getReference();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.info(<span class="hljs-string">&quot;main 拿到的版本号 &#123;&#125;&quot;</span>,stamp);<br>        other();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;修改后的版本号 &#123;&#125;&quot;</span>,ref.getStamp());<br>        log.info(<span class="hljs-string">&quot;change A-&gt;C:&#123;&#125;&quot;</span>, ref.compareAndSet(preVal, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);<br>            log.info(<span class="hljs-string">&quot;change A-&gt;B:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>            log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,stamp);<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A:&#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>,stamp,stamp + <span class="hljs-number">1</span>));<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-AtomicMarkableReference"><a href="#3-4-AtomicMarkableReference" class="headerlink" title="3.4 AtomicMarkableReference"></a>3.4 AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：A -&gt; B -&gt; A -&gt;C，<strong>通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次</strong>。</p><p>但是有时候，并不关心引用变量更改了几次，只是<strong>单纯的关心是否更改过</strong>，所以就有了AtomicMarkableReference</p><h2 id="4-原子数组"><a href="#4-原子数组" class="headerlink" title="4. 原子数组"></a>4. 原子数组</h2><p>使用原子的方式更新数组里的某个元素，使用原子数组可以保证<strong>数组元素</strong>的线程安全。</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_10_AtomicArrayTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 结果如下：</span><br><span class="hljs-comment">         * [9934, 9938, 9940, 9931, 9935, 9933, 9944, 9942, 9939, 9940]</span><br><span class="hljs-comment">         * [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000]</span><br><span class="hljs-comment">         */</span><br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>                (array) -&gt; array.length,<br>                (array, index) -&gt; array[index]++,<br>                (array) -&gt; System.out.println(Arrays.toString(array))<br>        );<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        demo(<br>                () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                (array) -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">            Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; printConsumer)</span> &#123;<br>        ArrayList&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 创建集合</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get(); <span class="hljs-comment">// 获取数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array); <span class="hljs-comment">// 获取数组的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j % length);<br>                &#125;<br>            &#125;));<br>        &#125;<br>        ts.forEach(Thread::start);<br>        ts.forEach((thread) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        printConsumer.accept(array);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-字段更新器"><a href="#5-字段更新器" class="headerlink" title="5. 字段更新器"></a>5. 字段更新器</h2><p>利用字段更新器，可以针对<strong>对象的某个域</strong>（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p><ul><li><p>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域  字段</p></li><li><p>AtomicIntegerFieldUpdater</p></li><li><p>AtomicLongFieldUpdater</p></li><li><p>字段更新器就是为了<strong>保证类中某个属性</strong>线程安全问题。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> <br>        AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="hljs-string">&quot;field&quot;</span>);<br> <br>        <span class="hljs-type">Test5</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test5</span>();<br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br> <br>        <span class="hljs-comment">// 修改成功 field = 10</span><br>        System.out.println(test5.field);<br> <br>        <span class="hljs-comment">// 修改成功 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(test5.field);<br> <br>        <span class="hljs-comment">// 修改失败 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>        System.out.println(test5.field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-原子累加器"><a href="#6-原子累加器" class="headerlink" title="6. 原子累加器"></a>6. 原子累加器</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>AtomicLong Vs <strong>LongAdder</strong><br>执行代码后，发现使用 <strong>LongAdder</strong> 比 AtomicLong 快2，3倍，使用 LongAdder 性能提升</p><h3 id="6-2-原理"><a href="#6-2-原理" class="headerlink" title="6.2 原理"></a>6.2 原理</h3><p>性能提升的原因很简单，就是在有竞争时，<strong>设置多个累加单元</strong>，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… <strong>最后将结果汇总</strong>。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</p><h3 id="6-3-LongAdder源码"><a href="#6-3-LongAdder源码" class="headerlink" title="6.3  LongAdder源码"></a>6.3  LongAdder源码</h3><p>LongAdder 类有几个关键域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 累加单元数组, 懒惰初始化</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br> <br><span class="hljs-comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br> <br><span class="hljs-comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><h2 id="7-Unsafe"><a href="#7-Unsafe" class="headerlink" title="7. Unsafe"></a>7. Unsafe</h2><p>Unsafe 对象提供了非常底层的，<strong>操作内存、线程的方法</strong>，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><p><strong>通过反射获取Unsafe 对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br><span class="hljs-comment">// Unsafe 使用了单例模式，unsafe 对象是类中的一个私有的变量 </span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)theUnsafe.get(<span class="hljs-literal">null</span>);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>Unsafe 模拟实现 cas 操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_14_UnsafeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br><br>        <span class="hljs-comment">// 创建 unsafe 对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe)theUnsafe.get(<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 拿到偏移量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>        <span class="hljs-comment">// 进行 cas 操作</span><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        unsafe.compareAndSwapLong(teacher, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        unsafe.compareAndSwapObject(teacher, nameOffset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;lisi&quot;</span>);<br><br>        System.out.println(teacher);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-本章总结"><a href="#8-本章总结" class="headerlink" title="8. 本章总结"></a>8. 本章总结</h2><ul><li>CAS 与 volatile</li><li>juc 包下 API<ul><li>原子整数</li><li>原子引用</li><li>原子数组</li><li>字段更新器</li><li>原子累加器</li></ul></li><li>Unsafe</li></ul><h1 id="六-共享模型之不可变"><a href="#六-共享模型之不可变" class="headerlink" title="六. 共享模型之不可变"></a>六. 共享模型之不可变</h1><p>不可变类的对象，因为无法修改共享成员的状态，所以不会有线程安全问题</p><ul><li>不可变类的使用</li><li>不可变类设计</li><li>无状态类设计</li></ul><h2 id="1-不可变类的使用"><a href="#1-不可变类的使用" class="headerlink" title="1. 不可变类的使用"></a>1. 不可变类的使用</h2><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的<br>在 Java 8 后，提供了一个新的日期格式化类 DateTimeFormatter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dtf</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> dtf.parse(<span class="hljs-string">&quot;2018-10-01&quot;</span>, LocalDate::from);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, date);<br>        &#125;).start();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-不可变类的设计-以String类为例"><a href="#2-不可变类的设计-以String类为例" class="headerlink" title="2. 不可变类的设计(以String类为例)"></a>2. 不可变类的设计(以String类为例)</h2><p>String 类是不可变的</p><h3 id="2-1-final-的使用"><a href="#2-1-final-的使用" class="headerlink" title="2.1 final 的使用"></a>2.1 final 的使用</h3><p>发现该类、类中所有属性都是 final 的</p><ul><li>属性用 final 修饰保证了<strong>该属性是只读的</strong>，不能修改</li><li>类用 final 修饰,<strong>没有子类继承</strong>，保证了该类中的<strong>方法不能被覆盖</strong>，防止子类无意间破坏不可变性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br> <br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// Default to 0</span><br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-保护性拷贝"><a href="#2-2-保护性拷贝" class="headerlink" title="2.2 保护性拷贝"></a>2.2 保护性拷贝</h3><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> value.length - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong><br>构造新字符串对象时，会生成新的 char[] value，对内容进行<strong>复制</strong> 。这种通过<strong>创建副本对象来避免共享</strong>的手段称之为【保护性拷贝，defensive copy】</p><h2 id="3-享元模式"><a href="#3-享元模式" class="headerlink" title="3. 享元模式"></a>3. 享元模式</h2><p>Flyweight pattern. 当需要重用数量有限的同一类对象时</p><h3 id="3-1-体现"><a href="#3-1-体现" class="headerlink" title="3.1 体现"></a>3.1 体现</h3><p><strong>包装类</strong>、<strong>String 串池</strong>、<strong>BigDecimal BigInteger</strong></p><ul><li>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的valueOf 会<strong>缓存 -128~127 之间的 Long 对象</strong>，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">long</span> l)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">if</span> (l &gt;= -<span class="hljs-number">128</span> &amp;&amp; l &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// will cache</span><br>        <span class="hljs-keyword">return</span> LongCache.cache[(<span class="hljs-type">int</span>)l + offset];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(l);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Byte, Short, Long 缓存的范围都是 -128~127</li><li>Character 缓存的范围是 0~127</li><li>Integer的默认范围是 -128~127</li><li>Boolean 缓存了 TRUE 和 FALSE</li></ul><h3 id="3-2-DIY-实现简单的数据库连接池"><a href="#3-2-DIY-实现简单的数据库连接池" class="headerlink" title="3.2 DIY 实现简单的数据库连接池"></a>3.2 DIY 实现简单的数据库连接池</h3><p>一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_17_DatabaseConnectionPoolTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(connection);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br><br>    <span class="hljs-comment">// 连接池的大小, 因为没有实现连接池大小的扩容, 用 final 表示池的大小是一个固定值。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>    <span class="hljs-comment">// 连接池</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br>    <span class="hljs-comment">// 表示连接状态, 如果是 0 表示没连接, 1 表示有连接</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray status;<br>    <span class="hljs-comment">// 初始化连接池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        status = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从连接池中获取连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == status.get(i)) &#123;<br>                    <span class="hljs-keyword">if</span>(status.compareAndSet(i,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.info(<span class="hljs-string">&quot;获取连接:&#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;wait ...&quot;</span>);<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从连接池中释放指定的连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection connection)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span>(connections[i] == connection) &#123;<br>                status.set(i, <span class="hljs-number">0</span>);<br>                log.info(<span class="hljs-string">&quot;释放连接:&#123;&#125;&quot;</span>, connections[i]);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockConnection</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-final的原理"><a href="#4-final的原理" class="headerlink" title="4. final的原理"></a>4. final的原理</h2><h3 id="4-1-设置-final-变量的原理"><a href="#4-1-设置-final-变量的原理" class="headerlink" title="4.1 设置 final 变量的原理"></a>4.1 设置 final 变量的原理</h3><p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFinal</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会<strong>加入写屏障</strong>，保证在其它线程读到它的值时不会出现为 0 的情况</p><h3 id="4-2-获取-final-变量的原理"><a href="#4-2-获取-final-变量的原理" class="headerlink" title="4.2 获取 final 变量的原理"></a>4.2 获取 final 变量的原理</h3><p><a href="https://blog.csdn.net/qq_42651904/article/details/87708198?ops_request_misc=%257B%2522request%255Fid%2522%253A%252203d3d48b5d881880308676771f04918a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=03d3d48b5d881880308676771f04918a&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-87708198-null-null.nonecase&utm_term=%E6%B7%B1%E5%85%A5final%E5%85%B3%E9%94%AE%E5%AD%97&spm=1018.2226.3001.4450">深入理解final关键字</a></p><h2 id="5-无状态"><a href="#5-无状态" class="headerlink" title="5. 无状态"></a>5. 无状态</h2><p>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种<strong>没有任何成员变量的类</strong>是线程安全的</p><ul><li>因为成员变量保存的数据也可以称为状态信息，因此<strong>没有成员变量</strong>就称之为【<strong>无状态</strong>】</li></ul><h1 id="七-共享模型之工具"><a href="#七-共享模型之工具" class="headerlink" title="七. 共享模型之工具"></a>七. 共享模型之工具</h1><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><p>池化技术的思想主要是为了<strong>减少每次获取资源的消耗，提高对资源的利用率</strong>。<br>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="1-1-自定义线程池"><a href="#1-1-自定义线程池" class="headerlink" title="1.1 自定义线程池"></a>1.1 自定义线程池</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.1.png"></p><ol><li>先初始化线程池、阻塞队列大小</li><li>开几个线程通过线程池对象调用方法执行任务，线程池中的线程会执行任务</li><li>如果<strong>任务过多，会添加到阻塞队列</strong>中，执行完任务再从阻塞队列中取值继续执行</li><li>当执行的<strong>线程数大于线程池和阻塞队列的大小</strong>，我们可以定义<strong>拒绝策略</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义线程池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Code_01_TestPool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Code_01_ThreadPoolTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPool</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPool</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS, <span class="hljs-number">1</span>,<br>                (queue, task) -&gt; &#123;<br>                    <span class="hljs-comment">// 1. 阻塞等待。</span><br><span class="hljs-comment">//                    queue.put(task);</span><br>                    <span class="hljs-comment">// 2. 带超时的等待</span><br><span class="hljs-comment">//                    queue.offer(task, 500, TimeUnit.MILLISECONDS);</span><br>                    <span class="hljs-comment">// 3. 调用者放弃</span><br><span class="hljs-comment">//                    log.info(&quot;放弃 &#123;&#125;&quot;, task);</span><br>                    <span class="hljs-comment">// 4. 调用者抛出异常</span><br><span class="hljs-comment">//                    throw new RuntimeException(&quot;任务执行失败&quot; + task);</span><br>                    <span class="hljs-comment">// 5. 调用者自己执行任务</span><br>                    task.run();<br>                &#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            threadPool.executor(() -&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, j);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">// 拒绝策略</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span>;<br>&#125;<br><br><span class="hljs-comment">// 实现线程池</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> Set&lt;Worker&gt; works = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Worker&gt;();<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br>    <span class="hljs-comment">// 线程池的核心数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br>    <span class="hljs-comment">// 获取任务的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br>    <span class="hljs-keyword">private</span> TimeUnit unit;<br>    <span class="hljs-comment">// 使用策略模式。</span><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit unit, <span class="hljs-type">int</span> queueCapacity,</span><br><span class="hljs-params">                      RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.unit = unit;<br>        taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapacity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executor</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">// 如果线程池满了. 就将任务加入到任务队列, 否则执行任务</span><br>        <span class="hljs-keyword">synchronized</span> (works) &#123;<br>            <span class="hljs-keyword">if</span>(works.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.info(<span class="hljs-string">&quot;新增 worker &#123;&#125; ，任务 &#123;&#125;&quot;</span>, worker, task);<br>                works.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//                taskQueue.put(task);</span><br>                <span class="hljs-comment">// 1）死等</span><br>                <span class="hljs-comment">// 2）带超时等待</span><br>                <span class="hljs-comment">// 3）让调用者放弃任务执行</span><br>                <span class="hljs-comment">// 4）让调用者抛出异常</span><br>                <span class="hljs-comment">// 5）让调用者自己执行任务</span><br><br>                taskQueue.tryPut(rejectPolicy, task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-comment">// 执行任务</span><br>        <span class="hljs-comment">// 1）当 task 不为空，执行任务</span><br>        <span class="hljs-comment">// 2）当 task 执行完毕，再接着从任务队列获取任务并执行</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//            while (task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, unit)) != <span class="hljs-literal">null</span>) &#123;<br>                 <span class="hljs-keyword">try</span> &#123; <br>                     log.info(<span class="hljs-string">&quot;正在执行 &#123;&#125;&quot;</span>, task);<br>                     task.run();<br>                 &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>                 &#125; <span class="hljs-keyword">finally</span> &#123;<br>                     task = <span class="hljs-literal">null</span>;<br>                 &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (works) &#123;<br>                log.info(<span class="hljs-string">&quot;worker 被移除 &#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                works.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现阻塞队列</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">// 阻塞队列的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-comment">// 双端链表, 从头取, 从尾加</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue;<br>    <span class="hljs-comment">// 定义锁</span><br>    <span class="hljs-keyword">private</span> ReentrantLock lock;<br>    <span class="hljs-comment">// 当阻塞队列满了时候, 去 fullWaitSet 休息, 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> Condition fullWaitSet;<br>    <span class="hljs-comment">// 当阻塞队列空了时候，去 emptyWaitSet 休息, 消费者小件变量</span><br>    <span class="hljs-keyword">private</span> Condition emptyWaitSet;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(capacity);<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        fullWaitSet = lock.newCondition();<br>        emptyWaitSet = lock.newCondition();<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-comment">// 带有超时时间的获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 同一时间单位</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 防止虚假唤醒, 返回的是所剩时间</span><br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125;&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 带有超时时间的添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.info(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125;&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.info(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断判断是否满</span><br>            <span class="hljs-keyword">if</span>(queue.size() == capacity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 有空闲</span><br>                log.info(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-ThreadPoolExecutor"><a href="#1-2-ThreadPoolExecutor" class="headerlink" title="1.2 ThreadPoolExecutor"></a>1.2 ThreadPoolExecutor</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.2.png"></p><h4 id="1-2-1-线程池状态"><a href="#1-2-1-线程池状态" class="headerlink" title="1.2.1 线程池状态"></a>1.2.1 线程池状态</h4><p>ThreadPoolExecutor 使用 int 的<strong>高 3 位来表示线程池状态</strong>，低 29 位表示线程数量</p><table><thead><tr><th>状态名称</th><th>高3位的值</th><th>描述</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>接收新任务，同时处理任务队列中的任务</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>不接受新任务，但是处理任务队列中的任务</td></tr><tr><td>STOP</td><td>001</td><td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td></tr><tr><td>TIDYING</td><td>010</td><td>任务执行完毕，活动线程为0时，即将进入终结阶段</td></tr><tr><td>TERMINATED</td><td>011</td><td>终结状态</td></tr></tbody></table><p>这些信息存储在<strong>一个</strong>原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以<strong>用一次 cas 原子操作</strong>进行赋值</p><h4 id="1-2-2-构造方法"><a href="#1-2-2-构造方法" class="headerlink" title="1.2.2 构造方法"></a>1.2.2 构造方法</h4><p>ThreadPoolExecutor 类参数最多、最全的有参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span><br></code></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.3.png"></p><ul><li>当核心线程被用完了，并且任务太多了，阻塞队列放不下，这个时候<strong>救急线程就会被启用来处理任务</strong>。</li><li><strong>核心线程</strong>永远不会超时，一直运行；<strong>救急线程</strong>会超时，超时被关闭</li></ul><p><strong>工作流程</strong>：</p><ol><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li><li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</li><li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。</li><li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制</li></ol><p><strong>拒绝策略</strong>：<br>jdk 提供了 4 种实现，其它著名框架也提供了实现</p><ol><li><strong>AbortPolicy</strong> 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li><strong>CallerRunsPolicy</strong> 让调用者运行任务</li><li><strong>DiscardPolicy</strong> 放弃本次任务</li><li><strong>DiscardOldestPolicy</strong> 放弃队列中最早的任务，本任务取而代之</li></ol><ul><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.4.png"></p><h4 id="1-2-3-newFixedThreadPool"><a href="#1-2-3-newFixedThreadPool" class="headerlink" title="1.2.3  newFixedThreadPool"></a>1.2.3  newFixedThreadPool</h4><p>适用于<strong>任务量已知，相对耗时</strong>的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>核心线程数 &#x3D;&#x3D; 最大线程数</strong>（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><h4 id="1-2-4-newCachedThreadPool"><a href="#1-2-4-newCachedThreadPool" class="headerlink" title="1.2.4  newCachedThreadPool"></a>1.2.4  newCachedThreadPool</h4><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 <strong>适合任务数比较密集，但每个任务执行时间较短</strong>的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>核心线程数是 0</strong>， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<strong>全部都是救急线程</strong>（60s 后可以回收）</li><li>救急线程可以无限创建</li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li></ul><h4 id="1-2-5-newSingleThreadExecutor"><a href="#1-2-5-newSingleThreadExecutor" class="headerlink" title="1.2.5  newSingleThreadExecutor"></a>1.2.5  newSingleThreadExecutor</h4><p>适用于<strong>多个任务排队执行（串行）</strong>。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>区别：</p><ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul><h4 id="1-2-6-提交任务"><a href="#1-2-6-提交任务" class="headerlink" title="1.2.6 提交任务"></a>1.2.6 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行任务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>;<br><span class="hljs-comment">// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br><span class="hljs-comment">// 提交 tasks 中所有任务</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，带超时时间</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br><span class="hljs-comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<br></code></pre></td></tr></table></figure><h4 id="1-2-7-关闭线程池"><a href="#1-2-7-关闭线程池" class="headerlink" title="1.2.7 关闭线程池"></a>1.2.7 关闭线程池</h4><h5 id="1-2-7-1-shutdown"><a href="#1-2-7-1-shutdown" class="headerlink" title="1.2.7.1 shutdown"></a>1.2.7.1 shutdown</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 SHUTDOWN</span><br><span class="hljs-comment"> - 不会接收新任务</span><br><span class="hljs-comment"> - 但已提交任务会执行完</span><br><span class="hljs-comment"> - 此方法不会阻塞调用线程的执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h5 id="1-2-7-2-shutdownNow"><a href="#1-2-7-2-shutdownNow" class="headerlink" title="1.2.7.2 shutdownNow"></a>1.2.7.2 shutdownNow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">线程池状态变为 STOP</span><br><span class="hljs-comment"> - 不会接收新任务</span><br><span class="hljs-comment"> - 会将队列中的任务返回</span><br><span class="hljs-comment"> - 并用 interrupt 的方式中断正在执行的任务</span><br><span class="hljs-comment">*/</span><br>List&lt;Runnable&gt; <span class="hljs-title function_">shutdownNow</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h5 id="1-2-7-3-其他方法"><a href="#1-2-7-3-其他方法" class="headerlink" title="1.2.7.3 其他方法"></a>1.2.7.3 其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdown</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">// 线程池状态是否是 TERMINATED</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isTerminated</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitTermination</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><h4 id="1-2-8-任务调度线程池"><a href="#1-2-8-任务调度线程池" class="headerlink" title="1.2.8 任务调度线程池"></a>1.2.8 任务调度线程池</h4><p>线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来<strong>执行延迟或反复执行的任务</strong></p><ul><li>ScheduledExecutorService 中 scheduleAtFixedRate 方法的使用，是 一段时间 的 期间。</li><li>ScheduledExecutorService 中 scheduleWithFixedDelay 方法的使用，是 一段时间 的 间隔。</li></ul><h4 id="1-2-9-正确处理执行任务异常"><a href="#1-2-9-正确处理执行任务异常" class="headerlink" title="1.2.9 正确处理执行任务异常"></a>1.2.9 正确处理执行任务异常</h4><ul><li>方法1：主动捉异常,try catch</li><li>方法2：使用 Future，错误信息都被封装进submit方法的返回方法中</li></ul><h4 id="1-2-10-Tomcat-线程池"><a href="#1-2-10-Tomcat-线程池" class="headerlink" title="1.2.10  Tomcat 线程池"></a>1.2.10  Tomcat 线程池</h4><p><img src="/img/blogs/java/jvm-juc/juc.7.5.png"></p><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的  Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I&#x2F;O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li><p>如果总线程数达到 maximumPoolSize</p><ul><li>这时不会立刻抛 RejectedExecutionException 异常</li><li>而是再次<strong>尝试将任务放入队列</strong>，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li><li><p>当添加新的任务时，如果提交的任务大于核心线程数，小于最大线程数就创建救急线程，否则就加入任务队列中：</p></li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.6.png"></p><h3 id="1-3-异步模式之工作线程"><a href="#1-3-异步模式之工作线程" class="headerlink" title="1.3 异步模式之工作线程"></a>1.3 异步模式之工作线程</h3><h4 id="1-3-1-定义"><a href="#1-3-1-定义" class="headerlink" title="1.3.1 定义"></a>1.3.1 定义</h4><p>让<strong>有限的工作线程来轮流异步处理无限多的任务</strong>。也可以将其归类为分工模式，它的典型实现就是线程池，也体现了经典设计模式中的享元模式。</p><ul><li>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</li></ul><p>注意，<strong>不同任务类型应该使用不同的线程池</strong>，这样能够<strong>避免饥饿</strong>，并能提升效率</p><ul><li>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</li></ul><h4 id="1-3-2-饥饿"><a href="#1-3-2-饥饿" class="headerlink" title="1.3.2 饥饿"></a>1.3.2 饥饿</h4><ul><li>固定大小线程池会有饥饿现象<ul><li>两个工人是同一个线程池中的两个线程</li><li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作</li><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li><li>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</li><li>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</li></ul></li></ul><h4 id="1-3-3-创建多少线程池合适"><a href="#1-3-3-创建多少线程池合适" class="headerlink" title="1.3.3 创建多少线程池合适"></a>1.3.3 创建多少线程池合适</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h5 id="1-3-3-1-CPU-密集型运算"><a href="#1-3-3-1-CPU-密集型运算" class="headerlink" title="1.3.3.1 CPU 密集型运算"></a>1.3.3.1 CPU 密集型运算</h5><p>通常采用  <code>cpu 核数 + 1</code>  能够实现<strong>最优的 CPU 利用率</strong>，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><h5 id="1-3-3-2-I-O-密集型运算"><a href="#1-3-3-2-I-O-密集型运算" class="headerlink" title="1.3.3.2 I&#x2F;O 密集型运算"></a>1.3.3.2 I&#x2F;O 密集型运算</h5><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p><p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p><ul><li>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式<br><code>4 * 100% * 100% / 10% = 40</code></li></ul><h3 id="1-4-Fork-Join-线程池"><a href="#1-4-Fork-Join-线程池" class="headerlink" title="1.4 Fork&#x2F;Join 线程池"></a>1.4 Fork&#x2F;Join 线程池</h3><h4 id="1-4-1-概念"><a href="#1-4-1-概念" class="headerlink" title="1.4.1 概念"></a>1.4.1 概念</h4><ul><li>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种<strong>分治思想</strong>，<strong>适用于能够进行任务拆分的 cpu 密集型运算</strong></li><li>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</li><li>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</li><li>Fork&#x2F;Join 默认会<strong>创建与 cpu 核心数大小相同</strong>的线程池</li></ul><h4 id="1-4-2-使用"><a href="#1-4-2-使用" class="headerlink" title="1.4.2 使用"></a>1.4.2 使用</h4><p>提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务</p><p><img src="/img/blogs/java/jvm-juc/juc.7.7.png"></p><h2 id="2-J-U-C-java-util-concurrent"><a href="#2-J-U-C-java-util-concurrent" class="headerlink" title="2. J.U.C(java.util.concurrent)"></a>2. J.U.C(java.util.concurrent)</h2><h3 id="2-1-AQS-原理"><a href="#2-1-AQS-原理" class="headerlink" title="2.1 AQS 原理"></a>2.1 AQS 原理</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁</span><br><span class="hljs-comment">// 如果获取锁失败</span><br><span class="hljs-keyword">if</span> (!tryAcquire(arg)) &#123;<br>    <span class="hljs-comment">// 入队, 可以选择阻塞当前线程  park unpark</span><br>&#125;<br><br><span class="hljs-comment">//释放锁</span><br><span class="hljs-comment">// 如果释放锁成功</span><br><span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>    <span class="hljs-comment">// 让阻塞线程恢复运行</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-ReentrantLock-原理"><a href="#2-2-ReentrantLock-原理" class="headerlink" title="2.2 ReentrantLock 原理"></a>2.2 ReentrantLock 原理</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.8.png"></p><h4 id="2-2-1-非公平锁实现原理"><a href="#2-2-1-非公平锁实现原理" class="headerlink" title="2.2.1 非公平锁实现原理"></a>2.2.1 非公平锁实现原理</h4><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>       sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<span class="hljs-comment">//NonfairSync 继承自 AQS</span><br>   &#125;<br></code></pre></td></tr></table></figure><ul><li>没有竞争时</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.9.png"></p><ul><li>第一个竞争出现时</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.10.png"></p><p>Thread-1 执行了</p><ol><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul></li></ol><p><img src="/img/blogs/java/jvm-juc/juc.7.11.png"></p><p>当前线程进入 acquireQueued 逻辑</p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.7.12.png"></p><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.7.13.png"></p><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><p><img src="/img/blogs/java/jvm-juc/juc.7.14.png"></p><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state &#x3D; 0</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.15.png"></p><ul><li>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程</li><li>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为Thread-1</li><li>回到 Thread-1 的 acquireQueued 流程</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.16.png"></p><p>如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收<br>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.17.png"></p><p>如果不巧又被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h4 id="2-2-2-可重入原理"><a href="#2-2-2-可重入原理" class="headerlink" title="2.2.2 可重入原理"></a>2.2.2 可重入原理</h4><ul><li>加锁时：每增加一个锁，状态加一，state++</li><li>解锁时：解锁一层，state–；直到为0才释放锁</li></ul><h4 id="2-2-3-可打断原理"><a href="#2-2-3-可打断原理" class="headerlink" title="2.2.3 可打断原理"></a>2.2.3 可打断原理</h4><ul><li>不可打断模式： 在此模式下，即使它被打断，仍<strong>会驻留在 AQS 队列</strong>中，一直要等到获得锁后方能得知自己被打断了</li><li>可打断模式： 在 park 过程中如果被 interrupt ，这时候<strong>抛出异常</strong>, 而不会再次进入 for (;;)</li></ul><h4 id="2-2-4-公平锁实现原理"><a href="#2-2-4-公平锁实现原理" class="headerlink" title="2.2.4 公平锁实现原理"></a>2.2.4 公平锁实现原理</h4><p>公平锁： 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</p><h4 id="2-2-5-条件变量实现原理"><a href="#2-2-5-条件变量实现原理" class="headerlink" title="2.2.5 条件变量实现原理"></a>2.2.5 条件变量实现原理</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><h5 id="2-2-5-1-await-流程"><a href="#2-2-5-1-await-流程" class="headerlink" title="2.2.5.1 await 流程"></a>2.2.5.1 await 流程</h5><ul><li>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</li><li>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.18.png"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="/img/blogs/java/jvm-juc/juc.7.19.png"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="/img/blogs/java/jvm-juc/juc.7.20.png"></p><p>park 阻塞 Thread-0</p><p><img src="/img/blogs/java/jvm-juc/juc.7.21.png"></p><h5 id="2-2-5-2-signal-流程"><a href="#2-2-5-2-signal-流程" class="headerlink" title="2.2.5.2 signal 流程"></a>2.2.5.2 signal 流程</h5><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="/img/blogs/java/jvm-juc/juc.7.22.png"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="/img/blogs/java/jvm-juc/juc.7.23.png"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><p><img src="/img/blogs/java/jvm-juc/juc.7.24.png"></p><p>Thread-1 释放锁，进入 unlock 流程，略</p><h3 id="2-3-读写锁"><a href="#2-3-读写锁" class="headerlink" title="2.3 读写锁"></a>2.3 读写锁</h3><h4 id="2-3-1-ReentrantReadWriteLock"><a href="#2-3-1-ReentrantReadWriteLock" class="headerlink" title="2.3.1 ReentrantReadWriteLock"></a>2.3.1 ReentrantReadWriteLock</h4><p>当读操作远远高于写操作时，这时候<strong>使用读写锁让读-读可以并发</strong>，提高性能。 类似于数据库中的  <code>select ...from ... lock in share mode</code></p><ul><li>读锁<strong>不支持条件变量</strong></li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li><li>重入时降级支持：即持有写锁的情况下去获取读锁</li></ul><h4 id="2-3-2-应用之缓存"><a href="#2-3-2-应用之缓存" class="headerlink" title="2.3.2 应用之缓存"></a>2.3.2 应用之缓存</h4><h5 id="2-3-2-1-缓存更新策略"><a href="#2-3-2-1-缓存更新策略" class="headerlink" title="2.3.2.1 缓存更新策略"></a>2.3.2.1 缓存更新策略</h5><p>更新时，是先清缓存还是先更新数据库？</p><ul><li>先清除缓存:</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.25.png"></p><ul><li>先更新数据库(推荐)</li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.26.png"></p><h5 id="2-3-2-2-读写锁实现一致性缓存"><a href="#2-3-2-2-读写锁实现一致性缓存" class="headerlink" title="2.3.2.2 读写锁实现一致性缓存"></a>2.3.2.2 读写锁实现一致性缓存</h5><p>使用读写锁可以实现一个简单的按需加载缓存，保证缓存和数据库的一致性</p><h4 id="2-3-3-StampedLock"><a href="#2-3-3-StampedLock" class="headerlink" title="2.3.3 StampedLock"></a>2.3.3 StampedLock</h4><p>该类自 JDK 8 加入，是为了<strong>进一步优化读性能</strong>，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p><strong>加解读锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.readLock();<br>lock.unlockRead(stamp);<br></code></pre></td></tr></table></figure><p><strong>加解写锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>lock.unlockWrite(stamp);<br></code></pre></td></tr></table></figure><p><strong>乐观读</strong>: StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br><span class="hljs-comment">// 验戳</span><br><span class="hljs-keyword">if</span>(!lock.validate(stamp))&#123;<br> <span class="hljs-comment">// 锁升级</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ul><h3 id="2-4-读写锁原理"><a href="#2-4-读写锁原理" class="headerlink" title="2.4 读写锁原理"></a>2.4 读写锁原理</h3><p>读写锁用的是同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p><h4 id="2-4-1-t1-w-lock，t2-r-lock"><a href="#2-4-1-t1-w-lock，t2-r-lock" class="headerlink" title="2.4.1 t1 w.lock，t2 r.lock"></a>2.4.1 t1 w.lock，t2 r.lock</h4><ol><li>t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁使用的是 state 的高 16 位</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.7.27.png"></p><ol start="2"><li>t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写锁占据，那么 tryAcquireShared 返回 -1 表示失败</li></ol><ul><li>tryAcquireShared 返回值表示<ul><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li></ul></li></ul><p><img src="/img/blogs/java/jvm-juc/juc.7.28.png"></p><ol start="3"><li>这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.7.29.png"></p><ol start="4"><li>t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</li><li>如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</li></ol><p><img src="/img/blogs/java/jvm-juc/juc.7.30.png"></p><h4 id="2-4-2-t3-r-lock，t4-w-lock"><a href="#2-4-2-t3-r-lock，t4-w-lock" class="headerlink" title="2.4.2 t3 r.lock，t4 w.lock"></a>2.4.2 t3 r.lock，t4 w.lock</h4><p>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p><p><img src="/img/blogs/java/jvm-juc/juc.7.31.png"></p><h4 id="2-4-3-t1-w-unlock"><a href="#2-4-3-t1-w-unlock" class="headerlink" title="2.4.3 t1 w.unlock"></a>2.4.3 t1 w.unlock</h4><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p><p><img src="/img/blogs/java/jvm-juc/juc.7.32.png"></p><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行<br>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="/img/blogs/java/jvm-juc/juc.7.33.png"></p><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="/img/blogs/java/jvm-juc/juc.7.34.png"></p><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在doAcquireShared 内parkAndCheckInterrupt() 处恢复运行</p><p><img src="/img/blogs/java/jvm-juc/juc.7.35.png"></p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><p><img src="/img/blogs/java/jvm-juc/juc.7.36.png"></p><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><p><img src="/img/blogs/java/jvm-juc/juc.7.37.png"></p><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p><h4 id="2-4-4-t2-r-unlock，t3-r-unlock"><a href="#2-4-4-t2-r-unlock，t3-r-unlock" class="headerlink" title="2.4.4 t2 r.unlock，t3 r.unlock"></a>2.4.4 t2 r.unlock，t3 r.unlock</h4><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p><p><img src="/img/blogs/java/jvm-juc/juc.7.38.png"></p><p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p><p><img src="/img/blogs/java/jvm-juc/juc.7.39.png"></p><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><p><img src="/img/blogs/java/jvm-juc/juc.7.40.png"></p><h3 id="2-5-Semaphore"><a href="#2-5-Semaphore" class="headerlink" title="2.5 Semaphore"></a>2.5 Semaphore</h3><h4 id="2-5-1-定义"><a href="#2-5-1-定义" class="headerlink" title="2.5.1 定义"></a>2.5.1 定义</h4><p>信号量，<strong>用来限制能同时访问共享资源的线程上限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建一个对象</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 2. 开 10 个线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">// 获取一个许可</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;start ...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.info(<span class="hljs-string">&quot;end ....&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;t&quot;</span> + (i + <span class="hljs-number">1</span>)).start();;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-2-semaphore应用"><a href="#2-5-2-semaphore应用" class="headerlink" title="2.5.2 semaphore应用"></a>2.5.2 semaphore应用</h4><p><strong>限制对共享资源的使用</strong></p><ul><li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数</li><li>用  Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好，注意下面的实现中<strong>线程数和数据库连接数是相等的</strong></li></ul><h4 id="2-5-3-Semaphore-原理"><a href="#2-5-3-Semaphore-原理" class="headerlink" title="2.5.3 Semaphore 原理"></a>2.5.3 Semaphore 原理</h4><p><strong>加锁解锁流程</strong><br><strong>Semaphore 有点像一个停车场</strong>，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后停车场显示空余车位减一<br>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p><p><img src="/img/blogs/java/jvm-juc/juc.7.41.png"></p><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p><p><img src="/img/blogs/java/jvm-juc/juc.7.42.png"></p><p>这时 Thread-4 释放了 permits，状态如下</p><p><img src="/img/blogs/java/jvm-juc/juc.7.43.png"></p><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><p><img src="/img/blogs/java/jvm-juc/juc.7.44.png"></p><h3 id="2-6-CountdownLatch"><a href="#2-6-CountdownLatch" class="headerlink" title="2.6 CountdownLatch"></a>2.6 CountdownLatch</h3><p><strong>倒计时锁</strong></p><ul><li>CountDownLatch 允许多线程<strong>阻塞在一个地方</strong>，<strong>直至所有线程的任务都执行完毕</strong>。</li><li>用来进行线程同步协作，等待所有线程完成倒计时。</li><li>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</li><li>直至最后一个线程调用了 countDown ，使得 state &#x3D;&#x3D; 0，于是阻塞的线程便判断成功，全部往下执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br> <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1.5</span>);<br>        latch.countDown();<br>        log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>    &#125;).start();<br> <br>    log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    latch.await();<br>    log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>应用之同步等待多线程准备完毕</li><li>应用之同步等待多个远程调用结束</li></ul><h3 id="2-7-CyclicBarrier"><a href="#2-7-CyclicBarrier" class="headerlink" title="2.7 CyclicBarrier"></a>2.7 CyclicBarrier</h3><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><ul><li>跟 CountdownLatch 一样，但<strong>这个可以重用</strong>。</li></ul><h3 id="2-8-线程安全集合类概述"><a href="#2-8-线程安全集合类概述" class="headerlink" title="2.8 线程安全集合类概述"></a>2.8 线程安全集合类概述</h3><p><img src="/img/blogs/java/jvm-juc/juc.7.45.png"></p><p>线程安全集合类可以分为三大类：</p><ol><li>遗留的线程安全集合如  Hashtable ， Vector</li><li>使用 Collections 装饰的线程安全集合，如：<ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet    </li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li>java.util.concurrent.*</li></ol><p>重点介绍 java.util.concurrent.*  下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<strong>Blocking、CopyOnWrite、Concurrent</strong></p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul></li></ul></li></ul><p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p><h3 id="2-9-ConcurrentHashMap原理"><a href="#2-9-ConcurrentHashMap原理" class="headerlink" title="2.9 ConcurrentHashMap原理"></a>2.9 ConcurrentHashMap原理</h3><p>对HashMap的原子化类</p><p><strong>JDK 8 ConcurrentHashMap</strong>：<br><strong>重要属性和内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认为 0</span><br><span class="hljs-comment">// 当初始化时, 为 -1</span><br><span class="hljs-comment">// 当扩容时, 为 -(1 + 扩容线程数)</span><br><span class="hljs-comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> sizeCtl;<br> <br><span class="hljs-comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// hash 表</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] table;<br> <br><span class="hljs-comment">// 扩容时的 新 hash 表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<br> <br><span class="hljs-comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReservationNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// 作为 treebin 的头节点, 存储 root 和 first</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br> <br><span class="hljs-comment">// 作为 treebin 的节点, 存储 parent, left, right</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>重要方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Node[] 中第 i 个 Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="hljs-title function_">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i)</span><br>    <br><span class="hljs-comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span><br>    <br><span class="hljs-comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> i, Node&lt;K,V&gt; v)</span><br></code></pre></td></tr></table></figure><p>Java 8 <strong>数组（Node） +（ 链表 Node | 红黑树 TreeNode</strong> ） 以下数组简称（table），链表简称（bin）</p><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1&#x2F;6 的节点会把复制到新 table 中</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</li></ul><h3 id="2-10-LinkedBlockingQueue"><a href="#2-10-LinkedBlockingQueue" class="headerlink" title="2.10 LinkedBlockingQueue"></a>2.10 LinkedBlockingQueue</h3><h4 id="2-10-1-基本的入队出队"><a href="#2-10-1-基本的入队出队" class="headerlink" title="2.10.1 基本的入队出队"></a>2.10.1 基本的入队出队</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * One of:</span><br><span class="hljs-comment">         * - the real successor Node(真正的后继节点)</span><br><span class="hljs-comment">         * - this Node, meaning the successor is head.next(自己, 发生在出队的时候)</span><br><span class="hljs-comment">         * - null, meaning there is no successor (this is the last node)(null, 表示没有后继节点, 是最后了)</span><br><span class="hljs-comment">         */</span><br>        Node&lt;E&gt; next;<br><br>        Node(E x) &#123; item = x; &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node&lt;E&gt; node)</span> &#123;<br>      <span class="hljs-comment">// assert putLock.isHeldByCurrentThread();</span><br>      <span class="hljs-comment">// assert last.next == null;</span><br>      last = last.next = node;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-10-2-加锁分析"><a href="#2-10-2-加锁分析" class="headerlink" title="2.10.2 加锁分析"></a>2.10.2 加锁分析</h4><p>高明之处在于<strong>用了两把锁和 dummy 节点</strong></p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p><strong>线程安全分析</strong></p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用于 put(阻塞) offer(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-comment">// 用户 take(阻塞) poll(非阻塞)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br></code></pre></td></tr></table></figure><h4 id="2-10-3-性能比较"><a href="#2-10-3-性能比较" class="headerlink" title="2.10.3 性能比较"></a>2.10.3 性能比较</h4><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul><h3 id="2-11-ConcurrentLinkedQueue"><a href="#2-11-ConcurrentLinkedQueue" class="headerlink" title="2.11 ConcurrentLinkedQueue"></a>2.11 ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 cas 来实现<br>事实上，ConcurrentLinkedQueue 应用还是非常广泛的<br>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时<br>,正是采用了ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</li></ul><h3 id="2-12-CopyOnWriteArrayList"><a href="#2-12-CopyOnWriteArrayList" class="headerlink" title="2.12 CopyOnWriteArrayList"></a>2.12 CopyOnWriteArrayList</h3><p>CopyOnWriteArraySet  是它的马甲底层实现采用了  <strong>写入时拷贝</strong>  的思想，<strong>增删改操作会将底层数组拷贝一份</strong>，更改操作在新数组上执行，这时不影响其它线程的<strong>并发读，读写分离</strong>。</p><ul><li>适合『读多写少』的应用场景</li></ul><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记及面试问题分析</title>
    <link href="/2025/04/08/JAVA/redis/"/>
    <url>/2025/04/08/JAVA/redis/</url>
    
    <content type="html"><![CDATA[<h1 align="center">Redis学习笔记</h1><h1 id="一-Redis快速入门"><a href="#一-Redis快速入门" class="headerlink" title="一. Redis快速入门"></a>一. Redis快速入门</h1><h2 id="1-初识Redis"><a href="#1-初识Redis" class="headerlink" title="1. 初识Redis"></a>1. 初识Redis</h2><ul><li>Redis是一种<strong>键值型</strong>的<strong>NoSql数据库</strong></li><li>全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</li></ul><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h2 id="2-Redis常见命令"><a href="#2-Redis常见命令" class="headerlink" title="2. Redis常见命令"></a>2. Redis常见命令</h2><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型</p><p><img src="/img/blogs/java/redis/1.2.1.png"></p><h3 id="2-1-Redis通用命令"><a href="#2-1-Redis通用命令" class="headerlink" title="2.1 Redis通用命令"></a>2.1 Redis通用命令</h3><p>都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key<strong>设置有效期</strong>，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的<strong>剩余有效期</strong></li></ul><h3 id="2-2-String类型"><a href="#2-2-String类型" class="headerlink" title="2.2 String类型"></a>2.2 String类型</h3><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类:</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p><strong>String的常见命令有</strong>：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="2-3-Key结构"><a href="#2-3-Key结构" class="headerlink" title="2.3 Key结构"></a>2.3 Key结构</h3><p>通过给key添加前缀加以区分,Redis的key允许有多个单词形成<strong>层级结构</strong>，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li>user相关的key：<strong>heima:user:1</strong></li><li>product相关的key：<strong>heima:product:1</strong></li></ul><h3 id="2-4-Hash类型"><a href="#2-4-Hash类型" class="headerlink" title="2.4 Hash类型"></a>2.4 Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p><img src="/img/blogs/java/redis/1.2.2.png"></p><p><strong>Hash的常见命令有</strong>：</p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="2-5-List类型"><a href="#2-5-List类型" class="headerlink" title="2.5 List类型"></a>2.5 List类型</h3><p>Redis中的List类型与Java中的<strong>LinkedList</strong>类似，可以看做是一个<strong>双向链表</strong>结构。既可以支持正向检索和也可以支持反向检索</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h3 id="2-6-Set类型"><a href="#2-6-Set类型" class="headerlink" title="2.6 Set类型"></a>2.6 Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap</p><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><h3 id="2-7-SortedSet类型"><a href="#2-7-SortedSet类型" class="headerlink" title="2.7 SortedSet类型"></a>2.7 SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的<strong>可排序特性</strong>，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</p><h2 id="3-Redis的Java客户端"><a href="#3-Redis的Java客户端" class="headerlink" title="3. Redis的Java客户端"></a>3. Redis的Java客户端</h2><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="3-1-Jedis客户端"><a href="#3-1-Jedis客户端" class="headerlink" title="3.1 Jedis客户端"></a>3.1 Jedis客户端</h3><h4 id="3-1-1-快速入门"><a href="#3-1-1-快速入门" class="headerlink" title="3.1.1 快速入门"></a>3.1.1 快速入门</h4><ol><li>引入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>建立连接<br>新建一个单元测试类，内容如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.建立连接</span><br>    <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>测试：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;<br>        jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-连接池"><a href="#3-1-2-连接池" class="headerlink" title="3.1.2 连接池"></a>3.1.2 连接池</h4><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们<strong>使用Jedis连接池代替Jedis的直连方式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;192.168.150.101&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;123321&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-SpringDataRedis客户端"><a href="#3-2-SpringDataRedis客户端" class="headerlink" title="3.2 SpringDataRedis客户端"></a>3.2 SpringDataRedis客户端</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中<strong>对Redis的集成模块就叫做SpringDataRedis</strong></p><ul><li>提供了<strong>对不同Redis客户端的整合（Lettuce和Jedis）</strong></li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/img/blogs/java/redis/1.3.1.png"></p><h4 id="3-2-1-快速入门"><a href="#3-2-1-快速入门" class="headerlink" title="3.2.1 快速入门"></a>3.2.1 快速入门</h4><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置Redis</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></table></figure><ol start="3"><li>注入RedisTemplate</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>编写测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate edisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-自定义序列化"><a href="#3-2-2-自定义序列化" class="headerlink" title="3.2.2 自定义序列化"></a>3.2.2 自定义序列化</h4><p>RedisTemplate可以接收任意Object作为值写入Redis：<br>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是序列化之后的字符串。可读性差，内存占用较大。</p><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-3-StringRedisTemplate"><a href="#3-2-3-StringRedisTemplate" class="headerlink" title="3.2.3 StringRedisTemplate"></a>3.2.3 StringRedisTemplate</h4><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="/img/blogs/java/redis/1.3.2.png"></p><p>StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-comment">// JSON序列化工具</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;<br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;虎哥&quot;</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入数据</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>, json);<br><br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);<br>    <span class="hljs-comment">// 手动反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>    System.out.println(<span class="hljs-string">&quot;user1 = &quot;</span> + user1);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二-实战篇-黑马点评"><a href="#二-实战篇-黑马点评" class="headerlink" title="二. 实战篇-黑马点评"></a>二. 实战篇-黑马点评</h1><p><img src="/img/blogs/java/redis/2.0.1.png"></p><h2 id="1-短信登录"><a href="#1-短信登录" class="headerlink" title="1. 短信登录"></a>1. 短信登录</h2><h3 id="1-1-基于Session实现登录流程"><a href="#1-1-基于Session实现登录流程" class="headerlink" title="1.1 基于Session实现登录流程"></a>1.1 基于Session实现登录流程</h3><p><img src="/img/blogs/java/redis/2.1.1.png"></p><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><h3 id="1-2-实现发送短信验证码功能"><a href="#1-2-实现发送短信验证码功能" class="headerlink" title="1.2 实现发送短信验证码功能"></a>1.2 实现发送短信验证码功能</h3><ul><li><strong>发送验证码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 4.保存验证码到 session</span><br>    session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>,code);<br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-comment">// 返回ok</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>登录</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.校验验证码</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span>(cacheCode == <span class="hljs-literal">null</span> || !cacheCode.toString().equals(code))&#123;<br>         <span class="hljs-comment">//3.不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">//5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//不存在，则创建</span><br>        user =  createUserWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">//7.保存用户信息到session中</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-实现登录拦截功能"><a href="#1-3-实现登录拦截功能" class="headerlink" title="1.3 实现登录拦截功能"></a>1.3 实现登录拦截功能</h3><p><img src="/img/blogs/java/redis/2.1.2.png"></p><p><strong>拦截器代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">//1.获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">//2.获取session中的用户</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">//3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>              <span class="hljs-comment">//4.不存在，拦截，返回401状态码</span><br>              response.setStatus(<span class="hljs-number">401</span>);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//5.存在，保存用户信息到Threadlocal</span><br>        UserHolder.saveUser((User)user);<br>        <span class="hljs-comment">//6.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>让拦截器生效</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// token刷新的拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-隐藏用户敏感信息"><a href="#1-4-隐藏用户敏感信息" class="headerlink" title="1.4 隐藏用户敏感信息"></a>1.4 隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDTO对象，这个UserDTO对象就没有敏感信息了，我们在返回前，<strong>将有用户敏感信息的User对象转化成没有敏感信息的UserDTO对象</strong>，那么就能够避免这个尴尬的问题了</p><h3 id="1-5-session共享问题"><a href="#1-5-session共享问题" class="headerlink" title="1.5 session共享问题"></a>1.5 session共享问题</h3><p>session共享问题:多台Tomcat并不共享session存储空间,当请求切换到不同tomcat服务时导致数据丢失的问题</p><p><img src="/img/blogs/java/redis/2.1.3.png"></p><ul><li>每个tomcat中都有一份属于自己的session</li><li>假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中</li><li>但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session</li></ul><p><strong>解决方法</strong>：</p><p>所以咱们后来采用的方案都是基于redis来完成，我们<strong>把session换成redis</strong>，<strong>redis数据本身就是共享的，就可以避免session共享</strong>的问题了</p><h3 id="1-6-Redis代替session的业务流程"><a href="#1-6-Redis代替session的业务流程" class="headerlink" title="1.6 Redis代替session的业务流程"></a>1.6 Redis代替session的业务流程</h3><p><img src="/img/blogs/java/redis/2.1.4.png"></p><p><img src="/img/blogs/java/redis/2.1.5.png"></p><ol><li>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建。最后将用户数据保存到redis，并且生成token作为redis的key</li><li>当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到ThreadLocal中，并且放行。</li></ol><h3 id="1-7-基于Redis实现短信登录"><a href="#1-7-基于Redis实现短信登录" class="headerlink" title="1.7 基于Redis实现短信登录"></a>1.7 基于Redis实现短信登录</h3><p><strong>UserServiceImpl代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.从redis获取验证码并校验</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>        <span class="hljs-comment">// 不一致，报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br><br>    <span class="hljs-comment">// 5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 6.不存在，创建新用户并保存</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br><br>    <span class="hljs-comment">// 7.保存用户信息到 redis中</span><br>    <span class="hljs-comment">// 7.1.随机生成token，作为登录令牌</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 7.2.将User对象转为HashMap存储</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>            CopyOptions.create()<br>                    .setIgnoreNullValue(<span class="hljs-literal">true</span>)<br>                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));<br>    <span class="hljs-comment">// 7.3.存储</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br>    <span class="hljs-comment">// 7.4.设置token有效期</span><br>    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br><br>    <span class="hljs-comment">// 8.返回token</span><br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8-解决状态登录刷新问题"><a href="#1-8-解决状态登录刷新问题" class="headerlink" title="1.8 解决状态登录刷新问题"></a>1.8 解决状态登录刷新问题</h3><ul><li>原始拦截器确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径</li><li>假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行</li></ul><p><img src="/img/blogs/java/redis/2.1.6.png"></p><ul><li>我们可以添加一个拦截器，在<strong>第一个拦截器中拦截所有的路径</strong>，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时<strong>第二个拦截器只需要判断拦截器中的user对象是否存在即可</strong>，完成整体刷新功能。</li></ul><p><strong>RefreshTokenInterceptor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RefreshTokenInterceptor</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取请求头中的token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 2.基于TOKEN获取redis中的用户</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span>  <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 5.将查询到的hash数据转为UserDTO</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 6.存在，保存用户信息到 ThreadLocal</span><br>        UserHolder.saveUser(userDTO);<br>        <span class="hljs-comment">// 7.刷新token有效期</span><br>        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 8.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>LoginInterceptor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span><br>        <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 没有，需要拦截，设置状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-comment">// 拦截</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有用户，则放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MvcConfig</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>       <span class="hljs-comment">// 登录拦截器</span><br>       registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>               .excludePathPatterns(<br>                       <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                       <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                       <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                       <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                       <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                       <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                       <span class="hljs-string">&quot;/user/login&quot;</span><br>               ).order(<span class="hljs-number">1</span>);<br>       <span class="hljs-comment">// token刷新的拦截器</span><br>       registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="2-商户查询缓存"><a href="#2-商户查询缓存" class="headerlink" title="2. 商户查询缓存"></a>2. 商户查询缓存</h2><h3 id="2-1-什么是缓存"><a href="#2-1-什么是缓存" class="headerlink" title="2.1 什么是缓存?"></a>2.1 什么是缓存?</h3><p>缓存就是数据交换的缓冲区（称作Cache），是存贮数据的临时地方，一般读写性能较高。</p><ul><li><p><strong>缓存(<strong>Cache),就是数据交换的</strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码</p></li><li><p>为什么使用缓存？</p><ul><li><strong>速度快,好用</strong></li><li>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力</li></ul></li><li><p>但是缓存也会增加代码复杂度和运营的成本</p></li></ul><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p><img src="/img/blogs/java/redis/2.2.1.png"></p><ul><li>查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis</li></ul><p><strong>ShopServiceImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在,直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">// 4.不存在,根据id查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 5.不存在,返回错误</span><br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.存在,写入redis</span><br>    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));<br>    <span class="hljs-comment">// 7.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>redis会对部分数据进行更新，或者把他叫为淘汰<br>有以下三种更新策略：</p><table><thead><tr><th></th><th>内存淘汰</th><th>超时删除</th><th>主动更新</th></tr></thead><tbody><tr><td><strong>说明</strong></td><td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td><td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。</td><td>编写业务逻辑，在修改数据库的同时，更新缓存。</td></tr><tr><td><strong>一致性</strong></td><td>差</td><td>一般</td><td>好</td></tr><tr><td><strong>维护成本</strong></td><td>无</td><td>低</td><td>高</td></tr></tbody></table><p>业务场景：</p><ul><li>低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存</li></ul><p><strong>数据库和缓存不一致采用什么方案</strong>？<br>人工编码方式：<strong>缓存调用者在更新完数据库后再去更新缓存</strong>，也称之为双写方案</p><ul><li><p>删除缓存还是更新缓存？(<strong>选择删除缓存</strong>)</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库？(<strong>先操作数据库，再删除缓存</strong>)</p><ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><h3 id="2-4-实现商铺和缓存与数据库双写一致"><a href="#2-4-实现商铺和缓存与数据库双写一致" class="headerlink" title="2.4 实现商铺和缓存与数据库双写一致"></a>2.4 实现商铺和缓存与数据库双写一致</h3><p>修改ShopController中的业务逻辑，满足下面的需求：</p><ul><li>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并<strong>设置超时时间</strong></li><li>根据id修改店铺时，<strong>先修改数据库，再删除缓存</strong></li></ul><h3 id="2-5-缓存穿透"><a href="#2-5-缓存穿透" class="headerlink" title="2.5 缓存穿透"></a>2.5 缓存穿透</h3><p>缓存穿透 ：缓存穿透是指客户端<strong>请求的数据在缓存中和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><img src="/img/blogs/java/redis/2.2.2.png"></p><p><strong>编码解决商品查询的缓存穿透问题</strong>：</p><ul><li>原来的逻辑中，我们如果发现这个<strong>数据在mysql中不存在，直接就返回404</strong>了，这样是会存在缓存穿透问题的</li><li>现在的逻辑中：如果这个数据不存在，我们不会返回404 <ul><li>而是<strong>会把这个数据写入到Redis中，并且将value设置为空</strong></li><li>当再次发起查询时，我们如果发现命中之后，<strong>判断这个value是否是null</strong>，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。</li></ul></li></ul><p><img src="/img/blogs/java/redis/2.2.3.png"></p><p><strong>CacheClient</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(</span><br><span class="hljs-params">        String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>    &#125;<br>    <span class="hljs-comment">// 判断命中的是否是空值</span><br>    <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 返回一个错误信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 4.不存在，根据id查询数据库</span><br>    <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>    <span class="hljs-comment">// 5.不存在，返回错误</span><br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将空值写入redis</span><br>        stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 返回错误信息</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 6.存在，写入redis</span><br>    <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-缓存雪崩"><a href="#2-6-缓存雪崩" class="headerlink" title="2.6 缓存雪崩"></a>2.6 缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="/img/blogs/java/redis/2.2.4.png"></p><h3 id="2-7-缓存击穿"><a href="#2-7-缓存击穿" class="headerlink" title="2.7 缓存击穿"></a>2.7 缓存击穿</h3><p>缓存击穿问题也叫热点Key问题，就是一个<strong>被高并发访问并且缓存重建业务较复杂的key突然失效了</strong>，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p><img src="/img/blogs/java/redis/2.2.5.png"></p><p><img src="/img/blogs/java/redis/2.2.6.png"></p><table><thead><tr><th>解决方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>- 没有额外的内存消耗<br>- 保证一致性<br>- 实现简单</td><td>- 线程需要等待，性能受影响<br>- 可能有死锁风险</td></tr><tr><td>逻辑过期</td><td>- 线程无需等待，性能较好</td><td>- 不保证一致性<br>- 有额外内存消耗<br>- 实现复杂</td></tr></tbody></table><h4 id="2-7-1-利用互斥锁解决缓存击穿问题"><a href="#2-7-1-利用互斥锁解决缓存击穿问题" class="headerlink" title="2.7.1 利用互斥锁解决缓存击穿问题"></a>2.7.1 利用互斥锁解决缓存击穿问题</h4><p><img src="/img/blogs/java/redis/2.2.7.png"></p><p><strong>ShopServiceImpl</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span>  &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>       <span class="hljs-comment">// 1、从redis中查询商铺缓存</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;key&quot;</span>);<br>       <span class="hljs-comment">// 2、判断是否存在</span><br>       <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>           <span class="hljs-comment">// 存在,直接返回</span><br>           <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);<br>       &#125;<br>       <span class="hljs-comment">//判断命中的值是否是空值</span><br>       <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//返回一个错误信息</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-comment">// 4.实现缓存重构</span><br>       <span class="hljs-comment">//4.1 获取互斥锁</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;<br>       <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>           <span class="hljs-comment">// 4.2 判断否获取成功</span><br>           <span class="hljs-keyword">if</span>(!isLock)&#123;<br>               <span class="hljs-comment">//4.3 失败，则休眠重试</span><br>               Thread.sleep(<span class="hljs-number">50</span>);<br>               <span class="hljs-keyword">return</span> queryWithMutex(id);<br>           &#125;<br>           <span class="hljs-comment">//4.4 成功，根据id查询数据库</span><br>            shop = getById(id);<br>           <span class="hljs-comment">// 5.不存在，返回错误</span><br>           <span class="hljs-keyword">if</span>(shop == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//将空值写入redis</span><br>               stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);<br>               <span class="hljs-comment">//返回错误信息</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>           &#125;<br>           <span class="hljs-comment">//6.写入redis</span><br>           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);<br><br>       &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>       &#125;<br>       <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">//7.释放互斥锁</span><br>           unlock(lockKey);<br>       &#125;<br>       <span class="hljs-keyword">return</span> shop;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="2-7-2-利用逻辑过期解决缓存击穿问题"><a href="#2-7-2-利用逻辑过期解决缓存击穿问题" class="headerlink" title="2.7.2 利用逻辑过期解决缓存击穿问题"></a>2.7.2 利用逻辑过期解决缓存击穿问题</h4><p>修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</p><p><img src="/img/blogs/java/redis/2.2.8.png"></p><p><strong>ShopServiceImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">( Long id )</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>        <span class="hljs-comment">// 3.存在，直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1.获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>    <span class="hljs-keyword">if</span> (isLock)&#123;<br>        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;<br><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id,<span class="hljs-number">20L</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-封装Redis工具类"><a href="#2-8-封装Redis工具类" class="headerlink" title="2.8 封装Redis工具类"></a>2.8 封装Redis工具类</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题</li><li>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决<strong>缓存穿透</strong>问题</li><li>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决<strong>缓存击穿</strong>问题</li></ul><p><strong>封装成CacheClient类</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheClient</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-comment">// 设置逻辑过期</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>        redisData.setData(value);<br>        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>        <span class="hljs-comment">// 写入Redis</span><br>        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回一个错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.不存在，根据id查询数据库</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>        <span class="hljs-comment">// 5.不存在，返回错误</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将空值写入redis</span><br>            stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-comment">// 返回错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在，写入redis</span><br>        <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.命中，需要先把json反序列化为对象</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>        <span class="hljs-comment">// 5.判断是否过期</span><br>        <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-comment">// 5.1.未过期，直接返回店铺信息</span><br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-comment">// 5.2.已过期，需要缓存重建</span><br>        <span class="hljs-comment">// 6.缓存重建</span><br>        <span class="hljs-comment">// 6.1.获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 6.2.判断是否获取锁成功</span><br>        <span class="hljs-keyword">if</span> (isLock) &#123;<br>            <span class="hljs-comment">// 6.3.成功，开启独立线程，实现缓存重建</span><br>            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 查询数据库</span><br>                    <span class="hljs-type">R</span> <span class="hljs-variable">newR</span> <span class="hljs-operator">=</span> dbFallback.apply(id);<br>                    <span class="hljs-comment">// 重建缓存</span><br>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 6.4.返回过期的商铺信息</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(</span><br><span class="hljs-params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>            <span class="hljs-comment">// 3.存在，直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(shopJson, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 返回一个错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 4.实现缓存重建</span><br>        <span class="hljs-comment">// 4.1.获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>            <span class="hljs-comment">// 4.2.判断是否获取成功</span><br>            <span class="hljs-keyword">if</span> (!isLock) &#123;<br>                <span class="hljs-comment">// 4.3.获取锁失败，休眠并重试</span><br>                Thread.sleep(<span class="hljs-number">50</span>);<br>                <span class="hljs-keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);<br>            &#125;<br>            <span class="hljs-comment">// 4.4.获取锁成功，根据id查询数据库</span><br>            r = dbFallback.apply(id);<br>            <span class="hljs-comment">// 5.不存在，返回错误</span><br>            <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 将空值写入redis</span><br>                stringRedisTemplate.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>                <span class="hljs-comment">// 返回错误信息</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// 6.存在，写入redis</span><br>            <span class="hljs-built_in">this</span>.set(key, r, time, unit);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 7.释放锁</span><br>            unlock(lockKey);<br>        &#125;<br>        <span class="hljs-comment">// 8.返回</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        stringRedisTemplate.delete(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-优惠券秒杀"><a href="#3-优惠券秒杀" class="headerlink" title="3. 优惠券秒杀"></a>3. 优惠券秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 全局唯一ID"></a>3.1 全局唯一ID</h3><p>当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题：</p><ul><li>id的规律性太明显</li><li>受单表数据量的限制</li></ul><p><strong>全局ID生成器</strong>，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p><ul><li>唯一性</li><li>高可用</li><li>高性能</li><li>递增性</li><li>安全性</li></ul><ul><li>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：<ul><li>ID的组成部分：符号位：1bit，永远为0</li><li>时间戳：31bit，以秒为单位，可以使用69年</li><li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</li></ul></li></ul><p><img src="/img/blogs/java/redis/2.3.1.png"></p><p><strong>Redis实现全局唯一Id</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号的位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisIdWorker</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_TIMESTAMP;<br><br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1.获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-comment">// 2.2.自增长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br><br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-添加优惠券-实现秒杀下单"><a href="#3-2-添加优惠券-实现秒杀下单" class="headerlink" title="3.2 添加优惠券&amp;实现秒杀下单"></a>3.2 添加优惠券&amp;实现秒杀下单</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p><p><img src="/img/blogs/java/redis/2.3.2.png"></p><p><strong>实现秒杀下单</strong>：</p><p><img src="/img/blogs/java/redis/2.3.3.png"></p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断秒杀是否已经结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-comment">// 尚未开始</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 库存不足</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//5，扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-comment">//扣减库存</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-comment">// 6.1.订单id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    <span class="hljs-comment">// 6.2.用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    voucherOrder.setUserId(userId);<br>    <span class="hljs-comment">// 6.3.代金券id</span><br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-库存超卖问题-多线程安全问题"><a href="#3-3-库存超卖问题-多线程安全问题" class="headerlink" title="3.3 库存超卖问题(多线程安全问题)"></a>3.3 库存超卖问题(多线程安全问题)</h3><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="/img/blogs/java/redis/2.3.4.png"></p><h4 id="3-3-1-解决方案-加锁"><a href="#3-3-1-解决方案-加锁" class="headerlink" title="3.3.1 解决方案(加锁)"></a>3.3.1 解决方案(加锁)</h4><p><strong>悲观锁：</strong></p><ul><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li><li>例如Synchronized、Lock都属于悲观锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。</li><li>如果没有修改则认为是安全的，自己才更新数据。</li><li>如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常</li></ul><h4 id="3-3-2-基于乐观锁-CAS-的解决方案"><a href="#3-3-2-基于乐观锁-CAS-的解决方案" class="headerlink" title="3.3.2 基于乐观锁(CAS)的解决方案"></a>3.3.2 基于乐观锁(CAS)的解决方案</h4><p><img src="/img/blogs/java/redis/2.3.5.png"></p><p>只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的。我们的乐观锁需要变一下，改成stock大于0 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//where id = ? and stock &gt; 0</span><br></code></pre></td></tr></table></figure><h4 id="3-3-3-总结"><a href="#3-3-3-总结" class="headerlink" title="3.3.3 总结"></a>3.3.3 总结</h4><p>超卖这样的线程安全问题，解决方案有哪些？</p><ul><li>悲观锁：添加同步锁，让线程串行执行<ul><li>优点：简单粗暴</li><li>缺点：性能一般</li></ul></li><li>乐观锁：不加锁，在更新时判断是否有其它线程在修改<ul><li>优点：性能好</li><li>缺点：存在成功率低的问题</li></ul></li></ul><h3 id="3-4-一人一单"><a href="#3-4-一人一单" class="headerlink" title="3.4 一人一单"></a>3.4 一人一单</h3><p>修改秒杀业务，要求<strong>同一个优惠券，一个用户只能下一单</strong></p><p><img src="/img/blogs/java/redis/2.3.6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 5.1.查询订单</span><br>   <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>   <span class="hljs-comment">// 5.2.判断是否存在</span><br>   <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-comment">// 用户已经购买过了</span><br>       <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>为了确保线程安全，在方法上添加了一把synchronized 锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-集群环境下一人一单的并发安全问题"><a href="#3-5-集群环境下一人一单的并发安全问题" class="headerlink" title="3.5 集群环境下一人一单的并发安全问题"></a>3.5 集群环境下一人一单的并发安全问题</h3><p>通过加锁可以解决在单机情况下的一人一单安全问题，但是<strong>在集群模式下就不行了</strong></p><p>由于现在我们部署了多个tomcat，<strong>每个tomcat都有一个属于自己的jvm</strong>，<strong>每个JVM都有各自的锁监视器，导致不同JVM的锁在不同的锁监视器中</strong>。那么假设在服务器A的tomcat内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器B的tomcat内部，又有两个线程，但是他们的锁对象写的虽然和服务器A一样，但是锁对象却不是同一个，所以线程3和线程4可以实现互斥，但是却无法和线程1和线程2实现互斥，这就是 集群环境下，syn锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。</p><p><img src="/img/blogs/java/redis/2.3.7.png"></p><h3 id="3-6-秒杀优化-异步秒杀"><a href="#3-6-秒杀优化-异步秒杀" class="headerlink" title="3.6 秒杀优化-异步秒杀"></a>3.6 秒杀优化-异步秒杀</h3><ul><li>我们将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功</li><li>再在后台开一个线程，后台线程慢慢的去执行queue里边的消息</li></ul><p><img src="/img/blogs/java/redis/2.3.8.png"></p><p><img src="/img/blogs/java/redis/2.3.9.png"></p><ol><li><p>当用户下单之后，判断库存是否充足只需要导redis中去根据key找对应的value是否大于0即可，如果不充足，则直接结束，如果充足，继续在redis中判断用户是否可以下单，如果set集合中没有这条数据，说明他可以下单，如果set集合中没有这条记录，则将userId和优惠卷存入到redis中，并且返回0，整个过程需要保证是原子性的，我们可以使用lua来操作</p></li><li><p>当以上判断逻辑走完之后，我们可以判断当前redis中返回的结果是否是0 ，如果是0，则表示可以下单，则将之前说的信息存入到到queue中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单id来判断是否下单成功。</p></li></ol><h3 id="3-7-秒杀优化-Redis完成秒杀资格判断"><a href="#3-7-秒杀优化-Redis完成秒杀资格判断" class="headerlink" title="3.7 秒杀优化-Redis完成秒杀资格判断"></a>3.7 秒杀优化-Redis完成秒杀资格判断</h3><p>需求：</p><ol><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li><li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p></li><li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p></li><li><p>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</p></li><li><p>新增秒杀优惠券的同时，将优惠券信息保存到Redis中</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis中</span><br>    <span class="hljs-comment">//SECKILL_STOCK_KEY 这个变量定义在RedisConstans中</span><br>    <span class="hljs-comment">//private static final String SECKILL_STOCK_KEY =&quot;seckill:stock:&quot;</span><br>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 1.3.订单id</span><br><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<br><br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span><br>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>VoucherOrderServiceImpl</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">//获取用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">// 1.执行lua脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>    );<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-comment">// 2.判断结果是否为0</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//TODO 保存阻塞队列</span><br>    <span class="hljs-comment">// 3.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-8-秒杀优化-基于阻塞队列实现秒杀优化"><a href="#3-8-秒杀优化-基于阻塞队列实现秒杀优化" class="headerlink" title="3.8 秒杀优化-基于阻塞队列实现秒杀优化"></a>3.8 秒杀优化-基于阻塞队列实现秒杀优化</h3><ol start="3"><li>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ol><p>修改下单动作，现在我们去下单时，是通过lua表达式去原子执行判断逻辑，如果判断我出来不为0 ，则要么是库存不足，要么是重复下单，返回错误信息，如果是0，则把下单的逻辑保存到队列中去，然后异步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//异步处理线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">SECKILL_ORDER_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br><span class="hljs-comment">//在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>   SECKILL_ORDER_EXECUTOR.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());<br>&#125;<br><span class="hljs-comment">// 用于线程池处理的任务</span><br><span class="hljs-comment">// 当初始化完毕后，就会去从对列中去拿信息</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 1.获取队列中的订单信息</span><br>                    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> orderTasks.take();<br>                    <span class="hljs-comment">// 2.创建订单</span><br>                    handleVoucherOrder(voucherOrder);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                &#125;<br>           &#125;<br>        &#125;<br>     <br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>            <span class="hljs-comment">//1.获取用户</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>            <span class="hljs-comment">// 2.创建锁对象</span><br>            <span class="hljs-type">RLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>            <span class="hljs-comment">// 3.尝试获取锁</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.lock();<br>            <span class="hljs-comment">// 4.判断是否获得锁成功</span><br>            <span class="hljs-keyword">if</span> (!isLock) &#123;<br>                <span class="hljs-comment">// 获取锁失败，直接返回失败或者重试</span><br>                log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span><br>                proxy.createVoucherOrder(voucherOrder);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                redisLock.unlock();<br>            &#125;<br>    &#125;<br>     <span class="hljs-comment">//a</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks =<span class="hljs-keyword">new</span>  <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        <span class="hljs-comment">// 1.执行lua脚本</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>                SECKILL_SCRIPT,<br>                Collections.emptyList(),<br>                voucherId.toString(), userId.toString(), String.valueOf(orderId)<br>        );<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>        <span class="hljs-comment">// 2.判断结果是否为0</span><br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2.1.不为0 ，代表没有购买资格</span><br>            <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        <span class="hljs-comment">// 2.3.订单id</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>        voucherOrder.setId(orderId);<br>        <span class="hljs-comment">// 2.4.用户id</span><br>        voucherOrder.setUserId(userId);<br>        <span class="hljs-comment">// 2.5.代金券id</span><br>        voucherOrder.setVoucherId(voucherId);<br>        <span class="hljs-comment">// 2.6.放入阻塞队列</span><br>        orderTasks.add(voucherOrder);<br>        <span class="hljs-comment">//3.获取代理对象</span><br>         proxy = (IVoucherOrderService)AopContext.currentProxy();<br>        <span class="hljs-comment">//4.返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>     <br>      <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>        <span class="hljs-comment">// 5.1.查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();<br>        <span class="hljs-comment">// 5.2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 用户已经购买过了</span><br>           log.error(<span class="hljs-string">&quot;用户已经购买过了&quot;</span>);<br>           <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">// 6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span><br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span><br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-comment">// 扣减失败</span><br>            log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        save(voucherOrder);<br> <br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>小总结：</strong></p><p>秒杀业务的优化思路是什么？</p><ul><li>先利用Redis完成库存余量、一人一单判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li><li>基于阻塞队列的异步秒杀存在哪些问题？<ul><li>内存限制问题</li><li>数据安全问题</li></ul></li></ul><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><h3 id="4-1-基本原理和实现方式对比"><a href="#4-1-基本原理和实现方式对比" class="headerlink" title="4.1 基本原理和实现方式对比"></a>4.1 基本原理和实现方式对比</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。<br>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="/img/blogs/java/redis/2.4.1.png"></p><ul><li>分布式锁需要满足的条件<ul><li>可见性</li><li>互斥</li><li>高可用</li><li>高性能</li><li>安全性</li></ul></li></ul><p><strong>常见的分布式锁有三种</strong>：</p><table><thead><tr><th></th><th>MySQL</th><th>Redis</th><th>Zookeeper</th></tr></thead><tbody><tr><td>互斥</td><td>利用MySQL本身的互斥锁机制</td><td>利用setnx这样的互斥命令</td><td>利用节点的唯一性和有序性实现互斥</td></tr><tr><td>高可用</td><td>好</td><td>好</td><td>好</td></tr><tr><td>高性能</td><td>一般</td><td>好</td><td>一般</td></tr><tr><td>安全性</td><td>断开连接，自动释放锁</td><td>利用锁超时时间，到期释放</td><td>临时节点，断开连接自动释放</td></tr></tbody></table><h3 id="4-2-基于Redis的分布式锁"><a href="#4-2-基于Redis的分布式锁" class="headerlink" title="4.2 基于Redis的分布式锁"></a>4.2 基于Redis的分布式锁</h3><p>实现分布式锁时需要实现的两个基本方法：</p><ul><li>获取锁：<ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment"># 添加锁，NX是互斥、EX是设置超时时间</span><br>SET lock thread1 NX EX <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><ul><li>释放锁：<ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment"># 释放锁，删除即可</span><br>DEL key<br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/redis/2.4.2.png"></p><p>我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可</p><h3 id="4-3-实现分布式锁-版本一"><a href="#4-3-实现分布式锁-版本一" class="headerlink" title="4.3 实现分布式锁(版本一)"></a>4.3 实现分布式锁(版本一)</h3><ul><li>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</li><li>释放锁逻辑<ul><li>释放锁，防止删除别人的锁</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_PREFIX=<span class="hljs-string">&quot;lock:&quot;</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId()<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>    <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//通过del删除锁</span><br>    stringRedisTemplate.delete(KEY_PREFIX + name);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改业务代码:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//创建锁对象(新增代码)</span><br>      <span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, stringRedisTemplate);<br>      <span class="hljs-comment">//获取锁对象</span><br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-comment">//加锁失败</span><br>      <span class="hljs-keyword">if</span> (!isLock) &#123;<br>          <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//获取代理对象(事务)</span><br>          <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>          <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          <span class="hljs-comment">//释放锁</span><br>          lock.unlock();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-Redis分布式锁误删情况"><a href="#4-4-Redis分布式锁误删情况" class="headerlink" title="4.4 Redis分布式锁误删情况"></a>4.4 Redis分布式锁误删情况</h3><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，<strong>走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除</strong>，这就是误删别人锁的情况说明</p><p><img src="/img/blogs/java/redis/2.4.3.png"></p><p>解决方案就是在每个线程<strong>释放锁的时候，去判断一下当前这把锁是否属于自己</strong>，如果属于自己，则不进行锁的删除</p><p><img src="/img/blogs/java/redis/2.4.4.png"></p><h4 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h4><p><img src="/img/blogs/java/redis/2.4.5.png"></p><p>需求：修改之前的分布式锁实现，满足：</p><ul><li>在获取锁时存入线程标示（可以用UUID表示）</li><li>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致<ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul></li></ul><p><strong>加锁</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>   <span class="hljs-comment">// 获取线程标示</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>   <span class="hljs-comment">// 获取锁</span><br>   <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()<br>                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>   <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>释放锁</strong>：<strong>先判断，再释放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取线程标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>    <span class="hljs-comment">// 获取锁中的标示</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<br>    <span class="hljs-comment">// 判断标示是否一致</span><br>    <span class="hljs-keyword">if</span>(threadId.equals(id)) &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        stringRedisTemplate.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-分布式锁的原子性问题"><a href="#4-5-分布式锁的原子性问题" class="headerlink" title="4.5 分布式锁的原子性问题"></a>4.5 分布式锁的原子性问题</h3><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的</p><p><img src="/img/blogs/java/redis/2.4.6.png"></p><h3 id="4-6-Lua脚本解决多条命令原子性问题"><a href="#4-6-Lua脚本解决多条命令原子性问题" class="headerlink" title="4.6 Lua脚本解决多条命令原子性问题"></a>4.6 Lua脚本解决多条命令原子性问题</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性</p><p>Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis.call(<span class="hljs-string">&#x27;命令名称&#x27;</span>, <span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;其它参数&#x27;</span>, ...)<br></code></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 执行 set name jack<br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>)<br></code></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 先执行 set name jack<br>redis.call(<span class="hljs-string">&#x27;set&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>)<br># 再执行 get name<br><span class="hljs-keyword">local</span> name = redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br># 返回<br><span class="hljs-keyword">return</span> name<br></code></pre></td></tr></table></figure><ul><li>释放锁的业务流程是这样的<ol><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol></li></ul><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span><br><span class="hljs-comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>  <span class="hljs-comment">-- 一致，则删除锁</span><br>  <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;DEL&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 不一致，则直接返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="4-7-利用Java代码调用Lua脚本改造分布式锁"><a href="#4-7-利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="4.7 利用Java代码调用Lua脚本改造分布式锁"></a>4.7 利用Java代码调用Lua脚本改造分布式锁</h3><p>RedisTemplate中，可以利用execute方法去执行lua脚本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用lua脚本</span><br>    stringRedisTemplate.execute(<br>            UNLOCK_SCRIPT,<br>            Collections.singletonList(KEY_PREFIX + name),<br>            ID_PREFIX + Thread.currentThread().getId());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-8-基于Redis的分布式锁实现思路"><a href="#4-8-基于Redis的分布式锁实现思路" class="headerlink" title="4.8 基于Redis的分布式锁实现思路"></a>4.8 基于Redis的分布式锁实现思路</h3><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><h3 id="4-9-分布式锁-redission功能介绍"><a href="#4-9-分布式锁-redission功能介绍" class="headerlink" title="4.9 分布式锁-redission功能介绍"></a>4.9 分布式锁-redission功能介绍</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><ul><li><strong>不可重入问题</strong>：同一个线程无法多次获取同一把锁</li><li><strong>不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制</li><li><strong>超时释放：</strong>： 锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li><li><strong>主从一致性：</strong> ：如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁实现</li></ul><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p><strong>Redission提供了分布式锁的多种多样的功能</strong></p><h3 id="4-10-分布式锁-Redission快速入门"><a href="#4-10-分布式锁-Redission快速入门" class="headerlink" title="4.10 分布式锁-Redission快速入门"></a>4.10 分布式锁-Redission快速入门</h3><ol><li>引入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置Redisson客户端：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://192.168.150.101:6379&quot;</span>)<br>            .setPassword(<span class="hljs-string">&quot;123321&quot;</span>);<br>        <span class="hljs-comment">// 创建RedissonClient对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用Redission的分布式锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-11-分布式锁-redission可重入锁原理"><a href="#4-11-分布式锁-redission可重入锁原理" class="headerlink" title="4.11 分布式锁-redission可重入锁原理"></a>4.11 分布式锁-redission可重入锁原理</h3><p><img src="/img/blogs/java/redis/2.4.7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建锁对象</span><br>   <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>       <span class="hljs-keyword">if</span> (!isLock) &#123;<br>           log.error(<span class="hljs-string">&quot;获取锁失败,1&quot;</span>);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-keyword">try</span> &#123;<br>           log.info(<span class="hljs-string">&quot;获取锁成功,1&quot;</span>);<br>           method2();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           log.info(<span class="hljs-string">&quot;释放锁,1&quot;</span>);<br>           lock.unlock();<br>       &#125;<br><br>       <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span> <span class="hljs-params">()</span> &#123;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>           <span class="hljs-keyword">if</span> (!isLock) &#123;<br>               log.error(<span class="hljs-string">&quot;获取锁失败,2&quot;</span>);<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>           <span class="hljs-keyword">try</span> &#123;<br>               log.info(<span class="hljs-string">&quot;获取锁成功,2&quot;</span>);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               log.info(<span class="hljs-string">&quot;释放锁,2&quot;</span>);<br>               lock.unlock();<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-12-分布式锁-redission-锁重试和WatchDog机制"><a href="#4-12-分布式锁-redission-锁重试和WatchDog机制" class="headerlink" title="4.12 分布式锁-redission 锁重试和WatchDog机制"></a>4.12 分布式锁-redission 锁重试和WatchDog机制</h3><p><img src="/img/blogs/java/redis/2.4.8.png"></p><p>Redisson分布式锁原理：</p><ul><li>可重入：利用hash结构记录线程id和重入次数</li><li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li></ul><h3 id="4-13-分布式锁-redission-锁的MutiLock原理"><a href="#4-13-分布式锁-redission-锁的MutiLock原理" class="headerlink" title="4.13 分布式锁-redission  锁的MutiLock原理"></a>4.13 分布式锁-redission  锁的MutiLock原理</h3><p>redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了,每个节点的地位都是一样的<br>这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="/img/blogs/java/redis/2.4.9.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>不可重入Redis分布式锁：<ul><li>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入的Redis分布式锁：<ul><li>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock：<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul></li></ol><h2 id="5-Redis消息队列-实现异步秒杀"><a href="#5-Redis消息队列-实现异步秒杀" class="headerlink" title="5. Redis消息队列(实现异步秒杀)"></a>5. Redis消息队列(实现异步秒杀)</h2><h3 id="5-1-认识消息队列"><a href="#5-1-认识消息队列" class="headerlink" title="5.1 认识消息队列"></a>5.1 认识消息队列</h3><p>什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="/img/blogs/java/redis/2.5.1.png"></p><p>Redis提供了三种不同的方式来实现消息队列：</p><ul><li>list结构：基于List结构模拟消息队列</li><li>PubSub：基本的点对点消息模型</li><li>Stream：比较完善的消息队列模型</li></ul><h3 id="5-2-基于List实现消息队列"><a href="#5-2-基于List实现消息队列" class="headerlink" title="5.2 基于List实现消息队列"></a>5.2 基于List实现消息队列</h3><p><strong>只能单个生产者单个消费者</strong><br>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><ul><li>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</li><li>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</li></ul><p><img src="/img/blogs/java/redis/2.5.2.png"></p><p><strong>基于List的消息队列有哪些优缺点</strong>?</p><ul><li><p>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul></li><li><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul></li></ul><h3 id="5-3-基于PubSub的消息队列"><a href="#5-3-基于PubSub的消息队列" class="headerlink" title="5.3 基于PubSub的消息队列"></a>5.3 基于PubSub的消息队列</h3><p><strong>可以多生产多消费</strong><br>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，<strong>消费者可以订阅一个或多个channel</strong>，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p>常用命令：</p><ul><li><code>SUBSCRIBE channel [channel]</code> ：订阅一个或多个频道</li><li><code>PUBLISH channel msg</code> ：向一个频道发送消息</li><li><code>PSUBSCRIBE pattern[pattern]</code> ：订阅与pattern格式匹配的所有频道</li></ul><p><img src="/img/blogs/java/redis/2.5.3.png"></p><p><strong>基于PubSub的消息队列有哪些优缺点？</strong><br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="5-4-基于Stream的消息队列"><a href="#5-4-基于Stream的消息队列" class="headerlink" title="5.4 基于Stream的消息队列"></a>5.4 基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><ol><li>发送消息的命令：</li></ol><p><img src="/img/blogs/java/redis/2.5.4.png"></p><ol start="2"><li>读取消息的方式之一：XREAD</li></ol><p><img src="/img/blogs/java/redis/2.5.5.png"></p><ol start="3"><li>XREAD阻塞方式，读取最新的消息：</li></ol><p><img src="/img/blogs/java/redis/2.5.6.png"></p><ol start="4"><li>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下</li></ol><p><img src="/img/blogs/java/redis/2.5.7.png"></p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="5-5-基于Stream的消息队列-消费者组"><a href="#5-5-基于Stream的消息队列-消费者组" class="headerlink" title="5.5 基于Stream的消息队列-消费者组"></a>5.5 基于Stream的消息队列-消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><ul><li><strong>消息分流</strong><ul><li>队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</li></ul></li><li><strong>消息标示</strong><ul><li>消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费</li></ul></li><li><strong>消息确认</strong><ul><li>消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list移除。</li></ul></li></ul><p><strong>创建消费者组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XGROUP CREATE  key groupName ID [MKSTREAM]<br></code></pre></td></tr></table></figure><ul><li>key：队列名称</li><li>groupName：消费者组名称</li><li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li><li>MKSTREAM：队列不存在时自动创建队列</li></ul><p><strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XGROUP DESTORY key groupName<br></code></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XGROUP CREATECONSUMER key groupname consumername<br></code></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XGROUP DELCONSUMER key groupname consumername<br></code></pre></td></tr></table></figure><p><strong>从消费者组读取消息</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：<ul><li>“&gt;”：从下一个未消费的消息开始</li><li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li></ul></li></ul><p><strong>消费者监听消息的基本思路</strong>:</p><p><img src="/img/blogs/java/redis/2.5.8.png"></p><p><strong>STREAM类型消息队列的XREADGROUP命令特点</strong>：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><p><strong>对比</strong>：</p><table><thead><tr><th></th><th>List</th><th>PubSub</th><th>Stream</th></tr></thead><tbody><tr><td><strong>消息持久化</strong></td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td><strong>阻塞读取</strong></td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td><strong>消息堆积处理</strong></td><td>受限于内存空间，可以利用多消费者加快处理</td><td>受限于消费者缓冲区</td><td>受限于队列长度，可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td><strong>消息确认机制</strong></td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td><strong>消息回溯</strong></td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><h3 id="5-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#5-6-基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="5.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>5.6 基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h3><ul><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ul><p><strong>VoucherOrderServiceImpl</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                    Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                    StreamReadOptions.empty().count(<span class="hljs-number">1</span>).block(Duration.ofSeconds(<span class="hljs-number">2</span>)),<br>                    StreamOffset.create(<span class="hljs-string">&quot;stream.orders&quot;</span>, ReadOffset.lastConsumed())<br>                );<br>                <span class="hljs-comment">// 2.判断订单信息是否为空</span><br>                <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 如果为null，说明没有消息，继续下一次循环</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 解析数据</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; value = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 3.创建订单</span><br>                createVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 4.确认消息 XACK</span><br>                stringRedisTemplate.opsForStream().acknowledge(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>                <span class="hljs-comment">//处理异常消息</span><br>                handlePendingList();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePendingList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span><br>                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(<br>                    Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),<br>                    StreamReadOptions.empty().count(<span class="hljs-number">1</span>),<br>                    StreamOffset.create(<span class="hljs-string">&quot;stream.orders&quot;</span>, ReadOffset.from(<span class="hljs-string">&quot;0&quot;</span>))<br>                );<br>                <span class="hljs-comment">// 2.判断订单信息是否为空</span><br>                <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;<br>                    <span class="hljs-comment">// 如果为null，说明没有异常消息，结束循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 解析数据</span><br>                MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="hljs-number">0</span>);<br>                Map&lt;Object, Object&gt; value = record.getValue();<br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">// 3.创建订单</span><br>                createVoucherOrder(voucherOrder);<br>                <span class="hljs-comment">// 4.确认消息 XACK</span><br>                stringRedisTemplate.opsForStream().acknowledge(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-string">&quot;g1&quot;</span>, record.getId());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理pendding订单异常&quot;</span>, e);<br>                <span class="hljs-keyword">try</span>&#123;<br>                    Thread.sleep(<span class="hljs-number">20</span>);<br>                &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-达人探店"><a href="#6-达人探店" class="headerlink" title="6. 达人探店"></a>6. 达人探店</h2><h3 id="6-1-发布探店笔记"><a href="#6-1-发布探店笔记" class="headerlink" title="6.1 发布探店笔记"></a>6.1 发布探店笔记</h3><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：</p><ul><li>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等</li><li>tb_blog_comments：其他用户对探店笔记的评价</li></ul><h4 id="6-1-1-上传接口"><a href="#6-1-1-上传接口" class="headerlink" title="6.1.1 上传接口"></a>6.1.1 上传接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取原始文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>            <span class="hljs-comment">// 生成新文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);<br>            <span class="hljs-comment">// 保存文件</span><br>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>            <span class="hljs-comment">// 返回结果</span><br>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);<br>            <span class="hljs-keyword">return</span> Result.ok(fileName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-BlogController"><a href="#6-1-2-BlogController" class="headerlink" title="6.1.2 BlogController"></a>6.1.2 BlogController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IBlogService blogService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>        <span class="hljs-comment">//获取登录用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        blog.setUpdateTime(user.getId());<br>        <span class="hljs-comment">//保存探店博文</span><br>        blogService.saveBlog(blog);<br>        <span class="hljs-comment">//返回id</span><br>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-3-BlogServiceImpl"><a href="#6-1-3-BlogServiceImpl" class="headerlink" title="6.1.3 BlogServiceImpl"></a>6.1.3 BlogServiceImpl</h4><p>实现查看发布探店笔记的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.查询blog</span><br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-keyword">if</span> (blog == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.查询blog有关的用户</span><br>    queryBlogUser(blog);<br>  <br>    <span class="hljs-keyword">return</span> Result.ok(blog);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-点赞功能"><a href="#6-2-点赞功能" class="headerlink" title="6.2 点赞功能"></a>6.2 点赞功能</h3><p>需求：</p><ul><li><strong>同一个用户只能点赞一次</strong>，再次点击则取消点赞</li><li>如果当前用户<strong>已经点赞，则点赞按钮高亮显示</strong>（前端已实现，判断字段Blog类的isLike属性）</li></ul><ul><li>为什么<strong>采用set集合</strong>：因为我们的数据是不能重复的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span>&#123;<br>       <span class="hljs-comment">// 1.获取登录用户</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>       <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());<br>       <span class="hljs-keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;<br>            <span class="hljs-comment">//3.如果未点赞，可以点赞</span><br>           <span class="hljs-comment">//3.1 数据库点赞数+1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>           <span class="hljs-comment">//3.2 保存用户到Redis的set集合</span><br>           <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>               stringRedisTemplate.opsForSet().add(key,userId.toString());<br>           &#125;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//4.如果已点赞，取消点赞</span><br>           <span class="hljs-comment">//4.1 数据库点赞数-1</span><br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>           <span class="hljs-comment">//4.2 把用户从Redis的set集合移除</span><br>           <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>               stringRedisTemplate.opsForSet().remove(key,userId.toString());<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><h3 id="6-3-点赞排行榜"><a href="#6-3-点赞排行榜" class="headerlink" title="6.3 点赞排行榜"></a>6.3 点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜</p><p>之前的点赞是放到set集合，但是set集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的set集合，就是咱们的sortedSet</p><table><thead><tr><th></th><th>List</th><th>Set</th><th>SortedSet</th></tr></thead><tbody><tr><td>排序方式</td><td>按添加顺序排序</td><td>无法排序</td><td>根据score值排序</td></tr><tr><td>唯一性</td><td>不唯一</td><td>唯一</td><td>唯一</td></tr><tr><td>查找方式</td><td>按索引查找或首尾查找</td><td>根据元素查找</td><td>根据元素查找</td></tr></tbody></table><h4 id="6-3-1-BlogServiceImpl"><a href="#6-3-1-BlogServiceImpl" class="headerlink" title="6.3.1 BlogServiceImpl"></a>6.3.1 BlogServiceImpl</h4><p>点赞逻辑代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>     <span class="hljs-comment">// 1.获取登录用户</span><br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>     <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>     <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>     <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// 3.如果未点赞，可以点赞</span><br>         <span class="hljs-comment">// 3.1.数据库点赞数 + 1</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>         <span class="hljs-comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span><br>         <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>             stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>         &#125;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 4.如果已点赞，取消点赞</span><br>         <span class="hljs-comment">// 4.1.数据库点赞数 -1</span><br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>         <span class="hljs-comment">// 4.2.把用户从Redis的set集合移除</span><br>         <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>             stringRedisTemplate.opsForZSet().remove(key, userId.toString());<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> Result.ok();<br> &#125;<br><br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isBlogLiked</span><span class="hljs-params">(Blog blog)</span> &#123;<br>     <span class="hljs-comment">// 1.获取登录用户</span><br>     <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>     <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">// 用户未登录，无需查询是否点赞</span><br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br>     <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();<br>     <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blog:liked:&quot;</span> + blog.getId();<br>     <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());<br>     blog.setIsLike(score != <span class="hljs-literal">null</span>);<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="6-3-2-点赞列表查询列表"><a href="#6-3-2-点赞列表查询列表" class="headerlink" title="6.3.2 点赞列表查询列表"></a>6.3.2 点赞列表查询列表</h4><p><strong>BlogController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> blogService.queryBlogLikes(id);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>BlogService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 1.查询top5的点赞用户 zrange key 0 4</span><br>    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 2.解析出其中的用户id</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    <span class="hljs-comment">// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span><br>    List&lt;UserDTO&gt; userDTOS = userService.query()<br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list()<br>            .stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(userDTOS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-好友关注"><a href="#7-好友关注" class="headerlink" title="7. 好友关注"></a>7. 好友关注</h2><h3 id="7-1-关注和取消关注"><a href="#7-1-关注和取消关注" class="headerlink" title="7.1 关注和取消关注"></a>7.1 关注和取消关注</h3><p>需求：基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>关注是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来标示</p><h4 id="7-1-1-FollowController"><a href="#7-1-1-FollowController" class="headerlink" title="7.1.1 FollowController"></a>7.1.1 FollowController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关注</span><br><span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;<br>    <span class="hljs-keyword">return</span> followService.follow(followUserId, isFollow);<br>&#125;<br><span class="hljs-comment">//取消关注</span><br><span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;<br>      <span class="hljs-keyword">return</span> followService.isFollow(followUserId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-2-FollowService"><a href="#7-1-2-FollowService" class="headerlink" title="7.1.2 FollowService"></a>7.1.2 FollowService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//取消关注service</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>        <span class="hljs-comment">// 1.获取登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">// 2.查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId).count();<br>        <span class="hljs-comment">// 3.判断</span><br>        <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>    &#125;<br><br> <span class="hljs-comment">//关注service</span><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>        <span class="hljs-comment">// 1.获取登录用户</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>        <span class="hljs-comment">// 1.判断到底是关注还是取关</span><br>        <span class="hljs-keyword">if</span> (isFollow) &#123;<br>            <span class="hljs-comment">// 2.关注，新增数据</span><br>            <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>            follow.setUserId(userId);<br>            follow.setFollowUserId(followUserId);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span><br>            remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                    .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-共同关注"><a href="#7-2-共同关注" class="headerlink" title="7.2 共同关注"></a>7.2 共同关注</h3><p>想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求</p><ol><li>去查询用户的详情</li><li>去查询用户的笔记</li></ol><p>需求：利用Redis中恰当的数据结构，实现共同关注功能。在博主个人页面展示出当前用户与博主的共同关注呢。</p><ul><li>当然是使用我们之前学习过的set集合咯，<strong>在set集合中，有交集并集补集的api</strong>，我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</li></ul><p><strong>FollowServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-comment">// 1.判断到底是关注还是取关</span><br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 2.关注，新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setUserId(userId);<br>        follow.setFollowUserId(followUserId);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(follow);<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span><br>            stringRedisTemplate.opsForSet().add(key, followUserId.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            <span class="hljs-comment">// 把关注用户的id从Redis集合中移除</span><br>            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FollowServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-comment">// 2.求交集</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + id;<br>    Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key, key2);<br>    <span class="hljs-keyword">if</span> (intersect == <span class="hljs-literal">null</span> || intersect.isEmpty()) &#123;<br>        <span class="hljs-comment">// 无交集</span><br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 3.解析id集合</span><br>    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.查询用户</span><br>    List&lt;UserDTO&gt; users = userService.listByIds(ids)<br>            .stream()<br>            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> Result.ok(users);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-共同推送-Feed流实现方案"><a href="#7-3-共同推送-Feed流实现方案" class="headerlink" title="7.3 共同推送-Feed流实现方案"></a>7.3 共同推送-Feed流实现方案</h3><p>关注推送也叫做Feed流，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息</p><p><img src="/img/blogs/java/redis/2.7.1.png"></p><h4 id="7-3-1-Feed流产品有两种常见模式"><a href="#7-3-1-Feed流产品有两种常见模式" class="headerlink" title="7.3.1 Feed流产品有两种常见模式"></a>7.3.1 Feed流产品有两种常见模式</h4><p><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</p><ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul><p><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户</p><ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用<br>本例中的个人页面，是基于关注的好友来做Feed流，因此采用Timeline的模式。该模式的实现方案有三种：</li></ul><p>我们本次针对好友的操作，采用的就是Timeline的方式，只需要拿到我们关注用户的信息，然后按照时间排序即可</p><h4 id="7-3-2-Timeline的三种模式"><a href="#7-3-2-Timeline的三种模式" class="headerlink" title="7.3.2 Timeline的三种模式"></a>7.3.2 Timeline的三种模式</h4><ul><li>拉模式</li><li>推模式</li><li>推拉结合</li></ul><p><strong>拉模式</strong>：也叫做读扩散</p><p><img src="/img/blogs/java/redis/2.7.2.png"></p><p><strong>推模式</strong>：也叫做写扩散。</p><p><img src="/img/blogs/java/redis/2.7.3.png"></p><p><strong>推拉结合模式</strong>：也叫做读写混合，兼具推和拉两种模式的优点</p><p><img src="/img/blogs/java/redis/2.7.4.png"></p><p><strong>三种模式对比</strong>：</p><table><thead><tr><th></th><th>拉模式</th><th>推模式</th><th>推拉结合</th></tr></thead><tbody><tr><td>写比例</td><td>低</td><td>高</td><td>中</td></tr><tr><td>读比例</td><td>高</td><td>低</td><td>中</td></tr><tr><td>用户读取延迟</td><td>高</td><td>低</td><td>低</td></tr><tr><td>实现难度</td><td>复杂</td><td>简单</td><td>很复杂</td></tr><tr><td>使用场景</td><td>很少使用</td><td>用户量少、没有大V</td><td>过千万的用户量，有大V</td></tr></tbody></table><h3 id="7-4-推送到粉丝收件箱"><a href="#7-4-推送到粉丝收件箱" class="headerlink" title="7.4 推送到粉丝收件箱"></a>7.4 推送到粉丝收件箱</h3><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p><strong>Feed流的滚动分页</strong></p><ul><li>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</li></ul><p><img src="/img/blogs/java/redis/2.7.5.png"></p><p>我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(Blog blog)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    blog.setUserId(user.getId());<br>    <span class="hljs-comment">// 2.保存探店笔记</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(blog);<br>    <span class="hljs-keyword">if</span>(!isSuccess)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;新增笔记失败!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.查询笔记作者的所有粉丝 select * from tb_follow where follow_user_id = ?</span><br>    List&lt;Follow&gt; follows = followService.query().eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, user.getId()).list();<br>    <span class="hljs-comment">// 4.推送笔记id给所有粉丝</span><br>    <span class="hljs-keyword">for</span> (Follow follow : follows) &#123;<br>        <span class="hljs-comment">// 4.1.获取粉丝id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> follow.getUserId();<br>        <span class="hljs-comment">// 4.2.推送</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;<br>        stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());<br>    &#125;<br>    <span class="hljs-comment">// 5.返回id</span><br>    <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-5-实现关注推送页面的分页查询"><a href="#7-5-实现关注推送页面的分页查询" class="headerlink" title="7.5 实现关注推送页面的分页查询"></a>7.5 实现关注推送页面的分页查询</h3><p>需求：在个人主页的“关注”卡片中，查询并展示推送的Blog信息：</p><ol><li>每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件</li><li>我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据</li></ol><ul><li>综上：我们的请求参数中就需要携带 lastId：<strong>上一次查询的最小时间戳</strong> 和<strong>偏移量</strong>这两个参数</li></ul><h4 id="7-5-1-定义出来具体的返回值实体类"><a href="#7-5-1-定义出来具体的返回值实体类" class="headerlink" title="7.5.1 定义出来具体的返回值实体类"></a>7.5.1 定义出来具体的返回值实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollResult</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;?&gt; list;<br>    <span class="hljs-keyword">private</span> Long minTime;<br>    <span class="hljs-keyword">private</span> Integer offset;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-5-2-BlogController"><a href="#7-5-2-BlogController" class="headerlink" title="7.5.2 BlogController"></a>7.5.2 BlogController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/of/follow&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@RequestParam(&quot;lastId&quot;)</span> Long max, <span class="hljs-meta">@RequestParam(value = &quot;offset&quot;, defaultValue = &quot;0&quot;)</span> Integer offset)</span>&#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogOfFollow(max, offset);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-5-3-BlogServiceImpl"><a href="#7-5-3-BlogServiceImpl" class="headerlink" title="7.5.3 BlogServiceImpl"></a>7.5.3 BlogServiceImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;<br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet()<br>        .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// 3.非空判断</span><br>    <span class="hljs-keyword">if</span> (typedTuples == <span class="hljs-literal">null</span> || typedTuples.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok();<br>    &#125;<br>    <span class="hljs-comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span><br>    List&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123; <span class="hljs-comment">// 5 4 4 2 2</span><br>        <span class="hljs-comment">// 4.1.获取id</span><br>        ids.add(Long.valueOf(tuple.getValue()));<br>        <span class="hljs-comment">// 4.2.获取分数(时间戳）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> tuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span>(time == minTime)&#123;<br>            os++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            minTime = time;<br>            os = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>os = minTime == max ? os : os + offset;<br>    <span class="hljs-comment">// 5.根据id查询blog</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    List&lt;Blog&gt; blogs = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br><br>    <span class="hljs-keyword">for</span> (Blog blog : blogs) &#123;<br>        <span class="hljs-comment">// 5.1.查询blog有关的用户</span><br>        queryBlogUser(blog);<br>        <span class="hljs-comment">// 5.2.查询blog是否被点赞</span><br>        isBlogLiked(blog);<br>    &#125;<br><br>    <span class="hljs-comment">// 6.封装并返回</span><br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    r.setList(blogs);<br>    r.setOffset(os);<br>    r.setMinTime(minTime);<br><br>    <span class="hljs-keyword">return</span> Result.ok(r);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-附近商户"><a href="#8-附近商户" class="headerlink" title="8. 附近商户"></a>8. 附近商户</h2><h3 id="8-1-GEO数据结构"><a href="#8-1-GEO数据结构" class="headerlink" title="8.1 GEO数据结构"></a>8.1 GEO数据结构</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li><li>GEODIST：计算指定的两个点之间的距离并返回</li><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li><li>GEOPOS：返回指定member的坐标</li><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.以后已废弃</li><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</li><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。 6.2.新功能</li></ul><h3 id="8-2-附近商户搜索"><a href="#8-2-附近商户搜索" class="headerlink" title="8.2 附近商户搜索"></a>8.2 附近商户搜索</h3><h4 id="8-2-1-导入店铺数据到GEO"><a href="#8-2-1-导入店铺数据到GEO" class="headerlink" title="8.2.1 导入店铺数据到GEO"></a>8.2.1 导入店铺数据到GEO</h4><ul><li>我们要做的事情是：将数据库表中的数据导入到redis中去，redis中的GEO，GEO在redis中就一个menber和一个经纬度，我们<strong>把x和y轴传入到redis做的经纬度位置</strong>去，但我们不能把所有的数据都放入到menber中去，毕竟作为redis是一个内存级数据库，如果存海量数据，redis还是力不从心，所以我们在这个地方<strong>存储他的id</strong>即可。</li><li>但是这个时候还有一个问题，就是在redis中并没有存储type，所以我们无法根据type来对数据进行筛选，所以<strong>我们可以按照商户类型做分组，类型相同的商户作为同一组</strong>，以typeId为key存入同一个GEO集合中即可</li></ul><p><strong>HmDianPingApplicationTests</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShopData</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.查询店铺信息</span><br>    List&lt;Shop&gt; list = shopService.list();<br>    <span class="hljs-comment">// 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合</span><br>    Map&lt;Long, List&lt;Shop&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));<br>    <span class="hljs-comment">// 3.分批完成写入Redis</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : map.entrySet()) &#123;<br>        <span class="hljs-comment">// 3.1.获取类型id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        <span class="hljs-comment">// 3.2.获取同类型的店铺的集合</span><br>        List&lt;Shop&gt; value = entry.getValue();<br>        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(value.size());<br>        <span class="hljs-comment">// 3.3.写入redis GEOADD key 经度 纬度 member</span><br>        <span class="hljs-keyword">for</span> (Shop shop : value) &#123;<br>            <span class="hljs-comment">// stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());</span><br>            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(<br>                    shop.getId().toString(),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())<br>            ));<br>        &#125;<br>        stringRedisTemplate.opsForGeo().add(key, locations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-2-2-实现附近商户功能"><a href="#8-2-2-实现附近商户功能" class="headerlink" title="8.2.2 实现附近商户功能"></a>8.2.2 实现附近商户功能</h4><p><strong>ShopController</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/of/type&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span><br><span class="hljs-params">)</span> &#123;<br>   <span class="hljs-keyword">return</span> shopService.queryShopByType(typeId, current, x, y);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ShopServiceImpl</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;<br>        <span class="hljs-comment">// 1.判断是否需要根据坐标查询</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 不需要坐标查询，按数据库查询</span><br>            Page&lt;Shop&gt; page = query()<br>                    .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)<br>                    .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.DEFAULT_PAGE_SIZE));<br>            <span class="hljs-comment">// 返回数据</span><br>            <span class="hljs-keyword">return</span> Result.ok(page.getRecords());<br>        &#125;<br><br>        <span class="hljs-comment">// 2.计算分页参数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * SystemConstants.DEFAULT_PAGE_SIZE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * SystemConstants.DEFAULT_PAGE_SIZE;<br><br>        <span class="hljs-comment">// 3.查询redis、按照距离排序、分页。结果：shopId、distance</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;<br>        GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo() <span class="hljs-comment">// GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE</span><br>                .search(<br>                        key,<br>                        GeoReference.fromCoordinate(x, y),<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),<br>                        RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)<br>                );<br>        <span class="hljs-comment">// 4.解析出id</span><br>        <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>        &#125;<br>        List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();<br>        <span class="hljs-keyword">if</span> (list.size() &lt;= from) &#123;<br>            <span class="hljs-comment">// 没有下一页了，结束</span><br>            <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>        &#125;<br>        <span class="hljs-comment">// 4.1.截取 from ~ end的部分</span><br>        List&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br>        Map&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());<br>        list.stream().skip(from).forEach(result -&gt; &#123;<br>            <span class="hljs-comment">// 4.2.获取店铺id</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();<br>            ids.add(Long.valueOf(shopIdStr));<br>            <span class="hljs-comment">// 4.3.获取距离</span><br>            <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();<br>            distanceMap.put(shopIdStr, distance);<br>        &#125;);<br>        <span class="hljs-comment">// 5.根据id查询Shop</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>        List&lt;Shop&gt; shops = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>        <span class="hljs-keyword">for</span> (Shop shop : shops) &#123;<br>            shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());<br>        &#125;<br>        <span class="hljs-comment">// 6.返回</span><br>        <span class="hljs-keyword">return</span> Result.ok(shops);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="9-用户签到"><a href="#9-用户签到" class="headerlink" title="9. 用户签到"></a>9. 用户签到</h2><h3 id="9-1-BitMap用法"><a href="#9-1-BitMap用法" class="headerlink" title="9.1 BitMap用法"></a>9.1 BitMap用法</h3><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0</p><p><img src="/img/blogs/java/redis/2.9.1.png"></p><p>把<strong>每一个bit位对应当月的每一天</strong>，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT ：获取指定位置（offset）的bit值</li><li>BITCOUNT ：统计BitMap中值为1的bit位的数量</li><li>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</li></ul><h3 id="9-2-实现签到功能"><a href="#9-2-实现签到功能" class="headerlink" title="9.2 实现签到功能"></a>9.2 实现签到功能</h3><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><h4 id="9-2-1-UserController"><a href="#9-2-1-UserController" class="headerlink" title="9.2.1 UserController"></a>9.2.1 UserController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-keyword">return</span> userService.sign();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-2-2-UserServiceImpl"><a href="#9-2-2-UserServiceImpl" class="headerlink" title="9.2.2 UserServiceImpl"></a>9.2.2 UserServiceImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">// 5.写入Redis SETBIT key offset 1</span><br>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-3-签到统计"><a href="#9-3-签到统计" class="headerlink" title="9.3 签到统计"></a>9.3 签到统计</h3><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><ul><li>**问题1：**什么叫做连续签到天数？<ul><li>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</li></ul></li><li>**问题2：**如何得到本月到今天为止的所有签到数据？<ul><li>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</li></ul></li><li><strong>问题3：如何从后向前遍历每个bit位？</strong><ul><li>我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0</li><li>我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</li></ul></li></ul><h4 id="9-3-1-UserController"><a href="#9-3-1-UserController" class="headerlink" title="9.3.1 UserController"></a>9.3.1 UserController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/sign/count&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> userService.signCount();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-3-2-UserServiceImpl"><a href="#9-3-2-UserServiceImpl" class="headerlink" title="9.3.2 UserServiceImpl"></a>9.3.2 UserServiceImpl</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">signCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.获取日期</span><br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>    <span class="hljs-comment">// 3.拼接key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">keySuffix</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + keySuffix;<br>    <span class="hljs-comment">// 4.获取今天是本月的第几天</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();<br>    <span class="hljs-comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span><br>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(<br>            key,<br>            BitFieldSubCommands.create()<br>                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)<br>    );<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;<br>        <span class="hljs-comment">// 没有任何签到结果</span><br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-literal">null</span> || num == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.循环遍历</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span><br>        <span class="hljs-keyword">if</span> ((num &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果为0，说明未签到，结束</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不为0，说明已签到，计数器+1</span><br>            count++;<br>        &#125;<br>        <span class="hljs-comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span><br>        num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(count);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-UV统计-HyperLogLog"><a href="#10-UV统计-HyperLogLog" class="headerlink" title="10. UV统计-HyperLogLog"></a>10. UV统计-HyperLogLog</h2><p>首先我们搞懂两个概念：</p><ul><li>UV：全称Unique Visitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><ul><li>通常来说UV会比PV大很多，所以衡量同一个网站的访问量，我们需要综合考虑很多因素，所以我们只是单纯的把这两个值作为一个参考值</li><li>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖，那怎么处理呢？</li></ul><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><ul><li>Hyperloglog(HLL)是从Loglog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</li><li>Redis中的HLL是基于string结构实现的，单个HLL的内存<strong>永远小于16kb</strong>，<strong>内存占用低</strong>的令人发指！作为代价，其测量结果是概率性的，<strong>有小于0.81％的误差</strong>。不过对于UV统计来说，这完全可以忽略。</li></ul><h1 id="三-Redis高级篇"><a href="#三-Redis高级篇" class="headerlink" title="三. Redis高级篇"></a>三. Redis高级篇</h1><h2 id="1-分布式缓存"><a href="#1-分布式缓存" class="headerlink" title="1. 分布式缓存"></a>1. 分布式缓存</h2><h3 id="1-1-单点Redis的问题"><a href="#1-1-单点Redis的问题" class="headerlink" title="1.1 单点Redis的问题"></a>1.1 单点Redis的问题</h3><ul><li><p>数据丢失问题</p><ul><li>Redis是内存存储，服务重启可能会丢失数据</li><li>解决方案：实现Redis数据持久化</li></ul></li><li><p>并发能力问题</p><ul><li>单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景</li><li>解决方案：搭建主从集群，实现读写分离</li></ul></li><li><p>故障恢复问题</p><ul><li>如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段</li><li>解决方案：利用Redis哨兵，实现健康检测和自动恢复</li></ul></li><li><p>存储能力问题</p><ul><li>Redis基于内存，单节点能存储的数据量难以满足海量数据需求</li><li>解决方案：搭建分片集群，利用插槽机制实现动态扩容</li></ul></li></ul><h3 id="1-2-Redis持久化"><a href="#1-2-Redis持久化" class="headerlink" title="1.2 Redis持久化"></a>1.2 Redis持久化</h3><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h4 id="1-2-1-RDB持久化"><a href="#1-2-1-RDB持久化" class="headerlink" title="1.2.1 RDB持久化"></a>1.2.1 RDB持久化</h4><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h5 id="1-2-1-1-RDB持久化在四种情况下会执行："><a href="#1-2-1-1-RDB持久化在四种情况下会执行：" class="headerlink" title="1.2.1.1 RDB持久化在四种情况下会执行："></a>1.2.1.1 RDB持久化在四种情况下会执行：</h5><ul><li>执行save命令</li><li>执行bgsave命令</li><li><strong>Redis停机时</strong></li><li>触发RDB条件时</li></ul><h5 id="1-2-1-2-触发RDB条件"><a href="#1-2-1-2-触发RDB条件" class="headerlink" title="1.2.1.2 触发RDB条件"></a>1.2.1.2 触发RDB条件</h5><ul><li>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="hljs-attr">save</span> <span class="hljs-string">900 1  </span><br><span class="hljs-attr">save</span> <span class="hljs-string">300 10  </span><br><span class="hljs-attr">save</span> <span class="hljs-string">60 10000 </span><br></code></pre></td></tr></table></figure><ul><li>RDB的其它配置也可以在redis.conf文件中设置：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br><span class="hljs-attr">rdbcompression</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># RDB文件名称</span><br><span class="hljs-attr">dbfilename</span> <span class="hljs-string">dump.rdb  </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 文件保存的路径目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">./ </span><br></code></pre></td></tr></table></figure><h4 id="1-2-2-RDB原理"><a href="#1-2-2-RDB原理" class="headerlink" title="1.2.2 RDB原理"></a>1.2.2 RDB原理</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="/img/blogs/java/redis/3.1.1.png"></p><h4 id="1-2-3-RDB小结"><a href="#1-2-3-RDB小结" class="headerlink" title="1.2.3 RDB小结"></a>1.2.3 RDB小结</h4><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h4 id="1-2-4-AOF持久化"><a href="#1-2-4-AOF持久化" class="headerlink" title="1.2.4 AOF持久化"></a>1.2.4 AOF持久化</h4><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="/img/blogs/java/redis/3.1.2.png"></p><ul><li>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 是否开启AOF功能，默认是no</span><br><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes</span><br><span class="hljs-comment"># AOF文件的名称</span><br><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span><br></code></pre></td></tr></table></figure><ul><li>AOF的命令记录的频率也可以通过redis.conf文件来配：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 表示每执行一次写命令，立即记录到AOF文件</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">always </span><br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec </span><br><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br><span class="hljs-attr">appendfsync</span> <span class="hljs-string">no</span><br></code></pre></td></tr></table></figure><h4 id="1-2-5-AOF文件重写"><a href="#1-2-5-AOF文件重写" class="headerlink" title="1.2.5 AOF文件重写"></a>1.2.5 AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="/img/blogs/java/redis/3.1.3.png"></p><ul><li>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><br><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写 </span><br><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb </span><br></code></pre></td></tr></table></figure><h4 id="1-2-6-RDB与AOF对比"><a href="#1-2-6-RDB与AOF对比" class="headerlink" title="1.2.6 RDB与AOF对比"></a>1.2.6 RDB与AOF对比</h4><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td><strong>持久化方式</strong></td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td><strong>数据完整性</strong></td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td><strong>文件大小</strong></td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td><strong>宕机恢复速度</strong></td><td>很快</td><td>慢</td></tr><tr><td><strong>数据恢复优先级</strong></td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td><strong>系统资源占用</strong></td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源<br>但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td><strong>使用场景</strong></td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table><h2 id="2-Redis主从"><a href="#2-Redis主从" class="headerlink" title="2. Redis主从"></a>2. Redis主从</h2><ul><li>Redis主结点只写(master)</li><li>Redis从结点只读(slave)</li></ul><h3 id="2-1-搭建主从架构"><a href="#2-1-搭建主从架构" class="headerlink" title="2.1 搭建主从架构"></a>2.1 搭建主从架构</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="/img/blogs/java/redis/3.2.1.png"></p><h3 id="2-2-主从数据同步原理"><a href="#2-2-主从数据同步原理" class="headerlink" title="2.2 主从数据同步原理"></a>2.2 主从数据同步原理</h3><h4 id="2-2-1-全量同步"><a href="#2-2-1-全量同步" class="headerlink" title="2.2.1 全量同步"></a>2.2.1 全量同步</h4><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点：</p><p><img src="/img/blogs/java/redis/3.2.2.png"></p><p><strong>master如何得知salve是第一次来连接呢</strong>？？<br>有几个概念，可以作为判断依据：</p><ul><li><p><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</p></li><li><p><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p></li><li><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p></li></ul><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p><img src="/img/blogs/java/redis/3.2.3.png"></p><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h4 id="2-2-2-增量同步"><a href="#2-2-2-增量同步" class="headerlink" title="2.2.2 增量同步"></a>2.2.2 增量同步</h4><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><ul><li>什么是增量同步？就是只更新slave与master存在差异的部分数据</li></ul><p><img src="/img/blogs/java/redis/3.2.4.png"></p><ul><li>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：<ul><li>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</li></ul></li><li>repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。</li></ul><h4 id="2-2-3-主从同步优化"><a href="#2-2-3-主从同步优化" class="headerlink" title="2.2.3 主从同步优化"></a>2.2.3 主从同步优化</h4><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p><img src="/img/blogs/java/redis/3.2.5.png"></p><h4 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h4><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul><h2 id="3-Redis哨兵"><a href="#3-Redis哨兵" class="headerlink" title="3. Redis哨兵"></a>3. Redis哨兵</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复</p><h3 id="3-1-哨兵的作用"><a href="#3-1-哨兵的作用" class="headerlink" title="3.1 哨兵的作用"></a>3.1 哨兵的作用</h3><ul><li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><p><img src="/img/blogs/java/redis/3.3.1.png"></p><h3 id="3-2-集群监控原理"><a href="#3-2-集群监控原理" class="headerlink" title="3.2 集群监控原理"></a>3.2 集群监控原理</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li></ul><p><img src="/img/blogs/java/redis/3.3.2.png"></p><h3 id="3-3-选举新的master"><a href="#3-3-选举新的master" class="headerlink" title="3.3 选举新的master"></a>3.3 选举新的master</h3><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><h3 id="3-4-如何实现故障转移"><a href="#3-4-如何实现故障转移" class="headerlink" title="3.4 如何实现故障转移"></a>3.4 如何实现故障转移</h3><p>当选出一个新的master后，该如何实现切换呢？</p><p>流程如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>广播：sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="/img/blogs/java/redis/3.3.3.png"></p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>Sentinel的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个slave作为新的master，执行slaveof no one</li><li>然后让所有节点都执行slaveof 新master</li><li>修改故障节点配置，添加slaveof 新master</li></ul><h3 id="3-6-RedisTemplate"><a href="#3-6-RedisTemplate" class="headerlink" title="3.6 RedisTemplate"></a>3.6 RedisTemplate</h3><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><ol><li>引入依赖<br>在项目的pom文件中引入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置Redis地址<br>然后在配置文件application.yml中指定redis的sentinel相关信息：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>  redis:<br>    sentinel:<br>      master: mymaster<br>      nodes:<br>        - <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">27001</span><br>        - <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">27002</span><br>        - <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">27003</span><br></code></pre></td></tr></table></figure><ol start="3"><li>配置读写分离<br>在项目的启动类中，添加一个新的bean：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="hljs-title function_">clientConfigurationBuilderCustomizer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul><h2 id="4-Redis分片集群"><a href="#4-Redis分片集群" class="headerlink" title="4. Redis分片集群"></a>4. Redis分片集群</h2><h3 id="4-1-分片集群"><a href="#4-1-分片集群" class="headerlink" title="4.1 分片集群"></a>4.1 分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul><p>使用分片集群可以解决上述问题，分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p><img src="/img/blogs/java/redis/3.4.1.png"></p><h3 id="4-2-散列插槽"><a href="#4-2-散列插槽" class="headerlink" title="4.2 散列插槽"></a>4.2 散列插槽</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上</p><p><img src="/img/blogs/java/redis/3.4.2.png"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p>Redis如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key的有效部分计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h3 id="4-3-集群伸缩"><a href="#4-3-集群伸缩" class="headerlink" title="4.3 集群伸缩"></a>4.3 集群伸缩</h3><p>redis-cli –cluster提供了很多操作集群的命令</p><ul><li>添加节点的命令：</li></ul><p><img src="/img/blogs/java/redis/3.4.3.png"></p><h3 id="4-4-故障转移"><a href="#4-4-故障转移" class="headerlink" title="4.4 故障转移"></a>4.4 故障转移</h3><h4 id="4-4-1-自动故障转移"><a href="#4-4-1-自动故障转移" class="headerlink" title="4.4.1 自动故障转移"></a>4.4.1 自动故障转移</h4><p>当集群中有一个master宕机会发生什么呢？</p><p>直接停止一个redis实例，例如7002：</p><ol><li>首先是该实例与其它实例失去连接</li><li>然后是疑似宕机：</li><li>最后是确定下线，自动提升一个slave为新的master</li><li>当7002再次启动，就会变为一个slave节点了</li></ol><h4 id="4-4-2-手动故障转移"><a href="#4-4-2-手动故障转移" class="headerlink" title="4.4.2 手动故障转移"></a>4.4.2 手动故障转移</h4><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。</p><h3 id="4-5-RedisTemplate访问分片集群"><a href="#4-5-RedisTemplate访问分片集群" class="headerlink" title="4.5 RedisTemplate访问分片集群"></a>4.5 RedisTemplate访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><ol><li>引入redis的starter依赖</li><li>配置分片集群地址</li><li>配置读写分离</li></ol><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">cluster:</span><br>      <span class="hljs-attr">nodes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:7001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:7002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:7003</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8001</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8002</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8003</span><br></code></pre></td></tr></table></figure><h2 id="5-多级缓存"><a href="#5-多级缓存" class="headerlink" title="5. 多级缓存"></a>5. 多级缓存</h2><h3 id="5-1-什么是多级缓存"><a href="#5-1-什么是多级缓存" class="headerlink" title="5.1 什么是多级缓存"></a>5.1 什么是多级缓存</h3><p><strong>传统的缓存</strong>策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库</p><ul><li>请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</li><li>Redis缓存失效时，会对数据库产生冲击</li></ul><p><img src="/img/blogs/java/redis/3.5.1.png"></p><p><strong>多级缓存</strong>就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p><ul><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端</li><li>请求到达Nginx后，优先读取Nginx本地缓存</li><li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li><li>如果Redis查询未命中，则查询Tomcat</li><li>请求进入Tomcat后，优先查询JVM进程缓存</li><li>如果JVM进程缓存未命中，则查询数据库</li></ul><p><img src="/img/blogs/java/redis/3.5.2.png"></p><p>多级缓存的关键有两个：</p><ul><li>一个是在nginx中编写业务，实现nginx本地缓存、Redis、Tomcat的查询</li><li>另一个就是在Tomcat中实现JVM进程缓存</li></ul><h3 id="5-2-JVM进程缓存"><a href="#5-2-JVM进程缓存" class="headerlink" title="5.2 JVM进程缓存"></a>5.2 JVM进程缓存</h3><p><img src="/img/blogs/java/redis/3.5.3.png"></p><h4 id="5-2-1-初识Caffeine"><a href="#5-2-1-初识Caffeine" class="headerlink" title="5.2.1 初识Caffeine"></a>5.2.1 初识Caffeine</h4><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减少数据库的压力。我们把缓存分为两类：</p><ul><li>分布式缓存，例如Redis：<ul><li>优点：存储容量更大、可靠性更好、可以在集群间共享</li><li>缺点：访问缓存有网络开销</li><li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li></ul></li><li>进程本地缓存，例如HashMap、GuavaCache：<ul><li>优点：读取本地内存，没有网络开销，速度更快</li><li>缺点：存储容量有限、可靠性较低、无法共享</li><li>场景：性能要求较高，缓存数据量较小</li></ul></li></ul><p>我们今天会利用Caffeine框架来实现JVM进程缓存</p><p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。</p><ul><li>缓存使用的基本API：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBasicOps</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 构建cache对象</span><br>    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();<br><br>    <span class="hljs-comment">// 存数据</span><br>    cache.put(<span class="hljs-string">&quot;gf&quot;</span>, <span class="hljs-string">&quot;迪丽热巴&quot;</span>);<br><br>    <span class="hljs-comment">// 取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">gf</span> <span class="hljs-operator">=</span> cache.getIfPresent(<span class="hljs-string">&quot;gf&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;gf = &quot;</span> + gf);<br><br>    <span class="hljs-comment">// 取数据，包含两个参数：</span><br>    <span class="hljs-comment">// 参数一：缓存的key</span><br>    <span class="hljs-comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span><br>    <span class="hljs-comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">defaultGF</span> <span class="hljs-operator">=</span> cache.get(<span class="hljs-string">&quot;defaultGF&quot;</span>, key -&gt; &#123;<br>        <span class="hljs-comment">// 根据key去数据库查询数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;柳岩&quot;</span>;<br>    &#125;);<br>    System.out.println(<span class="hljs-string">&quot;defaultGF = &quot;</span> + defaultGF);<br>&#125;<br></code></pre></td></tr></table></figure><p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。Caffeine提供了三种缓存驱逐策略：</p><ul><li><p><strong>基于容量</strong>：设置缓存的数量上限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建缓存对象</span><br>Cache&lt;String, String&gt; cache = Caffeine.newBuilder()<br>    .maximumSize(<span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓存大小上限为 1</span><br>    .build();<br></code></pre></td></tr></table></figure></li><li><p><strong>基于时间</strong>：设置缓存的有效时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建缓存对象</span><br>Cache&lt;String, String&gt; cache = Caffeine.newBuilder()<br>    <span class="hljs-comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span><br>    .expireAfterWrite(Duration.ofSeconds(<span class="hljs-number">10</span>)) <br>    .build();<br><br></code></pre></td></tr></table></figure></li><li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p></li></ul><p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p><h4 id="5-2-2-实现JVM进程缓存"><a href="#5-2-2-实现JVM进程缓存" class="headerlink" title="5.2.2 实现JVM进程缓存"></a>5.2.2 实现JVM进程缓存</h4><p>利用Caffeine实现下列需求：</p><ul><li>给根据id查询商品的业务添加缓存，缓存未命中时查询数据库</li><li>给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库</li><li>缓存初始大小为100</li><li>缓存上限为10000</li></ul><h5 id="定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。"><a href="#定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。" class="headerlink" title="定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。"></a>定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</h5><p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.item.config;<br><br><span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Cache;<br><span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;<br><span class="hljs-keyword">import</span> com.heima.item.pojo.Item;<br><span class="hljs-keyword">import</span> com.heima.item.pojo.ItemStock;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaffeineConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Cache&lt;Long, Item&gt; <span class="hljs-title function_">itemCache</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Caffeine.newBuilder()<br>                .initialCapacity(<span class="hljs-number">100</span>)<br>                .maximumSize(<span class="hljs-number">10_000</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="hljs-title function_">stockCache</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Caffeine.newBuilder()<br>                .initialCapacity(<span class="hljs-number">100</span>)<br>                .maximumSize(<span class="hljs-number">10_000</span>)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ItemController"><a href="#ItemController" class="headerlink" title="ItemController"></a>ItemController</h5><p>修改item-service中的<code>com.heima.item.web</code>包下的ItemController类，添加缓存逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;item&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IItemService itemService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IItemStockService stockService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cache&lt;Long, Item&gt; itemCache;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;<br>    <br>    <span class="hljs-comment">// ...其它略</span><br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> itemCache.get(id, key -&gt; itemService.query()<br>                .ne(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">3</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, key)<br>                .one()<br>        );<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> ItemStock <span class="hljs-title function_">findStockById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-Lua语法入门"><a href="#5-3-Lua语法入门" class="headerlink" title="5.3 Lua语法入门"></a>5.3 Lua语法入门</h3><p>Nginx编程需要用到Lua语言</p><p><img src="/img/blogs/java/redis/3.5.4.png"></p><h4 id="5-3-1-初识Lua"><a href="#5-3-1-初识Lua" class="headerlink" title="5.3.1 初识Lua"></a>5.3.1 初识Lua</h4><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><h4 id="5-3-2-变量和循环"><a href="#5-3-2-变量和循环" class="headerlink" title="5.3.2 变量和循环"></a>5.3.2 变量和循环</h4><h5 id="Lua的数据类型"><a href="#Lua的数据类型" class="headerlink" title="Lua的数据类型"></a>Lua的数据类型</h5><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><ul><li>Lua提供了type()函数来判断一个变量的数据类型</li></ul><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为局部变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明字符串，可以用单引号或双引号，</span><br><span class="hljs-keyword">local</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-comment">-- 字符串拼接可以使用 ..</span><br><span class="hljs-keyword">local</span> str2 = <span class="hljs-string">&#x27;hello&#x27;</span> .. <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-comment">-- 声明数字</span><br><span class="hljs-keyword">local</span> num = <span class="hljs-number">21</span><br><span class="hljs-comment">-- 声明布尔类型</span><br><span class="hljs-keyword">local</span> flag = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明数组 ，key为角标的 table</span><br><span class="hljs-keyword">local</span> arr = &#123;<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>&#125;<br><span class="hljs-comment">-- 声明table，类似java的map</span><br><span class="hljs-keyword">local</span> map =  &#123;name=<span class="hljs-string">&#x27;Jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<br></code></pre></td></tr></table></figure><p>Lua中的数组角标是从1开始，访问的时候与Java中类似：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 访问数组，lua数组的角标从1开始</span><br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>Lua中的table可以用key来访问：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 访问table</span><br><span class="hljs-built_in">print</span>(map[<span class="hljs-string">&#x27;name&#x27;</span>])<br><span class="hljs-built_in">print</span>(map.name)<br></code></pre></td></tr></table></figure><h4 id="5-3-3-循环"><a href="#5-3-3-循环" class="headerlink" title="5.3.3 循环"></a>5.3.3 循环</h4><p>对于table，我们可以利用for循环来遍历。不过数组和普通table遍历略有差异。<br>遍历数组：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明数组 key为索引的 table</span><br><span class="hljs-keyword">local</span> arr = &#123;<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>&#125;<br><span class="hljs-comment">-- 遍历数组</span><br><span class="hljs-keyword">for</span> index,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(index, value) <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>遍历普通table</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明map，也就是table</span><br><span class="hljs-keyword">local</span> map = &#123;name=<span class="hljs-string">&#x27;Jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<br><span class="hljs-comment">-- 遍历table</span><br><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(map) <span class="hljs-keyword">do</span><br>   <span class="hljs-built_in">print</span>(key, value) <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="5-3-4-函数"><a href="#5-3-4-函数" class="headerlink" title="5.3.4 函数"></a>5.3.4 函数</h4><p>定义函数的语法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名<span class="hljs-params">( argument1, argument2..., argumentn)</span></span><br>    <span class="hljs-comment">-- 函数体</span><br>    <span class="hljs-keyword">return</span> 返回值<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>例如，定义一个函数，用来打印数组：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr)</span></span><br>    <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">print</span>(value)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="5-3-5-条件控制"><a href="#5-3-5-条件控制" class="headerlink" title="5.3.5 条件控制"></a>5.3.5 条件控制</h4><p>类似Java的条件控制，例如if、else语法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(布尔表达式)<br><span class="hljs-keyword">then</span><br>   <span class="hljs-comment">--[ 布尔表达式为 true 时执行该语句块 --]</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-comment">--[ 布尔表达式为 false 时执行该语句块 --]</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="5-3-6-案例"><a href="#5-3-6-案例" class="headerlink" title="5.3.6 案例"></a>5.3.6 案例</h4><p>需求：自定义一个函数，可以打印table，当参数为nil时，打印错误信息</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> arr <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数组不能为空！&#x27;</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">print</span>(value)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="6-实现多级缓存"><a href="#6-实现多级缓存" class="headerlink" title="6. 实现多级缓存"></a>6. 实现多级缓存</h2><h3 id="6-1-OpenResty"><a href="#6-1-OpenResty" class="headerlink" title="6.1 OpenResty"></a>6.1 OpenResty</h3><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开OpenResty</p><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：</p><ul><li>具备Nginx的完整功能</li><li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li><li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li></ul><h3 id="6-2-OpenResty快速入门"><a href="#6-2-OpenResty快速入门" class="headerlink" title="6.2 OpenResty快速入门"></a>6.2 OpenResty快速入门</h3><p>OpenResty监听请求<br>OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：</p><ol><li>添加对OpenResty的Lua模块的加载<br>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#lua 模块</span><br><span class="hljs-attribute">lua_package_path</span> <span class="hljs-string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;<br><span class="hljs-comment">#c模块     </span><br><span class="hljs-attribute">lua_package_cpath</span> <span class="hljs-string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;  <br></code></pre></td></tr></table></figure><ol start="2"><li>监听&#x2F;api&#x2F;item路径<br>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对&#x2F;api&#x2F;item这个路径的监听：</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span>  /api/item &#123;<br>    <span class="hljs-comment"># 默认的响应类型</span><br>    <span class="hljs-attribute">default_type</span> application/json;<br>    <span class="hljs-comment"># 响应结果由lua/item.lua文件来决定</span><br>    <span class="hljs-attribute">content_by_lua_file</span> lua/item.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个监听，就类似于SpringMVC中的<code>@GetMapping(&quot;/api/item&quot;)</code>做路径映射。<br>而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。</p><ol start="3"><li>编写item.lua，返回假数据<br>item.lua中，利用ngx.say()函数返回数据到Response中</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">ngx.say(<span class="hljs-string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:17900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="6-3-请求参数处理"><a href="#6-3-请求参数处理" class="headerlink" title="6.3 请求参数处理"></a>6.3 请求参数处理</h3><p>要返回真实数据，必须根据前端传递来的商品id，查询商品信息才可以。那么如何获取前端传递的商品参数呢？</p><ul><li>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</li></ul><table><thead><tr><th>参数格式</th><th>参数示例</th><th>参数解析代码示例</th></tr></thead><tbody><tr><td>路径占位符</td><td><code>/item/1001</code></td><td>–1.正则表达式匹配:<br>location ~ &#x2F;item&#x2F;(\d+) {<br>    content_by_lua_file lua&#x2F;item.lua;<br>}<br>– 2. 匹配到的参数会存入ngx.var数组中，<br>– 可以用角标获取<br>local id &#x3D; ngx.var[1]</td></tr><tr><td>请求头</td><td><code>id: 1001</code></td><td>– 获取请求头，返回值是table类型<br>local headers &#x3D; ngx.req.get_headers()</td></tr><tr><td>Get请求参数</td><td><code>?id=1001</code></td><td>– 获取GET请求参数，返回值是table类型<br>local getParams &#x3D; ngx.req.get_url_args()</td></tr><tr><td>Post表单参数</td><td><code>id=1001</code></td><td>– 读取请求体<br>ngx.req.read_body()<br>– 获取POST表单参数，返回值是table类型<br>local postParams &#x3D; ngx.req.get_post_args()</td></tr><tr><td>JSON参数</td><td><code>{&quot;id&quot;: 1001}</code></td><td>– 读取请求体<br>ngx.req.read_body()<br>– 获取body中的json参数，返回值是string类型<br>local jsonBody &#x3D; ngx.req.get_body_data()</td></tr></tbody></table><h3 id="6-4-查询Tomcat"><a href="#6-4-查询Tomcat" class="headerlink" title="6.4 查询Tomcat"></a>6.4 查询Tomcat</h3><p>拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息</p><p><img src="/img/blogs/java/redis/3.6.1.png"></p><h4 id="6-4-1-发送http请求的API"><a href="#6-4-1-发送http请求的API" class="headerlink" title="6.4.1 发送http请求的API"></a>6.4.1 发送http请求的API</h4><p>nginx提供了内部API用以发送http请求：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> resp = ngx.location.capture(<span class="hljs-string">&quot;/path&quot;</span>,&#123;<br>    method = ngx.HTTP_GET,   <span class="hljs-comment">-- 请求方式</span><br>    args = &#123;a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>&#125;,  <span class="hljs-comment">-- get方式传参数</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>返回的响应内容包括：</p><ul><li>resp.status：响应状态码</li><li>resp.header：响应头，是一个table</li><li>resp.body：响应体，就是响应数据</li></ul><h4 id="6-4-2-封装HTTP查询函数"><a href="#6-4-2-封装HTTP查询函数" class="headerlink" title="6.4.2 封装HTTP查询函数"></a>6.4.2 封装HTTP查询函数</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 封装函数，发送http请求，并解析响应</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_http</span><span class="hljs-params">(path, params)</span></span><br>    <span class="hljs-keyword">local</span> resp = ngx.location.capture(<span class="hljs-built_in">path</span>,&#123;<br>        method = ngx.HTTP_GET,<br>        args = params,<br>    &#125;)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> resp <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 记录错误信息，返回404</span><br>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;http请求查询失败, path: &quot;</span>, <span class="hljs-built_in">path</span> , <span class="hljs-string">&quot;, args: &quot;</span>, args)<br>        ngx.<span class="hljs-built_in">exit</span>(<span class="hljs-number">404</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> resp.body<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 将方法导出</span><br><span class="hljs-keyword">local</span> _M = &#123;  <br>    read_http = read_http<br>&#125;  <br><span class="hljs-keyword">return</span> _M<br></code></pre></td></tr></table></figure><h4 id="6-4-3-实现商品查询"><a href="#6-4-3-实现商品查询" class="headerlink" title="6.4.3 实现商品查询"></a>6.4.3 实现商品查询</h4><p>最后，我们修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span><br><span class="hljs-keyword">local</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;common&quot;</span>)<br><span class="hljs-comment">-- 从 common中获取read_http这个函数</span><br><span class="hljs-keyword">local</span> read_http = common.read_http<br><span class="hljs-comment">-- 获取路径参数</span><br><span class="hljs-keyword">local</span> id = ngx.var[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 根据id查询商品</span><br><span class="hljs-keyword">local</span> itemJSON = read_http(<span class="hljs-string">&quot;/item/&quot;</span>.. id, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">-- 根据id查询商品库存</span><br><span class="hljs-keyword">local</span> itemStockJSON = read_http(<span class="hljs-string">&quot;/item/stock/&quot;</span>.. id, <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><h4 id="6-4-4-CJSON工具类"><a href="#6-4-4-CJSON工具类" class="headerlink" title="6.4.4 CJSON工具类"></a>6.4.4 CJSON工具类</h4><p>OpenResty提供了一个cjson的模块用来处理JSON的序列化和反序列化。</p><ol><li>引入cjson模块：</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;cjson&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>序列化：</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> obj = &#123;<br>    name = <span class="hljs-string">&#x27;jack&#x27;</span>,<br>    age = <span class="hljs-number">21</span><br>&#125;<br><span class="hljs-comment">-- 把 table 序列化为 json</span><br><span class="hljs-keyword">local</span> json = cjson.encode(obj)<br></code></pre></td></tr></table></figure><ol start="3"><li>反序列化：</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> json = <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span><br><span class="hljs-comment">-- 反序列化 json为 table</span><br><span class="hljs-keyword">local</span> obj = cjson.decode(json);<br><span class="hljs-built_in">print</span>(obj.name)<br></code></pre></td></tr></table></figure><h4 id="6-4-5-实现Tomcat查询"><a href="#6-4-5-实现Tomcat查询" class="headerlink" title="6.4.5 实现Tomcat查询"></a>6.4.5 实现Tomcat查询</h4><p>下面，我们修改之前的item.lua中的业务，添加json处理功能：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 导入common函数库</span><br><span class="hljs-keyword">local</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;common&#x27;</span>)<br><span class="hljs-keyword">local</span> read_http = common.read_http<br><span class="hljs-comment">-- 导入cjson库</span><br><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cjson&#x27;</span>)<br><br><span class="hljs-comment">-- 获取路径参数</span><br><span class="hljs-keyword">local</span> id = ngx.var[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 根据id查询商品</span><br><span class="hljs-keyword">local</span> itemJSON = read_http(<span class="hljs-string">&quot;/item/&quot;</span>.. id, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">-- 根据id查询商品库存</span><br><span class="hljs-keyword">local</span> itemStockJSON = read_http(<span class="hljs-string">&quot;/item/stock/&quot;</span>.. id, <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">-- JSON转化为lua的table</span><br><span class="hljs-keyword">local</span> item = cjson.decode(itemJSON)<br><span class="hljs-keyword">local</span> stock = cjson.decode(stockJSON)<br><br><span class="hljs-comment">-- 组合数据</span><br>item.stock = stock.stock<br>item.sold = stock.sold<br><br><span class="hljs-comment">-- 把item序列化为json 返回结果</span><br>ngx.say(cjson.encode(item))<br></code></pre></td></tr></table></figure><h4 id="6-4-6-基于ID负载均衡"><a href="#6-4-6-基于ID负载均衡" class="headerlink" title="6.4.6 基于ID负载均衡"></a>6.4.6 基于ID负载均衡</h4><p>我们的tomcat是单机部署。而实际开发中，tomcat一定是集群模式</p><p><img src="/img/blogs/java/redis/3.6.2.png"></p><p>OpenResty需要对tomcat集群做负载均衡。</p><p>而默认的负载均衡规则是轮询模式，当我们查询&#x2F;item&#x2F;10001时：</p><ul><li>第一次会访问8081端口的tomcat服务，在该服务内部就形成了JVM进程缓存</li><li>第二次会访问8082端口的tomcat服务，该服务内部没有JVM缓存（因为JVM缓存无法共享），会查询数据库</li></ul><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。<br>首先，定义tomcat集群，并设置基于路径做负载均衡：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> tomcat-cluster &#123;<br>    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$request_uri</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.150.1:8081</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.150.1:8082</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /item &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://tomcat-cluster;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5-Redis缓存预热"><a href="#6-5-Redis缓存预热" class="headerlink" title="6.5 Redis缓存预热"></a>6.5 Redis缓存预热</h3><p><img src="/img/blogs/java/redis/3.6.3.png"></p><p>Redis缓存会面临冷启动问题：</p><ul><li><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</li><li><strong>缓存预热</strong>：在实际开发中，我们可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</li><li>我们数据量较少，并且没有数据统计相关功能，目前可以在启动时将所有数据都放入缓存中。</li></ul><p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。<br>这里我们利用InitializingBean接口来实现，因为InitializingBean可以在对象被Spring创建并且成员变量全部注入后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IItemService itemService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IItemStockService stockService;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">MAPPER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 初始化缓存</span><br>        <span class="hljs-comment">// 1.查询商品信息</span><br>        List&lt;Item&gt; itemList = itemService.list();<br>        <span class="hljs-comment">// 2.放入缓存</span><br>        <span class="hljs-keyword">for</span> (Item item : itemList) &#123;<br>            <span class="hljs-comment">// 2.1.item序列化为JSON</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> MAPPER.writeValueAsString(item);<br>            <span class="hljs-comment">// 2.2.存入redis</span><br>            redisTemplate.opsForValue().set(<span class="hljs-string">&quot;item:id:&quot;</span> + item.getId(), json);<br>        &#125;<br><br>        <span class="hljs-comment">// 3.查询商品库存信息</span><br>        List&lt;ItemStock&gt; stockList = stockService.list();<br>        <span class="hljs-comment">// 4.放入缓存</span><br>        <span class="hljs-keyword">for</span> (ItemStock stock : stockList) &#123;<br>            <span class="hljs-comment">// 2.1.item序列化为JSON</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> MAPPER.writeValueAsString(stock);<br>            <span class="hljs-comment">// 2.2.存入redis</span><br>            redisTemplate.opsForValue().set(<span class="hljs-string">&quot;item:stock:id:&quot;</span> + stock.getId(), json);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-6-查询Redis缓存"><a href="#6-6-查询Redis缓存" class="headerlink" title="6.6 查询Redis缓存"></a>6.6 查询Redis缓存</h3><p>当请求进入OpenResty之后：</p><ul><li>优先查询Redis缓存</li><li>如果Redis缓存未命中，再查询Tomcat</li></ul><p>修改item.lua文件，实现对Redis的查询，查询逻辑是：</p><ul><li>根据id查询Redis</li><li>如果查询失败则继续查询Tomcat</li><li>将查询结果返回</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 导入common函数库</span><br><span class="hljs-keyword">local</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;common&#x27;</span>)<br><span class="hljs-keyword">local</span> read_http = common.read_http<br><span class="hljs-keyword">local</span> read_redis = common.read_redis<br><span class="hljs-comment">-- 导入cjson库</span><br><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cjson&#x27;</span>)<br><br><span class="hljs-comment">-- 封装查询函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_data</span><span class="hljs-params">(key, path, params)</span></span><br>    <span class="hljs-comment">-- 查询本地缓存</span><br>    <span class="hljs-keyword">local</span> val = read_redis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>, key)<br>    <span class="hljs-comment">-- 判断查询结果</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> val <span class="hljs-keyword">then</span><br>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)<br>        <span class="hljs-comment">-- redis查询失败，去查询http</span><br>        val = read_http(<span class="hljs-built_in">path</span>, params)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">-- 返回数据</span><br>    <span class="hljs-keyword">return</span> val<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 获取路径参数</span><br><span class="hljs-keyword">local</span> id = ngx.var[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">-- 查询商品信息</span><br><span class="hljs-keyword">local</span> itemJSON = read_data(<span class="hljs-string">&quot;item:id:&quot;</span> .. id,  <span class="hljs-string">&quot;/item/&quot;</span> .. id, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">-- 查询库存信息</span><br><span class="hljs-keyword">local</span> stockJSON = read_data(<span class="hljs-string">&quot;item:stock:id:&quot;</span> .. id, <span class="hljs-string">&quot;/item/stock/&quot;</span> .. id, <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">-- JSON转化为lua的table</span><br><span class="hljs-keyword">local</span> item = cjson.decode(itemJSON)<br><span class="hljs-keyword">local</span> stock = cjson.decode(stockJSON)<br><span class="hljs-comment">-- 组合数据</span><br>item.stock = stock.stock<br>item.sold = stock.sold<br><br><span class="hljs-comment">-- 把item序列化为json 返回结果</span><br>ngx.say(cjson.encode(item))<br></code></pre></td></tr></table></figure><h3 id="6-7-Nginx本地缓存"><a href="#6-7-Nginx本地缓存" class="headerlink" title="6.7 Nginx本地缓存"></a>6.7 Nginx本地缓存</h3><p><img src="/img/blogs/java/redis/3.6.4.png"></p><p>OpenResty为Nginx提供了<strong>shard dict</strong>的功能，可以在nginx的多个worker之间共享数据，实现缓存功能。</p><ol><li>开启共享字典，在nginx.conf的http下添加配置：</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span><br><span class="hljs-attribute">lua_shared_dict</span> item_cache <span class="hljs-number">150m</span>; <br></code></pre></td></tr></table></figure><ol start="2"><li>操作共享字典：</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取本地缓存对象</span><br><span class="hljs-keyword">local</span> item_cache = ngx.shared.item_cache<br><span class="hljs-comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span><br>item_cache:set(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-number">1000</span>)<br><span class="hljs-comment">-- 读取</span><br><span class="hljs-keyword">local</span> val = item_cache:get(<span class="hljs-string">&#x27;key&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="实现本地缓存查询"><a href="#实现本地缓存查询" class="headerlink" title="实现本地缓存查询"></a>实现本地缓存查询</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 导入common函数库</span><br><span class="hljs-keyword">local</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;common&#x27;</span>)<br><span class="hljs-keyword">local</span> read_http = common.read_http<br><span class="hljs-keyword">local</span> read_redis = common.read_redis<br><span class="hljs-comment">-- 导入cjson库</span><br><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cjson&#x27;</span>)<br><span class="hljs-comment">-- 导入共享词典，本地缓存</span><br><span class="hljs-keyword">local</span> item_cache = ngx.shared.item_cache<br><br><span class="hljs-comment">-- 封装查询函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_data</span><span class="hljs-params">(key, expire, path, params)</span></span><br>    <span class="hljs-comment">-- 查询本地缓存</span><br>    <span class="hljs-keyword">local</span> val = item_cache:get(key)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> val <span class="hljs-keyword">then</span><br>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;本地缓存查询失败，尝试查询Redis， key: &quot;</span>, key)<br>        <span class="hljs-comment">-- 查询redis</span><br>        val = read_redis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>, key)<br>        <span class="hljs-comment">-- 判断查询结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> val <span class="hljs-keyword">then</span><br>            ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)<br>            <span class="hljs-comment">-- redis查询失败，去查询http</span><br>            val = read_http(<span class="hljs-built_in">path</span>, params)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">-- 查询成功，把数据写入本地缓存</span><br>    item_cache:set(key, val, expire)<br>    <span class="hljs-comment">-- 返回数据</span><br>    <span class="hljs-keyword">return</span> val<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 获取路径参数</span><br><span class="hljs-keyword">local</span> id = ngx.var[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">-- 查询商品信息</span><br><span class="hljs-keyword">local</span> itemJSON = read_data(<span class="hljs-string">&quot;item:id:&quot;</span> .. id, <span class="hljs-number">1800</span>,  <span class="hljs-string">&quot;/item/&quot;</span> .. id, <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">-- 查询库存信息</span><br><span class="hljs-keyword">local</span> stockJSON = read_data(<span class="hljs-string">&quot;item:stock:id:&quot;</span> .. id, <span class="hljs-number">60</span>, <span class="hljs-string">&quot;/item/stock/&quot;</span> .. id, <span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">-- JSON转化为lua的table</span><br><span class="hljs-keyword">local</span> item = cjson.decode(itemJSON)<br><span class="hljs-keyword">local</span> stock = cjson.decode(stockJSON)<br><span class="hljs-comment">-- 组合数据</span><br>item.stock = stock.stock<br>item.sold = stock.sold<br><br><span class="hljs-comment">-- 把item序列化为json 返回结果</span><br>ngx.say(cjson.encode(item))<br></code></pre></td></tr></table></figure><h2 id="7-缓存同步"><a href="#7-缓存同步" class="headerlink" title="7. 缓存同步"></a>7. 缓存同步</h2><p>我们必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步</p><h3 id="7-1-数据同步策略"><a href="#7-1-数据同步策略" class="headerlink" title="7.1 数据同步策略"></a>7.1 数据同步策略</h3><p>缓存数据同步的常见方式有三种：</p><p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><ul><li>优势：简单、方便</li><li>缺点：时效性差，缓存过期之前可能不一致</li><li>场景：更新频率较低，时效性要求低的业务</li></ul><p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p><ul><li>优势：时效性强，缓存与数据库强一致</li><li>缺点：有代码侵入，耦合度高；</li><li>场景：对一致性、时效性要求较高的缓存数据</li></ul><p>**异步通知：**修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><ul><li>优势：低耦合，可以同时通知多个缓存服务</li><li>缺点：时效性一般，可能存在中间不一致状态</li><li>场景：时效性要求一般，有多个服务需要同步</li></ul><p><strong>异步实现：基于Canal的通知</strong>：</p><ul><li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li><li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li><li>缓存服务接收到canal通知，更新缓存</li></ul><p><img src="/img/blogs/java/redis/3.7.1.png"></p><h3 id="7-2-Canal"><a href="#7-2-Canal" class="headerlink" title="7.2 Canal"></a>7.2 Canal</h3><p><strong>Canal</strong>，译意为水道&#x2F;管道&#x2F;沟渠，canal是阿里巴巴旗下的一款开源项目，基于Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。</p><p>Canal是基于mysql的主从同步来实现的，MySQL主从同步的原理如下：</p><p><img src="/img/blogs/java/redis/3.7.2.png"></p><p>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binary log变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</p><h3 id="7-3-监听Canal"><a href="#7-3-监听Canal" class="headerlink" title="7.3 监听Canal"></a>7.3 监听Canal</h3><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。</p><p><img src="/img/blogs/java/redis/3.7.3.png"></p><p>我们可以利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p><h5 id="编写监听器"><a href="#编写监听器" class="headerlink" title="编写监听器"></a>编写监听器</h5><p>通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p><ul><li>实现类通过<code>@CanalTable(&quot;tb_item&quot;)</code>指定监听的表信息</li><li>EntryHandler的泛型是与表对应的实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CanalTable(&quot;tb_item&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EntryHandler</span>&lt;Item&gt; &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisHandler redisHandler;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cache&lt;Long, Item&gt; itemCache;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Item item)</span> &#123;<br>        <span class="hljs-comment">// 写数据到JVM进程缓存</span><br>        itemCache.put(item.getId(), item);<br>        <span class="hljs-comment">// 写数据到redis</span><br>        redisHandler.saveItem(item);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Item before, Item after)</span> &#123;<br>        <span class="hljs-comment">// 写数据到JVM进程缓存</span><br>        itemCache.put(after.getId(), after);<br>        <span class="hljs-comment">// 写数据到redis</span><br>        redisHandler.saveItem(after);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Item item)</span> &#123;<br>        <span class="hljs-comment">// 删除数据到JVM进程缓存</span><br>        itemCache.invalidate(item.getId());<br>        <span class="hljs-comment">// 删除数据到redis</span><br>        redisHandler.deleteItemById(item.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-多级缓存总结"><a href="#8-多级缓存总结" class="headerlink" title="8. 多级缓存总结"></a>8. 多级缓存总结</h2><p><img src="/img/blogs/java/redis/3.8.1.png"></p><h2 id="9-Redis最佳实践"><a href="#9-Redis最佳实践" class="headerlink" title="9. Redis最佳实践"></a>9. Redis最佳实践</h2><h3 id="9-1-Redis键值设计"><a href="#9-1-Redis键值设计" class="headerlink" title="9.1 Redis键值设计"></a>9.1 Redis键值设计</h3><h4 id="9-1-1-优雅的key结构"><a href="#9-1-1-优雅的key结构" class="headerlink" title="9.1.1 优雅的key结构"></a>9.1.1 优雅的key结构</h4><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p><ul><li>遵循基本格式：<code>[业务名称]:[数据名]:[id]</code></li><li>长度不超过44字节</li><li>不包含特殊字符</li></ul><p><img src="/img/blogs/java/redis/3.9.1.png"></p><p>这样设计的好处：</p><ul><li>可读性强</li><li>避免key冲突</li><li>方便管理</li><li>更节省内存</li></ul><h4 id="9-1-2-拒绝BigKey"><a href="#9-1-2-拒绝BigKey" class="headerlink" title="9.1.2 拒绝BigKey"></a>9.1.2 拒绝BigKey</h4><h5 id="9-1-2-1-BigKey"><a href="#9-1-2-1-BigKey" class="headerlink" title="9.1.2.1 BigKey"></a>9.1.2.1 BigKey</h5><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p><ul><li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB</li><li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个</li><li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB</li></ul><p>推荐值：</p><ul><li>单个key的value小于10KB</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><h5 id="9-1-2-2-BigKey的危害"><a href="#9-1-2-2-BigKey的危害" class="headerlink" title="9.1.2.2 BigKey的危害"></a>9.1.2.2 BigKey的危害</h5><ul><li>网络阻塞<ul><li>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</li></ul></li><li>数据倾斜<ul><li>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡</li></ul></li><li>Redis阻塞<ul><li>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</li></ul></li><li>CPU压力<ul><li>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</li></ul></li></ul><h5 id="9-1-2-3-如何发现BigKey"><a href="#9-1-2-3-如何发现BigKey" class="headerlink" title="9.1.2.3 如何发现BigKey"></a>9.1.2.3 如何发现BigKey</h5><ul><li><strong>redis-cli –bigkeys</strong><ul><li>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key</li></ul></li><li><strong>scan扫描</strong><ul><li>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）</li></ul></li><li><strong>第三方工具</strong><ul><li>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况</li></ul></li><li><strong>网络监控</strong><ul><li>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</li></ul></li></ul><h5 id="9-1-2-4-如何删除BigKey"><a href="#9-1-2-4-如何删除BigKey" class="headerlink" title="9.1.2.4 如何删除BigKey"></a>9.1.2.4 如何删除BigKey</h5><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p><ul><li>redis 3.0 及以下版本<ul><li>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey</li></ul></li><li>Redis 4.0以后<ul><li>Redis在4.0后提供了异步删除的命令：unlink</li></ul></li></ul><h4 id="9-1-3-恰当的数据类型"><a href="#9-1-3-恰当的数据类型" class="headerlink" title="9.1.3 恰当的数据类型"></a>9.1.3 恰当的数据类型</h4><h5 id="例1：比如存储一个User对象，我们有三种存储方式："><a href="#例1：比如存储一个User对象，我们有三种存储方式：" class="headerlink" title="例1：比如存储一个User对象，我们有三种存储方式："></a>例1：比如存储一个User对象，我们有三种存储方式：</h5><ol><li>方式一：json字符串</li><li>方式二：字段打散</li><li>方式三：hash（<strong>推荐</strong>）</li></ol><p><img src="/img/blogs/java/redis/3.9.2.png"></p><h5 id="例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"><a href="#例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？" class="headerlink" title="例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？"></a>例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</h5><p>存在的问题：</p><ul><li>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多</li><li>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</li></ul><ol><li>方案一： 拆分为string类型</li><li>方案二： 拆分为小的hash，将 id &#x2F; 100 作为key， 将id % 100 作为field，这样每100个元素为一个Hash(<strong>推荐</strong>)</li></ol><h4 id="9-1-4-总结"><a href="#9-1-4-总结" class="headerlink" title="9.1.4 总结"></a>9.1.4 总结</h4><ul><li>Key的最佳实践<ul><li>固定格式：<code>[业务名]:[数据名]:[id]</code></li><li>足够简短：不超过44字节</li><li>不包含特殊字符</li></ul></li><li>Value的最佳实践：<ul><li>合理的拆分数据，拒绝BigKey</li><li>选择合适数据结构</li><li>Hash结构的entry数量不要超过1000</li><li>设置合理的超时时间</li></ul></li></ul><h3 id="9-2-批处理优化"><a href="#9-2-批处理优化" class="headerlink" title="9.2 批处理优化"></a>9.2 批处理优化</h3><h4 id="9-2-1-Pipeline"><a href="#9-2-1-Pipeline" class="headerlink" title="9.2.1 Pipeline"></a>9.2.1 Pipeline</h4><h5 id="9-2-1-1-客户端与redis服务器是这样交互的"><a href="#9-2-1-1-客户端与redis服务器是这样交互的" class="headerlink" title="9.2.1.1 客户端与redis服务器是这样交互的"></a>9.2.1.1 客户端与redis服务器是这样交互的</h5><ol><li>单个命令的执行流程<br>一次命令的响应时间 &#x3D; 1次往返的网络传输耗时 + 1次Redis执行命令耗时</li></ol><p><img src="/img/blogs/java/redis/3.9.3.png"></p><ol start="2"><li>N条命令依次执行<br>N次命令的响应时间 &#x3D; N次往返的网络传输耗时 + N次Redis执行命令耗时</li></ol><p><img src="/img/blogs/java/redis/3.9.4.png"></p><ol start="3"><li>N条命令批量执行<br>N次命令的响应时间 &#x3D; 1次往返的网络传输耗时 + N次Redis执行命令耗时</li></ol><p><img src="/img/blogs/java/redis/3.9.5.png"></p><h5 id="9-2-1-2-MSet"><a href="#9-2-1-2-MSet" class="headerlink" title="9.2.1.2 MSet"></a>9.2.1.2 MSet</h5><p>Redis提供了很多Mxxx这样的命令，可以实现批量插入数据，例如：</p><ul><li>mset</li><li>hmset</li></ul><p>利用mset批量插入10万条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMxx</span><span class="hljs-params">()</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2000</span>];<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>        j = (i % <span class="hljs-number">1000</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>        arr[j] = <span class="hljs-string">&quot;test:key_&quot;</span> + i;<br>        arr[j + <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value_&quot;</span> + i;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>            jedis.mset(arr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time: &quot;</span> + (e - b));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="9-2-1-3-Pipeline"><a href="#9-2-1-3-Pipeline" class="headerlink" title="9.2.1.3 Pipeline"></a>9.2.1.3 Pipeline</h5><p>MSET虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPipeline</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> jedis.pipelined();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;<br>        <span class="hljs-comment">// 放入命令到管道</span><br>        pipeline.set(<span class="hljs-string">&quot;test:key_&quot;</span> + i, <span class="hljs-string">&quot;value_&quot;</span> + i);<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 每放入1000条命令，批量执行</span><br>            pipeline.sync();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;time: &quot;</span> + (e - b));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-2-2-集群下的批处理"><a href="#9-2-2-集群下的批处理" class="headerlink" title="9.2.2 集群下的批处理"></a>9.2.2 集群下的批处理</h4><p>如MSET或Pipeline这样的批处理需要在一次请求中携带多条命令，而此时如果Redis是一个集群，那批处理命令的多个key必须落在一个插槽中，否则就会导致执行失败。</p><table><thead><tr><th></th><th>串行命令</th><th>串行slot</th><th>并行slot(推荐)</th><th>hash_tag</th></tr></thead><tbody><tr><td>实现思路</td><td>for循环遍历，依次执行每个命令</td><td>在客户端计算每个key的slot，将slot一致分为一组，每组都利用Pipeline批处理，串行执行各组命令</td><td>在客户端计算每个key的slot，将slot一致分为一组，每组都利用Pipeline批处理，并行执行各组命令</td><td>将所有key设置相同的hash_tag，则所有key的slot一定相同</td></tr><tr><td>耗时</td><td>N次网络耗时 + N次命令耗时</td><td>m次网络耗时 + N次命令耗时<br>(m &#x3D; key的slot个数)</td><td>1次网络耗时 + N次命令耗时</td><td>1次网络耗时 + N次命令耗时</td></tr><tr><td>优点</td><td>实现简单</td><td>耗时较短</td><td>耗时非常短</td><td>耗时非常短、实现简单</td></tr><tr><td>缺点</td><td>耗时非常久</td><td>实现稍复杂</td><td>实现复杂</td><td>容易出现数据倾斜</td></tr></tbody></table><ul><li>推荐使用并行slot</li></ul><h3 id="9-3-服务端优化"><a href="#9-3-服务端优化" class="headerlink" title="9.3 服务端优化"></a>9.3 服务端优化</h3><h4 id="9-3-1-持久化配置"><a href="#9-3-1-持久化配置" class="headerlink" title="9.3.1 持久化配置"></a>9.3.1 持久化配置</h4><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p><ul><li>用来做缓存的Redis实例尽量不要开启持久化功能</li><li>建议关闭RDB持久化功能，<strong>使用AOF持久化</strong></li><li>利用脚本定期在slave节点做RDB，实现数据备份</li><li>设置合理的rewrite阈值，避免频繁的bgrewrite</li><li>配置no-appendfsync-on-rewrite &#x3D; yes，禁止在rewrite期间做aof，避免因AOF引起的阻塞</li><li>部署有关建议：<ul><li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li><li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li><li>不要与CPU密集型应用部署在一起</li><li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li></ul></li></ul><h4 id="9-3-2-慢查询优化"><a href="#9-3-2-慢查询优化" class="headerlink" title="9.3.2 慢查询优化"></a>9.3.2 慢查询优化</h4><p>在Redis执行时耗时超过某个阈值的命令，称为慢查询。</p><ul><li><p><strong>慢查询的危害</strong>：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错，所以我们需要解决慢查询问题。</p></li><li><p>慢查询的阈值可以通过配置指定：</p><ul><li>slowlog-log-slower-than：慢查询阈值，单位是微秒。默认是10000，建议1000</li></ul></li><li><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p><ul><li>slowlog-max-len：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</li></ul></li></ul><p>查看慢查询日志列表:</p><ul><li>slowlog len：查询慢查询日志长度</li><li>slowlog get [n]：读取n条慢查询日志</li><li>slowlog reset：清空慢查询列表</li></ul><h4 id="9-3-3-命令及安全配置"><a href="#9-3-3-命令及安全配置" class="headerlink" title="9.3.3 命令及安全配置"></a>9.3.3 命令及安全配置</h4><p>漏洞出现的核心的原因有以下几点：</p><ul><li>Redis未设置密码</li><li>利用了Redis的config set命令动态修改Redis配置</li><li>使用了Root账号权限启动Redis</li></ul><p>为了避免这样的漏洞，这里给出一些建议：</p><ul><li>Redis一定要设置密码</li><li>禁止线上使用下面命令：keys、flushall、flushdb、config set等命令。可以利用rename-command禁用。</li><li>bind：限制网卡，禁止外网网卡访问</li><li>开启防火墙</li><li>不要使用Root账户启动Redis</li><li>尽量不是有默认的端口</li></ul><h4 id="9-3-4-内存配置"><a href="#9-3-4-内存配置" class="headerlink" title="9.3.4 内存配置"></a>9.3.4 内存配置</h4><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p><table><thead><tr><th>内存类型</th><th>说明</th></tr></thead><tbody><tr><td>数据内存</td><td>是Redis最主要的部分，存储Redis的键值信息。主要问题是BigKey问题、内存碎片问题</td></tr><tr><td>进程内存</td><td>Redis主进程本身运行肯定需要占用内存，如代码、常量池等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略</td></tr><tr><td>缓冲区内存</td><td>一般包括客户端缓冲区、AOF缓冲区、复制缓冲区等。客户端缓冲区又包括输入缓冲区和输出缓冲区两种。这部分内存占用波动较大，不当使用BigKey可能导致内存溢出</td></tr></tbody></table><p>内存缓冲区常见的有三种：</p><ul><li>复制缓冲区：主从复制的repl_backlog_buf，如果太小可能导致频繁的全量复制，影响性能。通过replbacklog-size来设置，默认1mb</li><li>AOF缓冲区：AOF刷盘之前的缓存区域，AOF执行rewrite的缓冲区。无法设置容量上限</li><li>客户端缓冲区：分为输入缓冲区和输出缓冲区，输入缓冲区最大1G且不能设置。输出缓冲区可以设置</li></ul><h3 id="9-4-集群最佳实践"><a href="#9-4-集群最佳实践" class="headerlink" title="9.4 集群最佳实践"></a>9.4 集群最佳实践</h3><h4 id="9-4-1-问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务："><a href="#9-4-1-问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：" class="headerlink" title="9.4.1 问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务："></a>9.4.1 问题1、在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</h4><ul><li>为了保证高可用特性，这里建议将 cluster-require-full-coverage配置为false</li></ul><h4 id="9-4-2-问题2、集群带宽问题"><a href="#9-4-2-问题2、集群带宽问题" class="headerlink" title="9.4.2 问题2、集群带宽问题"></a>9.4.2 问题2、集群带宽问题</h4><p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li>插槽信息</li><li>集群状态信息</li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题，所以我们需要去解决这样的问题</p><p><strong>解决途径：</strong></p><ul><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li><li>避免在单个物理机中运行太多Redis实例</li><li>配置合适的cluster-node-timeout值</li></ul><h4 id="9-4-3-其他问题"><a href="#9-4-3-其他问题" class="headerlink" title="9.4.3 其他问题"></a>9.4.3 其他问题</h4><ul><li>数据倾斜问题</li><li>客户端性能问题</li><li>命令的集群兼容性问题</li><li>lua和事务问题</li></ul><p><strong>那我们到底是集群还是主从</strong></p><ul><li>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</li></ul><h1 id="四-Redis原理篇"><a href="#四-Redis原理篇" class="headerlink" title="四. Redis原理篇"></a>四. Redis原理篇</h1><h2 id="1-Redis数据结构"><a href="#1-Redis数据结构" class="headerlink" title="1. Redis数据结构"></a>1. Redis数据结构</h2><h3 id="1-1-动态字符串SDS"><a href="#1-1-动态字符串SDS" class="headerlink" title="1.1 动态字符串SDS"></a>1.1 动态字符串SDS</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。</p><ul><li>例如：Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“虎哥”的SDS。</li></ul><p><img src="/img/blogs/java/redis/4.1.1.png"></p><p>Redis是C语言实现的，其中SDS是一个结构体,源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* buf已保存的字符串字节数，不包含结束标示*/</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* buf申请的总的字节数，不包含结束标示*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 不同SDS的头类型，用来控制SDS的头大小</span><br><span class="hljs-comment">    char buf[];</span><br><span class="hljs-comment">&#125;;</span><br></code></pre></td></tr></table></figure><p>例如，一个包含字符串“name”的sds结构如下：</p><p><img src="/img/blogs/java/redis/4.1.2.png"></p><ul><li>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS</li><li>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间<ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</li></ul></li></ul><h3 id="1-2-IntSet"><a href="#1-2-IntSet" class="headerlink" title="1.2 IntSet"></a>1.2 IntSet</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">intset</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> encoding; <span class="hljs-comment">/* 编码方式，支持存放16位、32位、64位整数*/</span><br>    <span class="hljs-type">uint32_t</span> length; <span class="hljs-comment">/* 元素个数 */</span><br>    <span class="hljs-type">int8_t</span> contents[]; <span class="hljs-comment">/* 整数数组，保存集合数据*/</span><br>&#125; intset;<br></code></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Note that these encodings are ordered, so:</span><br><span class="hljs-comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t)) <span class="hljs-comment">/* 2字节整数，范围类似java的short*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t)) <span class="hljs-comment">/* 4字节整数，范围类似java的int */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t)) <span class="hljs-comment">/* 8字节整数，范围类似java的long */</span></span><br></code></pre></td></tr></table></figure><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p><p><img src="/img/blogs/java/redis/4.1.3.png"></p><h4 id="IntSet升级"><a href="#IntSet升级" class="headerlink" title="IntSet升级"></a>IntSet升级</h4><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li><li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p>原本：</p><p><img src="/img/blogs/java/redis/4.1.4.png"></p><p>扩容后：</p><p><img src="/img/blogs/java/redis/4.1.5.png"></p><p><strong>总结</strong>：Intset可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h3 id="1-3-Dict"><a href="#1-3-Dict" class="headerlink" title="1.3 Dict"></a>1.3 Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。</p><ul><li>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</li></ul><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后<strong>利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置</strong>。</p><ul><li>我们存储k1&#x3D;v1，假设k1的哈希值h &#x3D;1，则1&amp;3 &#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置。</li></ul><h4 id="Dict的扩容"><a href="#Dict的扩容" class="headerlink" title="Dict的扩容"></a>Dict的扩容</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used&#x2F;size） ，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><h4 id="Dict的收缩"><a href="#Dict的收缩" class="headerlink" title="Dict的收缩"></a>Dict的收缩</h4><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩</p><h4 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx &#x3D; 0，标示开始rehash</li><li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><h3 id="1-4-ZipList"><a href="#1-4-ZipList" class="headerlink" title="1.4 ZipList"></a>1.4 ZipList</h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="/img/blogs/java/redis/4.1.6.png"></p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table><h4 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a>ZipListEntry</h4><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="/img/blogs/java/redis/4.1.7.png"></p><ul><li>previous_entry_length：前一节点的长度，占1个或5个字节。<ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</li><li>contents：负责保存节点的数据，可以是字符串或整数</li></ul><h4 id="ZipList的连锁更新问题"><a href="#ZipList的连锁更新问题" class="headerlink" title="ZipList的连锁更新问题"></a>ZipList的连锁更新问题</h4><p>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="/img/blogs/java/redis/4.1.8.png"></p><p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>ZipList特性：</strong></p><ul><li>压缩列表的可以看做一种连续内存空间的”双向链表”</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题</li></ul><h3 id="1-5-QuickList"><a href="#1-5-QuickList" class="headerlink" title="1.5 QuickList"></a>1.5 QuickList</h3><ul><li><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><ul><li>答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</li></ul></li><li><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><ul><li>答：我们可以创建多个ZipList来分片存储数据。</li></ul></li><li><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><ul><li>答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</li></ul></li><li><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。</p></li><li><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项list-compress-depth来控制</p></li></ul><p><strong>QuickList的特点</strong>：</p><ul><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><h3 id="1-6-SkipList"><a href="#1-6-SkipList" class="headerlink" title="1.6 SkipList"></a>1.6 SkipList</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p><ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同。</li></ul><p><img src="/img/blogs/java/redis/4.1.9.png"></p><p><strong>SkipList的特点</strong>：</p><ul><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><h3 id="1-7-RedisObject"><a href="#1-7-RedisObject" class="headerlink" title="1.7 RedisObject"></a>1.7 RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象</p><p><img src="/img/blogs/java/redis/4.1.10.png"></p><h3 id="1-8-Redis基本数据类型-String"><a href="#1-8-Redis基本数据类型-String" class="headerlink" title="1.8 Redis基本数据类型-String"></a>1.8 Redis基本数据类型-String</h3><p>String是Redis中最常见的数据存储类型：</p><ul><li>其基本编码方式是<strong>RAW</strong>，基于简单动态字符串（SDS）实现，存储上限为512mb。</li><li>如果存储的SDS长度小于44字节，则会采用<strong>EMBSTR编码</strong>，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</li><li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<strong>INT编码</strong>：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</li></ul><p><img src="/img/blogs/java/redis/4.1.11.png"></p><h3 id="1-9-Redis基本数据类型-List"><a href="#1-9-Redis基本数据类型-List" class="headerlink" title="1.9 Redis基本数据类型-List"></a>1.9 Redis基本数据类型-List</h3><p>Redis的List类型可以从首、尾操作列表中的元素：</p><ul><li>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</li><li>在3.2版本之后，Redis统一采用QuickList来实现List</li></ul><p><img src="/img/blogs/java/redis/4.1.12.png"></p><ul><li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><h3 id="1-10-Redis基本数据类型-Set"><a href="#1-10-Redis基本数据类型-Set" class="headerlink" title="1.10 Redis基本数据类型-Set"></a>1.10 Redis基本数据类型-Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>求交集、并集、差集</li></ul><p>什么样的数据结构可以满足？</p><ul><li>HashTable，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</li></ul><p>Set是Redis中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p><ul><li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</li><li>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</li></ul><h3 id="1-11-Redis基本数据类型-ZSet"><a href="#1-11-Redis基本数据类型-ZSet" class="headerlink" title="1.11 Redis基本数据类型-ZSet"></a>1.11 Redis基本数据类型-ZSet</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p><ul><li><strong>SkipList</strong>：可以排序，并且可以同时存储score和ele值（member）</li><li><strong>HT（Dict）</strong>：可以键值存储，并且可以根据key找value</li></ul><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><h3 id="1-12-Redis基本数据类型-Hash"><a href="#1-12-Redis基本数据类型-Hash" class="headerlink" title="1.12 Redis基本数据类型-Hash"></a>1.12 Redis基本数据类型-Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别如下：</p><ul><li>zset的键是member，值是score；hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可</p><ul><li>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value</li><li>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个：<ul><li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li></ul></li></ul><h2 id="2-Redis网络模型"><a href="#2-Redis网络模型" class="headerlink" title="2. Redis网络模型"></a>2. Redis网络模型</h2><h3 id="2-1-用户空间和内核态空间"><a href="#2-1-用户空间和内核态空间" class="headerlink" title="2.1 用户空间和内核态空间"></a>2.1 用户空间和内核态空间</h3><p>用户的应用，比如redis，mysql等其实是没有办法去执行访问我们操作系统的硬件的，所以我们可以通过发行版的这个壳子去访问内核，再通过内核去访问计算机硬件<br>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等</p><p><img src="/img/blogs/java/redis/4.2.1.png"></p><p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p><ul><li>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></li><li>用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访</li><li>内核空间可以执行特权命令（Ring0），调用一切系统资源</li></ul><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul><p><img src="/img/blogs/java/redis/4.2.2.png"></p><h3 id="2-2-阻塞IO"><a href="#2-2-阻塞IO" class="headerlink" title="2.2 阻塞IO"></a>2.2 阻塞IO</h3><p>总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><p><img src="/img/blogs/java/redis/4.2.3.png"></p><p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO<br>顾名思义，阻塞IO就是两个阶段都必须阻塞等待，具体流程如下图：</p><p><img src="/img/blogs/java/redis/4.2.4.png"></p><p><strong>阶段一：</strong></p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>此时用户进程也处于阻塞状态</li></ul><p>阶段二：</p><ul><li>数据到达并拷贝到内核缓冲区，代表已就绪</li><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，阻塞IO模型中，<strong>用户进程在两个阶段都是阻塞状态</strong>。</p><h3 id="2-3-非阻塞IO"><a href="#2-3-非阻塞IO" class="headerlink" title="2.3 非阻塞IO"></a>2.3 非阻塞IO</h3><p>顾名思义，非阻塞IO的recvfrom操作会<strong>立即返回结果</strong>而不是阻塞用户进程。</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li><strong>循环往复，直到数据就绪</strong></li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li><li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li></ul><p><img src="/img/blogs/java/redis/4.2.5.png"></p><h3 id="2-4-IO多路复用"><a href="#2-4-IO多路复用" class="headerlink" title="2.4 IO多路复用"></a>2.4 IO多路复用</h3><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li><p>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。</p></li><li><p>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据<br>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p></li><li><p><strong>文件描述符</strong>（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</p></li><li><p>IO多路复用：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p></li></ul><p><img src="/img/blogs/java/redis/4.2.6.png"></p><p>阶段一：</p><ul><li>用户进程调用select，指定要监听的FD集合</li><li>核监听FD对应的多个socket</li><li>任意一个或多个socket数据就绪则返回readable</li><li>此过程中用户进程阻塞</li></ul><p>阶段二：</p><ul><li>用户进程找到就绪的socket</li><li>依次调用recvfrom读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><h4 id="IO多路复用常见方式的有："><a href="#IO多路复用常见方式的有：" class="headerlink" title="IO多路复用常见方式的有："></a>IO多路复用常见方式的有：</h4><ul><li><p>select</p></li><li><p>poll</p></li><li><p>epoll</p></li><li><p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p></li><li><p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p></li></ul><h3 id="2-5-IO多路复用的三种方式"><a href="#2-5-IO多路复用的三种方式" class="headerlink" title="2.5 IO多路复用的三种方式"></a>2.5 IO多路复用的三种方式</h3><h4 id="2-5-1-select方式"><a href="#2-5-1-select方式" class="headerlink" title="2.5.1 select方式"></a>2.5.1 select方式</h4><p><img src="/img/blogs/java/redis/4.2.7.png"></p><p>select模式存在的问题：</p><ul><li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024</li></ul><h4 id="2-5-2-poll模式"><a href="#2-5-2-poll模式" class="headerlink" title="2.5.2 poll模式"></a>2.5.2 poll模式</h4><p>poll模式对select模式做了简单改进，但性能提升不明显</p><p>IO流程：</p><ul><li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li></ul><p><strong>与select对比：</strong></p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><h4 id="2-5-3-epoll函数"><a href="#2-5-3-epoll函数" class="headerlink" title="2.5.3 epoll函数"></a>2.5.3 epoll函数</h4><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><ol><li>红黑树-&gt; 记录的事要监听的FD</li><li>一个是链表-&gt;一个链表，记录的是就绪的FD</li></ol><ul><li>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，就是准备好了，现在就把fd把数据添加到list_head中去</li></ul><ol start="3"><li>调用epoll_wait函数</li></ol><ul><li>就去等待，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据。</li></ul><p><img src="/img/blogs/java/redis/4.2.8.png"></p><h4 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4 总结"></a>2.5.4 总结</h4><p>select模式存在的三个问题：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p>poll模式的问题：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll模式中如何解决这些问题的？</p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降</li></ul><h3 id="2-6-IO多路复用-epoll"><a href="#2-6-IO多路复用-epoll" class="headerlink" title="2.6 IO多路复用-epoll"></a>2.6 IO多路复用-epoll</h3><h4 id="2-6-1-时间通知机制"><a href="#2-6-1-时间通知机制" class="headerlink" title="2.6.1 时间通知机制"></a>2.6.1 时间通知机制</h4><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><h4 id="2-6-2-基于epoll的服务器端流程"><a href="#2-6-2-基于epoll的服务器端流程" class="headerlink" title="2.6.2 基于epoll的服务器端流程"></a>2.6.2 基于epoll的服务器端流程</h4><p>基于epoll模式的web服务的基本流程如图：</p><p><img src="/img/blogs/java/redis/4.2.9.png"></p><h3 id="2-7-信号驱动IO"><a href="#2-7-信号驱动IO" class="headerlink" title="2.7 信号驱动IO"></a>2.7 信号驱动IO</h3><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：</p><ul><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li></ul><p>阶段二：</p><ul><li>收到SIGIO回调信号</li><li>调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><img src="/img/blogs/java/redis/4.2.10.png"></p><ul><li>缺点：当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</li></ul><h3 id="2-8-异步IO"><a href="#2-8-异步IO" class="headerlink" title="2.8 异步IO"></a>2.8 异步IO</h3><p>异步IO的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。</p><ul><li>异步IO模型中，用户进程在两个阶段都是非阻塞状态。</li></ul><p><img src="/img/blogs/java/redis/4.2.11.png"></p><h3 id="2-9-五种IO模型对比"><a href="#2-9-五种IO模型对比" class="headerlink" title="2.9 五种IO模型对比"></a>2.9 五种IO模型对比</h3><p><img src="/img/blogs/java/redis/4.2.12.png"></p><h3 id="2-10-Redis网络模型"><a href="#2-10-Redis网络模型" class="headerlink" title="2.10 Redis网络模型"></a>2.10 Redis网络模型</h3><h4 id="2-10-1-Redis是单线程的吗？为什么使用单线程"><a href="#2-10-1-Redis是单线程的吗？为什么使用单线程" class="headerlink" title="2.10.1 Redis是单线程的吗？为什么使用单线程"></a>2.10.1 Redis是单线程的吗？为什么使用单线程</h4><p><strong>Redis到底是单线程还是多线程？</strong></p><ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li></ul><p><strong>为什么Redis要选择单线程？</strong></p><ul><li>抛开持久化不谈，Redis是纯  内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul><h4 id="2-10-2-Redis单线程和多线程网络模型变更"><a href="#2-10-2-Redis单线程和多线程网络模型变更" class="headerlink" title="2.10.2 Redis单线程和多线程网络模型变更"></a>2.10.2 Redis单线程和多线程网络模型变更</h4><p>Redis通过<strong>IO多路复用来提高网络性能</strong>，并且支持各种不同的多路复用实现，并且将这些实现进行封装， 提供了统一的高性能事件库API库 AE<br>Redis 6.0版本中引入了多线程，目的是为了提高IO读写效率。因此在解析客户端命令、写响应结果时采用了多线程。核心的命令执行、IO多路复用模块依然是由主线程执行。</p><h2 id="3-通信协议"><a href="#3-通信协议" class="headerlink" title="3. 通信协议"></a>3. 通信协议</h2><h3 id="3-1-RESP协议"><a href="#3-1-RESP协议" class="headerlink" title="3.1 RESP协议"></a>3.1 RESP协议</h3><p>Redis是一个CS架构的软件，通信一般分两步：</p><ul><li>客户端（client）向服务端（server）发送一条命令</li><li>服务端解析并执行命令，返回响应结果给客户端</li></ul><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><ul><li>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</li></ul><h4 id="RESP协议的数据类型"><a href="#RESP协议的数据类型" class="headerlink" title="RESP协议的数据类型"></a>RESP协议的数据类型</h4><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p><ol><li>单行字符串：首字节是 ‘+’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回”OK”： “+OK\r\n”</li><li>错误（Errors）：首字节是 ‘-’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\r\n”</li><li>数值：首字节是 ‘:’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\r\n”</li><li>多行字符串：首字节是 ‘$’ ，表示二进制安全的字符串，最大支持512MB：<ul><li>如果大小为0，则代表空字符串：”$0\r\n\r\n”</li><li>如果大小为-1，则代表不存在：”$-1\r\n”</li></ul></li><li>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</li></ol><h3 id="3-2-基于Socket自定义Redis的客户端"><a href="#3-2-基于Socket自定义Redis的客户端" class="headerlink" title="3.2 基于Socket自定义Redis的客户端"></a>3.2 基于Socket自定义Redis的客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Socket s;<br>    <span class="hljs-keyword">static</span> PrintWriter writer;<br>    <span class="hljs-keyword">static</span> BufferedReader reader;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1.建立连接</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.150.101&quot;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">6379</span>;<br>            s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port);<br>            <span class="hljs-comment">// 2.获取输出流、输入流</span><br>            writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));<br>            reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));<br><br>            <span class="hljs-comment">// 3.发出请求</span><br>            <span class="hljs-comment">// 3.1.获取授权 auth 123321</span><br>            sendRequest(<span class="hljs-string">&quot;auth&quot;</span>, <span class="hljs-string">&quot;123321&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> handleResponse();<br>            System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj);<br><br>            <span class="hljs-comment">// 3.2.set name 虎哥</span><br>            sendRequest(<span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);<br>            <span class="hljs-comment">// 4.解析响应</span><br>            obj = handleResponse();<br>            System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj);<br><br>            <span class="hljs-comment">// 3.2.set name 虎哥</span><br>            sendRequest(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-comment">// 4.解析响应</span><br>            obj = handleResponse();<br>            System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj);<br><br>            <span class="hljs-comment">// 3.2.set name 虎哥</span><br>            sendRequest(<span class="hljs-string">&quot;mget&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-string">&quot;msg&quot;</span>);<br>            <span class="hljs-comment">// 4.解析响应</span><br>            obj = handleResponse();<br>            System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 5.释放连接</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (reader != <span class="hljs-literal">null</span>) reader.close();<br>                <span class="hljs-keyword">if</span> (writer != <span class="hljs-literal">null</span>) writer.close();<br>                <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) s.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">handleResponse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 读取首字节</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> reader.read();<br>        <span class="hljs-comment">// 判断数据类型标示</span><br>        <span class="hljs-keyword">switch</span> (prefix) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-comment">// 单行字符串，直接读一行</span><br>                <span class="hljs-keyword">return</span> reader.readLine();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-comment">// 异常，也读一行</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(reader.readLine());<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>: <span class="hljs-comment">// 数字</span><br>                <span class="hljs-keyword">return</span> Long.parseLong(reader.readLine());<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;$&#x27;</span>: <span class="hljs-comment">// 多行字符串</span><br>                <span class="hljs-comment">// 先读长度</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Integer.parseInt(reader.readLine());<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>                &#125;<br>                <span class="hljs-comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span><br>                <span class="hljs-keyword">return</span> reader.readLine();<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                <span class="hljs-keyword">return</span> readBulkString();<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;错误的数据格式！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">readBulkString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取数组大小</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Integer.parseInt(reader.readLine());<br>        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 定义集合，接收多个元素</span><br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(len);<br>        <span class="hljs-comment">// 遍历，依次读取每个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            list.add(handleResponse());<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">// set name 虎哥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRequest</span><span class="hljs-params">(String ... args)</span> &#123;<br>        writer.println(<span class="hljs-string">&quot;*&quot;</span> + args.length);<br>        <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>            writer.println(<span class="hljs-string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);<br>            writer.println(arg);<br>        &#125;<br>        writer.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Redis内存回收"><a href="#4-Redis内存回收" class="headerlink" title="4. Redis内存回收"></a>4. Redis内存回收</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p><ul><li>内存过期策略</li><li>内存淘汰策略</li></ul><h3 id="4-1-内存过期策略"><a href="#4-1-内存过期策略" class="headerlink" title="4.1 内存过期策略"></a>4.1 内存过期策略</h3><p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间）：</p><ul><li>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</li></ul><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span><br>    dict *dict;                 <span class="hljs-comment">/* 存放所有key及value的地方，也被称为keyspace*/</span><br>    dict *expires;              <span class="hljs-comment">/* 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/</span><br>    dict *blocking_keys;        <span class="hljs-comment">/* Keys with clients waiting for data (BLPOP)*/</span><br>    dict *ready_keys;           <span class="hljs-comment">/* Blocked keys that received a PUSH */</span><br>    dict *watched_keys;         <span class="hljs-comment">/* WATCHED keys for MULTI/EXEC CAS */</span><br>    <span class="hljs-type">int</span> id;                     <span class="hljs-comment">/* Database ID，0~15 */</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> avg_ttl;          <span class="hljs-comment">/* 记录平均TTL时长 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> expires_cursor; <span class="hljs-comment">/* expire检查时在dict中抽样的索引位置. */</span><br>    <span class="hljs-built_in">list</span> *defrag_later;         <span class="hljs-comment">/* 等待碎片整理的key列表. */</span><br>&#125; redisDb;<br></code></pre></td></tr></table></figure><p>Redis是如何知道一个key是否过期呢？</p><ul><li>利用两个Dict分别记录key-value对及key-ttl对</li></ul><h4 id="是不是TTL到期就立即删除了呢？"><a href="#是不是TTL到期就立即删除了呢？" class="headerlink" title="是不是TTL到期就立即删除了呢？"></a>是不是TTL到期就立即删除了呢？</h4><p><strong>惰性删除</strong><br>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p><p><strong>周期删除</strong><br>周期删除：顾明思议是通过一个定时任务，周期性的<strong>抽样部分过期的key</strong>，然后执行删除。执行周期有两种：</p><ul><li>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW</li><li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li></ul><p>SLOW模式规则：</p><ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li><li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li><li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><p>FAST模式规则（过期key比例小于10%不执行 ）：</p><ul><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期<br>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>RedisKey的TTL记录方式：</p><ul><li>在RedisDB中通过一个Dict记录每个Key的TTL时间</li></ul><p>过期key的删除策略：</p><ul><li>惰性清理：每次查找key时判断是否过期，如果过期则删除</li><li>定期清理：定期抽样部分key，判断是否过期，如果过期则删除。</li></ul><p>定期清理的两种模式：</p><ul><li>SLOW模式执行频率默认为10，每次不超过25ms</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><h3 id="4-2-内存淘汰策略"><a href="#4-2-内存淘汰策略" class="headerlink" title="4.2 内存淘汰策略"></a>4.2 内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。<br>Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰</p><p>Redis支持8种不同策略来选择要删除的key：</p><ul><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</li></ul><p>比较容易混淆的有两个：</p><ul><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li></ul><p>Redis的数据都会被封装为RedisObject结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;        <span class="hljs-comment">// 对象类型</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;  <span class="hljs-comment">// LRU：以秒为单位记录最近一次访问时间，长度24bit</span><br>              <span class="hljs-comment">// LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span><br>    <span class="hljs-type">int</span> refcount;           <span class="hljs-comment">// 引用计数，计数为0则可以回收</span><br>    <span class="hljs-type">void</span> *ptr;              <span class="hljs-comment">// 数据指针，指向真实数据</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><p>LFU的访问次数之所以叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p><ul><li>生成0~1之间的随机数R</li><li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li><li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li></ul><p><img src="/img/blogs/java/redis/4.4.1.png"></p><hr><hr><hr><h1 id="五-黑马点评简历"><a href="#五-黑马点评简历" class="headerlink" title="五. 黑马点评简历"></a>五. 黑马点评简历</h1><p><strong>项目亮点：</strong></p><ol><li>采用 Redis 对高频访问的商户信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿问题</li><li>通过 ThreadLocal 保存已登录用户信息，请求处理完后移除，避免内存泄露与资源浪费</li><li>利用 Redisson 分布式锁解决集群环境下的并发安全问题，结合乐观锁机制防止秒杀超卖问题</li><li>基于 Redis 实现分布式 Session 共享，使用拦截器实现用户的登录校验和权限刷新</li><li>实现基于推模式的 Feed 流功能，采用滚动分页，用户发布笔记时实时推送至粉丝消息队列</li><li>借助 Redis 的 ZSet 实现点赞排行榜，利用 Set 数据结构支持用户关注与共同关注功能</li></ol><h2 id="项目亮点详解"><a href="#项目亮点详解" class="headerlink" title="项目亮点详解"></a>项目亮点详解</h2><h3 id="1-采用-Redis-对高频访问的商户信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿问题"><a href="#1-采用-Redis-对高频访问的商户信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿问题" class="headerlink" title="1. 采用 Redis 对高频访问的商户信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿问题"></a>1. 采用 Redis 对高频访问的商户信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿问题</h3><p><a href="#2-%E5%95%86%E6%88%B7%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">跳转到商户查询缓存这一节</a></p><h4 id="1-1-缓存和内存的区别？"><a href="#1-1-缓存和内存的区别？" class="headerlink" title="1.1 缓存和内存的区别？"></a>1.1 缓存和内存的区别？</h4><table><thead><tr><th>项目</th><th>缓存（Cache）</th><th>内存（Memory，也叫主存，RAM）</th></tr></thead><tbody><tr><td>定义</td><td><strong>CPU与内存之间</strong>的高速缓存，用于<strong>存放近期使用的热点数据</strong></td><td>计算机的主内存，用于<strong>存储当前运行中的程序和数据</strong></td></tr><tr><td>作用</td><td>提高CPU访问数据的速度，减少对内存的访问频率</td><td>提供运行程序时所需的数据空间</td></tr></tbody></table><ul><li>Redis 是一种常用的缓存技术：用来缓存热点数据、页面、Session 等，减轻数据库压力(<strong>基于内存，访问速度非常快</strong>)</li></ul><h4 id="1-2-使用Redis添加商户缓存的流程"><a href="#1-2-使用Redis添加商户缓存的流程" class="headerlink" title="1.2 使用Redis添加商户缓存的流程"></a>1.2 使用Redis添加商户缓存的流程</h4><ul><li>查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;<br>    <span class="hljs-comment">// 1.从redis查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在,直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">// 4.不存在,根据id查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 5.不存在,返回错误</span><br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//6.存在,写入redis</span><br>    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));<br>    <span class="hljs-comment">// 7.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-如何保证数据库和缓存的一致性？"><a href="#1-3-如何保证数据库和缓存的一致性？" class="headerlink" title="1.3 如何保证数据库和缓存的一致性？"></a>1.3 如何保证数据库和缓存的一致性？</h4><p><a href="#23-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5">跳转到缓存更新策略这一节</a></p><p>如果更新了数据库，导致数据库中的数据内容和当前缓存中保留的以前的内容不一致。如何保证一致性？</p><ul><li>数据库是新的，缓存是旧的 —— 数据脏读</li></ul><ol><li>先更新数据库</li><li>再删除缓存</li><li>下次请求读缓存 -&gt; 发现没了 -&gt; 读数据库 -&gt; 再写入缓存</li></ol><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul><h4 id="1-4-如何解决缓存穿透？"><a href="#1-4-如何解决缓存穿透？" class="headerlink" title="1.4 如何解决缓存穿透？"></a>1.4 如何解决缓存穿透？</h4><p><a href="#25-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">跳转到缓存穿透这一节</a></p><ul><li>缓存穿透是指客户端<strong>请求的数据在缓存中和数据库中都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库</li></ul><p>常见的解决方案有两种：</p><ul><li>缓存空对象</li><li>布隆过滤器</li></ul><p><strong>如何使用布隆过滤器解决缓存穿透问题？</strong><br>用布隆过滤器提前记录 所有合法的 key（比如用户 ID、商品 ID）</p><ul><li>请求进来先查布隆过滤器</li><li>如果布隆过滤器里都没有，那就<strong>直接拦截</strong>，不用查 Redis、数据库了。</li></ul><p>布隆过滤器通过记录所有“合法 key”，<strong>在访问缓存前快速拦截掉非法请求</strong>，从而解决缓存穿透问题</p><p><strong>布隆过滤：<strong>布隆过滤器其实采用的是</strong>哈希思想</strong>来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：<strong>布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</strong></p><ul><li>有一定误判率：可能会误判为存在，但不会误判为不存在</li></ul><h4 id="1-5-如何解决缓存雪崩？"><a href="#1-5-如何解决缓存雪崩？" class="headerlink" title="1.5 如何解决缓存雪崩？"></a>1.5 如何解决缓存雪崩？</h4><p><a href="https://blog.csdn.net/m0_52031708/article/details/142862864?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171eed587531abcfcf154d766791ee79%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171eed587531abcfcf154d766791ee79&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-142862864-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=caffeine%20redis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98&spm=1018.2226.3001.4187">使用Caffeine+Redis实现应用级二层缓存</a></p><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值（同一时段，给不同key设置不同的TTL）</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略（微服务）</li><li>给业务添加多级缓存</li></ul><p>这里我采用<strong>多级缓存</strong>的方式解决缓存雪崩问题<br>多级缓存 &#x3D; 本地缓存（如 Caffeine） + 分布式缓存（如 Redis）</p><p>使用流程大致如下：</p><ol><li>首先从一级缓存（caffeine-本地应用内）中查找数据；</li><li>如果没有的话，则从二级缓存（redis-内存）中查找数据；</li><li>如果还是没有的话，再从数据库（数据库-磁盘）中查找数据；</li></ol><h4 id="1-6-如何解决缓存击穿？"><a href="#1-6-如何解决缓存击穿？" class="headerlink" title="1.6 如何解决缓存击穿？"></a>1.6 如何解决缓存击穿？</h4><p>某个热点 key 在瞬间失效，大量并发请求同时访问这个 key，缓存没命中，导致并发打到数据库。</p><p><a href="#27-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">跳转到缓存击穿这一节</a></p><p><strong>这里我用的是互斥锁的方式解决缓存击穿</strong></p><p>常见的解决方案有：</p><ul><li><strong>互斥锁</strong>: 当缓存失效时，第一个线程获取锁并查询数据库，其它线程等待。</li><li>设置永不过期 + 后台定时异步更新缓存(当热点key的数量少，占用内存少的时候)</li><li>逻辑过期</li></ul><p><strong>设置永不过期 + 后台定时异步更新缓存</strong></p><ul><li>你不让缓存自然过期，而是用 主动刷新 来维持数据一致性</li><li>不会失效，自然也不会击穿</li></ul><p><strong>逻辑过期</strong></p><ul><li>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理</li><li>假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞</li><li>获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回</li><li>假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据</li><li>只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</li></ul><h3 id="2-通过-ThreadLocal-保存已登录用户信息，请求处理完后移除，避免内存泄露与资源浪费"><a href="#2-通过-ThreadLocal-保存已登录用户信息，请求处理完后移除，避免内存泄露与资源浪费" class="headerlink" title="2. 通过 ThreadLocal 保存已登录用户信息，请求处理完后移除，避免内存泄露与资源浪费"></a>2. 通过 ThreadLocal 保存已登录用户信息，请求处理完后移除，避免内存泄露与资源浪费</h3><h4 id="2-1-为什么不使用session存储用户信息，而是使用ThreadLocal存放用户信息？"><a href="#2-1-为什么不使用session存储用户信息，而是使用ThreadLocal存放用户信息？" class="headerlink" title="2.1 为什么不使用session存储用户信息，而是使用ThreadLocal存放用户信息？"></a>2.1 为什么不使用session存储用户信息，而是使用ThreadLocal存放用户信息？</h4><ol><li>Session 依赖服务端状态，不适合分布式场景(Session共享问题)<ul><li>HttpSession 是服务端状态，会话信息默认保存在服务端内存中（如 Tomcat 内部）。</li><li>在<strong>分布式部署</strong>时，如果没有做 Session 共享（如使用 Redis Session），<strong>用户可能每次请求会打到不同的服务节点，导致 Session 丢失</strong>。</li></ul></li><li>如果遇到<strong>高并发</strong>，多人同时登录系统时，会出现session混乱</li><li>ThreadLocal 为每个线程维护一个独立副本，天然线程隔离，避免并发访问带来的数据安全问题</li><li>我们可以借助这个ThreadLocal来存储登录用户的信息，<strong>在一个请求中，所有调用的方法都在同一个线程中去处理</strong>，这样就实现了<strong>在任何地方都可以获取到用户信息</strong>了。</li><li><strong>放到 ThreadLocal 就可以不用每次都查 Redis</strong>。如果你把这个 UserDTO 存到 ThreadLocal 中，那么在这一请求生命周期内，后续任何地方就<strong>可以直接从 ThreadLocal 取出用户信息</strong>，而不用重复从 Redis 查询或多层传参。</li></ol><h4 id="2-2-完整的用户登录-拦截器鉴权-ThreadLocal-用户上下文管理"><a href="#2-2-完整的用户登录-拦截器鉴权-ThreadLocal-用户上下文管理" class="headerlink" title="2.2 完整的用户登录 + 拦截器鉴权 + ThreadLocal 用户上下文管理"></a>2.2 完整的用户登录 + 拦截器鉴权 + ThreadLocal 用户上下文管理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">├── config<br>│   └── LoginInterceptor.java      <span class="hljs-comment">// 登录拦截器</span><br>├── dto<br>│   └── UserDTO.java               <span class="hljs-comment">// 登录用户信息简化封装</span><br>├── utils<br>│   └── UserHolder.java           <span class="hljs-comment">// ThreadLocal 用户上下文管理</span><br>├── controller<br>│   └── UserController.java        <span class="hljs-comment">// 登录相关接口</span><br>├── service<br>│   └── UserService.java           <span class="hljs-comment">// 登录逻辑（含Redis token校验）</span><br>└── ...<br></code></pre></td></tr></table></figure><ol><li>定义用户实体：<code>UserDTO</code>(用于存储登录用户的简化信息)</li><li>定义工具类<code>UserHolder</code>操作ThreadLocal（存放，获取，删除用户信息）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//保存用户信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(UserDTO user)</span>&#123;<br>        tl.set(user);<br>    &#125;<br><br>    <span class="hljs-comment">//获取用户信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br><br>    <span class="hljs-comment">//删除用户信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">()</span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>登录拦截器：判断是否需要拦截（ThreadLocal中是否有用户）<ul><li>访问接口时将用户信息放入ThreadLocal</li><li>访问结束时候删除ThreadLocal中信息（线程放入线程池并不一定会销毁）</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span><br>        <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 没有，需要拦截，设置状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-comment">// 拦截</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 有用户，则放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>配置拦截器，让拦截器生效(拦截需要登录的接口)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 拦截需要登录的接口</span><br>        registry.addInterceptor(loginInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">// 可细化路径</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/user/register&quot;</span>, <span class="hljs-string">&quot;/static/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-为什么请求处理完后要移除-ThreadLocal-的值？"><a href="#2-3-为什么请求处理完后要移除-ThreadLocal-的值？" class="headerlink" title="2.3 为什么请求处理完后要移除 ThreadLocal 的值？"></a>2.3 为什么请求处理完后要移除 ThreadLocal 的值？</h4><p>目的：<strong>避免内存泄漏与资源浪费</strong></p><p><strong>原因</strong>：</p><ol><li>ThreadLocalMap 的 key 是弱引用，value 是强引用<ul><li>当 ThreadLocal 实例（key）被 GC 回收后，如果没有手动 remove()，它对应的 <strong>value 会“悬挂”在内存中</strong>，而 ThreadLocalMap 是挂在 Thread 对象上的，<strong>线程不死，value 就不会释放，造成内存泄漏</strong>。</li></ul></li><li>线程池复用线程：线程池导致线程长期存活，加剧泄漏问题<ul><li>如果你在线程中使用了 ThreadLocal 但没调用 <strong>remove()</strong>，上一个请求的数据就可能<strong>被下一个请求复用的线程误用</strong>，造成<strong>数据泄漏和安全风险。</strong></li></ul></li></ol><ul><li><strong>ThreadLocal 的 key 是弱引用，若不及时调用 remove() 清除绑定数据，可能因线程池复用导致内存泄漏与用户数据错乱</strong>，尤其在高并发系统中危害更明显。</li></ul><h4 id="2-4-ThreadLocal原理-重点"><a href="#2-4-ThreadLocal原理-重点" class="headerlink" title="2.4 ThreadLocal原理(重点)"></a>2.4 ThreadLocal原理(重点)</h4><p><a href="https://blog.csdn.net/weixin_44184990/article/details/122279854?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224d0490e493964472613e577c3e94bd9f%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=4d0490e493964472613e577c3e94bd9f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122279854-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=ThreadLocal%E5%8E%9F%E7%90%86&spm=1018.2226.3001.4187">ThreadLocal原理</a></p><h3 id="3-利用-Redisson-分布式锁解决集群环境下的并发安全问题，结合乐观锁机制防止秒杀超卖问题"><a href="#3-利用-Redisson-分布式锁解决集群环境下的并发安全问题，结合乐观锁机制防止秒杀超卖问题" class="headerlink" title="3. 利用 Redisson 分布式锁解决集群环境下的并发安全问题，结合乐观锁机制防止秒杀超卖问题"></a>3. 利用 Redisson 分布式锁解决集群环境下的并发安全问题，结合乐观锁机制防止秒杀超卖问题</h3><h4 id="3-1-什么是集群环境下的并发安全问题？"><a href="#3-1-什么是集群环境下的并发安全问题？" class="headerlink" title="3.1 什么是集群环境下的并发安全问题？"></a>3.1 什么是集群环境下的并发安全问题？</h4><p><a href="#35-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">跳转到集群环境下一人一单的并发安全问题</a></p><ul><li><strong>一人一单</strong>：秒杀业务要求<strong>同一个优惠券，一个用户只能下一单</strong></li><li><strong>集群环境下的一人一单</strong>：<ul><li>通过加锁可以解决在单机情况下的一人一单安全问题，但是<strong>在集群模式下就不行了</strong></li><li><strong>每个tomcat都有一个属于自己的jvm</strong>，<strong>每个JVM都有各自的锁监视器，导致不同JVM的锁在不同的锁监视器中</strong></li><li>在集群模式下，加锁只是对该 JVM 给当前这台服务器的请求的加锁，而<strong>集群是多台服务器，所以要使用分布式锁</strong>，满足集群模式下多进程可见并且互斥的锁。</li></ul></li></ul><h4 id="3-2-什么是分布式锁？"><a href="#3-2-什么是分布式锁？" class="headerlink" title="3.2 什么是分布式锁？"></a>3.2 什么是分布式锁？</h4><p><a href="#4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">跳转到分布式锁</a></p><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见并且互斥的锁</strong>。</p><ul><li>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</li></ul><h4 id="3-3-Redisson分布式锁的原理和使用"><a href="#3-3-Redisson分布式锁的原理和使用" class="headerlink" title="3.3 Redisson分布式锁的原理和使用"></a>3.3 Redisson分布式锁的原理和使用</h4><p><a href="#49-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redission%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D">跳转到Redisson分布式锁</a></p><p>Redisson 是一个 Java 客户端框架，基于 Redis 实现了分布式锁、分布式集合、分布式对象等高阶功能</p><p><strong>Redisson 分布式锁的原理：</strong></p><ol><li><strong>加锁原理</strong>：Redisson 使用 Redis 的 <code>SET key value NX PX</code> 命令加锁<ul><li>key 是锁名，value 是唯一标识（UUID+线程ID）</li><li>设置 30 秒过期时间（默认值，可配置）</li></ul></li><li><strong>看门狗机制（Watchdog）</strong><ul><li>如果使用 lock() 加锁（不带超时时间），Redisson 会启动一个后台定时任务，每隔 10 秒自动续期，将锁的过期时间续为 30 秒；</li><li>如果你主动设置了锁的过期时间，比如 lock(10, TimeUnit.SECONDS)，则不会自动续期，10 秒后自动释放；</li></ul></li><li><strong>解锁原理</strong><ul><li>Redisson 会验证当前线程是否是锁的拥有者（根据 UUID+线程ID 判断）</li><li>是的话执行 Lua 脚本删除锁，防止误删其他线程的锁（原子操作）</li></ul></li><li><strong>支持多种模式</strong><ul><li>公平锁：排队机制，先来先得（适用于高并发下公平访问资源的场景）</li><li>可重入锁：同一个线程可以多次获取同一把锁</li></ul></li></ol><p><strong>使用Redission的分布式锁：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedissionClient redissonClient;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">//获取锁(可重入)，指定锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>    <span class="hljs-comment">//判断获取锁成功</span><br>    <span class="hljs-keyword">if</span>(isLock)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);          <br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-为什么会出现超卖？"><a href="#3-4-为什么会出现超卖？" class="headerlink" title="3.4 为什么会出现超卖？"></a>3.4 为什么会出现超卖？</h4><p>主要是在高并发场景下并发控制不当造成的，下面是一个典型流程：</p><ol><li>多个用户同时查询库存（比如查到当前库存为 5）</li><li>多个用户几乎同时发起下单请求</li><li>系统来不及“同步更新”库存，导致多个请求都成功了 ➜ 库存变负数<br><strong>卖出去的数量超过了实际库存</strong>。</li></ol><h4 id="3-5-什么是乐观锁？"><a href="#3-5-什么是乐观锁？" class="headerlink" title="3.5 什么是乐观锁？"></a>3.5 什么是乐观锁？</h4><p><strong>悲观锁：</strong></p><ul><li>认为线程安全问题一定会发生，因此<strong>在操作数据之前先获取锁</strong>，确保线程串行执行。</li><li>例如Synchronized、Lock都属于悲观锁</li></ul><p><strong>乐观锁(CAS)：</strong></p><ul><li>认为线程安全问题不一定会发生，因此不加锁，<strong>只是在更新数据时去判断有没有其它线程对数据做了修改</strong>。</li><li>如果没有修改则认为是安全的，自己才更新数据。</li><li>如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常</li></ul><h4 id="3-6-如何使用乐观锁-CAS-解决超卖问题？"><a href="#3-6-如何使用乐观锁-CAS-解决超卖问题？" class="headerlink" title="3.6 如何使用乐观锁(CAS)解决超卖问题？"></a>3.6 如何使用乐观锁(CAS)解决超卖问题？</h4><p><a href="#332-%E5%9F%BA%E4%BA%8E%E4%B9%90%E8%A7%82%E9%94%81cas%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">跳转到乐观锁解决方案</a></p><p><strong>只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的</strong><br>我们的乐观锁需要变一下，改成stock大于0 即可</p><ul><li><strong>只要库存大于0，就可以买，不会超卖</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock= stock -1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//where id = ? and stock &gt; 0</span><br></code></pre></td></tr></table></figure><h3 id="4-使用-Redis-解决了在集群模式下的-Session-共享问题，使用拦截器实现用户的登录校验和权限刷新"><a href="#4-使用-Redis-解决了在集群模式下的-Session-共享问题，使用拦截器实现用户的登录校验和权限刷新" class="headerlink" title="4. 使用 Redis 解决了在集群模式下的 Session 共享问题，使用拦截器实现用户的登录校验和权限刷新"></a>4. 使用 Redis 解决了在集群模式下的 Session 共享问题，使用拦截器实现用户的登录校验和权限刷新</h3><p><a href="https://kneegcyao.github.io/posts/bbf9fa63.html">黑马点评重点面试问题</a></p><h4 id="4-1-什么是Session共享问题？"><a href="#4-1-什么是Session共享问题？" class="headerlink" title="4.1 什么是Session共享问题？"></a>4.1 什么是Session共享问题？</h4><p><a href="#15-session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98">跳转到session共享问题</a></p><p><strong>多台 Tomct 并不共享 session 存储空间，当请求切换到不同 tomcat 服务时导致数据丢失的问题。</strong></p><p><strong>每个tomcat中都有一份属于自己的session</strong>,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么<strong>在第二台服务器上，肯定没有第一台服务器存放的session</strong>，所以此时 整个登录拦截功能就会出现问题</p><p>我们能如何解决这个问题呢？<strong>早期的方案是session拷贝</strong>，就是说虽然每个tomcat上都有不同的session，但是每当<strong>任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session</strong>，这样的话，就可以实现session的共享了</p><p>后来采用的方案都是基于redis来完成，我们<strong>把session换成redis</strong>，<strong>redis数据本身就是共享的，就可以避免session共享</strong>的问题了</p><h4 id="4-2-如何在登录过程中用Redis代替Session的？"><a href="#4-2-如何在登录过程中用Redis代替Session的？" class="headerlink" title="4.2 如何在登录过程中用Redis代替Session的？"></a>4.2 如何在登录过程中用Redis代替Session的？</h4><p><a href="#16-redis%E4%BB%A3%E6%9B%BFsession%E7%9A%84%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B">跳转到Redis代替session的业务流程</a></p><p><strong>登录流程：</strong></p><ol><li><strong>发送短信验证码</strong>：将验证码保存到Redis里面，而不是session</li><li><strong>登录过程</strong>：根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis(作为值)，并且生成token作为redis的key</li><li><strong>校验登录状态</strong>：当我们校验用户是否登录时，会去<strong>携带着token进行访问</strong>，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</li></ol><h4 id="4-3-还有其他解决方法吗？"><a href="#4-3-还有其他解决方法吗？" class="headerlink" title="4.3 还有其他解决方法吗？"></a>4.3 还有其他解决方法吗？</h4><ul><li><strong>基于 Cookie 的 Token 机制</strong>，不再使用服务器端保存 Session，而是通过<strong>客户端保存 Token</strong>（如 JWT）。</li><li>Token 包含用户的认证信息（如用户 ID、权限等），并通过签名验证其完整性和真实性。</li><li>每次请求，<strong>客户端将 Token 放在 Cookie 或 HTTP 头中发送到服务</strong>，进行验证</li></ul><h4 id="4-4-如何使用拦截器实现用户的登录校验和权限刷新？"><a href="#4-4-如何使用拦截器实现用户的登录校验和权限刷新？" class="headerlink" title="4.4 如何使用拦截器实现用户的登录校验和权限刷新？"></a>4.4 如何使用拦截器实现用户的登录校验和权限刷新？</h4><p><a href="#18-%E8%A7%A3%E5%86%B3%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98">跳转到拦截器</a></p><p><strong>问题所在：</strong></p><ul><li>原始方案确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他<strong>只是拦截需要被拦截的路径</strong></li><li>假设<strong>当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效</strong>，所以此时<strong>令牌刷新的动作实际上就不会执行</strong>，所以这个方案他是存在问题的</li></ul><p><strong>实现方案：</strong></p><ul><li>我们可以添加一个拦截器</li></ul><ol><li>在<strong>第一个拦截器中拦截所有的路径</strong>，把第二个拦截器做的事情放入到第一个拦截器中，同时<strong>刷新令牌</strong></li><li>因为第一个拦截器有了ThreadLocal的数据，所以此时<strong>第二个拦截器只需要判断拦截器中的user对象是否存在即可</strong>，完成整体刷新功能。</li></ol><ul><li>第一层拦截器是做<strong>全局处理</strong>，例如获取 Token，查询 Redis 中的用户信息，刷新 Token 有效期等通用操作。</li><li>第二层拦截器专注于<strong>验证用户登录</strong>的逻辑，如果路径需要登录，但用户未登录，则直接拦截请求。<strong>作用是拦截未登录的用户</strong></li></ul><p><strong>好处：</strong></p><ul><li>职责分离：这种分层设计让每个拦截器的职责更加单一，代码更加清晰、易于维护</li><li>提升性能</li></ul><h3 id="5-实现基于推模式的-Feed-流功能，采用滚动分页，用户发布笔记时实时推送至粉丝消息队列"><a href="#5-实现基于推模式的-Feed-流功能，采用滚动分页，用户发布笔记时实时推送至粉丝消息队列" class="headerlink" title="5. 实现基于推模式的 Feed 流功能，采用滚动分页，用户发布笔记时实时推送至粉丝消息队列"></a>5. 实现基于推模式的 Feed 流功能，采用滚动分页，用户发布笔记时实时推送至粉丝消息队列</h3><p><a href="#73-%E5%85%B1%E5%90%8C%E6%8E%A8%E9%80%81-feed%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">跳转到共同推送-Feeed流实现方案</a></p><h4 id="5-1-什么是推模式的Feed流？"><a href="#5-1-什么是推模式的Feed流？" class="headerlink" title="5.1 什么是推模式的Feed流？"></a>5.1 什么是推模式的Feed流？</h4><ul><li><strong>关注推送也叫做Feed流</strong>，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息</li></ul><p>Feed流产品有两种常见模式</p><ul><li><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈</li><li><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户(抖音)</li></ul><p><strong>Timeline的三种模式</strong><br><a href="#73-%E5%85%B1%E5%90%8C%E6%8E%A8%E9%80%81-feed%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">跳转到共同推送查看</a></p><ul><li>拉模式</li><li>推模式：也叫写扩散</li><li>推拉结合</li></ul><p><strong>推模式的Feed流</strong></p><ul><li>当张三写了一个内容，此时会<strong>主动的把张三写的内容发送到他的粉丝收件箱</strong>中去，假设此时李四再来读取，就不用再去临时拉取了（像朋友圈的方式）</li><li><strong>用户发布笔记时实时推送至粉丝消息队列</strong></li></ul><h4 id="5-2-为什么要使用滚动分页？"><a href="#5-2-为什么要使用滚动分页？" class="headerlink" title="5.2 为什么要使用滚动分页？"></a>5.2 为什么要使用滚动分页？</h4><p>Feed流中的<strong>数据会不断更新</strong>，所以数据的角标也在变化，因此不能采用传统的分页模式。</p><ul><li>如何实现Feed流的分页功能是一个复杂的问题，如果采用MyBatis中的分页插件是不能满足分页功能的，<strong>因为Feed流是一个动态的，数据会不断更新，因此数据的角标会不停更新</strong>，当我们需要查询第5-10条的数据时，可能又保存了一个新的数据到数据库，从而<strong>导致我们分页查找的数据存在与上一次查询的数据重复的问题</strong></li></ul><h4 id="5-3-如何实现滚动分页？"><a href="#5-3-如何实现滚动分页？" class="headerlink" title="5.3 如何实现滚动分页？"></a>5.3 如何实现滚动分页？</h4><p>滚动分页就是每次查询过数据库后，我们需要<strong>记录这一次查询结果的最后一条数据，下一次查询时，从这个位置开始去读取数据</strong></p><ol><li>每次查询完成后，我们要分析出<strong>查询出数据的最小时间戳</strong>，这个值会<strong>作为下一次查询的条件</strong></li><li>我们需要<strong>找到与上一次查询相同的查询个数作为偏移量</strong>，下次查询时，<strong>跳过这些查询过的数据，拿到我们需要的数据</strong></li></ol><ul><li>综上：我们的请求参数中就需要携带 lastId：<strong>上一次查询的最小时间戳</strong> 和<strong>偏移量</strong>这两个参数</li></ul><h3 id="6-借助-Redis-的-ZSet-实现点赞排行榜，利用-Set-数据结构支持用户关注与共同关注功能"><a href="#6-借助-Redis-的-ZSet-实现点赞排行榜，利用-Set-数据结构支持用户关注与共同关注功能" class="headerlink" title="6. 借助 Redis 的 ZSet 实现点赞排行榜，利用 Set 数据结构支持用户关注与共同关注功能"></a>6. 借助 Redis 的 ZSet 实现点赞排行榜，利用 Set 数据结构支持用户关注与共同关注功能</h3><h4 id="6-1-为什么使用ZSet实现点赞排行榜？"><a href="#6-1-为什么使用ZSet实现点赞排行榜？" class="headerlink" title="6.1 为什么使用ZSet实现点赞排行榜？"></a>6.1 为什么使用ZSet实现点赞排行榜？</h4><p><a href="#63-%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C">跳转到点赞排行榜</a></p><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的TOP5，形成点赞排行榜</p><ul><li><strong>点赞功能</strong>：使用set集合，因为点赞是不能重复的</li><li><strong>点赞排行榜功能</strong>：使用sortedSet(ZSet)，因为需要采用一个<strong>可以排序的set集合</strong></li></ul><p>ZSet：保存用户ID为键，用户点赞时间作为score进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br></code></pre></td></tr></table></figure><p>查询top5的点赞用户: <code>zrange key 0 4</code></p><h4 id="6-2-如何利用Set实现用户关注和共同关注？"><a href="#6-2-如何利用Set实现用户关注和共同关注？" class="headerlink" title="6.2 如何利用Set实现用户关注和共同关注？"></a>6.2 如何利用Set实现用户关注和共同关注？</h4><p><a href="#72-%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8">跳转到关注和共同关注</a></p><p><strong>用户关注</strong>：是User之间的关系，是博主与粉丝的关系，数据库中有一张tb_follow表来表示</p><ul><li>表的主键是当前用户ID，有一个FollowedID表示关注的用户ID</li></ul><p><strong>共同关注</strong>：在博主个人页面展示出当前用户与博主的共同关注呢</p><ul><li>使用set集合，<strong>在set集合中，有交集并集补集的api</strong></li><li>我们可以把两人的关注的人分别放入到一个set集合中，然后再通过api去查看这两个set集合中的交集数据。</li></ul><h4 id="6-3-介绍Set数据结构和底层原理"><a href="#6-3-介绍Set数据结构和底层原理" class="headerlink" title="6.3 介绍Set数据结构和底层原理"></a>6.3 介绍Set数据结构和底层原理</h4><p><a href="#26-set%E7%B1%BB%E5%9E%8B">跳转到Set数据结构</a></p><p><a href="#27-sortedset%E7%B1%BB%E5%9E%8B">跳转到ZSet数据结构</a></p><p><a href="#110-redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-set">跳转到Set数据结构底层原理</a></p><p><a href="#111-redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-zset">跳转到ZSet数据结构底层原理</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud学习笔记</title>
    <link href="/2025/04/04/JAVA/SpringCloud/SpringCloud/"/>
    <url>/2025/04/04/JAVA/SpringCloud/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 align="center">SpringCloud微服务学习笔记</h1><h1 id="一-MybatisPlus"><a href="#一-MybatisPlus" class="headerlink" title="一. MybatisPlus"></a>一. MybatisPlus</h1><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><p>实现步骤：</p><ul><li>引入MybatisPlus依赖</li><li>定义Mapper</li></ul><h3 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-定义Mapper"><a href="#1-2-定义Mapper" class="headerlink" title="1.2 定义Mapper"></a>1.2 定义Mapper</h3><ul><li>MybatisPlus提供了一个基础的BaseMapper接口</li><li>修改mp-demo中的com.itheima.mp.mapper包下的UserMapper接口，让其继承BaseMapper：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-常见注解"><a href="#2-常见注解" class="headerlink" title="2. 常见注解"></a>2. 常见注解</h2><h3 id="2-1-默认情况"><a href="#2-1-默认情况" class="headerlink" title="2.1 默认情况"></a>2.1 默认情况</h3><p>MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</p><ul><li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li><li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为主键</li></ul><h3 id="2-2-TableName"><a href="#2-2-TableName" class="headerlink" title="2.2 @TableName"></a>2.2 @TableName</h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><h3 id="2-3-TableId"><a href="#2-3-TableId" class="headerlink" title="2.3 @TableId"></a>2.3 @TableId</h3><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><p>IdType属性的常见值：</p><ul><li>AUTO：利用数据库的id自增长</li><li>INPUT：手动生成id</li><li>ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="2-4-TableField"><a href="#2-4-TableField" class="headerlink" title="2.4 @TableField"></a>2.4 @TableField</h3><p>普通字段注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField(is_married&quot;)</span><br>    <span class="hljs-keyword">private</span> Boolean isMarried;<br>    <span class="hljs-meta">@TableField(&quot;`concat`&quot;)</span><br>    <span class="hljs-keyword">private</span> String concat;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加@TableField注解的一些特殊情况：</p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：&#96;&#96;</li></ul><h2 id="3-核心功能"><a href="#3-核心功能" class="headerlink" title="3. 核心功能"></a>3. 核心功能</h2><h3 id="3-1-条件构造器"><a href="#3-1-条件构造器" class="headerlink" title="3.1 条件构造器"></a>3.1 条件构造器</h3><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。</p><p>Wrapper就是条件构造的抽象类</p><p><img src="/img/blogs/java/springcloud/mp.1.png"></p><h4 id="3-1-1-QueryWrapper"><a href="#3-1-1-QueryWrapper" class="headerlink" title="3.1.1 QueryWrapper"></a>3.1.1 QueryWrapper</h4><p>查询：查询出名字中带o的，存款大于等于1000元的人。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>            .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>)<br>            .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 2.查询数据</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-UpdateWrapper"><a href="#3-1-2-UpdateWrapper" class="headerlink" title="3.1.2 UpdateWrapper"></a>3.1.2 UpdateWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateWrapper</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    <span class="hljs-comment">// 1.生成SQL</span><br>    UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;User&gt;()<br>            .setSql(<span class="hljs-string">&quot;balance = balance - 200&quot;</span>) <span class="hljs-comment">// SET balance = balance - 200</span><br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids); <span class="hljs-comment">// WHERE id in (1, 2, 4)</span><br>        <span class="hljs-comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span><br>    <span class="hljs-comment">// 而是基于UpdateWrapper中的setSQL来更新</span><br>    userMapper.update(<span class="hljs-literal">null</span>, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-LambdaQueryWrapper"><a href="#3-1-3-LambdaQueryWrapper" class="headerlink" title="3.1.3 LambdaQueryWrapper"></a>3.1.3 LambdaQueryWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLambdaQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.lambda()<br>            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(User::getBalance, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 2.查询</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-自定义SQL"><a href="#3-2-自定义SQL" class="headerlink" title="3.2 自定义SQL"></a>3.2 自定义SQL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testCustomWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.准备自定义查询条件</span><br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="hljs-string">&quot;id&quot;</span>, ids);<br><br>    <span class="hljs-comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span><br>    userMapper.deductBalanceByIds(<span class="hljs-number">200</span>, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在UserMapper中自定义SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>    <span class="hljs-meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductBalanceByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;money&quot;)</span> <span class="hljs-type">int</span> money, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Service接口"><a href="#3-3-Service接口" class="headerlink" title="3.3 Service接口"></a>3.3 Service接口</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。<br><strong>通用接口为IService</strong>，<strong>默认实现为ServiceImpl</strong>，其中封装的方法可以分为以下几类：</p><ul><li>save：新增</li><li>remove：删除</li><li>update：更新</li><li>get：查询单个结果</li><li>list：查询集合结果</li><li>count：计数</li><li>page：分页查询</li></ul><h4 id="3-3-2-基本用法"><a href="#3-3-2-基本用法" class="headerlink" title="3.3.2 基本用法"></a>3.3.2 基本用法</h4><p>自定义Service接口继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;<br>    <span class="hljs-comment">// 拓展自定义方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编写UserServiceImpl类，继承ServiceImpl，实现UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-Lambda"><a href="#3-3-3-Lambda" class="headerlink" title="3.3.3 Lambda"></a>3.3.3 Lambda</h4><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductBalance</span><span class="hljs-params">(Long id, Integer money)</span> &#123;<br>    <span class="hljs-comment">// 1.查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 2.校验用户状态</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户状态异常！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.校验余额是否充足</span><br>    <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户余额不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.扣减余额 update tb_user set balance = balance - ?</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remainBalance</span> <span class="hljs-operator">=</span> user.getBalance() - money;<br>    lambdaUpdate()<br>            .set(User::getBalance, remainBalance) <span class="hljs-comment">// 更新余额</span><br>            .set(remainBalance == <span class="hljs-number">0</span>, User::getStatus, <span class="hljs-number">2</span>) <span class="hljs-comment">// 动态判断，是否更新status</span><br>            .eq(User::getId, id)<br>            .eq(User::getBalance, user.getBalance()) <span class="hljs-comment">// 乐观锁</span><br>            .update();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-扩展功能"><a href="#4-扩展功能" class="headerlink" title="4. 扩展功能"></a>4. 扩展功能</h2><h3 id="4-1-代码生成"><a href="#4-1-代码生成" class="headerlink" title="4.1 代码生成"></a>4.1 代码生成</h3><p>使用MybatisX插件即可</p><p><a href="https://blog.csdn.net/weixin_47025166/article/details/125362323">SpringBoot中MybatisX插件的简单使用教程（超详细！！）</a></p><h3 id="4-2-静态工具"><a href="#4-2-静态工具" class="headerlink" title="4.2 静态工具"></a>4.2 静态工具</h3><p>有的时候<strong>Service之间也会相互调用</strong>，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserVO <span class="hljs-title function_">queryUserAndAddressById</span><span class="hljs-params">(Long userId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getById(userId);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.查询收货地址</span><br>    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)<br>            .eq(Address::getUserId, userId)<br>            .list();<br>    <span class="hljs-comment">// 3.处理vo</span><br>    <span class="hljs-type">UserVO</span> <span class="hljs-variable">userVO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserVO.class);<br>    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));<br>    <span class="hljs-keyword">return</span> userVO;<br>&#125;<br></code></pre></td></tr></table></figure><p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p><h3 id="4-3-逻辑删除"><a href="#4-3-逻辑删除" class="headerlink" title="4.3 逻辑删除"></a>4.3 逻辑删除</h3><p>对于一些比较重要的数据，我们不删除数据库中的数据，而是</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li></ul><p>我们要在application.yml中配置逻辑删除字段</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><h3 id="4-4-枚举处理器"><a href="#4-4-枚举处理器" class="headerlink" title="4.4 枚举处理器"></a>4.4 枚举处理器</h3><p>MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们把<strong>枚举类型与数据库类型自动转换</strong></p><h4 id="4-4-1-定义枚举"><a href="#4-4-1-定义枚举" class="headerlink" title="4.4.1 定义枚举"></a>4.4.1 定义枚举</h4><p><img src="/img/blogs/java/springcloud/mp.2.png"></p><h4 id="4-4-2-EnumValue"><a href="#4-4-2-EnumValue" class="headerlink" title="4.4.2 @EnumValue"></a>4.4.2 @EnumValue</h4><p>MybatisPlus提供了@EnumValue注解来标记枚举属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnumValue</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><p>表示value字段的值是数据库值</p><h4 id="4-4-3-配置枚举处理器"><a href="#4-4-3-配置枚举处理器" class="headerlink" title="4.4.3 配置枚举处理器"></a>4.4.3 配置枚举处理器</h4><p>在application.yaml文件中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br></code></pre></td></tr></table></figure><h3 id="4-5-JSON类型处理器"><a href="#4-5-JSON类型处理器" class="headerlink" title="4.5 JSON类型处理器"></a>4.5 JSON类型处理器</h3><p>数据库的user表中有一个info字段，是JSON类型。而目前User实体类中却是String类型。处理JSON就可以使用JacksonTypeHandler处理器</p><p><strong>使用类型处理器</strong><br>将User类的info字段修改为UserInfo类型，并声明类型处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(typeHandler = JacksonTypeHandler.class)</span><br><span class="hljs-keyword">private</span> UserInfo info;<br></code></pre></td></tr></table></figure><h2 id="5-插件功能-以分页插件为例"><a href="#5-插件功能-以分页插件为例" class="headerlink" title="5. 插件功能(以分页插件为例)"></a>5. 插件功能(以分页插件为例)</h2><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。</p><ul><li>PaginationInnerInterceptor：自动分页</li><li>TenantLineInnerInterceptor：多租户</li><li>DynamicTableNameInnerInterceptor：动态表名</li><li>OptimisticLockerInnerInterceptor：乐观锁</li><li>IllegalSQLInnerInterceptor：sql 性能规范</li><li>BlockAttackInnerInterceptor：防止全表更新与删除</li></ul><h3 id="5-1-配置分页插件"><a href="#5-1-配置分页插件" class="headerlink" title="5.1 配置分页插件"></a>5.1 配置分页插件</h3><p>在项目中新建一个配置类：MybatisConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化核心插件</span><br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">// 添加分页插件</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-分页查询的测试"><a href="#5-2-分页查询的测试" class="headerlink" title="5.2 分页查询的测试"></a>5.2 分页查询的测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageQuery</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span><br>    Page&lt;User&gt; p = userService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 2.总条数</span><br>    System.out.println(<span class="hljs-string">&quot;total = &quot;</span> + p.getTotal());<br>    <span class="hljs-comment">// 3.总页数</span><br>    System.out.println(<span class="hljs-string">&quot;pages = &quot;</span> + p.getPages());<br>    <span class="hljs-comment">// 4.数据</span><br>    List&lt;User&gt; records = p.getRecords();<br>    records.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二-Docker"><a href="#二-Docker" class="headerlink" title="二. Docker"></a>二. Docker</h1><h2 id="1-Docker介绍"><a href="#1-Docker介绍" class="headerlink" title="1. Docker介绍"></a>1. Docker介绍</h2><p>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p><img src="/img/blogs/java/springcloud/docker.1.png"></p><h2 id="2-Docker常见命令"><a href="#2-Docker常见命令" class="headerlink" title="2. Docker常见命令"></a>2. Docker常见命令</h2><h3 id="2-1-常见命令"><a href="#2-1-常见命令" class="headerlink" title="2.1 常见命令"></a>2.1 常见命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker pull</td><td>拉取镜像</td></tr><tr><td>docker push</td><td>推送镜像到 Docker Registry</td></tr><tr><td>docker images</td><td>查看本地镜像</td></tr><tr><td>docker rmi</td><td>删除本地镜像</td></tr><tr><td>docker run</td><td>创建并运行容器（不能重复创建）</td></tr><tr><td>docker stop</td><td>停止指定容器</td></tr><tr><td>docker start</td><td>启动指定容器</td></tr><tr><td>docker restart</td><td>重新启动容器</td></tr><tr><td>docker rm</td><td>删除指定容器</td></tr><tr><td>docker ps</td><td>查看容器</td></tr><tr><td>docker logs</td><td>查看容器运行日志</td></tr><tr><td>docker exec</td><td>进入容器</td></tr><tr><td>docker save</td><td>保存镜像到本地压缩文件</td></tr><tr><td>docker load</td><td>加载本地压缩文件到镜像</td></tr><tr><td>docker inspect</td><td>查看容器详细信息</td></tr></tbody></table><p><img src="/img/blogs/java/springcloud/docker.2.png"></p><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span><br><br><span class="hljs-comment"># 第2步，拉取Nginx镜像</span><br>docker pull nginx<br><br><span class="hljs-comment"># 第3步，查看镜像</span><br>docker images<br><span class="hljs-comment"># 结果如下：</span><br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>nginx        latest    605c77e624dd   16 months ago   141MB<br>mysql        latest    3218b38490ce   17 months ago   516MB<br><br><span class="hljs-comment"># 第4步，创建并允许Nginx容器</span><br>docker run -d --name nginx -p 80:80 nginx<br><br><span class="hljs-comment"># 第5步，查看运行中容器</span><br>docker ps<br><span class="hljs-comment"># 也可以加格式化方式访问，格式会更加清爽</span><br>docker ps --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第6步，访问网页，地址：http://虚拟机地址</span><br><br><span class="hljs-comment"># 第7步，停止容器</span><br>docker stop nginx<br><br><span class="hljs-comment"># 第8步，查看所有容器</span><br>docker ps -a --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第9步，再次启动nginx容器</span><br>docker start nginx<br><br><span class="hljs-comment"># 第10步，再次查看容器</span><br>docker ps --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第11步，查看容器详细信息</span><br>docker inspect nginx<br><br><span class="hljs-comment"># 第12步，进入容器,查看容器内目录</span><br>docker <span class="hljs-built_in">exec</span> -it nginx bash<br><span class="hljs-comment"># 或者，可以进入MySQL</span><br>docker <span class="hljs-built_in">exec</span> -it mysql mysql -uroot -p<br><br><span class="hljs-comment"># 第13步，删除容器</span><br>docker <span class="hljs-built_in">rm</span> nginx<br><span class="hljs-comment"># 发现无法删除，因为容器运行中，强制删除容器</span><br>docker <span class="hljs-built_in">rm</span> -f nginx<br></code></pre></td></tr></table></figure><h3 id="2-3-命令别名"><a href="#2-3-命令别名" class="headerlink" title="2.3 命令别名"></a>2.3 命令别名</h3><p>给常用Docker命令起别名，方便我们访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改/root/.bashrc文件</span><br>vi /root/.bashrc<br>内容如下：<br><span class="hljs-comment"># .bashrc</span><br><br><span class="hljs-comment"># User specific aliases and functions</span><br><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-string">&#x27;rm -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">cp</span>=<span class="hljs-string">&#x27;cp -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">mv</span>=<span class="hljs-string">&#x27;mv -i&#x27;</span><br><span class="hljs-built_in">alias</span> dps=<span class="hljs-string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br><span class="hljs-built_in">alias</span> dis=<span class="hljs-string">&#x27;docker images&#x27;</span><br><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -f /etc/bashrc ]; <span class="hljs-keyword">then</span><br>        . /etc/bashrc<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>执行命令使别名生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /root/.bashrc<br></code></pre></td></tr></table></figure><h2 id="3-数据卷"><a href="#3-数据卷" class="headerlink" title="3. 数据卷"></a>3. 数据卷</h2><h3 id="3-1-数据卷介绍"><a href="#3-1-数据卷介绍" class="headerlink" title="3.1 数据卷介绍"></a>3.1 数据卷介绍</h3><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。<br><strong>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁</strong></p><p><img src="/img/blogs/java/springcloud/docker.3.png"></p><ul><li>我们创建了两个数据卷：conf、html</li><li>Nginx容器内部的conf目录和html目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;conf&#x2F;_data目录和&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html&#x2F;_data目录<br>这样以来，容器内的conf和html目录就 与宿主机的conf和html目录关联起来，我们称为挂载。此时，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html&#x2F;_data就是在操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;_data目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</li></ul><h3 id="3-2-数据卷命令"><a href="#3-2-数据卷命令" class="headerlink" title="3.2 数据卷命令"></a>3.2 数据卷命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker volume create</td><td>创建数据卷</td></tr><tr><td>docker volume ls</td><td>查看所有数据卷</td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td></tr><tr><td>docker volume prune</td><td>清除数据卷</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span><br>docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx<br><br><span class="hljs-comment"># 2.然后查看数据卷</span><br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 结果</span><br>DRIVER    VOLUME NAME<br><span class="hljs-built_in">local</span>     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f<br><span class="hljs-built_in">local</span>     html<br><br><span class="hljs-comment"># 3.查看数据卷详情</span><br>docker volume inspect html<br><span class="hljs-comment"># 结果</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: null,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;html&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: null,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br><br><span class="hljs-comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span><br>ll /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 可以看到与nginx的html目录内容一样，结果如下：</span><br>总用量 8<br>-rw-r--r--. 1 root root 497 12月 28 2021 50x.html<br>-rw-r--r--. 1 root root 615 12月 28 2021 index.html<br><br><span class="hljs-comment"># 5.进入该目录，并随意修改index.html内容</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br>vi index.html<br><br><span class="hljs-comment"># 6.打开页面，查看效果</span><br><br><span class="hljs-comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span><br>docker <span class="hljs-built_in">exec</span> -it nginx bash<br></code></pre></td></tr></table></figure><h3 id="3-3-挂载本地目录或文件"><a href="#3-3-挂载本地目录或文件" class="headerlink" title="3.3 挂载本地目录或文件"></a>3.3 挂载本地目录或文件</h3><p>数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载本地目录</span><br>-v 本地目录:容器内目录<br><span class="hljs-comment"># 挂载本地文件</span><br>-v 本地文件:容器内文件<br></code></pre></td></tr></table></figure><p>演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 1.删除原来的MySQL容器</span><br>docker <span class="hljs-built_in">rm</span> -f mysql<br><br><span class="hljs-comment"># 2.进入root目录</span><br><span class="hljs-built_in">cd</span> ~<br><br><span class="hljs-comment"># 3.创建并运行新mysql容器，挂载本地目录</span><br>docker run -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=123 \<br>  -v ./mysql/data:/var/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  mysql<br><br><span class="hljs-comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span><br><span class="hljs-built_in">ls</span> -l mysql<br><span class="hljs-comment"># 结果：</span><br>总用量 4<br>drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf<br>drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data<br>drwxr-xr-x. 2 root    root   23 5月  19 15:11 init<br><br><span class="hljs-comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span><br><span class="hljs-built_in">ls</span> -l data<br><br><span class="hljs-comment"># 5.查看MySQL容器内数据</span><br><span class="hljs-comment"># 5.1.进入MySQL</span><br>docker <span class="hljs-built_in">exec</span> -it mysql mysql -uroot -p123<br><span class="hljs-comment"># 5.2.查看编码表</span><br>show variables like <span class="hljs-string">&quot;%char%&quot;</span>;<br><span class="hljs-comment"># 5.3.结果，发现编码是utf8mb4没有问题</span><br>+--------------------------+--------------------------------+<br>| Variable_name            | Value                          |<br>+--------------------------+--------------------------------+<br>| character_set_client     | utf8mb4                        |<br>| character_set_connection | utf8mb4                        |<br>| character_set_database   | utf8mb4                        |<br>| character_set_filesystem | binary                         |<br>| character_set_results    | utf8mb4                        |<br>| character_set_server     | utf8mb4                        |<br>| character_set_system     | utf8mb3                        |<br>| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |<br>+--------------------------+--------------------------------+<br><br><span class="hljs-comment"># 6.查看数据</span><br><span class="hljs-comment"># 6.1.查看数据库</span><br>show databases;<br><span class="hljs-comment"># 结果，hmall是黑马商城数据库</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| hmall              |<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>5 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br><span class="hljs-comment"># 6.2.切换到hmall数据库</span><br>use hmall;<br><span class="hljs-comment"># 6.3.查看表</span><br>show tables;<br><span class="hljs-comment"># 结果：</span><br>+-----------------+<br>| Tables_in_hmall |<br>+-----------------+<br>| address         |<br>| cart            |<br>| item            |<br>| order           |<br>| order_detail    |<br>| order_logistics |<br>| pay_order       |<br>| user            |<br>+-----------------+<br><span class="hljs-comment"># 6.4.查看address表数据</span><br>+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+<br>| <span class="hljs-built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |<br>+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+<br>| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |<br>| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |<br>| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |<br>| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |<br>+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br><br></code></pre></td></tr></table></figure><h2 id="4-镜像"><a href="#4-镜像" class="headerlink" title="4. 镜像"></a>4. 镜像</h2><h3 id="4-1-构建自己的镜像"><a href="#4-1-构建自己的镜像" class="headerlink" title="4.1 构建自己的镜像"></a>4.1 构建自己的镜像</h3><p>我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><h3 id="4-2-Dockerfile"><a href="#4-2-Dockerfile" class="headerlink" title="4.2 Dockerfile"></a>4.2 Dockerfile</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>ENV</td><td>设置环境变量，可在后面指令使用</td></tr><tr><td>COPY</td><td>拷贝本地文件到镜像的指定目录</td></tr><tr><td>RUN</td><td>执行 Linux 的 shell 命令，一般是安装过程的命令</td></tr><tr><td>EXPOSE</td><td>指定容器运行时监听的端口，是给镜像使用者看的</td></tr><tr><td>ENTRYPOINT</td><td>镜像中应用的启动命令，容器运行时调用</td></tr></tbody></table><p>有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基础镜像</span><br>FROM openjdk:11.0-jre-buster<br><span class="hljs-comment"># 设定时区</span><br>ENV TZ=Asia/Shanghai<br>RUN <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone<br><span class="hljs-comment"># 拷贝jar包</span><br>COPY docker-demo.jar /app.jar<br><span class="hljs-comment"># 入口</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="5-自定义网络"><a href="#5-自定义网络" class="headerlink" title="5. 自定义网络"></a>5. 自定义网络</h2><p>容器的网络IP其实是一个虚拟的IP，其值<strong>并不固定</strong>与某一个容器绑定</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker network create</td><td>创建一个网络</td></tr><tr><td>docker network ls</td><td>查看所有网络</td></tr><tr><td>docker network rm</td><td>删除指定网络</td></tr><tr><td>docker network prune</td><td>清除未使用的网络</td></tr><tr><td>docker network connect</td><td>使指定容器连接加入某网络</td></tr><tr><td>docker network disconnect</td><td>使指定容器连接离开某网络</td></tr><tr><td>docker network inspect</td><td>查看网络详细信息</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.首先通过命令创建一个网络</span><br>docker network create hmall<br><br><span class="hljs-comment"># 2.然后查看网络</span><br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 结果：</span><br>NETWORK ID     NAME      DRIVER    SCOPE<br>639bc44d0a87   bridge    bridge    <span class="hljs-built_in">local</span><br>403f16ec62a2   hmall     bridge    <span class="hljs-built_in">local</span><br>0dc0f72a0fbb   host      host      <span class="hljs-built_in">local</span><br>cd8d3e8df47b   none      null      <span class="hljs-built_in">local</span><br><span class="hljs-comment"># 其中，除了hmall以外，其它都是默认的网络</span><br><br><span class="hljs-comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span><br><span class="hljs-comment"># 这样该网络内的其它容器可以用别名互相访问！</span><br><span class="hljs-comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span><br>docker network connect hmall mysql --<span class="hljs-built_in">alias</span> db<br><span class="hljs-comment"># 3.2.db容器，也就是我们的java项目</span><br>docker network connect hmall <span class="hljs-built_in">dd</span><br><br><span class="hljs-comment"># 4.进入dd容器，尝试利用别名访问db</span><br><span class="hljs-comment"># 4.1.进入容器</span><br>docker <span class="hljs-built_in">exec</span> -it <span class="hljs-built_in">dd</span> bash<br><span class="hljs-comment"># 4.2.用db别名访问</span><br>ping db<br><span class="hljs-comment"># 结果</span><br>PING db (172.18.0.2) 56(84) bytes of data.<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.070 ms<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.056 ms<br><span class="hljs-comment"># 4.3.用容器名访问</span><br>ping mysql<br><span class="hljs-comment"># 结果：</span><br>PING mysql (172.18.0.2) 56(84) bytes of data.<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.044 ms<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.054 ms<br></code></pre></td></tr></table></figure><h2 id="6-DockerCompose"><a href="#6-DockerCompose" class="headerlink" title="6. DockerCompose"></a>6. DockerCompose</h2><p>Docker Compose可以帮助我们<strong>实现多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><p>部署mysql，可以使用docker-compose.yml进行部署</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/data:/var/lib/mysql&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">new</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">new:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">hmall</span><br></code></pre></td></tr></table></figure><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose [OPTIONS] [COMMAND]<br></code></pre></td></tr></table></figure><table>  <thead>    <tr>      <th>类型</th>      <th>参数或指令</th>      <th>说明</th>    </tr>  </thead>  <tbody>    <tr>      <td rowspan="2">Options</td>      <td>-f</td>      <td>指定 compose 文件的路径和名称</td>    </tr>    <tr>      <td>-p</td>      <td>指定 project 名称。project 就是当前 compose 文件中设置的多个 service 的集合，是逻辑概念</td>    </tr>    <tr>     <td rowspan="9">Commands</td>      <td>up</td>      <td>创建并启动所有 service 容器</td>    </tr>    <tr>      <td>down</td>      <td>停止并移除所有容器、网络</td>    </tr>    <tr>      <td>ps</td>      <td>列出所有启动的容器</td>    </tr>    <tr>      <td>logs</td>      <td>查看指定容器的日志</td>    </tr>    <tr>      <td>stop</td>      <td>停止容器</td>    </tr>    <tr>      <td>start</td>      <td>启动容器</td>    </tr>    <tr>      <td>restart</td>      <td>重启容器</td>    </tr>    <tr>      <td>top</td>      <td>查看运行的进程</td>    </tr>    <tr>      <td>exec</td>      <td>在指定的运行中容器中执行命令</td>    </tr>  </tbody></table><h1 id="三-微服务"><a href="#三-微服务" class="headerlink" title="三. 微服务"></a>三. 微服务</h1><h2 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1. 认识微服务"></a>1. 认识微服务</h2><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h3><p>单体架构（monolithic structure）：顾名思义，整个项目中<strong>所有功能模块都在一个工程中开发</strong>；项目部署时需要<strong>对所有模块一起编译、打包</strong>；项目的架构设计、开发模式都非常简单。</p><h3 id="1-2-微服务"><a href="#1-2-微服务" class="headerlink" title="1.2 微服务"></a>1.2 微服务</h3><p>微服务架构，首先是服务化，就是<strong>将单体架构中的功能模块从单体应用中拆分出来</strong>，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li>单一职责：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块。</li><li>团队自治：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模不超过10人（2张披萨能喂饱）</li><li>服务自治：<strong>每个微服务都独立打包部署，访问自己独立的数据库</strong>。并且要做好服务隔离，避免对其它服务产生影响</li></ul><p><img src="/img/blogs/java/springcloud/3.1.1.png"></p><h3 id="1-3-SpringCloud"><a href="#1-3-SpringCloud" class="headerlink" title="1.3 SpringCloud"></a>1.3 SpringCloud</h3><p>SpringCloud框架是目前Java领域最全面的微服务组件的集合</p><h2 id="2-微服务拆分"><a href="#2-微服务拆分" class="headerlink" title="2. 微服务拆分"></a>2. 微服务拆分</h2><h3 id="2-1-微服务拆分原则"><a href="#2-1-微服务拆分原则" class="headerlink" title="2.1 微服务拆分原则"></a>2.1 微服务拆分原则</h3><h4 id="2-1-1-什么时候拆"><a href="#2-1-1-什么时候拆" class="headerlink" title="2.1.1 什么时候拆"></a>2.1.1 什么时候拆</h4><ul><li>对于<strong>大多数小型项目来说，一般是先采用单体架构</strong>，随着用户规模扩大、<strong>业务复杂后再逐渐拆分为微服务架构</strong>。这样初期成本会比较低，可以快速试错。但是，这么做的问题就在于后期做服务拆分时，可能会遇到很多代码耦合带来的问题，拆分比较困难（<strong>前易后难</strong>）。</li><li>而<strong>对于一些大型项目</strong>，在立项之初目的就很明确，为了长远考虑，在架构设计时就<strong>直接选择微服务架构</strong>。虽然前期投入较多，但后期就少了拆分服务的烦恼（<strong>前难后易</strong>）。</li></ul><h4 id="2-1-2-怎么拆"><a href="#2-1-2-怎么拆" class="headerlink" title="2.1.2 怎么拆"></a>2.1.2 怎么拆</h4><ul><li>目标：微服务拆分时粒度要小</li><li><strong>高内聚</strong>：每个微服务的职责要尽量单一，包含的业务相互关联度高、完整度高。</li><li><strong>低耦合</strong>：每个微服务的功能要相对独立，尽量减少对其它微服务的依赖，或者依赖接口的稳定性要强。</li></ul><p>我们在做服务拆分时一般有两种方式：</p><ul><li>纵向拆分：<strong>按照项目的功能模块来拆分</strong>。例如黑马商城中，就有用户管理功能、订单管理功能、购物车功能、商品管理功能、支付功能等。那么按照功能模块将他们拆分为一个个服务，就属于纵向拆分。这种拆分模式可以尽可能提高服务的内聚性。</li><li>横向拆分：各个功能模块之间有没有<strong>公共的业务部分，如果有将其抽取出来作为通用服务</strong>。例如用户登录是需要发送消息通知，记录风控数据，下单时也要发送短信，记录风控数据。</li></ul><p>一般微服务项目有两种不同的工程结构：</p><ul><li>完全解耦：每一个微服务都创建为一个独立的工程，甚至可以使用不同的开发语言来开发，项目完全解耦。<ul><li>优点：服务之间耦合度低</li><li>缺点：每个项目都有自己的独立仓库，管理起来比较麻烦</li></ul></li><li>Maven聚合：整个项目为一个Project，然后每个微服务是其中的一个Module<ul><li>优点：项目代码集中，管理和运维方便</li><li>缺点：服务之间耦合，编译时间较长</li></ul></li></ul><h3 id="2-2-黑马商城的拆分"><a href="#2-2-黑马商城的拆分" class="headerlink" title="2.2 黑马商城的拆分"></a>2.2 黑马商城的拆分</h3><p><img src="/img/blogs/java/springcloud/3.2.1.png"></p><p><img src="/img/blogs/java/springcloud/3.2.2.png"></p><p><img src="/img/blogs/java/springcloud/3.2.3.png"></p><h2 id="3-服务注册和发现-与-OpenFeign"><a href="#3-服务注册和发现-与-OpenFeign" class="headerlink" title="3. 服务注册和发现 与 OpenFeign"></a>3. 服务注册和发现 与 OpenFeign</h2><h3 id="3-1-注册中心原理"><a href="#3-1-注册中心原理" class="headerlink" title="3.1 注册中心原理"></a>3.1 注册中心原理</h3><p>在微服务<strong>远程调用</strong>的过程中，包括两个角色：</p><ul><li><strong>服务提供者</strong>：提供接口供其它微服务访问，比如item-service</li><li><strong>服务消费者</strong>：调用其它微服务提供的接口，比如cart-service</li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了注册中心的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="/img/blogs/java/springcloud/3.3.1.png"></p><p>流程如下：</p><ol><li>服务启动时就会<strong>注册自己的服务信息</strong>（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，<strong>挑选一个实例</strong></li><li>调用者向该实例发起远程调用</li></ol><h3 id="3-2-Nacos注册中心"><a href="#3-2-Nacos注册中心" class="headerlink" title="3.2 Nacos注册中心"></a>3.2 Nacos注册中心</h3><p>Nacos: Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</p><h3 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3 服务注册"></a>3.3 服务注册</h3><p>把项目注册到Nacos, 步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>重启</li></ul><h4 id="3-3-1-添加依赖"><a href="#3-3-1-添加依赖" class="headerlink" title="3.3.1 添加依赖"></a>3.3.1 添加依赖</h4><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2-配置Nacos"><a href="#3-3-2-配置Nacos" class="headerlink" title="3.3.2 配置Nacos"></a>3.3.2 配置Nacos</h4><p>application.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># nacos地址</span><br></code></pre></td></tr></table></figure><h3 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4 服务发现"></a>3.4 服务发现</h3><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><h3 id="3-5-OpenFeign"><a href="#3-5-OpenFeign" class="headerlink" title="3.5 OpenFeign"></a>3.5 OpenFeign</h3><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型<br>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</li></ul><h3 id="3-6-抽取微服务"><a href="#3-6-抽取微服务" class="headerlink" title="3.6 抽取微服务"></a>3.6 抽取微服务</h3><p>避免重复编码的办法就是抽取。这里有两种抽取思路：</p><ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul><p><img src="/img/blogs/java/springcloud/3.3.2.png"></p><p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。<br>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><h2 id="4-网关"><a href="#4-网关" class="headerlink" title="4. 网关"></a>4. 网关</h2><h3 id="4-1-认识网关"><a href="#4-1-认识网关" class="headerlink" title="4.1 认识网关"></a>4.1 认识网关</h3><p>网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过<strong>网关来做数据的路由和转发以及数据安全的校验。</strong></p><p><img src="/img/blogs/java/springcloud/3.4.1.png"></p><p>前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是<strong>登录身份校验</strong>，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><h3 id="4-2-网关路由快速入门"><a href="#4-2-网关路由快速入门" class="headerlink" title="4.2 网关路由快速入门"></a>4.2 网关路由快速入门</h3><p>步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><p>在hm-gateway模块的resources目录新建一个application.yaml文件,配置网关路由：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item</span> <span class="hljs-comment"># 路由规则id，自定义，唯一</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span> <span class="hljs-comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span> <span class="hljs-comment"># 这里是以请求路径作为判断规则</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cart</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cart-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/carts/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/users/**,/addresses/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trade</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://trade-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/orders/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">pay</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://pay-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/pay-orders/**</span><br></code></pre></td></tr></table></figure><h3 id="4-3-路由过滤"><a href="#4-3-路由过滤" class="headerlink" title="4.3 路由过滤"></a>4.3 路由过滤</h3><p>路由规则：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span><br></code></pre></td></tr></table></figure><p>四个属性含义如下：</p><ul><li>id：路由的唯一标示</li><li>predicates：路由断言，其实就是<strong>匹配条件</strong></li><li>filters：<strong>路由过滤</strong>条件</li><li>uri：<strong>路由目标地址</strong>，lb:&#x2F;&#x2F;代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><ul><li>predicates，路由断言的类型:</li></ul><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td></tr><tr><td>Cookie</td><td>请求必须包含某些 cookie</td></tr><tr><td>Header</td><td>请求必须包含某些 header</td></tr><tr><td>Host</td><td>请求必须是访问某个 host（域名）</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td></tr><tr><td>RemoteAddr</td><td>请求者的 IP 必须是指定范围</td></tr><tr><td>weight</td><td>权重处理</td></tr></tbody></table><h3 id="4-4-网关登录校验"><a href="#4-4-网关登录校验" class="headerlink" title="4.4 网关登录校验"></a>4.4 网关登录校验</h3><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全<strong>可以把登录校验的工作放到网关去做</strong>，这样之前说的问题就解决了：</p><ul><li>只需要<strong>在网关和用户服务保存秘钥</strong></li><li>只需要<strong>在网关开发登录校验功能</strong></li></ul><p><img src="/img/blogs/java/springcloud/4.4.1.png"></p><h4 id="4-4-1-网关过滤器"><a href="#4-4-1-网关过滤器" class="headerlink" title="4.4.1 网关过滤器"></a>4.4.1 网关过滤器</h4><p><img src="/img/blogs/java/springcloud/4.4.2.png"></p><ol><li>客户端请求进入网关后由HandlerMapping对请求做判断，找到与当前请求匹配的路由规则（Route），然后将请求交给WebHandler去处理。</li><li>WebHandler则会加载当前路由下需要执行的过滤器链（Filter chain），然后按照顺序逐一执行过滤器（后面称为Filter）。</li><li>图中Filter被虚线分为左右两部分，是因为Filter内部的逻辑分为pre和post两部分，分别会在请求路由到微服务之前和之后被执行。</li><li>只有所有Filter的pre逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行Filter的post逻辑。</li><li>最终把响应结果返回</li></ol><p>网关过滤器链中的过滤器有两种：</p><ul><li><strong>GatewayFilter</strong>：<strong>路由过滤器</strong>，作用范围比较灵活，可以是任意指定的路由Route. </li><li><strong>GlobalFilter</strong>：<strong>全局过滤器</strong>，作用范围是所有路由，不可配置。</li></ul><h4 id="4-4-2-自定义过滤器"><a href="#4-4-2-自定义过滤器" class="headerlink" title="4.4.2 自定义过滤器"></a>4.4.2 自定义过滤器</h4><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintAnyGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 编写过滤器逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;未登录，无法访问&quot;</span>);<br>        <span class="hljs-comment">// 放行</span><br>        <span class="hljs-comment">// return chain.filter(exchange);</span><br><br>        <span class="hljs-comment">// 拦截</span><br>        <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>        response.setRawStatusCode(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> response.setComplete();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 过滤器执行顺序，值越小，优先级越高</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-微服务获取用户"><a href="#4-4-3-微服务获取用户" class="headerlink" title="4.4.3 微服务获取用户"></a>4.4.3 微服务获取用户</h4><p>由于网关发送请求到微服务依然采用的是Http请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以<strong>从请求头中获取登录用户信息</strong>。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><p><img src="/img/blogs/java/springcloud/4.4.3.png"></p><ul><li>改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务</li><li>编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行</li></ul><h4 id="4-4-4-OpenFeign传递用户"><a href="#4-4-4-OpenFeign传递用户" class="headerlink" title="4.4.4 OpenFeign传递用户"></a>4.4.4 OpenFeign传递用户</h4><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就必须在微服务发起调用时把用户信息存入请求头。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？<br>这里要借助Feign中提供的一个拦截器接口：feign.RequestInterceptor</p><h2 id="5-配置管理"><a href="#5-配置管理" class="headerlink" title="5. 配置管理"></a>5. 配置管理</h2><p>Nacos不仅仅具备注册中心功能，也具备配置管理的功能</p><p><img src="/img/blogs/java/springcloud/4.5.1.png"></p><p><strong>微服务共享的配置可以统一交给Nacos保存和管理</strong>，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且<strong>无需重启即可生效</strong>，实现<strong>配置热更新</strong>。<br>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h3 id="5-1-配置共享"><a href="#5-1-配置共享" class="headerlink" title="5.1 配置共享"></a>5.1 配置共享</h3><p>把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li><strong>在Nacos中添加共享配置</strong></li><li><strong>微服务拉取配置</strong></li></ul><p>SpringCloud在初始化上下文的时候会先读取一个名为bootstrap.yaml(或者bootstrap.properties)的文件，如果我们将nacos地址配置到bootstrap.yaml中，那么在项目引导阶段就可以读取nacos中的配置了。</p><p><img src="/img/blogs/java/springcloud/4.5.2.png"></p><h3 id="5-2-动态路由"><a href="#5-2-动态路由" class="headerlink" title="5.2 动态路由"></a>5.2 动态路由</h3><p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addListener</span><span class="hljs-params">(String dataId, String group, Listener listener)</span><br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;serverAddr&#125;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;dataId&#125;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;group&#125;&quot;</span>;<br><span class="hljs-comment">// 1.创建ConfigService，连接Nacos</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.put(<span class="hljs-string">&quot;serverAddr&quot;</span>, serverAddr);<br><span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> NacosFactory.createConfigService(properties);<br><span class="hljs-comment">// 2.读取配置</span><br><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);<br><span class="hljs-comment">// 3.添加配置监听器</span><br>configService.addListener(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;<br>        <span class="hljs-comment">// 配置变更的通知处理</span><br>                System.out.println(<span class="hljs-string">&quot;recieve1:&quot;</span> + configInfo);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>核心的步骤有2步：</p><ul><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><h1 id="四-服务保护和分布式事务"><a href="#四-服务保护和分布式事务" class="headerlink" title="四. 服务保护和分布式事务"></a>四. 服务保护和分布式事务</h1><h2 id="1-雪崩问题"><a href="#1-雪崩问题" class="headerlink" title="1. 雪崩问题"></a>1. 雪崩问题</h2><p>雪崩问题指的是<strong>某个服务不可用或响应变慢，导致依赖该服务的其他服务也无法正常工作，进而引发连锁反应，最终导致整个系统崩溃</strong>。这种现象类似于雪崩，由一个小问题逐步扩散，最终影响整个系统的稳定性。</p><p><img src="/img/blogs/java/springcloud/4.1.1.png"></p><p>雪崩问题产生的原因：</p><ul><li>微服务相互调用,<strong>服务提供者出现故障或阻塞</strong>。</li><li><strong>服务调用者</strong>没有做好异常处理,导致<strong>自身故障</strong>。</li><li>调用链中的所有服务级联失败,导致整个集群故障</li></ul><p>解决问题的思路：</p><ul><li>尽量避免服务出现故障或阻塞</li><li>保证代码的健壮性</li><li>保证网络畅通</li><li>能应对较高的并发请求</li></ul><h2 id="2-微服务保护"><a href="#2-微服务保护" class="headerlink" title="2. 微服务保护"></a>2. 微服务保护</h2><h3 id="2-1-微服务保护方案"><a href="#2-1-微服务保护方案" class="headerlink" title="2.1 微服务保护方案"></a>2.1 微服务保护方案</h3><ul><li><strong>请求限流</strong></li><li><strong>线程隔离</strong></li><li><strong>服务熔断</strong></li></ul><h4 id="2-1-1-请求限流"><a href="#2-1-1-请求限流" class="headerlink" title="2.1.1 请求限流"></a>2.1.1 请求限流</h4><p>服务故障最重要原因，就是<strong>并发太高！因此请求限流</strong>，就是<strong>限制或控制接口访问的并发流量</strong>，避免服务因流量激增而出现故障。</p><p><img src="/img/blogs/java/springcloud/4.2.1.png"></p><h4 id="2-1-2-线程隔离"><a href="#2-1-2-线程隔离" class="headerlink" title="2.1.2 线程隔离"></a>2.1.2 线程隔离</h4><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。<br>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以<strong>限定每个接口可以使用的资源范围</strong>，也就是将其“隔离”起来。</p><p><img src="/img/blogs/java/springcloud/4.2.2.png"></p><h4 id="2-1-3-服务熔断"><a href="#2-1-3-服务熔断" class="headerlink" title="2.1.3 服务熔断"></a>2.1.3 服务熔断</h4><p>统计服务提供方的<strong>异常比例，当比例过高</strong>表明该接口会影响到其它服务，<strong>应该拒绝调用该接口</strong>，而是直接走降级逻辑。<br>服务调用失败后的处理逻辑，根据业务场景，<strong>可以抛出异常，也可以返回友好提示或默认数据</strong>。</p><p><img src="/img/blogs/java/springcloud/4.2.3.png"></p><h4 id="2-1-4-解决雪崩问题的常见方案"><a href="#2-1-4-解决雪崩问题的常见方案" class="headerlink" title="2.1.4 解决雪崩问题的常见方案"></a>2.1.4 解决雪崩问题的常见方案</h4><ul><li>请求限流:<strong>限制流量</strong>在服务可以处理的范围,避免因突发流量而故障</li><li>线程隔离:<strong>控制业务可用的线程数量</strong>,将故障隔离在一定范围</li><li>服务熔断:<strong>将异常比例过高的接口断开</strong>,拒绝所有请求,直接走fallback</li><li>失败处理:<strong>定义fallback逻辑</strong>,让业务失败时不再抛出异常,而是<strong>返回默认数据或友好提示</strong></li></ul><h3 id="2-2-Sentinel-微服务保护技术"><a href="#2-2-Sentinel-微服务保护技术" class="headerlink" title="2.2 Sentinel(微服务保护技术)"></a>2.2 Sentinel(微服务保护技术)</h3><h4 id="2-2-1-Sentinel下载安装和运行"><a href="#2-2-1-Sentinel下载安装和运行" class="headerlink" title="2.2.1 Sentinel下载安装和运行"></a>2.2.1 Sentinel下载安装和运行</h4><p><a href="https://sentinelguard.io/zh-cn/">sentinel官网</a></p><p>在目录文件夹中cmd打开控制台运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar<br></code></pre></td></tr></table></figure><p>访问<code>http://localhost:8090</code>页面，就可以看到sentinel的控制台了</p><h4 id="2-2-2-请求限流"><a href="#2-2-2-请求限流" class="headerlink" title="2.2.2 请求限流"></a>2.2.2 请求限流</h4><p>在sentinel配置：</p><p><img src="/img/blogs/java/springcloud/4.2.4.png"></p><h4 id="2-2-3-线程隔离"><a href="#2-2-3-线程隔离" class="headerlink" title="2.2.3 线程隔离"></a>2.2.3 线程隔离</h4><p><strong>修改tomcat连接</strong>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">threads:</span><br>      <span class="hljs-attr">max:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 允许的最大线程数</span><br>    <span class="hljs-attr">accept-count:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 最大排队等待数量</span><br>    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 允许的最大连接</span><br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/springcloud/4.2.5.png"></p><h4 id="2-2-4-服务熔断"><a href="#2-2-4-服务熔断" class="headerlink" title="2.2.4 服务熔断"></a>2.2.4 服务熔断</h4><h5 id="2-2-4-1-Fallback"><a href="#2-2-4-1-Fallback" class="headerlink" title="2.2.4.1 Fallback"></a>2.2.4.1 Fallback</h5><p>超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个降级处理逻辑。<br>触发限流或熔断后的请求<strong>不一定要直接报错，也可以返回一些默认数据或者友好提示</strong>，用户体验会更好。</p><ul><li>定义降级处理类，实现FallbackFactory:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ItemClient <span class="hljs-title function_">create</span><span class="hljs-params">(Throwable cause)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemClient</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(Collection&lt;Long&gt; ids)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);<br>                <span class="hljs-comment">// 查询购物车允许失败，查询失败，返回空集合</span><br>                <span class="hljs-keyword">return</span> CollUtils.emptyList();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;<br>                <span class="hljs-comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizIllegalException</span>(cause);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-4-2-服务熔断"><a href="#2-2-4-2-服务熔断" class="headerlink" title="2.2.4.2 服务熔断"></a>2.2.4.2 服务熔断</h5><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会熔断该接口，即<strong>拦截访问该接口的一切请求</strong>，降级处理；当该接口<strong>恢复正常时，再放行</strong>对于该接口的请求。<br>断路器的工作状态切换有一个状态机来控制：</p><p><img src="/img/blogs/java/springcloud/4.2.6.png"></p><ul><li>closed：<strong>关闭状态，断路器放行所有请求</strong>，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li>open：<strong>打开状态，服务调用被熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li>half-open：<strong>半开状态，放行一次请求</strong>，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p><img src="/img/blogs/java/springcloud/4.2.7.png"></p><h2 id="3-分布式事务"><a href="#3-分布式事务" class="headerlink" title="3. 分布式事务"></a>3. 分布式事务</h2><p><strong>每个微服务的本地事务，也可以称为分支事务</strong>。<strong>多个有关联的分支事务一起就组成了全局事务</strong>。我们必须保证整个全局事务同时成功或失败。满足ACID特性。</p><h3 id="3-1-Seata"><a href="#3-1-Seata" class="headerlink" title="3.1 Seata"></a>3.1 Seata</h3><p>Seata是阿里巴巴的开源分布式事务框架<br>解决分布式事务的方法是<strong>找一个统一的事务协调者，与多个分支事务通信，检测每个分支事务的执行状态</strong>，<strong>保证全局事务下的每一个分支事务同时成功或失败</strong>即可。</p><p>在Seata的事务管理中有三个重要的角色：</p><ul><li><strong>TC</strong> (Transaction Coordinator) - <strong>事务协调者</strong>：<strong>维护全局和分支事务的状态</strong>，协调<strong>全局事务提交或回滚</strong>。 </li><li><strong>TM</strong> (Transaction Manager) - <strong>事务管理器</strong>：<strong>定义全局事务的范围</strong>、开始全局事务、提交或回滚全局事务。 </li><li><strong>RM</strong> (Resource Manager) - <strong>资源管理器</strong>：<strong>管理分支事务</strong>，与TC交谈以注册分支事务和报告分支事务的状态，并<strong>驱动分支事务提交或回滚</strong>。</li></ul><p><img src="/img/blogs/java/springcloud/4.3.1.png"></p><ul><li><strong>TC服务则是事务协调中心，是一个独立的微服务，需要单独部署</strong></li><li>TM和RM就会协助微服务，<strong>实现本地分支事务与TC之间交互</strong>，实现事务的提交或回滚。</li></ul><h3 id="3-2-部署TC服务"><a href="#3-2-部署TC服务" class="headerlink" title="3.2 部署TC服务"></a>3.2 部署TC服务</h3><p>维护全局和分支事务的状态，协调全局事务提交或回滚。 </p><h3 id="3-3-微服务集成Seata"><a href="#3-3-微服务集成Seata" class="headerlink" title="3.3 微服务集成Seata"></a>3.3 微服务集成Seata</h3><h4 id="3-3-1-引入依赖"><a href="#3-3-1-引入依赖" class="headerlink" title="3.3.1 引入依赖"></a>3.3.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--统一配置管理--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--读取bootstrap文件--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--seata--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2-配置seata"><a href="#3-3-2-配置seata" class="headerlink" title="3.3.2 配置seata"></a>3.3.2 配置seata</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">registry:</span> <span class="hljs-comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span> <span class="hljs-comment"># 注册中心类型 nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># nacos地址</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># namespace，默认为空</span><br>      <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 分组，默认是DEFAULT_GROUP</span><br>      <span class="hljs-attr">application:</span> <span class="hljs-string">seata-server</span> <span class="hljs-comment"># seata服务名称</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 事务组名称</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">vgroup-mapping:</span> <span class="hljs-comment"># 事务组与tc集群的映射关系</span><br>      <span class="hljs-attr">hmall:</span> <span class="hljs-string">&quot;default&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-4-XA模式"><a href="#3-4-XA模式" class="headerlink" title="3.4 XA模式"></a>3.4 XA模式</h3><p>Seata支持<strong>四种不同的分布式事务解决方案</strong>：</p><ul><li>XA</li><li>TCC</li><li>AT</li><li>SAGA</li></ul><p><img src="/img/blogs/java/springcloud/4.3.2.png"></p><p>RM一阶段的工作：</p><ol><li>注册分支事务到TC</li><li>执行分支业务sql但不提交</li><li>报告执行状态到TC</li></ol><p>TC二阶段的工作：</p><ul><li>TC检测各分支事务执行状态<ol><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol></li></ul><p>RM二阶段的工作：</p><ul><li>接收TC指令，提交或回滚事务</li></ul><p><strong>优缺点</strong><br>XA模式的优点是什么？</p><ul><li>事务的<strong>强一致性</strong>，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA模式的缺点是什么？</p><ul><li>因为<strong>一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</strong></li><li>依赖关系型数据库实现事务</li></ul><h3 id="3-5-AT模式"><a href="#3-5-AT模式" class="headerlink" title="3.5 AT模式"></a>3.5 AT模式</h3><p>AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p><p><img src="/img/blogs/java/springcloud/4.3.3.png"></p><p>阶段一RM的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态<br>阶段二提交时RM的工作：</li><li>删除undo-log即可<br>阶段二回滚时RM的工作：</li><li>根据undo-log恢复数据到更新前</li></ul><p><img src="/img/blogs/java/springcloud/4.3.4.png"></p><p><strong>AT与XA的区别</strong></p><ul><li>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</li><li>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</li><li>XA模式强一致；AT模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。</p><h1 id="五-MQ"><a href="#五-MQ" class="headerlink" title="五. MQ"></a>五. MQ</h1><h2 id="1-认识MQ"><a href="#1-认识MQ" class="headerlink" title="1. 认识MQ"></a>1. 认识MQ</h2><h3 id="1-1-同步调用"><a href="#1-1-同步调用" class="headerlink" title="1.1 同步调用"></a>1.1 同步调用</h3><p>在微服务架构中，同步调用（Synchronous Invocation）通常<strong>指一个服务调用另一个服务时，调用方必须等待被调用方处理完请求并返回响应后，才能继续执行后续逻辑</strong>。</p><p><img src="/img/blogs/java/springcloud/mq.1.png"></p><p><strong>特点</strong>：</p><ul><li><strong>阻塞执行</strong>：调用方在等待返回结果时无法执行其他任务。</li><li>执行顺序严格：<strong>必须按顺序等待上一个任务完成后才能继续下一个任务</strong>。</li><li><strong>适用于短时间执行的任务</strong>：如果被调用的方法执行时间较长，会影响系统的响应速度和并发能力。</li></ul><p><strong>存在的问题</strong>：</p><ul><li>拓展性差：每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</li><li>性能下降：每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和</li><li>级联失败(雪崩问题)：当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</li></ul><h3 id="1-2-异步调用"><a href="#1-2-异步调用" class="headerlink" title="1.2 异步调用"></a>1.2 异步调用</h3><p>在微服务架构中，异步调用（Asynchronous Invocation）指的是<strong>调用方在调用某个服务时，不需要等待其完成，而是立即返回并继续执行其他任务</strong>。<strong>被调用方在完成处理后</strong>，可以通过回调、轮询、<strong>消息队列</strong>等方式通知调用方。</p><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="/img/blogs/java/springcloud/mq.2.png"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p><img src="/img/blogs/java/springcloud/mq.3.png"></p><p>异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>异步通信存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h3 id="1-3-常见MQ技术对比"><a href="#1-3-常见MQ技术对比" class="headerlink" title="1.3 常见MQ技术对比"></a>1.3 常见MQ技术对比</h3><table><thead><tr><th>常见MQ</th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td><strong>公司&#x2F;社区</strong></td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td><strong>开发语言</strong></td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td><strong>协议支持</strong></td><td>AMQP, XMPP, SMTP, STOMP</td><td>OpenWire, STOMP, REST, XMPP, AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td><strong>可用性</strong></td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td><strong>单机吞吐量</strong></td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td><strong>消息延迟</strong></td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td><strong>消息可靠性</strong></td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2. RabbitMQ"></a>2. RabbitMQ</h2><h3 id="2-1-RabbitMQ架构"><a href="#2-1-RabbitMQ架构" class="headerlink" title="2.1 RabbitMQ架构"></a>2.1 RabbitMQ架构</h3><ul><li>publisher：<strong>生产者</strong>，也就是发送消息的一方</li><li>consumer：<strong>消费者</strong>，也就是消费消息的一方</li><li>queue：<strong>队列，存储消息</strong>。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>exchange：<strong>交换机，负责消息路由</strong>。生产者发送的消息由交换机决定投递到哪个队列。</li><li>virtual host：<strong>虚拟主机，起到数据隔离的作用</strong>。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p><img src="/img/blogs/java/springcloud/mq.4.png"></p><p>生产者发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定</p><h3 id="2-2-数据隔离"><a href="#2-2-数据隔离" class="headerlink" title="2.2 数据隔离"></a>2.2 数据隔离</h3><ul><li>给每个项目创建不同的virtual host，将每个项目的数据隔离。</li><li>给每个项目创建独立的运维账号，将管理权限分离。</li></ul><h2 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3. SpringAMQP"></a>3. SpringAMQP</h2><h3 id="3-1-入门案例"><a href="#3-1-入门案例" class="headerlink" title="3.1 入门案例"></a>3.1 入门案例</h3><h4 id="3-1-1-引入依赖"><a href="#3-1-1-引入依赖" class="headerlink" title="3.1.1 引入依赖"></a>3.1.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-添加配置"><a href="#3-1-2-添加配置" class="headerlink" title="3.1.2 添加配置"></a>3.1.2 添加配置</h4><p>在publisher服务的application.yml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 你的虚拟机IP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/hmall</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3-发送消息"><a href="#3-1-3-发送消息" class="headerlink" title="3.1.3 发送消息"></a>3.1.3 发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-4-接收消息"><a href="#3-1-4-接收消息" class="headerlink" title="3.1.4 接收消息"></a>3.1.4 接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-comment">// 利用RabbitListener来声明要监听的队列信息</span><br>    <span class="hljs-comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span><br>    <span class="hljs-comment">// 可以看到方法体中接收的就是消息体的内容</span><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-WorkQueues模型"><a href="#3-2-WorkQueues模型" class="headerlink" title="3.2 WorkQueues模型"></a>3.2 WorkQueues模型</h3><p>让多个消费者绑定到一个队列，共同消费队列中的消息。可以使用WorkQueues模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了。</p><p><img src="/img/blogs/java/springcloud/mq.5.png"></p><h4 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1 消息发送"></a>3.2.1 消息发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * workQueue</span><br><span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, message_&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>        <span class="hljs-comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span><br>        rabbitTemplate.convertAndSend(queueName, message + i);<br>        Thread.sleep(<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2 消息接收"></a>3.2.2 消息接收</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;work.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue1</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">20</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;work.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue2</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.err.println(<span class="hljs-string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h4 id="3-2-3-测试结果"><a href="#3-2-3-测试结果" class="headerlink" title="3.2.3 测试结果"></a>3.2.3 测试结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">消费者<span class="hljs-number">1</span>接收到消息：【hello, message_0】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.869555300</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_1】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.884518</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_2】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.907454400</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_4】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.953332100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_6】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.997867300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_8】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.042178700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_3】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.086478800</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_10】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.087476600</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_12】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.132578300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_14】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.175851200</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_16】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.218533400</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_18】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.261322900</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_5】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.287003700</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_20】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.304412400</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_22】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.349950100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_24】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.394533900</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_26】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.439876500</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_28】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.482937800</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_7】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.488977100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_30】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.526409300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_32】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.572148</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_34】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.618264800</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_36】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.660780600</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_9】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.689189300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_38】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.705261</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_40】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.746927300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_42】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.789835</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_44】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.834393100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_46】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.875312100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_11】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.889969500</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_48】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.920702500</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_13】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.090725900</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_15】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.293060600</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_17】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.493748</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_19】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.696635100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_21】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.896809700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_23】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.099533400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_25】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.301446400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_27】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.504999100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_29】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.705702500</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_31】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.906601200</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_33】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.108118500</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_35】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.308945400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_37】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.511547700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_39】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.714038400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_41】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.916192700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_43】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.116286400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_45】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.318055100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_47】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.520656400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_49】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.723106700</span><br></code></pre></td></tr></table></figure><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。<br>也就是说<strong>消息是平均分配给每个消费者</strong>，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。</li></ul><h4 id="3-2-4-能者多劳配置"><a href="#3-2-4-能者多劳配置" class="headerlink" title="3.2.4 能者多劳配置"></a>3.2.4 能者多劳配置</h4><p>修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><p>再次测试发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h4 id="3-2-5-Work模型总结"><a href="#3-2-5-Work模型总结" class="headerlink" title="3.2.5 Work模型总结"></a>3.2.5 Work模型总结</h4><ul><li><strong>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</strong></li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h3 id="3-3-交换机"><a href="#3-3-交换机" class="headerlink" title="3.3 交换机"></a>3.3 交换机</h3><p>交换机的类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li>Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li>Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li></ul><h4 id="3-3-1-Fanout交换机"><a href="#3-3-1-Fanout交换机" class="headerlink" title="3.3.1 Fanout交换机"></a>3.3.1 Fanout交换机</h4><p><strong>广播</strong>交换机，交换机把消息发送给绑定过的所有队列，每个队列的消费者都能收到消息</p><p><img src="/img/blogs/java/springcloud/mq.6.png"></p><ol><li>消息发送</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>消息接收</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h4 id="3-3-2-Direct交换机"><a href="#3-3-2-Direct交换机" class="headerlink" title="3.3.2 Direct交换机"></a>3.3.2 Direct交换机</h4><p>Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要<strong>指定一个RoutingKey（路由key）</strong></li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，<strong>只有队列的Routingkey与消息的 Routing key完全一致</strong>，才会接收到消息</li></ul><p><img src="/img/blogs/java/springcloud/mq.7.png"></p><h5 id="3-3-2-1-消息接收"><a href="#3-3-2-1-消息接收" class="headerlink" title="3.3.2.1 消息接收"></a>3.3.2.1 消息接收</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue2</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-2-2-消息发送"><a href="#3-3-2-2-消息发送" class="headerlink" title="3.3.2.2 消息发送"></a>3.3.2.2 消息发送</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendDirectExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.direct&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;最新报道，哥斯拉是居民自治巨型气球，虚惊一场！&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;blue&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时只有<code>blue</code>的消费者才会收到消息，也就是消费者1</p><h5 id="3-3-2-3-总结"><a href="#3-3-2-3-总结" class="headerlink" title="3.3.2.3 总结"></a>3.3.2.3 总结</h5><p>Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h4 id="3-3-3-Topic交换机"><a href="#3-3-3-Topic交换机" class="headerlink" title="3.3.3 Topic交换机"></a>3.3.3 Topic交换机</h4><p>Topic类型的Exchange与Direct相比，都是可以<strong>根据RoutingKey把消息路由到不同的队列</strong>。<br>只不过Topic类型Exchange<strong>可以</strong>让队列在绑定BindingKey 的时候<strong>使用通配符</strong>！</p><p>通配符规则：</p><ul><li>#：匹配一个或多个词</li><li>*：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li>item.#：能够匹配item.spu.insert 或者 item.spu</li><li>item.*：只能匹配item.spu</li></ul><p><img src="/img/blogs/java/springcloud/mq.8.png"></p><ol><li>消息发送</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * topicExchange</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendTopicExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.topic&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>消息接收</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Direct交换机与Topic交换机的差异</li></ol><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 . 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li>#：代表0个或多个词</li><li>*：代表1个词</li></ul><h3 id="3-4-声明队列和交换机"><a href="#3-4-声明队列和交换机" class="headerlink" title="3.4 声明队列和交换机"></a>3.4 声明队列和交换机</h3><p>Spring提供了基于注解方式来声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-消息转换器-JSON转换器"><a href="#3-5-消息转换器-JSON转换器" class="headerlink" title="3.5 消息转换器(JSON转换器)"></a>3.5 消息转换器(JSON转换器)</h3><p>默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="3-5-1-引入依赖"><a href="#3-5-1-引入依赖" class="headerlink" title="3.5.1 引入依赖"></a>3.5.1 引入依赖</h4><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-5-2-配置消息转换器"><a href="#3-5-2-配置消息转换器" class="headerlink" title="3.5.2 配置消息转换器"></a>3.5.2 配置消息转换器</h4><p>在publisher和consumer两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jackson2JsonMessageConverter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jackson2JsonMessageConverter.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jackson2JsonMessageConverter;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-3-接收消息"><a href="#3-5-3-接收消息" class="headerlink" title="3.5.3 接收消息"></a>3.5.3 接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;object.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(Map&lt;String, Object&gt; msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-MQ消息的可靠性"><a href="#4-MQ消息的可靠性" class="headerlink" title="4. MQ消息的可靠性"></a>4. MQ消息的可靠性</h2><p>在微服务架构中，消息队列（MQ）的可靠性指的是<strong>消息在生产、传输和消费的过程中不会丢失、不会重复、不被篡改，并且能够按预期被正确消费</strong>。确保 MQ 可靠性对于保证业务数据一致性、提高系统稳定性至关重要。</p><p>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li><strong>发送消息时丢失</strong>：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到Exchange</li><li>生产者发送消息到达MQ的Exchange后，未找到合适的Queue</li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li><strong>MQ导致消息丢失</strong>：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li><strong>消费者处理消息时</strong>：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><h3 id="4-1-发送者的可靠性"><a href="#4-1-发送者的可靠性" class="headerlink" title="4.1 发送者的可靠性"></a>4.1 发送者的可靠性</h3><h4 id="4-1-1-生产者重试机制"><a href="#4-1-1-生产者重试机制" class="headerlink" title="4.1.1 生产者重试机制"></a>4.1.1 生产者重试机制</h4><p>生产者发送消息时，出现了网络故障，导致与MQ的连接中断。<br>为了解决这个问题，SpringAMQP提供的消息发送时的<strong>重试机制。即：当RabbitTemplate与MQ连接超时后，多次重试</strong>。</p><p>修改publisher模块的application.yaml文件，添加下面的内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><p>注意：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的<strong>重试机制是阻塞式的重试</strong>，也就是说多次重试等待的过程中，当前线程是被阻塞的。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h4 id="4-1-2-生产者确认机制-一般情况下不建议开启"><a href="#4-1-2-生产者确认机制-一般情况下不建议开启" class="headerlink" title="4.1.2 生产者确认机制(一般情况下不建议开启)"></a>4.1.2 生产者确认机制(一般情况下不建议开启)</h4><p>RabbitMQ提供了生产者消息确认机制，包括Publisher Confirm和Publisher Return两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执。</p><p><img src="/img/blogs/java/springcloud/mq.9.png"></p><p>总结：</p><ul><li>当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><h5 id="4-1-2-1-开启生产者确认"><a href="#4-1-2-1-开启生产者确认" class="headerlink" title="4.1.2.1 开启生产者确认"></a>4.1.2.1 开启生产者确认</h5><p>在publisher模块的application.yaml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span> <span class="hljs-comment"># 开启publisher confirm机制，并设置confirm类型</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启publisher return机制</span><br></code></pre></td></tr></table></figure><p>这里publisher-confirm-type有三种模式可选：</p><ul><li>none：关闭confirm机制</li><li>simple：同步阻塞等待MQ的回执</li><li>correlated：MQ异步回调返回回执(推荐)</li></ul><h5 id="4-1-2-2-定义ReturnCallback"><a href="#4-1-2-2-定义ReturnCallback" class="headerlink" title="4.1.2.2 定义ReturnCallback"></a>4.1.2.2 定义ReturnCallback</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MqConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ReturnsCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;触发return callback,&quot;</span>);<br>                log.debug(<span class="hljs-string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());<br>                log.debug(<span class="hljs-string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());<br>                log.debug(<span class="hljs-string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());<br>                log.debug(<span class="hljs-string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());<br>                log.debug(<span class="hljs-string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-2-3-定义ConfirmCallback"><a href="#4-1-2-3-定义ConfirmCallback" class="headerlink" title="4.1.2.3 定义ConfirmCallback"></a>4.1.2.3 定义ConfirmCallback</h5><p>CorrelationData中包含两个核心的东西：</p><ul><li>id：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li>SettableListenableFuture：回执结果的Future对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherConfirm</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建CorrelationData</span><br>    <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    <span class="hljs-comment">// 2.给Future添加ConfirmCallback</span><br>    cd.getFuture().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>            <span class="hljs-comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span><br>            log.error(<span class="hljs-string">&quot;send message fail&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(CorrelationData.Confirm result)</span> &#123;<br>            <span class="hljs-comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span><br>            <span class="hljs-keyword">if</span>(result.isAck())&#123; <span class="hljs-comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span><br>                log.debug(<span class="hljs-string">&quot;发送消息成功，收到 ack!&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// result.getReason()，String类型，返回nack时的异常描述</span><br>                log.error(<span class="hljs-string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 3.发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hmall.direct&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, cd);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-MQ的可靠性"><a href="#4-2-MQ的可靠性" class="headerlink" title="4.2 MQ的可靠性"></a>4.2 MQ的可靠性</h3><p>消息到达MQ以后，因为<strong>MQ是基于内存存储的，如果内存空间被消息占满，如果MQ不能及时保存，也会导致消息丢失</strong><br>有两种解决方法：</p><ul><li>数据持久化</li><li>LazyQueue(推荐)</li></ul><h4 id="4-2-1-数据持久化"><a href="#4-2-1-数据持久化" class="headerlink" title="4.2.1 数据持久化"></a>4.2.1 数据持久化</h4><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li><strong>交换机持久化</strong></li><li><strong>队列持久化</strong></li><li><strong>消息持久化</strong></li></ul><p>在控制台配置相关的持久化模式，即可开启数据持久化</p><h4 id="4-2-2-LazyQueue惰性队列"><a href="#4-2-2-LazyQueue惰性队列" class="headerlink" title="4.2.2 LazyQueue惰性队列"></a>4.2.2 LazyQueue惰性队列</h4><p>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li><strong>接收到消息后直接存入磁盘而非内存</strong></li><li>消费者要<strong>消费消息时才会从磁盘中读取并加载到内存</strong>（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="4-3-消费者的可靠性"><a href="#4-3-消费者的可靠性" class="headerlink" title="4.3 消费者的可靠性"></a>4.3 消费者的可靠性</h3><p>消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了<strong>网络故障</strong></li><li><strong>消费者</strong>接收到消息后突然<strong>宕机</strong></li><li>消费者接收到消息后，<strong>因处理不当导致异常</strong></li></ul><h4 id="4-3-1-消费者确认机制"><a href="#4-3-1-消费者确认机制" class="headerlink" title="4.3.1 消费者确认机制"></a>4.3.1 消费者确认机制</h4><p>消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：<strong>成功处理消息</strong>，RabbitMQ<strong>从队列中删除该消息</strong></li><li>nack：<strong>消息处理失败</strong>，RabbitMQ需要<strong>再次投递消息</strong></li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p><img src="/img/blogs/java/springcloud/mq.10.png"></p><p>SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li>manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活</li><li>auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是业务异常，会自动返回nack；</li><li>如果是消息处理或校验异常，自动返回reject;</li></ul></li></ul><p>修改SpringAMQP的ACK处理方式:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">none</span> <span class="hljs-comment"># 不做处理</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-失败重试机制"><a href="#4-3-2-失败重试机制" class="headerlink" title="4.3.2 失败重试机制"></a>4.3.2 失败重试机制</h4><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。<br>极端情况就是消费者一直无法执行成功，那么<strong>消息requeue就会无限循环</strong>，导致mq的消息处理飙升，带来不必要的压力。</p><p>修改consumer服务的application.yml文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启消费者失败重试</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 初识的失败等待时长为1秒</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span><br></code></pre></td></tr></table></figure><ul><li><strong>重试达到最大次数后，Spring会返回reject，消息会被丢弃</strong></li></ul><h4 id="4-3-3-失败处理策略"><a href="#4-3-3-失败处理策略" class="headerlink" title="4.3.3 失败处理策略"></a>4.3.3 失败处理策略</h4><p>Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由MessageRecovery接口来定义的，它有3个不同实现：</p><ul><li>RejectAndDontRequeueRecoverer：<strong>重试耗尽后，直接reject，丢弃消息</strong>。默认就是这种方式 </li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队 </li><li>RepublishMessageRecoverer：<strong>重试耗尽后，将失败消息投递到指定的交换机</strong> (推荐)</li></ul><ul><li>RepublishMessageRecoverer: 失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</li></ul><p>在consumer服务中定义处理失败消息的交换机和队列,定义一个RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorMessageConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">errorMessageExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;error.direct&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">errorQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;error.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">errorBinding</span><span class="hljs-params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MessageRecoverer <span class="hljs-title function_">republishMessageRecoverer</span><span class="hljs-params">(RabbitTemplate rabbitTemplate)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="hljs-string">&quot;error.direct&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-业务幂等性"><a href="#4-4-业务幂等性" class="headerlink" title="4.4 业务幂等性"></a>4.4 业务幂等性</h3><p>在程序开发中，则是指<strong>同一个业务，执行一次或多次对业务状态的影响是一致的</strong>。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>数据的更新往往不是幂等的，如果<strong>重复执行可能造成不一样的后果</strong>。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，<strong>我们要尽可能避免业务被重复执行</strong>。</p><h4 id="4-4-1-唯一消息ID"><a href="#4-4-1-唯一消息ID" class="headerlink" title="4.4.1 唯一消息ID"></a>4.4.1 唯一消息ID</h4><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li><strong>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理</strong>。</li></ol><p>SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jjmc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jjmc.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jjmc;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-业务判断"><a href="#4-4-2-业务判断" class="headerlink" title="4.4.2 业务判断"></a>4.4.2 业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息。<br>当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以<strong>在执行业务时判断订单状态是否是未支付</strong>，如果不是则证明订单已经被处理过，无需重复处理。</p><p><img src="/img/blogs/java/springcloud/mq.11.png"></p><p>以支付修改订单的业务为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">markOrderPaySuccess</span><span class="hljs-params">(Long orderId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询订单</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> getById(orderId);<br>    <span class="hljs-comment">// 2.判断订单状态</span><br>    <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span> || old.getStatus() != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 订单不存在或者订单状态不是1，放弃处理</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3.尝试更新订单</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>    order.setId(orderId);<br>    order.setStatus(<span class="hljs-number">2</span>);<br>    order.setPayTime(LocalDateTime.now());<br>    updateById(order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-兜底方案"><a href="#4-5-兜底方案" class="headerlink" title="4.5 兜底方案"></a>4.5 兜底方案</h3><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>既然MQ通知不一定发送到交易服务，那么<strong>交易服务就必须自己主动去查询支付状态</strong>。这样即便支付服务的MQ通知失败，我们依然能<strong>通过主动查询来保证订单状态的一致</strong>。</p><p><img src="/img/blogs/java/springcloud/mq.12.png"></p><p>通常我们采取的措施就是利用<strong>定时任务定期查询</strong>，例如每隔20秒就查询一次，<strong>并判断支付状态</strong>。如果发现订单已经支付，则立刻更新订单状态为已支付即可。</p><h3 id="4-6-支付服务与交易服务之间的订单状态一致性是如何保证的？"><a href="#4-6-支付服务与交易服务之间的订单状态一致性是如何保证的？" class="headerlink" title="4.6 支付服务与交易服务之间的订单状态一致性是如何保证的？"></a>4.6 支付服务与交易服务之间的订单状态一致性是如何保证的？</h3><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h2 id="5-延迟消息"><a href="#5-延迟消息" class="headerlink" title="5. 延迟消息"></a>5. 延迟消息</h2><p>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存。像这种<strong>在一段时间以后才执行的任务，我们称之为延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件(推荐)</li></ul><h3 id="5-1-死信交换机"><a href="#5-1-死信交换机" class="headerlink" title="5.1 死信交换机"></a>5.1 死信交换机</h3><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p><img src="/img/blogs/java/springcloud/mq.13.png"></p><ul><li>利用 TTL 让消息在普通队列中延迟一段时间。</li><li>超时后，消息进入死信交换机，再转发到真正的目标队列。</li><li>消费者监听目标队列，延迟时间一到，才会收到消息。</li></ul><h3 id="5-2-DelayExchange插件-推荐"><a href="#5-2-DelayExchange插件-推荐" class="headerlink" title="5.2 DelayExchange插件(推荐)"></a>5.2 DelayExchange插件(推荐)</h3><p>RabbitMQ社区提供了一个延迟消息插件来实现相同的效果</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">插件下载地址</a></p><p><strong>声明延迟交换机</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span><br><span class="hljs-meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">        key = &quot;delay&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送延迟消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherDelayMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, delayed message&quot;</span>;<br>    <span class="hljs-comment">// 2.发送消息，利用消息后置处理器添加消息头</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessagePostProcessor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException &#123;<br>            <span class="hljs-comment">// 添加延迟消息属性</span><br>            message.getMessageProperties().setDelay(<span class="hljs-number">5000</span>);<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，不建议设置延迟时间过长的延迟消息。</li></ul><h3 id="5-3-超时订单问题"><a href="#5-3-超时订单问题" class="headerlink" title="5.3 超时订单问题"></a>5.3 超时订单问题</h3><p>用户下单完成后,发送15分钟延迟消息,在15分钟后接收消息,检查支付状态:</p><ul><li>已支付:更新订单状态为已支付</li><li>未支付:更新订单状态为关闭订单,恢复商品库存</li></ul><p><img src="/img/blogs/java/springcloud/mq.14.png"></p><h1 id="六-Elasticsearch"><a href="#六-Elasticsearch" class="headerlink" title="六. Elasticsearch"></a>六. Elasticsearch</h1><h2 id="1-Elasticsearch"><a href="#1-Elasticsearch" class="headerlink" title="1. Elasticsearch"></a>1. Elasticsearch</h2><p>Elasticsearch是由elastic公司开发的一套搜索引擎技术</p><h3 id="1-1-倒排索引"><a href="#1-1-倒排索引" class="headerlink" title="1.1 倒排索引"></a>1.1 倒排索引</h3><p>倒排索引的概念是基于MySQL这样的正向索引而言的</p><h4 id="1-1-1-正向索引"><a href="#1-1-1-正向索引" class="headerlink" title="1.1.1 正向索引"></a>1.1.1 正向索引</h4><ul><li>正向索引（Forward Index）通常指的是数据库索引按照字段的自然顺序进行存储和查找的索引方式。在 MySQL 中，常见的正向索引主要是B+ 树索引。</li><li>当搜索条件为<strong>模糊匹配时，由于索引无法生效</strong>，导致<strong>从索引查询退化为全表扫描</strong>，效率很差。</li></ul><h4 id="1-1-2-倒排索引"><a href="#1-1-2-倒排索引" class="headerlink" title="1.1.2 倒排索引"></a>1.1.2 倒排索引</h4><p>两个概念：</p><ul><li>文档（Document）：用来搜索的数据，其中的<strong>每一条数据就是一个文档</strong>。例如一个网页、一个商品信息</li><li>词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>:</p><p><img src="/img/blogs/java/springcloud/es.1.png"></p><p>倒排索引的<strong>搜索流程</strong>:</p><p><img src="/img/blogs/java/springcloud/es.2.png"></p><p>流程描述：</p><ol><li>用户输入条件”华为手机”进行搜索。</li><li>对用户输入条件分词，得到词条：华为、手机。</li><li>拿着词条在倒排索引中查找（由于词条有索引，查询效率很高），即可得到包含词条的文档id：1、2、3。</li><li>拿着文档id到正向索引中查找具体文档即可（由于id也有索引，查询效率也很高）。</li></ol><h4 id="1-1-3-正向和倒排"><a href="#1-1-3-正向和倒排" class="headerlink" title="1.1.3 正向和倒排"></a>1.1.3 正向和倒排</h4><ul><li>正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。 </li><li>而倒排索引则相反，是<strong>先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档</strong>。是根据词条找文档的过程。</li></ul><h3 id="1-2-IK分词器"><a href="#1-2-IK分词器" class="headerlink" title="1.2 IK分词器"></a>1.2 IK分词器</h3><p>地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p><p>IK分词器包含两种模式：</p><ul><li>ik_smart：智能语义切分 </li><li>ik_max_word：最细粒度切分</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员学习java太棒了&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;tokens&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;程序员&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;学习&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ENGLISH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;太棒了&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">14</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>拓展词典</strong>:</p><ol><li>打开IK分词器config目录</li><li>在IKAnalyzer.cfg.xml配置文件内容添加</li><li>在IK分词器的config目录新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</li><li>重启elasticsearch</li></ol><h3 id="1-3-ES基础概念"><a href="#1-3-ES基础概念" class="headerlink" title="1.3 ES基础概念"></a>1.3 ES基础概念</h3><p>elasticsearch是<strong>面向文档（Document）存储</strong>的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中</p><p><img src="/img/blogs/java/springcloud/es.3.png"></p><p>将类型相同的文档集中在一起管理，称为索引（Index）</p><p><img src="/img/blogs/java/springcloud/es.4.png"></p><p><strong>MySQL和ES的对比</strong>：</p><p><img src="/img/blogs/java/springcloud/es.5.png"></p><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性 </li><li>Elasticsearch：擅长海量数据的搜索、分析、计算<br>两者结合使用：</li><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h2 id="2-索引库操作"><a href="#2-索引库操作" class="headerlink" title="2. 索引库操作"></a>2. 索引库操作</h2><p>Index就类似数据库表，Mapping映射就类似表的结构。我们要向es中存储数据，必须先创建Index和Mapping</p><h3 id="2-1-Mapping映射属性"><a href="#2-1-Mapping映射属性" class="headerlink" title="2.1 Mapping映射属性"></a>2.1 Mapping映射属性</h3><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有： <ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h3 id="2-2-索引库的增删改查"><a href="#2-2-索引库的增删改查" class="headerlink" title="2.2 索引库的增删改查"></a>2.2 索引库的增删改查</h3><p>Elasticsearch采用的是Restful风格的API，而且请求参数也都采用JSON风格</p><table><thead><tr><th>接口类型</th><th>请求方式</th><th>请求路径</th><th>请求参数</th></tr></thead><tbody><tr><td>查询用户</td><td>GET</td><td>&#x2F;users&#x2F;{id}</td><td>路径中的 id</td></tr><tr><td>新增用户</td><td>POST</td><td>&#x2F;users</td><td>json 格式 user 对象</td></tr><tr><td>修改用户</td><td>PUT</td><td>&#x2F;users&#x2F;{id}</td><td>路径中的 id<br>json 格式对象</td></tr><tr><td>删除用户</td><td>DELETE</td><td>&#x2F;users&#x2F;{id}</td><td>路径中的 id</td></tr></tbody></table><h4 id="2-2-1-创建索引库"><a href="#2-2-1-创建索引库" class="headerlink" title="2.2.1 创建索引库"></a>2.2.1 创建索引库</h4><p>基本语法：</p><ul><li>请求方式：PUT</li><li>请求路径：&#x2F;索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;子字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// ...略</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"># PUT /heima<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-查询、删除索引库"><a href="#2-2-2-查询、删除索引库" class="headerlink" title="2.2.2 查询、删除索引库"></a>2.2.2 查询、删除索引库</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库名<br>DELETE /索引库名<br></code></pre></td></tr></table></figure><h4 id="2-2-3-修改索引库"><a href="#2-2-3-修改索引库" class="headerlink" title="2.2.3 修改索引库"></a>2.2.3 修改索引库</h4><p>索引库一旦创建，无法修改mapping。但是却允许添加新的字段到mapping中</p><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /heima/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a>3. 文档操作</h2><p>有了索引库，接下来就可以向索引库的文档中添加数据了。</p><h3 id="3-1-新增文档"><a href="#3-1-新增文档" class="headerlink" title="3.1 新增文档"></a>3.1 新增文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2 查询文档"></a>3.2 查询文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名称<span class="hljs-punctuation">&#125;</span>/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-3-删除文档"><a href="#3-3-删除文档" class="headerlink" title="3.3 删除文档"></a>3.3 删除文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/id值<br></code></pre></td></tr></table></figure><h3 id="3-4-修改文档"><a href="#3-4-修改文档" class="headerlink" title="3.4 修改文档"></a>3.4 修改文档</h3><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>局部修改：修改文档中的部分字段</li></ul><h4 id="3-4-1-全量修改"><a href="#3-4-1-全量修改" class="headerlink" title="3.4.1 全量修改"></a>3.4.1 全量修改</h4><p>全量修改是覆盖原来的文档，其本质是两步操作：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ... 略</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-2-局部修改"><a href="#3-4-2-局部修改" class="headerlink" title="3.4.2 局部修改"></a>3.4.2 局部修改</h4><p>局部修改是只修改指定id匹配的文档中的部分字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;新的值&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-批处理"><a href="#3-5-批处理" class="headerlink" title="3.5 批处理"></a>3.5 批处理</h3><p>批处理采用POST请求，基本语法如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">POST _bulk<br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;field1&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;delete&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;create&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;field1&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value3&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;update&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;doc&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;field2&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value2&quot;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>index代表新增操作<ul><li>_index：指定索引库名</li><li>_id指定要操作的文档id</li><li>{ “field1” : “value1” }：则是要新增的文档内容</li></ul></li><li>delete代表删除操作<ul><li>_index：指定索引库名</li><li>_id指定要操作的文档id</li></ul></li><li>update代表更新操作<ul><li>_index：指定索引库名</li><li>_id指定要操作的文档id</li><li>{ “doc” : {“field2” : “value2”} }：要更新的文档字段</li></ul></li></ul><h3 id="3-6-案例"><a href="#3-6-案例" class="headerlink" title="3.6 案例"></a>3.6 案例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs json"># 新增文档<br>POST /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员Java讲师&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br># 查询文档<br>GET /heima/_doc/<span class="hljs-number">1</span><br><br># 删除文档<br>DELETE /heima/_doc/<span class="hljs-number">1</span><br><br># 全量修改文档<br>PUT /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员高级Java讲师&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br># 局部修改文档<br>POST /heima/_update/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ZhaoYun@itcast.cn&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br># 批量新增文档<br>POST /_bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员C++讲师&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ww@itcast.cn&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;五&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;王&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员前端讲师&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zhangsan@itcast.cn&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;三&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;张&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><br># 批量删除文档<br>POST /_bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;delete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;delete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-JavaRestClient"><a href="#4-JavaRestClient" class="headerlink" title="4. JavaRestClient"></a>4. JavaRestClient</h2><h3 id="4-1-客户端初始化RestClient"><a href="#4-1-客户端初始化RestClient" class="headerlink" title="4.1 客户端初始化RestClient"></a>4.1 客户端初始化RestClient</h3><ol><li>在item-service模块中引入es的RestHighLevelClient依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>因为SpringBoot默认的ES版本是7.17.10，所以我们需要覆盖默认的ES版本：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>初始化RestHighLevelClient：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure><h3 id="4-2-创建索引库"><a href="#4-2-创建索引库" class="headerlink" title="4.2 创建索引库"></a>4.2 创建索引库</h3><p>要实现对商品搜索，所以我们需要将商品添加到Elasticsearch中，不过需要根据搜索业务的需求来设定索引库结构，而不是一股脑的把MySQL数据写入Elasticsearch.</p><h4 id="4-2-1-商品Mapping映射"><a href="#4-2-1-商品Mapping映射" class="headerlink" title="4.2.1 商品Mapping映射"></a>4.2.1 商品Mapping映射</h4><p>结合数据库表结构，字段对应的mapping映射属性如下：</p><p><img src="/img/blogs/java/springcloud/es.6.png"></p><p>索引库文档结构:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /items<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;stock&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;sold&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commentCount&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isAD&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;boolean&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;updateTime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;date&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4-2-2-在java中创建索引库"><a href="#4-2-2-在java中创建索引库" class="headerlink" title="4.2.2 在java中创建索引库"></a>4.2.2 在java中创建索引库</h4><ol><li>创建Request对象。<br>  因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>添加请求参数<br>  其实就是Json格式的Mapping映射参数。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>发送请求<br>  client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。例如创建索引、删除索引、判断索引是否存在等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">CreateIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.source(MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.indices().create(request, RequestOptions.DEFAULT);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MAPPING_TEMPLATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;stock\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;image\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;category\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;sold\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;commentCount\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;isAD\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;updateTime\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-在java中删除和查询索引库"><a href="#4-3-在java中删除和查询索引库" class="headerlink" title="4.3 在java中删除和查询索引库"></a>4.3 在java中删除和查询索引库</h3><h4 id="4-3-1-删除索引库"><a href="#4-3-1-删除索引库" class="headerlink" title="4.3.1 删除索引库"></a>4.3.1 删除索引库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">DeleteIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.indices().delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2-查询索引库"><a href="#4-3-2-查询索引库" class="headerlink" title="4.3.2 查询索引库"></a>4.3.2 查询索引库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testExistsIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">GetIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.输出</span><br>    System.err.println(exists ? <span class="hljs-string">&quot;索引库已经存在！&quot;</span> : <span class="hljs-string">&quot;索引库不存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-文档操作"><a href="#4-4-文档操作" class="headerlink" title="4.4 文档操作"></a>4.4 文档操作</h3><h4 id="4-4-1-新增文档"><a href="#4-4-1-新增文档" class="headerlink" title="4.4.1 新增文档"></a>4.4.1 新增文档</h4><ol><li>创建Request对象，这里是IndexRequest，因为添加文档就是创建倒排索引的过程</li><li>准备请求参数，本例中就是Json文档</li><li>发送请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.根据id查询商品数据</span><br>    <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemService.getById(<span class="hljs-number">100002644680L</span>);<br>    <span class="hljs-comment">// 2.转换为文档类型</span><br>    <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);<br>    <span class="hljs-comment">// 3.将ItemDTO转json</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(itemDoc);<br><br>    <span class="hljs-comment">// 1.准备Request对象</span><br>    <span class="hljs-type">IndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(itemDoc.getId());<br>    <span class="hljs-comment">// 2.准备Json文档</span><br>    request.source(doc, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.index(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-查询文档"><a href="#4-4-2-查询文档" class="headerlink" title="4.4.2 查询文档"></a>4.4.2 查询文档</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request对象</span><br>    <span class="hljs-type">GetRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;100002644680&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    <span class="hljs-type">GetResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.get(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.获取响应结果中的source</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> response.getSourceAsString();<br>    <br>    <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, ItemDoc.class);<br>    System.out.println(<span class="hljs-string">&quot;itemDoc= &quot;</span> + ItemDoc);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-删除文档"><a href="#4-4-3-删除文档" class="headerlink" title="4.4.3 删除文档"></a>4.4.3 删除文档</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request，两个参数，第一个是索引库名，第二个是文档id</span><br>    <span class="hljs-type">DeleteRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteRequest</span>(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;100002644680&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-4-修改文档"><a href="#4-4-4-修改文档" class="headerlink" title="4.4.4 修改文档"></a>4.4.4 修改文档</h4><ul><li>全量修改：本质是先根据id删除，再新增</li><li>局部修改：修改文档中的指定字段值</li></ul><p>我们主要关注局部修改的API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">UpdateRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateRequest</span>(<span class="hljs-string">&quot;items&quot;</span>, <span class="hljs-string">&quot;100002644680&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.doc(<br>            <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">58800</span>,<br>            <span class="hljs-string">&quot;commentCount&quot;</span>, <span class="hljs-number">1</span><br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.update(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-5-批量导入文档"><a href="#4-4-5-批量导入文档" class="headerlink" title="4.4.5 批量导入文档"></a>4.4.5 批量导入文档</h4><p>Bulk中添加了多个IndexRequest，就是批量新增功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBulk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;1&quot;</span>).source(<span class="hljs-string">&quot;json doc1&quot;</span>, XContentType.JSON));<br>    request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;2&quot;</span>).source(<span class="hljs-string">&quot;json doc2&quot;</span>, XContentType.JSON));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.bulk(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><p>采用循环遍历方式，每次导入1000条左右的数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoadItemDocs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 分页查询商品数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        Page&lt;Item&gt; page = itemService.lambdaQuery().eq(Item::getStatus, <span class="hljs-number">1</span>).page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;Item&gt;(pageNo, size));<br>        <span class="hljs-comment">// 非空校验</span><br>        List&lt;Item&gt; items = page.getRecords();<br>        <span class="hljs-keyword">if</span> (CollUtils.isEmpty(items)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;加载第&#123;&#125;页数据，共&#123;&#125;条&quot;</span>, pageNo, items.size());<br>        <span class="hljs-comment">// 1.创建Request</span><br>        <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>        <span class="hljs-comment">// 2.准备参数，添加多个新增的Request</span><br>        <span class="hljs-keyword">for</span> (Item item : items) &#123;<br>            <span class="hljs-comment">// 2.1.转换为文档类型ItemDTO</span><br>            <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);<br>            <span class="hljs-comment">// 2.2.创建新增文档的Request对象</span><br>            request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>()<br>                            .id(itemDoc.getId())<br>                            .source(JSONUtil.toJsonStr(itemDoc), XContentType.JSON));<br>        &#125;<br>        <span class="hljs-comment">// 3.发送请求</span><br>        client.bulk(request, RequestOptions.DEFAULT);<br><br>        <span class="hljs-comment">// 翻页</span><br>        pageNo++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-DSL查询"><a href="#5-DSL查询" class="headerlink" title="5. DSL查询"></a>5. DSL查询</h2><p>Elasticsearch的查询可以分为两大类：</p><ul><li>叶子查询（Leaf query clauses）：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li>复合查询（Compound query clauses）：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><h3 id="5-1-叶子查询"><a href="#5-1-叶子查询" class="headerlink" title="5.1 叶子查询"></a>5.1 叶子查询</h3><p>叶子查询的类型：</p><ul><li>全文检索查询（Full Text Queries）：利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li>match：</li><li>multi_match</li></ul></li><li>精确查询（Term-level queries）：不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：<ul><li>ids</li><li>term</li><li>range</li></ul></li><li>地理坐标查询：用于搜索地理位置，搜索方式很多，例如：<ul><li>geo_bounding_box：按矩形搜索</li><li>geo_distance：按点和半径搜索</li></ul></li></ul><h4 id="5-1-1-全文检索查询"><a href="#5-1-1-全文检索查询" class="headerlink" title="5.1.1 全文检索查询"></a>5.1.1 全文检索查询</h4><p>match语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索条件&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>multi_match语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;multi_match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索条件&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;字段1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;字段2&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;multi_match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;华为&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5-1-2-精确查询"><a href="#5-1-2-精确查询" class="headerlink" title="5.1.2 精确查询"></a>5.1.2 精确查询</h4><p>词条级别的查询；作为一个词条，与搜索的字段内容精确值匹配。因此推荐查找keyword、数值、日期、boolean类型的字段。</p><p>term查询:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索条件&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>range查询:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>最小值<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>最大值<span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-复合查询"><a href="#5-2-复合查询" class="headerlink" title="5.2 复合查询"></a>5.2 复合查询</h3><ul><li>第一类：基于逻辑运算组合叶子查询，实现组合条件，例如<ul><li>bool</li></ul></li><li>第二类：基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：<ul><li>function_score</li><li>dis_max</li></ul></li></ul><h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><p>bool查询，即布尔查询。就是利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，不参与算分，类似“非”</li><li>filter：必须匹配，不参与算分</li></ul><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;should&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vivo&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小米&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;must_not&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2500</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>搜索手机，但品牌必须是华为，价格必须是900~1599：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;华为&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;lt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">159900</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-排序"><a href="#5-3-排序" class="headerlink" title="5.3 排序"></a>5.3 排序</h3><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，<strong>能参与排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型</strong>等。</p><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;排序字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;排序方式asc和desc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>按照商品价格排序:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-4-分页"><a href="#5-4-分页" class="headerlink" title="5.4 分页"></a>5.4 分页</h3><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了</p><h4 id="5-4-1-基础分页"><a href="#5-4-1-基础分页" class="headerlink" title="5.4.1 基础分页"></a>5.4.1 基础分页</h4><p>elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 每页文档数量，默认10</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5-4-2-深度分页"><a href="#5-4-2-深度分页" class="headerlink" title="5.4.2 深度分页"></a>5.4.2 深度分页</h4><p>elasticsearch的数据一般会采用分片存储，也就是把一个索引中的数据分成N份，存储到不同节点上。这种存储方式比较有利于数据扩展，但给分页带来了一些麻烦。<br>试想一下，假如我们现在要查询的是第999页数据呢，是不是要找第9990~10000的数据，那岂不是需要把每个分片中的前10000名数据都查询出来，汇总在一起，在内存中排序？如果查询的分页深度更深呢，需要一次检索的数据岂不是更多？</p><p><img src="/img/blogs/java/springcloud/es.7.png"></p><p>针对深度分页，elasticsearch提供了解决方案：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li></ul><h3 id="5-5-高亮"><a href="#5-5-高亮" class="headerlink" title="5.5 高亮"></a>5.5 高亮</h3><p>词条的高亮标签肯定是由服务端提供数据的时候已经加上的。</p><p>实现高亮的思路就是：</p><ul><li>用户输入搜索关键字搜索数据</li><li>服务端根据搜索关键字到elasticsearch搜索，并给搜索结果中的关键字词条添加html标签</li><li>前端提前给约定好的html标签添加CSS样式</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;搜索字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索关键字&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;highlight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;高亮字段名称&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;pre_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;em&gt;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;post_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-JavaRestClient查询"><a href="#6-JavaRestClient查询" class="headerlink" title="6. JavaRestClient查询"></a>6. JavaRestClient查询</h2><h3 id="6-1-文档搜索的基本步骤"><a href="#6-1-文档搜索的基本步骤" class="headerlink" title="6.1 文档搜索的基本步骤"></a>6.1 文档搜索的基本步骤</h3><ol><li>创建SearchRequest对象</li><li>准备request.source()，也就是DSL。</li><li>QueryBuilders来构建查询条件</li><li>传入request.source() 的 query() 方法</li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatchAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 2.遍历结果数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 3.得到_source，也就是原始json文档</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 4.反序列化并打印</span><br>        <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> JSONUtil.toBean(source, ItemDoc.class);<br>        System.out.println(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-叶子查询"><a href="#6-2-叶子查询" class="headerlink" title="6.2 叶子查询"></a>6.2 叶子查询</h3><p>match查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>multi_match查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMultiMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;脱脂牛奶&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;category&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>range查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(<span class="hljs-number">10000</span>).lte(<span class="hljs-number">30000</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>term查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testTerm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.termQuery(<span class="hljs-string">&quot;brand&quot;</span>, <span class="hljs-string">&quot;华为&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-复合查询"><a href="#6-3-复合查询" class="headerlink" title="6.3 复合查询"></a>6.3 复合查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    <span class="hljs-comment">// 2.1.准备bool查询</span><br>    <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">bool</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>    <span class="hljs-comment">// 2.2.关键字搜索</span><br>    bool.must(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 2.3.品牌过滤</span><br>    bool.filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;brand&quot;</span>, <span class="hljs-string">&quot;德亚&quot;</span>));<br>    <span class="hljs-comment">// 2.4.价格过滤</span><br>    bool.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">30000</span>));<br>    request.source().query(bool);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-排序和分页"><a href="#6-4-排序和分页" class="headerlink" title="6.4 排序和分页"></a>6.4 排序和分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageAndSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, pageSize = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    <span class="hljs-comment">// 2.1.搜索条件参数</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 2.2.排序参数</span><br>    request.source().sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>    <span class="hljs-comment">// 2.3.分页参数</span><br>    request.source().from((pageNo - <span class="hljs-number">1</span>) * pageSize).size(pageSize);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5-高亮"><a href="#6-5-高亮" class="headerlink" title="6.5 高亮"></a>6.5 高亮</h3><ul><li>条件同样是在request.source()中指定，只不过高亮条件要基于HighlightBuilder来构造</li><li>高亮响应结果与搜索的文档结果不在一起，需要单独解析</li></ul><p>查询:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    <span class="hljs-comment">// 2.1.query条件</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 2.2.高亮条件</span><br>    request.source().highlighter(<br>            SearchSourceBuilder.highlight()<br>                    .field(<span class="hljs-string">&quot;name&quot;</span>)<br>                    .preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>)<br>                    .postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>)<br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 2.遍历结果数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 3.得到_source，也就是原始json文档</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 4.反序列化</span><br>        <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> JSONUtil.toBean(source, ItemDoc.class);<br>        <span class="hljs-comment">// 5.获取高亮结果</span><br>        Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;<br>            <span class="hljs-comment">// 5.1.有高亮结果，获取name的高亮结果</span><br>            <span class="hljs-type">HighlightField</span> <span class="hljs-variable">hf</span> <span class="hljs-operator">=</span> hfs.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (hf != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 5.2.获取第一个高亮结果片段，就是商品名称的高亮值</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">hfName</span> <span class="hljs-operator">=</span> hf.getFragments()[<span class="hljs-number">0</span>].string();<br>                item.setName(hfName);<br>            &#125;<br>        &#125;<br>        System.out.println(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-数据聚合"><a href="#7-数据聚合" class="headerlink" title="7. 数据聚合"></a>7. 数据聚合</h2><h3 id="7-1-聚合的概念"><a href="#7-1-聚合的概念" class="headerlink" title="7.1 聚合的概念"></a>7.1 聚合的概念</h3><p>聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算</p><p>聚合常见的有三类：</p><ul><li>桶（Bucket）聚合：用来对文档做分组 </li><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li><li>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 </li><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li><li>管道（pipeline）聚合：其它聚合的结果为基础做进一步运算</li></ul><p><strong>注意</strong>：参加聚合的<strong>字段必须是keyword、日期、数值、布尔类型</strong></p><h3 id="7-2-DSL实现聚合"><a href="#7-2-DSL实现聚合" class="headerlink" title="7.2 DSL实现聚合"></a>7.2 DSL实现聚合</h3><h4 id="7-2-1-Bucket聚合"><a href="#7-2-1-Bucket聚合" class="headerlink" title="7.2.1 Bucket聚合"></a>7.2.1 Bucket聚合</h4><p>我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;category_agg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;category&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>size：设置size为0，就是每页查0条，则结果中就不包含文档，只包含聚合</li><li>aggs：定义聚合<ul><li>category_agg：聚合名称，自定义，但不能重复<ul><li>terms：聚合的类型，按分类聚合，所以用term<ul><li>field：参与聚合的字段名称</li><li>size：希望返回的聚合结果的最大数量</li></ul></li></ul></li></ul></li></ul><h4 id="7-2-2-带条件聚合"><a href="#7-2-2-带条件聚合" class="headerlink" title="7.2.2 带条件聚合"></a>7.2.2 带条件聚合</h4><p>价格高于3000元的手机品牌有哪些</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">300000</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brand_agg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="7-2-3-Metric聚合"><a href="#7-2-3-Metric聚合" class="headerlink" title="7.2.3 Metric聚合"></a>7.2.3 Metric聚合</h4><p>我们需要对桶内的商品做运算，获取每个品牌价格的最小值、最大值、平均值。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">300000</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brand_agg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stats_meric&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;stats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;price&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>stats_meric：聚合名称<ul><li>stats：聚合类型，stats是metric聚合的一种<ul><li>field：聚合字段，这里选择price，统计价格</li></ul></li></ul></li></ul><h3 id="7-3-JavaRestClient实现聚合"><a href="#7-3-JavaRestClient实现聚合" class="headerlink" title="7.3 JavaRestClient实现聚合"></a>7.3 JavaRestClient实现聚合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAgg</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">bool</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery()<br>            .filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-string">&quot;手机&quot;</span>))<br>            .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(<span class="hljs-number">300000</span>));<br>    request.source().query(bool).size(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 3.聚合参数</span><br>    request.source().aggregation(<br>            AggregationBuilders.terms(<span class="hljs-string">&quot;brand_agg&quot;</span>).field(<span class="hljs-string">&quot;brand&quot;</span>).size(<span class="hljs-number">5</span>)<br>    );<br>    <span class="hljs-comment">// 4.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br><br><br><br>    <span class="hljs-comment">// 5.解析聚合结果</span><br>    <span class="hljs-type">Aggregations</span> <span class="hljs-variable">aggregations</span> <span class="hljs-operator">=</span> response.getAggregations();<br>    <span class="hljs-comment">// 5.1.获取品牌聚合</span><br>    <span class="hljs-type">Terms</span> <span class="hljs-variable">brandTerms</span> <span class="hljs-operator">=</span> aggregations.get(<span class="hljs-string">&quot;brand_agg&quot;</span>);<br>    <span class="hljs-comment">// 5.2.获取聚合中的桶</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();<br>    <span class="hljs-comment">// 5.3.遍历桶内数据</span><br>    <span class="hljs-keyword">for</span> (Terms.Bucket bucket : buckets) &#123;<br>        <span class="hljs-comment">// 5.4.获取桶内key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> bucket.getKeyAsString();<br>        System.out.print(<span class="hljs-string">&quot;brand = &quot;</span> + brand);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> bucket.getDocCount();<br>        System.out.println(<span class="hljs-string">&quot;; count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七-微服务面试篇"><a href="#七-微服务面试篇" class="headerlink" title="七. 微服务面试篇"></a>七. 微服务面试篇</h1><h2 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h2><h3 id="1-1-CAP定理"><a href="#1-1-CAP定理" class="headerlink" title="1.1 CAP定理"></a>1.1 CAP定理</h3><p>加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p><ul><li>Consistency（一致性）</li><li>Availability（可用性）</li><li>Partition tolerance （分区容错性）<br>它们的第一个字母分别是 C、A、P。Eric Brewer认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做 CAP 定理。</li></ul><h4 id="1-1-1-一致性"><a href="#1-1-1-一致性" class="headerlink" title="1.1.1.一致性"></a>1.1.1.一致性</h4><p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。</p><p><img src="/img/blogs/java/springcloud/7.1.1.png"></p><h4 id="1-1-2-可用性"><a href="#1-1-2-可用性" class="headerlink" title="1.1.2.可用性"></a>1.1.2.可用性</h4><p>Availability （可用性）：用户访问分布式系统时，读或写操作总能成功。<br>只能读不能写，或者只能写不能读，或者两者都不能执行，就说明系统弱可用或不可用。</p><p><img src="/img/blogs/java/springcloud/7.1.2.png"></p><h4 id="1-1-3-分区容错性"><a href="#1-1-3-分区容错性" class="headerlink" title="1.1.3 分区容错性"></a>1.1.3 分区容错性</h4><ul><li>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</li><li>Tolerance（容错）：系统要能容忍网络分区现象，出现分区时，整个系统也要持续对外提供服务<ul><li>如果此时只允许读，不允许写，满足所有节点一致性。但是牺牲了可用性。符合CP</li><li>如果此时允许任意读写，满足了可用性。但由于node3无法同步，导致数据不一致，牺牲了一致性。符合AP</li></ul></li></ul><p><img src="/img/blogs/java/springcloud/7.1.3.png"></p><h3 id="1-2-BASE理论"><a href="#1-2-BASE理论" class="headerlink" title="1.2 BASE理论"></a>1.2 BASE理论</h3><p>BASE理论是对CAP的一种解决思路，包含三个思想：</p><ul><li>Basically Available （<strong>基本可用</strong>）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>Soft State（<strong>软状态</strong>）：在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li>Eventually Consistent（<strong>最终一致性</strong>）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><p>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论：</p><ul><li><strong>CP模式</strong>：各个子事务执行后互相等待，同时提交，同时回滚，达成<strong>强一致</strong>。但事务等待过程中，处于弱可用状态。例如XA模式</li><li><strong>AP模式</strong>：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。例如AT模式就是如此</li></ul><h3 id="1-3-AT模式的脏写问题"><a href="#1-3-AT模式的脏写问题" class="headerlink" title="1.3 AT模式的脏写问题"></a>1.3 AT模式的脏写问题</h3><p>AT模式也分为两个阶段：第一阶段是记录数据快照，执行并提交事务：</p><p><img src="/img/blogs/java/springcloud/7.1.4.png"></p><p>第二阶段根据阶段一的结果来判断：</p><ul><li>如果每一个分支事务都成功，则事务已经结束（因为阶段一已经提交），因此删除阶段一的快照即可</li><li>如果有任意分支事务失败，则需要根据快照恢复到更新前数据。然后删除快照</li></ul><p><img src="/img/blogs/java/springcloud/7.1.5.png"></p><p>这种模式在大多数情况下（99%）并不会有什么问题，不过在极端情况下，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，如图：</p><p><img src="/img/blogs/java/springcloud/7.1.6.png"></p><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><p><img src="/img/blogs/java/springcloud/7.1.7.png"></p><h3 id="1-4-TCC模式"><a href="#1-4-TCC模式" class="headerlink" title="1.4 TCC模式"></a>1.4 TCC模式</h3><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li>try：资源的检测和预留； </li><li>confirm：完成资源操作业务；要求 try 成功 confirm 一定要能成功。 </li><li>cancel：预留资源释放，可以理解为try的反向操作。</li></ul><p>举例:</p><p><img src="/img/blogs/java/springcloud/7.1.8.png"></p><p>TCC工作模型图：</p><p><img src="/img/blogs/java/springcloud/7.1.9.png"></p><ul><li>假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞</li><li>如果阻塞时间太长，可能导致全局事务超时而触发二阶段的cancel操作。两个分支事务都会执行cancel操作</li><li>要知道，其中一个分支是未执行try操作的，直接执行了cancel操作，反而会导致数据错误。因此，这种情况下，尽管cancel方法要执行，但其中不能做任何回滚操作，这就是空回滚</li><li>对于整个空回滚的分支事务，将来try方法阻塞结束依然会执行。但是整个全局事务其实已经结束了，因此永远不会再有confirm或cancel，也就是说这个事务执行了一半，处于悬挂状态，这就是业务悬挂问题</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TCC模式的每个阶段是做什么的？</p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p>TCC的优点是什么？</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>TCC的缺点是什么？</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理、事务悬挂和空回滚处理</li></ul><h3 id="1-5-最大努力通知"><a href="#1-5-最大努力通知" class="headerlink" title="1.5 最大努力通知"></a>1.5 最大努力通知</h3><p>最大努力通知是一种最终一致性的分布式事务解决方案。顾明思议，就是通过消息通知的方式来通知事务参与者完成业务执行，如果执行失败会多次通知。无需任何分布式事务组件介入。</p><p><img src="/img/blogs/java/springcloud/7.1.10.png"></p><h2 id="2-注册中心"><a href="#2-注册中心" class="headerlink" title="2. 注册中心"></a>2. 注册中心</h2><h3 id="2-1-环境隔离"><a href="#2-1-环境隔离" class="headerlink" title="2.1 环境隔离"></a>2.1 环境隔离</h3><p>企业实际开发中，往往会搭建多个运行环境，例如：开发环境、测试环境、发布环境。不同环境之间需要隔离。或者不同项目使用了一套Nacos，不同项目之间要做环境隔离。</p><p><img src="/img/blogs/java/springcloud/7.2.1.png"></p><ul><li>Nacos中可以配置多个namespace，相互之间完全隔离。默认的namespace名为public</li><li>namespace下还可以继续分组，也就是group ，相互隔离。 默认的group是DEFAULT_GROUP</li><li>group之下就是服务和配置了</li></ul><h3 id="2-2-分级模型"><a href="#2-2-分级模型" class="headerlink" title="2.2 分级模型"></a>2.2 分级模型</h3><p>在一些大型应用中，同一个服务可以部署很多实例。而这些实例可能分布在全国各地的不同机房。由于存在地域差异，网络传输的速度会有很大不同，因此在做服务治理时需要区分不同机房的实例。</p><p>Nacos中提供了集群（cluster）的概念，来对应不同机房。也就是说，一个服务（service）下可以有很多集群（cluster），而一个集群（cluster）中下又可以包含很多实例（instance）。</p><p><img src="/img/blogs/java/springcloud/7.2.2.png"></p><p>任何一个微服务的实例在注册到Nacos时，都会生成以下几个信息，用来确认当前实例的身份，从外到内依次是：</p><ul><li><p>namespace：命名空间</p></li><li><p>group：分组</p></li><li><p>service：服务名</p></li><li><p>cluster：集群</p></li><li><p>instance：实例，包含ip和端口<br>这就是nacos中的服务分级模型。</p></li><li><p>在Nacos内部会有一个服务实例的注册表，是基于Map实现的，其结构与分级模型的对应关系如下：</p></li></ul><p><img src="/img/blogs/java/springcloud/7.2.3.png"></p><h2 id="3-远程调用"><a href="#3-远程调用" class="headerlink" title="3. 远程调用"></a>3. 远程调用</h2><h3 id="3-1-负载均衡原理"><a href="#3-1-负载均衡原理" class="headerlink" title="3.1 负载均衡原理"></a>3.1 负载均衡原理</h3><p>OpenFeign在整合SpringCloudLoadBalancer时，与我们手动服务发现、复杂均衡的流程类似。</p><ol><li>获取serviceId，也就是服务名称</li><li>根据serviceId拉取服务列表</li><li>利用负载均衡算法选择一个服务</li><li>重构请求的URL路径，发起远程调用</li></ol><p><strong>负载均衡原理</strong>：</p><p><img src="/img/blogs/java/springcloud/7.3.1.png"></p><h4 id="切换负载均衡策略"><a href="#切换负载均衡策略" class="headerlink" title="切换负载均衡策略"></a>切换负载均衡策略</h4><h2 id="4-服务保护"><a href="#4-服务保护" class="headerlink" title="4. 服务保护"></a>4. 服务保护</h2><h3 id="4-1-线程隔离"><a href="#4-1-线程隔离" class="headerlink" title="4.1 线程隔离"></a>4.1 线程隔离</h3><p>线程隔离有两种方式实现：</p><ul><li>线程池隔离(Hystix默认采用)：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</li><li>信号量隔离(Sentinel默认使用)：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求</li></ul><p><img src="/img/blogs/java/springcloud/7.4.1.png"></p><p><strong>Sentinel的线程隔离与Hystix的线程隔离有什么差别?</strong></p><ul><li>问题说明：考察对线程隔离方案的掌握情况</li><li>难易程度：一般</li><li>参考话术：<ul><li>答：线程隔离可以采用线程池隔离或者信号量隔离。<ul><li>Hystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。</li><li>Sentinel则是基于信号量隔离的原理，这种方式不用创建线程池，性能较好，但是隔离性一般。</li></ul></li></ul></li></ul><h3 id="4-2-滑动窗口算法"><a href="#4-2-滑动窗口算法" class="headerlink" title="4.2 滑动窗口算法"></a>4.2 滑动窗口算法</h3><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。sentinel中采用的计数器算法就是滑动窗口计数算法。</p><h4 id="4-2-1-固定窗口计数"><a href="#4-2-1-固定窗口计数" class="headerlink" title="4.2.1 固定窗口计数"></a>4.2.1 固定窗口计数</h4><p>固定窗口计数器算法概念如下：</p><ul><li>将时间划分为多个窗口，窗口时间跨度称为Interval，本例中为1000ms；</li><li>每个窗口分别计数统计，每有一次请求就将计数器加一，限流就是设置计数器阈值，本例为3</li><li>如果计数器超过了限流阈值，则超出阈值的请求都被丢弃。</li></ul><p><img src="/img/blogs/java/springcloud/7.4.2.png"></p><h4 id="4-2-2-滑动窗口算法"><a href="#4-2-2-滑动窗口算法" class="headerlink" title="4.2.2 滑动窗口算法"></a>4.2.2 滑动窗口算法</h4><p>固定时间窗口算法中窗口有很多，其跨度和位置是与时间区间绑定，因此是很多固定不动的窗口。而滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动动的，与时间区间无关。</p><p>滑动窗口计数器算法会将一个窗口划分为n个更小的区间，例如</p><ul><li>窗口时间跨度Interval为1秒；区间数量 n &#x3D; 2 ，则每个小区间时间跨度为500ms，每个区间都有计数器</li><li>限流阈值依然为3，时间窗口（1秒）内请求超过阈值时，超出的请求被限流</li><li>窗口会根据当前请求所在时间（currentTime）移动，窗口范围是从（currentTime-Interval）之后的第一个时区开始，到currentTime所在时区结束。</li></ul><p><img src="/img/blogs/java/springcloud/7.4.3.png"></p><h3 id="4-3-漏桶算法"><a href="#4-3-漏桶算法" class="headerlink" title="4.3 漏桶算法"></a>4.3 漏桶算法</h3><p>漏桶算法说明：</p><ul><li>将每个请求视作”水滴”放入”漏桶”进行存储；</li><li>“漏桶”以固定速率向外”漏”出请求来执行，如果”漏桶”空了则停止”漏水”；</li><li>如果”漏桶”满了则多余的”水滴”会被直接丢弃。</li><li>可以理解成请求在桶内排队等待</li></ul><p><img src="/img/blogs/java/springcloud/7.4.4.png"></p><p>Sentinel内部基于漏桶算法实现了排队等待效果，桶的容量取决限流的QPS阈值以及允许等待的最大超时时间：<br>例如：限流QPS&#x3D;5，队列超时时间为2000ms。我们让所有请求进入一个队列中，如同进入漏桶中。由于漏桶是固定频率执行，因此QPS为5就是每200ms执行一个请求。那第N个请求的预期的执行时间 是第(N - 1) * 200ms。如果请求预期的执行时间超出最大时长2000ms，说明“桶满了”，新的请求则会被拒绝。</p><h3 id="4-4-令牌桶算法"><a href="#4-4-令牌桶算法" class="headerlink" title="4.4 令牌桶算法"></a>4.4 令牌桶算法</h3><p>限流的另一种常见算法是令牌桶算法。Sentinel中的热点参数限流正是基于令牌桶算法实现的。</p><p>令牌桶算法说明：</p><ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，停止生成</li><li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理</li><li>如果令牌桶中没有令牌，则请求等待或丢弃</li></ul><p><img src="/img/blogs/java/springcloud/7.4.5.png"></p><p>基于令牌桶算法，每秒产生的令牌数量基本就是QPS上限。<br>当然也有例外情况，例如：</p><ul><li>某一秒令牌桶中产生了很多令牌，达到令牌桶上限N，缓存在令牌桶中，但是这一秒没有请求进入。</li><li>下一秒的前半秒涌入了超过2N个请求，之前缓存的令牌桶的令牌耗尽，同时这一秒又生成了N个令牌，于是总共放行了2N个请求。超出了我们设定的QPS阈值。<br>因此，在使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样我们才能应对突发流量。</li></ul><h3 id="4-5-Sentinel的限流与Gateway的限流有什么差别？"><a href="#4-5-Sentinel的限流与Gateway的限流有什么差别？" class="headerlink" title="4.5 Sentinel的限流与Gateway的限流有什么差别？"></a>4.5 Sentinel的限流与Gateway的限流有什么差别？</h3><p>问题说明：考察对限流算法的掌握情况<br>难易程度：难<br>参考话术：</p><ul><li>限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。Gateway则采用了基于Redis实现的令牌桶算法</li><li>而Sentinel内部却比较复杂：<ul><li>默认限流模式是基于滑动时间窗口算法，另外Sentinel中断路器的计数也是基于滑动时间窗口算法</li><li>限流后可以快速失败和排队等待，其中排队等待基于漏桶算法</li><li>而热点参数限流则是基于令牌桶算法</li></ul></li></ul><p>引用：<a href="https://b11et3un53m.feishu.cn/wiki/FYNkwb1i6i0qwCk7lF2caEq5nRe">https://b11et3un53m.feishu.cn/wiki/FYNkwb1i6i0qwCk7lF2caEq5nRe</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch学习笔记</title>
    <link href="/2025/03/08/JAVA/SpringCloud/Elasticsearch/"/>
    <url>/2025/03/08/JAVA/SpringCloud/Elasticsearch/</url>
    
    <content type="html"><![CDATA[<h1 align="center">Elasticsearch学习笔记</h1><h2 id="1-Elasticsearch"><a href="#1-Elasticsearch" class="headerlink" title="1. Elasticsearch"></a>1. Elasticsearch</h2><p>Elasticsearch是由elastic公司开发的一套搜索引擎技术</p><h3 id="1-1-倒排索引"><a href="#1-1-倒排索引" class="headerlink" title="1.1 倒排索引"></a>1.1 倒排索引</h3><p>倒排索引的概念是基于MySQL这样的正向索引而言的</p><h4 id="1-1-1-正向索引"><a href="#1-1-1-正向索引" class="headerlink" title="1.1.1 正向索引"></a>1.1.1 正向索引</h4><ul><li>正向索引（Forward Index）通常指的是数据库索引按照字段的自然顺序进行存储和查找的索引方式。在 MySQL 中，常见的正向索引主要是B+ 树索引。</li><li>当搜索条件为<strong>模糊匹配时，由于索引无法生效</strong>，导致<strong>从索引查询退化为全表扫描</strong>，效率很差。</li></ul><h4 id="1-1-2-倒排索引"><a href="#1-1-2-倒排索引" class="headerlink" title="1.1.2 倒排索引"></a>1.1.2 倒排索引</h4><p>两个概念：</p><ul><li>文档（Document）：用来搜索的数据，其中的<strong>每一条数据就是一个文档</strong>。例如一个网页、一个商品信息</li><li>词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>:</p><p><img src="/img/blogs/java/springcloud/es.1.png"></p><p>倒排索引的<strong>搜索流程</strong>:</p><p><img src="/img/blogs/java/springcloud/es.2.png"></p><p>流程描述：</p><ol><li>用户输入条件”华为手机”进行搜索。</li><li>对用户输入条件分词，得到词条：华为、手机。</li><li>拿着词条在倒排索引中查找（由于词条有索引，查询效率很高），即可得到包含词条的文档id：1、2、3。</li><li>拿着文档id到正向索引中查找具体文档即可（由于id也有索引，查询效率也很高）。</li></ol><h4 id="1-1-3-正向和倒排"><a href="#1-1-3-正向和倒排" class="headerlink" title="1.1.3 正向和倒排"></a>1.1.3 正向和倒排</h4><ul><li>正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。 </li><li>而倒排索引则相反，是<strong>先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档</strong>。是根据词条找文档的过程。</li></ul><h3 id="1-2-IK分词器"><a href="#1-2-IK分词器" class="headerlink" title="1.2 IK分词器"></a>1.2 IK分词器</h3><p>地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p><p>IK分词器包含两种模式：</p><ul><li>ik_smart：智能语义切分 </li><li>ik_max_word：最细粒度切分</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /_analyze<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员学习java太棒了&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;tokens&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;程序员&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;学习&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">7</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ENGLISH&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;token&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;太棒了&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;start_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">11</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;end_offset&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">14</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;type&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;CN_WORD&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;position&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>拓展词典</strong>:</p><ol><li>打开IK分词器config目录</li><li>在IKAnalyzer.cfg.xml配置文件内容添加</li><li>在IK分词器的config目录新建一个 ext.dic，可以参考config目录下复制一个配置文件进行修改</li><li>重启elasticsearch</li></ol><h3 id="1-3-ES基础概念"><a href="#1-3-ES基础概念" class="headerlink" title="1.3 ES基础概念"></a>1.3 ES基础概念</h3><p>elasticsearch是<strong>面向文档（Document）存储</strong>的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中</p><p><img src="/img/blogs/java/springcloud/es.3.png"></p><p>将类型相同的文档集中在一起管理，称为索引（Index）</p><p><img src="/img/blogs/java/springcloud/es.4.png"></p><p><strong>MySQL和ES的对比</strong>：</p><p><img src="/img/blogs/java/springcloud/es.5.png"></p><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性 </li><li>Elasticsearch：擅长海量数据的搜索、分析、计算<br>两者结合使用：</li><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h2 id="2-索引库操作"><a href="#2-索引库操作" class="headerlink" title="2. 索引库操作"></a>2. 索引库操作</h2><p>Index就类似数据库表，Mapping映射就类似表的结构。我们要向es中存储数据，必须先创建Index和Mapping</p><h3 id="2-1-Mapping映射属性"><a href="#2-1-Mapping映射属性" class="headerlink" title="2.1 Mapping映射属性"></a>2.1 Mapping映射属性</h3><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有： <ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><h3 id="2-2-索引库的增删改查"><a href="#2-2-索引库的增删改查" class="headerlink" title="2.2 索引库的增删改查"></a>2.2 索引库的增删改查</h3><p>Elasticsearch采用的是Restful风格的API，而且请求参数也都采用JSON风格</p><table><thead><tr><th>接口类型</th><th>请求方式</th><th>请求路径</th><th>请求参数</th></tr></thead><tbody><tr><td>查询用户</td><td>GET</td><td>&#x2F;users&#x2F;{id}</td><td>路径中的 id</td></tr><tr><td>新增用户</td><td>POST</td><td>&#x2F;users</td><td>json 格式 user 对象</td></tr><tr><td>修改用户</td><td>PUT</td><td>&#x2F;users&#x2F;{id}</td><td>路径中的 id<br>json 格式对象</td></tr><tr><td>删除用户</td><td>DELETE</td><td>&#x2F;users&#x2F;{id}</td><td>路径中的 id</td></tr></tbody></table><h4 id="2-2-1-创建索引库"><a href="#2-2-1-创建索引库" class="headerlink" title="2.2.1 创建索引库"></a>2.2.1 创建索引库</h4><p>基本语法：</p><ul><li>请求方式：PUT</li><li>请求路径：&#x2F;索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名称<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名2&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;字段名3&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;子字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// ...略</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"># PUT /heima<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;false&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-查询、删除索引库"><a href="#2-2-2-查询、删除索引库" class="headerlink" title="2.2.2 查询、删除索引库"></a>2.2.2 查询、删除索引库</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /索引库名<br>DELETE /索引库名<br></code></pre></td></tr></table></figure><h4 id="2-2-3-修改索引库"><a href="#2-2-3-修改索引库" class="headerlink" title="2.2.3 修改索引库"></a>2.2.3 修改索引库</h4><p>索引库一旦创建，无法修改mapping。但是却允许添加新的字段到mapping中</p><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /索引库名/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;新字段名&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /heima/_mapping<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="3-文档操作"><a href="#3-文档操作" class="headerlink" title="3. 文档操作"></a>3. 文档操作</h2><p>有了索引库，接下来就可以向索引库的文档中添加数据了。</p><h3 id="3-1-新增文档"><a href="#3-1-新增文档" class="headerlink" title="3.1 新增文档"></a>3.1 新增文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /索引库名/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;子属性1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值3&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;子属性2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-查询文档"><a href="#3-2-查询文档" class="headerlink" title="3.2 查询文档"></a>3.2 查询文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名称<span class="hljs-punctuation">&#125;</span>/_doc/<span class="hljs-punctuation">&#123;</span>id<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-3-删除文档"><a href="#3-3-删除文档" class="headerlink" title="3.3 删除文档"></a>3.3 删除文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">DELETE /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/id值<br></code></pre></td></tr></table></figure><h3 id="3-4-修改文档"><a href="#3-4-修改文档" class="headerlink" title="3.4 修改文档"></a>3.4 修改文档</h3><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>局部修改：修改文档中的部分字段</li></ul><h4 id="3-4-1-全量修改"><a href="#3-4-1-全量修改" class="headerlink" title="3.4.1 全量修改"></a>3.4.1 全量修改</h4><p>全量修改是覆盖原来的文档，其本质是两步操作：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_doc/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;字段1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;字段2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;值2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ... 略</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-2-局部修改"><a href="#3-4-2-局部修改" class="headerlink" title="3.4.2 局部修改"></a>3.4.2 局部修改</h4><p>局部修改是只修改指定id匹配的文档中的部分字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">POST /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_update/文档id<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;新的值&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-批处理"><a href="#3-5-批处理" class="headerlink" title="3.5 批处理"></a>3.5 批处理</h3><p>批处理采用POST请求，基本语法如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">POST _bulk<br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;field1&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value1&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;delete&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;create&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span> <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;field1&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value3&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;update&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_id&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_index&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;doc&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;field2&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;value2&quot;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>index代表新增操作<ul><li>_index：指定索引库名</li><li>_id指定要操作的文档id</li><li>{ “field1” : “value1” }：则是要新增的文档内容</li></ul></li><li>delete代表删除操作<ul><li>_index：指定索引库名</li><li>_id指定要操作的文档id</li></ul></li><li>update代表更新操作<ul><li>_index：指定索引库名</li><li>_id指定要操作的文档id</li><li>{ “doc” : {“field2” : “value2”} }：要更新的文档字段</li></ul></li></ul><h3 id="3-6-案例"><a href="#3-6-案例" class="headerlink" title="3.6 案例"></a>3.6 案例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs json"># 新增文档<br>POST /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员Java讲师&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br># 查询文档<br>GET /heima/_doc/<span class="hljs-number">1</span><br><br># 删除文档<br>DELETE /heima/_doc/<span class="hljs-number">1</span><br><br># 全量修改文档<br>PUT /heima/_doc/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员高级Java讲师&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zy@itcast.cn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;云&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;赵&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br># 局部修改文档<br>POST /heima/_update/<span class="hljs-number">1</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ZhaoYun@itcast.cn&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br># 批量新增文档<br>POST /_bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员C++讲师&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ww@itcast.cn&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;五&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;王&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;黑马程序员前端讲师&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;zhangsan@itcast.cn&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;firstName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;三&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;lastName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;张&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><br># 批量删除文档<br>POST /_bulk<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;delete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;delete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_index&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;heima&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;4&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="4-JavaRestClient"><a href="#4-JavaRestClient" class="headerlink" title="4. JavaRestClient"></a>4. JavaRestClient</h2><h3 id="4-1-客户端初始化RestClient"><a href="#4-1-客户端初始化RestClient" class="headerlink" title="4.1 客户端初始化RestClient"></a>4.1 客户端初始化RestClient</h3><ol><li>在item-service模块中引入es的RestHighLevelClient依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>因为SpringBoot默认的ES版本是7.17.10，所以我们需要覆盖默认的ES版本：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">elasticsearch.version</span>&gt;</span>7.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">elasticsearch.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>初始化RestHighLevelClient：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestHighLevelClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestHighLevelClient</span>(RestClient.builder(<br>        HttpHost.create(<span class="hljs-string">&quot;http://192.168.150.101:9200&quot;</span>)<br>));<br></code></pre></td></tr></table></figure><h3 id="4-2-创建索引库"><a href="#4-2-创建索引库" class="headerlink" title="4.2 创建索引库"></a>4.2 创建索引库</h3><p>要实现对商品搜索，所以我们需要将商品添加到Elasticsearch中，不过需要根据搜索业务的需求来设定索引库结构，而不是一股脑的把MySQL数据写入Elasticsearch.</p><h4 id="4-2-1-商品Mapping映射"><a href="#4-2-1-商品Mapping映射" class="headerlink" title="4.2.1 商品Mapping映射"></a>4.2.1 商品Mapping映射</h4><p>结合数据库表结构，字段对应的mapping映射属性如下：</p><p><img src="/img/blogs/java/springcloud/es.6.png"></p><p>索引库文档结构:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs json">PUT /items<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_max_word&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;stock&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;image&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;sold&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;commentCount&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;isAD&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;boolean&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;updateTime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;date&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4-2-2-在java中创建索引库"><a href="#4-2-2-在java中创建索引库" class="headerlink" title="4.2.2 在java中创建索引库"></a>4.2.2 在java中创建索引库</h4><ol><li>创建Request对象。<br>  因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>添加请求参数<br>  其实就是Json格式的Mapping映射参数。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>发送请求<br>  client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。例如创建索引、删除索引、判断索引是否存在等</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testCreateIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">CreateIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.source(MAPPING_TEMPLATE, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.indices().create(request, RequestOptions.DEFAULT);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">MAPPING_TEMPLATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;stock\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;image\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;category\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;sold\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;commentCount\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;isAD\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;      \&quot;updateTime\&quot;:&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;      &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;  &#125;\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-在java中删除和查询索引库"><a href="#4-3-在java中删除和查询索引库" class="headerlink" title="4.3 在java中删除和查询索引库"></a>4.3 在java中删除和查询索引库</h3><h4 id="4-3-1-删除索引库"><a href="#4-3-1-删除索引库" class="headerlink" title="4.3.1 删除索引库"></a>4.3.1 删除索引库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">DeleteIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.indices().delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2-查询索引库"><a href="#4-3-2-查询索引库" class="headerlink" title="4.3.2 查询索引库"></a>4.3.2 查询索引库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testExistsIndex</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request对象</span><br>    <span class="hljs-type">GetIndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetIndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.输出</span><br>    System.err.println(exists ? <span class="hljs-string">&quot;索引库已经存在！&quot;</span> : <span class="hljs-string">&quot;索引库不存在！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-文档操作"><a href="#4-4-文档操作" class="headerlink" title="4.4 文档操作"></a>4.4 文档操作</h3><h4 id="4-4-1-新增文档"><a href="#4-4-1-新增文档" class="headerlink" title="4.4.1 新增文档"></a>4.4.1 新增文档</h4><ol><li>创建Request对象，这里是IndexRequest，因为添加文档就是创建倒排索引的过程</li><li>准备请求参数，本例中就是Json文档</li><li>发送请求</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.根据id查询商品数据</span><br>    <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> itemService.getById(<span class="hljs-number">100002644680L</span>);<br>    <span class="hljs-comment">// 2.转换为文档类型</span><br>    <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);<br>    <span class="hljs-comment">// 3.将ItemDTO转json</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> JSONUtil.toJsonStr(itemDoc);<br><br>    <span class="hljs-comment">// 1.准备Request对象</span><br>    <span class="hljs-type">IndexRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(itemDoc.getId());<br>    <span class="hljs-comment">// 2.准备Json文档</span><br>    request.source(doc, XContentType.JSON);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.index(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-查询文档"><a href="#4-4-2-查询文档" class="headerlink" title="4.4.2 查询文档"></a>4.4.2 查询文档</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetDocumentById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request对象</span><br>    <span class="hljs-type">GetRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GetRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;100002644680&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    <span class="hljs-type">GetResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.get(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 3.获取响应结果中的source</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> response.getSourceAsString();<br>    <br>    <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, ItemDoc.class);<br>    System.out.println(<span class="hljs-string">&quot;itemDoc= &quot;</span> + ItemDoc);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-删除文档"><a href="#4-4-3-删除文档" class="headerlink" title="4.4.3 删除文档"></a>4.4.3 删除文档</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request，两个参数，第一个是索引库名，第二个是文档id</span><br>    <span class="hljs-type">DeleteRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeleteRequest</span>(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;100002644680&quot;</span>);<br>    <span class="hljs-comment">// 2.发送请求</span><br>    client.delete(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-4-修改文档"><a href="#4-4-4-修改文档" class="headerlink" title="4.4.4 修改文档"></a>4.4.4 修改文档</h4><ul><li>全量修改：本质是先根据id删除，再新增</li><li>局部修改：修改文档中的指定字段值</li></ul><p>我们主要关注局部修改的API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.准备Request</span><br>    <span class="hljs-type">UpdateRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateRequest</span>(<span class="hljs-string">&quot;items&quot;</span>, <span class="hljs-string">&quot;100002644680&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.doc(<br>            <span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">58800</span>,<br>            <span class="hljs-string">&quot;commentCount&quot;</span>, <span class="hljs-number">1</span><br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.update(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-5-批量导入文档"><a href="#4-4-5-批量导入文档" class="headerlink" title="4.4.5 批量导入文档"></a>4.4.5 批量导入文档</h4><p>Bulk中添加了多个IndexRequest，就是批量新增功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBulk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>();<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;1&quot;</span>).source(<span class="hljs-string">&quot;json doc1&quot;</span>, XContentType.JSON));<br>    request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>(<span class="hljs-string">&quot;items&quot;</span>).id(<span class="hljs-string">&quot;2&quot;</span>).source(<span class="hljs-string">&quot;json doc2&quot;</span>, XContentType.JSON));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    client.bulk(request, RequestOptions.DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><p>采用循环遍历方式，每次导入1000条左右的数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoadItemDocs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 分页查询商品数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        Page&lt;Item&gt; page = itemService.lambdaQuery().eq(Item::getStatus, <span class="hljs-number">1</span>).page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;Item&gt;(pageNo, size));<br>        <span class="hljs-comment">// 非空校验</span><br>        List&lt;Item&gt; items = page.getRecords();<br>        <span class="hljs-keyword">if</span> (CollUtils.isEmpty(items)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;加载第&#123;&#125;页数据，共&#123;&#125;条&quot;</span>, pageNo, items.size());<br>        <span class="hljs-comment">// 1.创建Request</span><br>        <span class="hljs-type">BulkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BulkRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>        <span class="hljs-comment">// 2.准备参数，添加多个新增的Request</span><br>        <span class="hljs-keyword">for</span> (Item item : items) &#123;<br>            <span class="hljs-comment">// 2.1.转换为文档类型ItemDTO</span><br>            <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);<br>            <span class="hljs-comment">// 2.2.创建新增文档的Request对象</span><br>            request.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexRequest</span>()<br>                            .id(itemDoc.getId())<br>                            .source(JSONUtil.toJsonStr(itemDoc), XContentType.JSON));<br>        &#125;<br>        <span class="hljs-comment">// 3.发送请求</span><br>        client.bulk(request, RequestOptions.DEFAULT);<br><br>        <span class="hljs-comment">// 翻页</span><br>        pageNo++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-DSL查询"><a href="#5-DSL查询" class="headerlink" title="5. DSL查询"></a>5. DSL查询</h2><p>Elasticsearch的查询可以分为两大类：</p><ul><li>叶子查询（Leaf query clauses）：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li>复合查询（Compound query clauses）：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><h3 id="5-1-叶子查询"><a href="#5-1-叶子查询" class="headerlink" title="5.1 叶子查询"></a>5.1 叶子查询</h3><p>叶子查询的类型：</p><ul><li>全文检索查询（Full Text Queries）：利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li>match：</li><li>multi_match</li></ul></li><li>精确查询（Term-level queries）：不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：<ul><li>ids</li><li>term</li><li>range</li></ul></li><li>地理坐标查询：用于搜索地理位置，搜索方式很多，例如：<ul><li>geo_bounding_box：按矩形搜索</li><li>geo_distance：按点和半径搜索</li></ul></li></ul><h4 id="5-1-1-全文检索查询"><a href="#5-1-1-全文检索查询" class="headerlink" title="5.1.1 全文检索查询"></a>5.1.1 全文检索查询</h4><p>match语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索条件&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>multi_match语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;multi_match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索条件&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;字段1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;字段2&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;multi_match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;华为&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;name&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5-1-2-精确查询"><a href="#5-1-2-精确查询" class="headerlink" title="5.1.2 精确查询"></a>5.1.2 精确查询</h4><p>词条级别的查询；作为一个词条，与搜索的字段内容精确值匹配。因此推荐查找keyword、数值、日期、boolean类型的字段。</p><p>term查询:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索条件&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>range查询:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;字段名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>最小值<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>最大值<span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-复合查询"><a href="#5-2-复合查询" class="headerlink" title="5.2 复合查询"></a>5.2 复合查询</h3><ul><li>第一类：基于逻辑运算组合叶子查询，实现组合条件，例如<ul><li>bool</li></ul></li><li>第二类：基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：<ul><li>function_score</li><li>dis_max</li></ul></li></ul><h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><p>bool查询，即布尔查询。就是利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，不参与算分，类似“非”</li><li>filter：必须匹配，不参与算分</li></ul><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;should&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vivo&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;小米&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;must_not&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2500</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;lte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>搜索手机，但品牌必须是华为，价格必须是900~1599：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;华为&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">90000</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;lt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">159900</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-排序"><a href="#5-3-排序" class="headerlink" title="5.3 排序"></a>5.3 排序</h3><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，<strong>能参与排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型</strong>等。</p><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /indexName/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;排序字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;排序方式asc和desc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>按照商品价格排序:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-4-分页"><a href="#5-4-分页" class="headerlink" title="5.4 分页"></a>5.4 分页</h3><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了</p><h4 id="5-4-1-基础分页"><a href="#5-4-1-基础分页" class="headerlink" title="5.4.1 基础分页"></a>5.4.1 基础分页</h4><p>elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match_all&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 分页开始的位置，默认为0</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 每页文档数量，默认10</span><br>  <span class="hljs-attr">&quot;sort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;desc&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5-4-2-深度分页"><a href="#5-4-2-深度分页" class="headerlink" title="5.4.2 深度分页"></a>5.4.2 深度分页</h4><p>elasticsearch的数据一般会采用分片存储，也就是把一个索引中的数据分成N份，存储到不同节点上。这种存储方式比较有利于数据扩展，但给分页带来了一些麻烦。<br>试想一下，假如我们现在要查询的是第999页数据呢，是不是要找第9990~10000的数据，那岂不是需要把每个分片中的前10000名数据都查询出来，汇总在一起，在内存中排序？如果查询的分页深度更深呢，需要一次检索的数据岂不是更多？</p><p><img src="/img/blogs/java/springcloud/es.7.png"></p><p>针对深度分页，elasticsearch提供了解决方案：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li></ul><h3 id="5-5-高亮"><a href="#5-5-高亮" class="headerlink" title="5.5 高亮"></a>5.5 高亮</h3><p>词条的高亮标签肯定是由服务端提供数据的时候已经加上的。</p><p>实现高亮的思路就是：</p><ul><li>用户输入搜索关键字搜索数据</li><li>服务端根据搜索关键字到elasticsearch搜索，并给搜索结果中的关键字词条添加html标签</li><li>前端提前给约定好的html标签添加CSS样式</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /<span class="hljs-punctuation">&#123;</span>索引库名<span class="hljs-punctuation">&#125;</span>/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;搜索字段&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搜索关键字&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;highlight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;高亮字段名称&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;pre_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;em&gt;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;post_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;/em&gt;&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="6-JavaRestClient查询"><a href="#6-JavaRestClient查询" class="headerlink" title="6. JavaRestClient查询"></a>6. JavaRestClient查询</h2><h3 id="6-1-文档搜索的基本步骤"><a href="#6-1-文档搜索的基本步骤" class="headerlink" title="6.1 文档搜索的基本步骤"></a>6.1 文档搜索的基本步骤</h3><ol><li>创建SearchRequest对象</li><li>准备request.source()，也就是DSL。</li><li>QueryBuilders来构建查询条件</li><li>传入request.source() 的 query() 方法</li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatchAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.matchAllQuery());<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 2.遍历结果数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 3.得到_source，也就是原始json文档</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 4.反序列化并打印</span><br>        <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> JSONUtil.toBean(source, ItemDoc.class);<br>        System.out.println(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-叶子查询"><a href="#6-2-叶子查询" class="headerlink" title="6.2 叶子查询"></a>6.2 叶子查询</h3><p>match查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>multi_match查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testMultiMatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.multiMatchQuery(<span class="hljs-string">&quot;脱脂牛奶&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;category&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>range查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(<span class="hljs-number">10000</span>).lte(<span class="hljs-number">30000</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>term查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testTerm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    request.source().query(QueryBuilders.termQuery(<span class="hljs-string">&quot;brand&quot;</span>, <span class="hljs-string">&quot;华为&quot;</span>));<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-复合查询"><a href="#6-3-复合查询" class="headerlink" title="6.3 复合查询"></a>6.3 复合查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    <span class="hljs-comment">// 2.1.准备bool查询</span><br>    <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">bool</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery();<br>    <span class="hljs-comment">// 2.2.关键字搜索</span><br>    bool.must(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 2.3.品牌过滤</span><br>    bool.filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;brand&quot;</span>, <span class="hljs-string">&quot;德亚&quot;</span>));<br>    <span class="hljs-comment">// 2.4.价格过滤</span><br>    bool.filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).lte(<span class="hljs-number">30000</span>));<br>    request.source().query(bool);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-4-排序和分页"><a href="#6-4-排序和分页" class="headerlink" title="6.4 排序和分页"></a>6.4 排序和分页</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageAndSort</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, pageSize = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    <span class="hljs-comment">// 2.1.搜索条件参数</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 2.2.排序参数</span><br>    request.source().sort(<span class="hljs-string">&quot;price&quot;</span>, SortOrder.ASC);<br>    <span class="hljs-comment">// 2.3.分页参数</span><br>    request.source().from((pageNo - <span class="hljs-number">1</span>) * pageSize).size(pageSize);<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5-高亮"><a href="#6-5-高亮" class="headerlink" title="6.5 高亮"></a>6.5 高亮</h3><ul><li>条件同样是在request.source()中指定，只不过高亮条件要基于HighlightBuilder来构造</li><li>高亮响应结果与搜索的文档结果不在一起，需要单独解析</li></ul><p>查询:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHighlight</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.组织请求参数</span><br>    <span class="hljs-comment">// 2.1.query条件</span><br>    request.source().query(QueryBuilders.matchQuery(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;脱脂牛奶&quot;</span>));<br>    <span class="hljs-comment">// 2.2.高亮条件</span><br>    request.source().highlighter(<br>            SearchSourceBuilder.highlight()<br>                    .field(<span class="hljs-string">&quot;name&quot;</span>)<br>                    .preTags(<span class="hljs-string">&quot;&lt;em&gt;&quot;</span>)<br>                    .postTags(<span class="hljs-string">&quot;&lt;/em&gt;&quot;</span>)<br>    );<br>    <span class="hljs-comment">// 3.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br>    <span class="hljs-comment">// 4.解析响应</span><br>    handleResponse(response);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(SearchResponse response)</span> &#123;<br>    <span class="hljs-type">SearchHits</span> <span class="hljs-variable">searchHits</span> <span class="hljs-operator">=</span> response.getHits();<br>    <span class="hljs-comment">// 1.获取总条数</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> searchHits.getTotalHits().value;<br>    System.out.println(<span class="hljs-string">&quot;共搜索到&quot;</span> + total + <span class="hljs-string">&quot;条数据&quot;</span>);<br>    <span class="hljs-comment">// 2.遍历结果数组</span><br>    SearchHit[] hits = searchHits.getHits();<br>    <span class="hljs-keyword">for</span> (SearchHit hit : hits) &#123;<br>        <span class="hljs-comment">// 3.得到_source，也就是原始json文档</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> hit.getSourceAsString();<br>        <span class="hljs-comment">// 4.反序列化</span><br>        <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> JSONUtil.toBean(source, ItemDoc.class);<br>        <span class="hljs-comment">// 5.获取高亮结果</span><br>        Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();<br>        <span class="hljs-keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;<br>            <span class="hljs-comment">// 5.1.有高亮结果，获取name的高亮结果</span><br>            <span class="hljs-type">HighlightField</span> <span class="hljs-variable">hf</span> <span class="hljs-operator">=</span> hfs.get(<span class="hljs-string">&quot;name&quot;</span>);<br>            <span class="hljs-keyword">if</span> (hf != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 5.2.获取第一个高亮结果片段，就是商品名称的高亮值</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">hfName</span> <span class="hljs-operator">=</span> hf.getFragments()[<span class="hljs-number">0</span>].string();<br>                item.setName(hfName);<br>            &#125;<br>        &#125;<br>        System.out.println(item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-数据聚合"><a href="#7-数据聚合" class="headerlink" title="7. 数据聚合"></a>7. 数据聚合</h2><h3 id="7-1-聚合的概念"><a href="#7-1-聚合的概念" class="headerlink" title="7.1 聚合的概念"></a>7.1 聚合的概念</h3><p>聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算</p><p>聚合常见的有三类：</p><ul><li>桶（Bucket）聚合：用来对文档做分组 </li><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li><li>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 </li><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li><li>管道（pipeline）聚合：其它聚合的结果为基础做进一步运算</li></ul><p><strong>注意</strong>：参加聚合的<strong>字段必须是keyword、日期、数值、布尔类型</strong></p><h3 id="7-2-DSL实现聚合"><a href="#7-2-DSL实现聚合" class="headerlink" title="7.2 DSL实现聚合"></a>7.2 DSL实现聚合</h3><h4 id="7-2-1-Bucket聚合"><a href="#7-2-1-Bucket聚合" class="headerlink" title="7.2.1 Bucket聚合"></a>7.2.1 Bucket聚合</h4><p>我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;category_agg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;category&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>size：设置size为0，就是每页查0条，则结果中就不包含文档，只包含聚合</li><li>aggs：定义聚合<ul><li>category_agg：聚合名称，自定义，但不能重复<ul><li>terms：聚合的类型，按分类聚合，所以用term<ul><li>field：参与聚合的字段名称</li><li>size：希望返回的聚合结果的最大数量</li></ul></li></ul></li></ul></li></ul><h4 id="7-2-2-带条件聚合"><a href="#7-2-2-带条件聚合" class="headerlink" title="7.2.2 带条件聚合"></a>7.2.2 带条件聚合</h4><p>价格高于3000元的手机品牌有哪些</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">300000</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brand_agg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="7-2-3-Metric聚合"><a href="#7-2-3-Metric聚合" class="headerlink" title="7.2.3 Metric聚合"></a>7.2.3 Metric聚合</h4><p>我们需要对桶内的商品做运算，获取每个品牌价格的最小值、最大值、平均值。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json">GET /items/_search<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;filter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手机&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;gte&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">300000</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;brand_agg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;terms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;brand&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;aggs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;stats_meric&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;stats&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;price&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>stats_meric：聚合名称<ul><li>stats：聚合类型，stats是metric聚合的一种<ul><li>field：聚合字段，这里选择price，统计价格</li></ul></li></ul></li></ul><h3 id="7-3-JavaRestClient实现聚合"><a href="#7-3-JavaRestClient实现聚合" class="headerlink" title="7.3 JavaRestClient实现聚合"></a>7.3 JavaRestClient实现聚合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testAgg</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1.创建Request</span><br>    <span class="hljs-type">SearchRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequest</span>(<span class="hljs-string">&quot;items&quot;</span>);<br>    <span class="hljs-comment">// 2.准备请求参数</span><br>    <span class="hljs-type">BoolQueryBuilder</span> <span class="hljs-variable">bool</span> <span class="hljs-operator">=</span> QueryBuilders.boolQuery()<br>            .filter(QueryBuilders.termQuery(<span class="hljs-string">&quot;category&quot;</span>, <span class="hljs-string">&quot;手机&quot;</span>))<br>            .filter(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;price&quot;</span>).gte(<span class="hljs-number">300000</span>));<br>    request.source().query(bool).size(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 3.聚合参数</span><br>    request.source().aggregation(<br>            AggregationBuilders.terms(<span class="hljs-string">&quot;brand_agg&quot;</span>).field(<span class="hljs-string">&quot;brand&quot;</span>).size(<span class="hljs-number">5</span>)<br>    );<br>    <span class="hljs-comment">// 4.发送请求</span><br>    <span class="hljs-type">SearchResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.search(request, RequestOptions.DEFAULT);<br><br><br><br>    <span class="hljs-comment">// 5.解析聚合结果</span><br>    <span class="hljs-type">Aggregations</span> <span class="hljs-variable">aggregations</span> <span class="hljs-operator">=</span> response.getAggregations();<br>    <span class="hljs-comment">// 5.1.获取品牌聚合</span><br>    <span class="hljs-type">Terms</span> <span class="hljs-variable">brandTerms</span> <span class="hljs-operator">=</span> aggregations.get(<span class="hljs-string">&quot;brand_agg&quot;</span>);<br>    <span class="hljs-comment">// 5.2.获取聚合中的桶</span><br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();<br>    <span class="hljs-comment">// 5.3.遍历桶内数据</span><br>    <span class="hljs-keyword">for</span> (Terms.Bucket bucket : buckets) &#123;<br>        <span class="hljs-comment">// 5.4.获取桶内key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> bucket.getKeyAsString();<br>        System.out.print(<span class="hljs-string">&quot;brand = &quot;</span> + brand);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> bucket.getDocCount();<br>        System.out.println(<span class="hljs-string">&quot;; count = &quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考文献：<a href="https://b11et3un53m.feishu.cn/wiki/LDLew5xnDiDv7Qk2uPwcoeNpngf">https://b11et3un53m.feishu.cn/wiki/LDLew5xnDiDv7Qk2uPwcoeNpngf</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>SpringCloud</tag>
      
      <tag>Elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ学习笔记</title>
    <link href="/2025/03/08/JAVA/SpringCloud/RabbitMQ/"/>
    <url>/2025/03/08/JAVA/SpringCloud/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 align="center">RabbitMQ学习笔记</h1><h2 id="1-认识MQ"><a href="#1-认识MQ" class="headerlink" title="1. 认识MQ"></a>1. 认识MQ</h2><h3 id="1-1-同步调用"><a href="#1-1-同步调用" class="headerlink" title="1.1 同步调用"></a>1.1 同步调用</h3><p>在微服务架构中，同步调用（Synchronous Invocation）通常<strong>指一个服务调用另一个服务时，调用方必须等待被调用方处理完请求并返回响应后，才能继续执行后续逻辑</strong>。</p><p><img src="/img/blogs/java/springcloud/mq.1.png"></p><p><strong>特点</strong>：</p><ul><li>阻塞执行：调用方在等待返回结果时无法执行其他任务。</li><li>执行顺序严格：必须按顺序等待上一个任务完成后才能继续下一个任务。</li><li>适用于短时间执行的任务：如果被调用的方法执行时间较长，会影响系统的响应速度和并发能力。</li></ul><p><strong>存在的问题</strong>：</p><ul><li>拓展性差：每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</li><li>性能下降：每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和</li><li>级联失败(雪崩问题)：当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。</li></ul><h3 id="1-2-异步调用"><a href="#1-2-异步调用" class="headerlink" title="1.2 异步调用"></a>1.2 异步调用</h3><p>在微服务架构中，异步调用（Asynchronous Invocation）指的是<strong>调用方在调用某个服务时，不需要等待其完成，而是立即返回并继续执行其他任务</strong>。<strong>被调用方在完成处理后</strong>，可以通过回调、轮询、<strong>消息队列</strong>等方式通知调用方。</p><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="/img/blogs/java/springcloud/mq.2.png"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p><img src="/img/blogs/java/springcloud/mq.3.png"></p><p>异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>异步通信存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h3 id="1-3-常见MQ技术对比"><a href="#1-3-常见MQ技术对比" class="headerlink" title="1.3 常见MQ技术对比"></a>1.3 常见MQ技术对比</h3><table><thead><tr><th>常见MQ</th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td><strong>公司&#x2F;社区</strong></td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td><strong>开发语言</strong></td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td><strong>协议支持</strong></td><td>AMQP, XMPP, SMTP, STOMP</td><td>OpenWire, STOMP, REST, XMPP, AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td><strong>可用性</strong></td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td><strong>单机吞吐量</strong></td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td><strong>消息延迟</strong></td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td><strong>消息可靠性</strong></td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><h2 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2. RabbitMQ"></a>2. RabbitMQ</h2><h3 id="2-1-RabbitMQ架构"><a href="#2-1-RabbitMQ架构" class="headerlink" title="2.1 RabbitMQ架构"></a>2.1 RabbitMQ架构</h3><ul><li>publisher：生产者，也就是发送消息的一方</li><li>consumer：消费者，也就是消费消息的一方</li><li>queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p><img src="/img/blogs/java/springcloud/mq.4.png"></p><p>生产者发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定</p><h3 id="2-2-数据隔离"><a href="#2-2-数据隔离" class="headerlink" title="2.2 数据隔离"></a>2.2 数据隔离</h3><ul><li>给每个项目创建不同的virtual host，将每个项目的数据隔离。</li><li>给每个项目创建独立的运维账号，将管理权限分离。</li></ul><h2 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3. SpringAMQP"></a>3. SpringAMQP</h2><h3 id="3-1-入门案例"><a href="#3-1-入门案例" class="headerlink" title="3.1 入门案例"></a>3.1 入门案例</h3><h4 id="3-1-1-引入依赖"><a href="#3-1-1-引入依赖" class="headerlink" title="3.1.1 引入依赖"></a>3.1.1 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-2-添加配置"><a href="#3-1-2-添加配置" class="headerlink" title="3.1.2 添加配置"></a>3.1.2 添加配置</h4><p>在publisher服务的application.yml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># 你的虚拟机IP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/hmall</span> <span class="hljs-comment"># 虚拟主机</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 用户名</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 密码</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3-发送消息"><a href="#3-1-3-发送消息" class="headerlink" title="3.1.3 发送消息"></a>3.1.3 发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 队列名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>        <span class="hljs-comment">// 消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>        <span class="hljs-comment">// 发送消息</span><br>        rabbitTemplate.convertAndSend(queueName, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-4-接收消息"><a href="#3-1-4-接收消息" class="headerlink" title="3.1.4 接收消息"></a>3.1.4 接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>        <span class="hljs-comment">// 利用RabbitListener来声明要监听的队列信息</span><br>    <span class="hljs-comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span><br>    <span class="hljs-comment">// 可以看到方法体中接收的就是消息体的内容</span><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-WorkQueues模型"><a href="#3-2-WorkQueues模型" class="headerlink" title="3.2 WorkQueues模型"></a>3.2 WorkQueues模型</h3><p>让多个消费者绑定到一个队列，共同消费队列中的消息。可以使用WorkQueues模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了。</p><p><img src="/img/blogs/java/springcloud/mq.5.png"></p><h4 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1 消息发送"></a>3.2.1 消息发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * workQueue</span><br><span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="hljs-comment">     */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 队列名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, message_&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>        <span class="hljs-comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span><br>        rabbitTemplate.convertAndSend(queueName, message + i);<br>        Thread.sleep(<span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2 消息接收"></a>3.2.2 消息接收</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;work.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue1</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">20</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;work.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue2</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.err.println(<span class="hljs-string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span> + LocalTime.now());<br>    Thread.sleep(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h4 id="3-2-3-测试结果"><a href="#3-2-3-测试结果" class="headerlink" title="3.2.3 测试结果"></a>3.2.3 测试结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java">消费者<span class="hljs-number">1</span>接收到消息：【hello, message_0】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.869555300</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_1】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.884518</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_2】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.907454400</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_4】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.953332100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_6】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">00.997867300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_8】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.042178700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_3】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.086478800</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_10】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.087476600</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_12】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.132578300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_14】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.175851200</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_16】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.218533400</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_18】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.261322900</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_5】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.287003700</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_20】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.304412400</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_22】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.349950100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_24】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.394533900</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_26】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.439876500</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_28】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.482937800</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_7】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.488977100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_30】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.526409300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_32】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.572148</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_34】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.618264800</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_36】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.660780600</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_9】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.689189300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_38】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.705261</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_40】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.746927300</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_42】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.789835</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_44】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.834393100</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_46】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.875312100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_11】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.889969500</span><br>消费者<span class="hljs-number">1</span>接收到消息：【hello, message_48】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">01.920702500</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_13】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.090725900</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_15】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.293060600</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_17】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.493748</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_19】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.696635100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_21】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">02.896809700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_23】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.099533400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_25】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.301446400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_27】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.504999100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_29】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.705702500</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_31】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">03.906601200</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_33】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.108118500</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_35】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.308945400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_37】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.511547700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_39】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.714038400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_41】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">04.916192700</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_43】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.116286400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_45】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.318055100</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_47】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.520656400</span><br>消费者<span class="hljs-number">2.</span>.......接收到消息：【hello, message_49】<span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">05.723106700</span><br></code></pre></td></tr></table></figure><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。<br>也就是说<strong>消息是平均分配给每个消费者</strong>，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。</li></ul><h4 id="3-2-4-能者多劳配置"><a href="#3-2-4-能者多劳配置" class="headerlink" title="3.2.4 能者多劳配置"></a>3.2.4 能者多劳配置</h4><p>修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></code></pre></td></tr></table></figure><p>再次测试发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h4 id="3-2-5-Work模型总结"><a href="#3-2-5-Work模型总结" class="headerlink" title="3.2.5 Work模型总结"></a>3.2.5 Work模型总结</h4><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h3 id="3-3-交换机"><a href="#3-3-交换机" class="headerlink" title="3.3 交换机"></a>3.3 交换机</h3><p>交换机的类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li>Direct：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li>Topic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li></ul><h4 id="3-3-1-Fanout交换机"><a href="#3-3-1-Fanout交换机" class="headerlink" title="3.3.1 Fanout交换机"></a>3.3.1 Fanout交换机</h4><p><strong>广播</strong>交换机，交换机把消息发送给绑定过的所有队列，每个队列的消费者都能收到消息</p><p><img src="/img/blogs/java/springcloud/mq.6.png"></p><ol><li>消息发送</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>消息接收</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.fanout&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, everyone!&quot;</span>;<br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h4 id="3-3-2-Direct交换机"><a href="#3-3-2-Direct交换机" class="headerlink" title="3.3.2 Direct交换机"></a>3.3.2 Direct交换机</h4><p>Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，<strong>只有队列的Routingkey与消息的 Routing key完全一致</strong>，才会接收到消息</li></ul><p><img src="/img/blogs/java/springcloud/mq.7.png"></p><h5 id="3-3-2-1-消息接收"><a href="#3-3-2-1-消息接收" class="headerlink" title="3.3.2.1 消息接收"></a>3.3.2.1 消息接收</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue2</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-2-2-消息发送"><a href="#3-3-2-2-消息发送" class="headerlink" title="3.3.2.2 消息发送"></a>3.3.2.2 消息发送</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendDirectExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.direct&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;最新报道，哥斯拉是居民自治巨型气球，虚惊一场！&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;blue&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时只有<code>blue</code>的消费者才会收到消息，也就是消费者1</p><h5 id="3-3-2-3-总结"><a href="#3-3-2-3-总结" class="headerlink" title="3.3.2.3 总结"></a>3.3.2.3 总结</h5><p>Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h4 id="3-3-3-Topic交换机"><a href="#3-3-3-Topic交换机" class="headerlink" title="3.3.3 Topic交换机"></a>3.3.3 Topic交换机</h4><p>Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。<br>只不过Topic类型Exchange可以让队列在绑定BindingKey 的时候使用通配符！</p><p>通配符规则：</p><ul><li>#：匹配一个或多个词</li><li>*：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li>item.#：能够匹配item.spu.insert 或者 item.spu</li><li>item.*：只能匹配item.spu</li></ul><p><img src="/img/blogs/java/springcloud/mq.8.png"></p><ol><li>消息发送</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * topicExchange</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendTopicExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 交换机名称</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hmall.topic&quot;</span>;<br>    <span class="hljs-comment">// 消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;china.news&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>消息接收</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue2</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Direct交换机与Topic交换机的差异</li></ol><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 . 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li>#：代表0个或多个词</li><li>*：代表1个词</li></ul><h3 id="3-4-声明队列和交换机"><a href="#3-4-声明队列和交换机" class="headerlink" title="3.4 声明队列和交换机"></a>3.4 声明队列和交换机</h3><p>Spring提供了基于注解方式来声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="hljs-meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String msg)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-消息转换器-JSON转换器"><a href="#3-5-消息转换器-JSON转换器" class="headerlink" title="3.5 消息转换器(JSON转换器)"></a>3.5 消息转换器(JSON转换器)</h3><p>默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="3-5-1-引入依赖"><a href="#3-5-1-引入依赖" class="headerlink" title="3.5.1 引入依赖"></a>3.5.1 引入依赖</h4><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-5-2-配置消息转换器"><a href="#3-5-2-配置消息转换器" class="headerlink" title="3.5.2 配置消息转换器"></a>3.5.2 配置消息转换器</h4><p>在publisher和consumer两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jackson2JsonMessageConverter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jackson2JsonMessageConverter.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jackson2JsonMessageConverter;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-3-接收消息"><a href="#3-5-3-接收消息" class="headerlink" title="3.5.3 接收消息"></a>3.5.3 接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;object.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(Map&lt;String, Object&gt; msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-MQ消息的可靠性"><a href="#4-MQ消息的可靠性" class="headerlink" title="4. MQ消息的可靠性"></a>4. MQ消息的可靠性</h2><p>在微服务架构中，消息队列（MQ）的可靠性指的是<strong>消息在生产、传输和消费的过程中不会丢失、不会重复、不被篡改，并且能够按预期被正确消费</strong>。确保 MQ 可靠性对于保证业务数据一致性、提高系统稳定性至关重要。</p><p>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到Exchange</li><li>生产者发送消息到达MQ的Exchange后，未找到合适的Queue</li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><h3 id="4-1-发送者的可靠性"><a href="#4-1-发送者的可靠性" class="headerlink" title="4.1 发送者的可靠性"></a>4.1 发送者的可靠性</h3><h4 id="4-1-1-生产者重试机制"><a href="#4-1-1-生产者重试机制" class="headerlink" title="4.1.1 生产者重试机制"></a>4.1.1 生产者重试机制</h4><p>生产者发送消息时，出现了网络故障，导致与MQ的连接中断。<br>为了解决这个问题，SpringAMQP提供的消息发送时的<strong>重试机制。即：当RabbitTemplate与MQ连接超时后，多次重试</strong>。</p><p>修改publisher模块的application.yaml文件，添加下面的内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment"># 设置MQ的连接超时时间</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">retry:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span><br>        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span><br>        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span><br>        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br></code></pre></td></tr></table></figure><p>注意：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的<strong>重试机制是阻塞式的重试</strong>，也就是说多次重试等待的过程中，当前线程是被阻塞的。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h4 id="4-1-2-生产者确认机制-一般情况下不建议开启"><a href="#4-1-2-生产者确认机制-一般情况下不建议开启" class="headerlink" title="4.1.2 生产者确认机制(一般情况下不建议开启)"></a>4.1.2 生产者确认机制(一般情况下不建议开启)</h4><p>RabbitMQ提供了生产者消息确认机制，包括Publisher Confirm和Publisher Return两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执。</p><p><img src="/img/blogs/java/springcloud/mq.9.png"></p><p>总结：</p><ul><li>当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><h5 id="4-1-2-1-开启生产者确认"><a href="#4-1-2-1-开启生产者确认" class="headerlink" title="4.1.2.1 开启生产者确认"></a>4.1.2.1 开启生产者确认</h5><p>在publisher模块的application.yaml中添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span> <span class="hljs-comment"># 开启publisher confirm机制，并设置confirm类型</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启publisher return机制</span><br></code></pre></td></tr></table></figure><p>这里publisher-confirm-type有三种模式可选：</p><ul><li>none：关闭confirm机制</li><li>simple：同步阻塞等待MQ的回执</li><li>correlated：MQ异步回调返回回执(推荐)</li></ul><h5 id="4-1-2-2-定义ReturnCallback"><a href="#4-1-2-2-定义ReturnCallback" class="headerlink" title="4.1.2.2 定义ReturnCallback"></a>4.1.2.2 定义ReturnCallback</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MqConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        rabbitTemplate.setReturnsCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RabbitTemplate</span>.ReturnsCallback() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;触发return callback,&quot;</span>);<br>                log.debug(<span class="hljs-string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());<br>                log.debug(<span class="hljs-string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());<br>                log.debug(<span class="hljs-string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());<br>                log.debug(<span class="hljs-string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());<br>                log.debug(<span class="hljs-string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-2-3-定义ConfirmCallback"><a href="#4-1-2-3-定义ConfirmCallback" class="headerlink" title="4.1.2.3 定义ConfirmCallback"></a>4.1.2.3 定义ConfirmCallback</h5><p>CorrelationData中包含两个核心的东西：</p><ul><li>id：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li>SettableListenableFuture：回执结果的Future对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherConfirm</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建CorrelationData</span><br>    <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>();<br>    <span class="hljs-comment">// 2.给Future添加ConfirmCallback</span><br>    cd.getFuture().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>            <span class="hljs-comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span><br>            log.error(<span class="hljs-string">&quot;send message fail&quot;</span>, ex);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(CorrelationData.Confirm result)</span> &#123;<br>            <span class="hljs-comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span><br>            <span class="hljs-keyword">if</span>(result.isAck())&#123; <span class="hljs-comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span><br>                log.debug(<span class="hljs-string">&quot;发送消息成功，收到 ack!&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// result.getReason()，String类型，返回nack时的异常描述</span><br>                log.error(<span class="hljs-string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 3.发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hmall.direct&quot;</span>, <span class="hljs-string">&quot;q&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, cd);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-MQ的可靠性"><a href="#4-2-MQ的可靠性" class="headerlink" title="4.2 MQ的可靠性"></a>4.2 MQ的可靠性</h3><p>消息到达MQ以后，因为<strong>MQ是基于内存存储的，如果内存空间被消息占满，如果MQ不能及时保存，也会导致消息丢失</strong><br>有两种解决方法：</p><ul><li>数据持久化</li><li>LazyQueue(推荐)</li></ul><h4 id="4-2-1-数据持久化"><a href="#4-2-1-数据持久化" class="headerlink" title="4.2.1 数据持久化"></a>4.2.1 数据持久化</h4><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>在控制台配置相关的持久化模式，即可开启数据持久化</p><h4 id="4-2-2-LazyQueue"><a href="#4-2-2-LazyQueue" class="headerlink" title="4.2.2 LazyQueue"></a>4.2.2 LazyQueue</h4><p>从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li><strong>接收到消息后直接存入磁盘而非内存</strong></li><li>消费者要<strong>消费消息时才会从磁盘中读取并加载到内存</strong>（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="4-3-消费者的可靠性"><a href="#4-3-消费者的可靠性" class="headerlink" title="4.3 消费者的可靠性"></a>4.3 消费者的可靠性</h3><p>消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li></ul><h4 id="4-3-1-消费者确认机制"><a href="#4-3-1-消费者确认机制" class="headerlink" title="4.3.1 消费者确认机制"></a>4.3.1 消费者确认机制</h4><p>消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p><img src="/img/blogs/java/springcloud/mq.10.png"></p><p>SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li>manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活</li><li>auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是业务异常，会自动返回nack；</li><li>如果是消息处理或校验异常，自动返回reject;</li></ul></li></ul><p>修改SpringAMQP的ACK处理方式:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">none</span> <span class="hljs-comment"># 不做处理</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-失败重试机制"><a href="#4-3-2-失败重试机制" class="headerlink" title="4.3.2 失败重试机制"></a>4.3.2 失败重试机制</h4><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。<br>极端情况就是消费者一直无法执行成功，那么<strong>消息requeue就会无限循环</strong>，导致mq的消息处理飙升，带来不必要的压力。</p><p>修改consumer服务的application.yml文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启消费者失败重试</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 初识的失败等待时长为1秒</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 最大重试次数</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span><br></code></pre></td></tr></table></figure><ul><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h4 id="4-3-3-失败处理策略"><a href="#4-3-3-失败处理策略" class="headerlink" title="4.3.3 失败处理策略"></a>4.3.3 失败处理策略</h4><p>Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由MessageRecovery接口来定义的，它有3个不同实现：</p><ul><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式 </li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队 </li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机 (推荐)</li></ul><ul><li>RepublishMessageRecoverer: 失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</li></ul><p>在consumer服务中定义处理失败消息的交换机和队列,定义一个RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorMessageConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">errorMessageExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;error.direct&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">errorQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;error.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">errorBinding</span><span class="hljs-params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MessageRecoverer <span class="hljs-title function_">republishMessageRecoverer</span><span class="hljs-params">(RabbitTemplate rabbitTemplate)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="hljs-string">&quot;error.direct&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-业务幂等性"><a href="#4-4-业务幂等性" class="headerlink" title="4.4 业务幂等性"></a>4.4 业务幂等性</h3><p>在程序开发中，则是指<strong>同一个业务，执行一次或多次对业务状态的影响是一致的</strong>。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据<br>数据的更新往往不是幂等的，如果<strong>重复执行可能造成不一样的后果</strong>。比如：</li><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><h4 id="4-4-1-唯一消息ID"><a href="#4-4-1-唯一消息ID" class="headerlink" title="4.4.1 唯一消息ID"></a>4.4.1 唯一消息ID</h4><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 1.定义消息转换器</span><br>    <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jjmc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    <span class="hljs-comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span><br>    jjmc.setCreateMessageIds(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> jjmc;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-业务判断"><a href="#4-4-2-业务判断" class="headerlink" title="4.4.2 业务判断"></a>4.4.2 业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息。<br>当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以<strong>在执行业务时判断订单状态是否是未支付</strong>，如果不是则证明订单已经被处理过，无需重复处理。</p><p><img src="/img/blogs/java/springcloud/mq.11.png"></p><p>以支付修改订单的业务为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">markOrderPaySuccess</span><span class="hljs-params">(Long orderId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询订单</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> getById(orderId);<br>    <span class="hljs-comment">// 2.判断订单状态</span><br>    <span class="hljs-keyword">if</span> (old == <span class="hljs-literal">null</span> || old.getStatus() != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 订单不存在或者订单状态不是1，放弃处理</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3.尝试更新订单</span><br>    <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>    order.setId(orderId);<br>    order.setStatus(<span class="hljs-number">2</span>);<br>    order.setPayTime(LocalDateTime.now());<br>    updateById(order);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-兜底方案"><a href="#4-5-兜底方案" class="headerlink" title="4.5 兜底方案"></a>4.5 兜底方案</h3><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>既然MQ通知不一定发送到交易服务，那么<strong>交易服务就必须自己主动去查询支付状态</strong>。这样即便支付服务的MQ通知失败，我们依然能<strong>通过主动查询来保证订单状态的一致</strong>。</p><p><img src="/img/blogs/java/springcloud/mq.12.png"></p><p>通常我们采取的措施就是利用<strong>定时任务定期查询</strong>，例如每隔20秒就查询一次，<strong>并判断支付状态</strong>。如果发现订单已经支付，则立刻更新订单状态为已支付即可。</p><h3 id="4-6-支付服务与交易服务之间的订单状态一致性是如何保证的？"><a href="#4-6-支付服务与交易服务之间的订单状态一致性是如何保证的？" class="headerlink" title="4.6 支付服务与交易服务之间的订单状态一致性是如何保证的？"></a>4.6 支付服务与交易服务之间的订单状态一致性是如何保证的？</h3><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h2 id="5-延迟消息"><a href="#5-延迟消息" class="headerlink" title="5. 延迟消息"></a>5. 延迟消息</h2><p>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存。像这种<strong>在一段时间以后才执行的任务，我们称之为延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件(推荐)</li></ul><h3 id="5-1-死信交换机"><a href="#5-1-死信交换机" class="headerlink" title="5.1 死信交换机"></a>5.1 死信交换机</h3><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p><img src="/img/blogs/java/springcloud/mq.13.png"></p><ul><li>利用 TTL 让消息在普通队列中延迟一段时间。</li><li>超时后，消息进入死信交换机，再转发到真正的目标队列。</li><li>消费者监听目标队列，延迟时间一到，才会收到消息。</li></ul><h3 id="5-2-DelayExchange插件-推荐"><a href="#5-2-DelayExchange插件-推荐" class="headerlink" title="5.2 DelayExchange插件(推荐)"></a>5.2 DelayExchange插件(推荐)</h3><p>RabbitMQ社区提供了一个延迟消息插件来实现相同的效果</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">插件下载地址</a></p><p><strong>声明延迟交换机</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span><br><span class="hljs-meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">        key = &quot;delay&quot;</span><br><span class="hljs-meta">))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送延迟消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPublisherDelayMessage</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.创建消息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, delayed message&quot;</span>;<br>    <span class="hljs-comment">// 2.发送消息，利用消息后置处理器添加消息头</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessagePostProcessor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">postProcessMessage</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> AmqpException &#123;<br>            <span class="hljs-comment">// 添加延迟消息属性</span><br>            message.getMessageProperties().setDelay(<span class="hljs-number">5000</span>);<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，不建议设置延迟时间过长的延迟消息。</li></ul><h3 id="5-3-超时订单问题"><a href="#5-3-超时订单问题" class="headerlink" title="5.3 超时订单问题"></a>5.3 超时订单问题</h3><p>用户下单完成后,发送15分钟延迟消息,在15分钟后接收消息,检查支付状态:</p><ul><li>已支付:更新订单状态为已支付</li><li>未支付:更新订单状态为关闭订单,恢复商品库存</li></ul><p><img src="/img/blogs/java/springcloud/mq.14.png"></p><p>参考文献：<a href="https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc">https://b11et3un53m.feishu.cn/wiki/OQH4weMbcimUSLkIzD6cCpN0nvc</a></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>SpringCloud</tag>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2025/03/05/JAVA/SpringCloud/Docker/"/>
    <url>/2025/03/05/JAVA/SpringCloud/Docker/</url>
    
    <content type="html"><![CDATA[<h1 align="center">Docker学习笔记</h1><h2 id="1-Docker介绍"><a href="#1-Docker介绍" class="headerlink" title="1. Docker介绍"></a>1. Docker介绍</h2><p>Docker本身包含一个后台服务，我们可以利用Docker命令告诉Docker服务，帮助我们快速部署指定的应用。Docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p><p><img src="/img/blogs/java/springcloud/docker.1.png"></p><h2 id="2-Docker常见命令"><a href="#2-Docker常见命令" class="headerlink" title="2. Docker常见命令"></a>2. Docker常见命令</h2><h3 id="2-1-常见命令"><a href="#2-1-常见命令" class="headerlink" title="2.1 常见命令"></a>2.1 常见命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker pull</td><td>拉取镜像</td></tr><tr><td>docker push</td><td>推送镜像到 Docker Registry</td></tr><tr><td>docker images</td><td>查看本地镜像</td></tr><tr><td>docker rmi</td><td>删除本地镜像</td></tr><tr><td>docker run</td><td>创建并运行容器（不能重复创建）</td></tr><tr><td>docker stop</td><td>停止指定容器</td></tr><tr><td>docker start</td><td>启动指定容器</td></tr><tr><td>docker restart</td><td>重新启动容器</td></tr><tr><td>docker rm</td><td>删除指定容器</td></tr><tr><td>docker ps</td><td>查看容器</td></tr><tr><td>docker logs</td><td>查看容器运行日志</td></tr><tr><td>docker exec</td><td>进入容器</td></tr><tr><td>docker save</td><td>保存镜像到本地压缩文件</td></tr><tr><td>docker load</td><td>加载本地压缩文件到镜像</td></tr><tr><td>docker inspect</td><td>查看容器详细信息</td></tr></tbody></table><p><img src="/img/blogs/java/springcloud/docker.2.png"></p><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span><br><br><span class="hljs-comment"># 第2步，拉取Nginx镜像</span><br>docker pull nginx<br><br><span class="hljs-comment"># 第3步，查看镜像</span><br>docker images<br><span class="hljs-comment"># 结果如下：</span><br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>nginx        latest    605c77e624dd   16 months ago   141MB<br>mysql        latest    3218b38490ce   17 months ago   516MB<br><br><span class="hljs-comment"># 第4步，创建并允许Nginx容器</span><br>docker run -d --name nginx -p 80:80 nginx<br><br><span class="hljs-comment"># 第5步，查看运行中容器</span><br>docker ps<br><span class="hljs-comment"># 也可以加格式化方式访问，格式会更加清爽</span><br>docker ps --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第6步，访问网页，地址：http://虚拟机地址</span><br><br><span class="hljs-comment"># 第7步，停止容器</span><br>docker stop nginx<br><br><span class="hljs-comment"># 第8步，查看所有容器</span><br>docker ps -a --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第9步，再次启动nginx容器</span><br>docker start nginx<br><br><span class="hljs-comment"># 第10步，再次查看容器</span><br>docker ps --format <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 第11步，查看容器详细信息</span><br>docker inspect nginx<br><br><span class="hljs-comment"># 第12步，进入容器,查看容器内目录</span><br>docker <span class="hljs-built_in">exec</span> -it nginx bash<br><span class="hljs-comment"># 或者，可以进入MySQL</span><br>docker <span class="hljs-built_in">exec</span> -it mysql mysql -uroot -p<br><br><span class="hljs-comment"># 第13步，删除容器</span><br>docker <span class="hljs-built_in">rm</span> nginx<br><span class="hljs-comment"># 发现无法删除，因为容器运行中，强制删除容器</span><br>docker <span class="hljs-built_in">rm</span> -f nginx<br></code></pre></td></tr></table></figure><h3 id="2-3-命令别名"><a href="#2-3-命令别名" class="headerlink" title="2.3 命令别名"></a>2.3 命令别名</h3><p>给常用Docker命令起别名，方便我们访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改/root/.bashrc文件</span><br>vi /root/.bashrc<br>内容如下：<br><span class="hljs-comment"># .bashrc</span><br><br><span class="hljs-comment"># User specific aliases and functions</span><br><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">rm</span>=<span class="hljs-string">&#x27;rm -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">cp</span>=<span class="hljs-string">&#x27;cp -i&#x27;</span><br><span class="hljs-built_in">alias</span> <span class="hljs-built_in">mv</span>=<span class="hljs-string">&#x27;mv -i&#x27;</span><br><span class="hljs-built_in">alias</span> dps=<span class="hljs-string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br><span class="hljs-built_in">alias</span> dis=<span class="hljs-string">&#x27;docker images&#x27;</span><br><br><span class="hljs-comment"># Source global definitions</span><br><span class="hljs-keyword">if</span> [ -f /etc/bashrc ]; <span class="hljs-keyword">then</span><br>        . /etc/bashrc<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>执行命令使别名生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /root/.bashrc<br></code></pre></td></tr></table></figure><h2 id="3-数据卷"><a href="#3-数据卷" class="headerlink" title="3. 数据卷"></a>3. 数据卷</h2><h3 id="3-1-数据卷介绍"><a href="#3-1-数据卷介绍" class="headerlink" title="3.1 数据卷介绍"></a>3.1 数据卷介绍</h3><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。<br><strong>数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁</strong></p><p><img src="/img/blogs/java/springcloud/docker.3.png"></p><ul><li>我们创建了两个数据卷：conf、html</li><li>Nginx容器内部的conf目录和html目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;conf&#x2F;_data目录和&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html&#x2F;_data目录<br>这样以来，容器内的conf和html目录就 与宿主机的conf和html目录关联起来，我们称为挂载。此时，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html&#x2F;_data就是在操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;_data目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</li></ul><h3 id="3-2-数据卷命令"><a href="#3-2-数据卷命令" class="headerlink" title="3.2 数据卷命令"></a>3.2 数据卷命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker volume create</td><td>创建数据卷</td></tr><tr><td>docker volume ls</td><td>查看所有数据卷</td></tr><tr><td>docker volume rm</td><td>删除指定数据卷</td></tr><tr><td>docker volume inspect</td><td>查看某个数据卷的详情</td></tr><tr><td>docker volume prune</td><td>清除数据卷</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span><br>docker run -d --name nginx -p 80:80 -v html:/usr/share/nginx/html nginx<br><br><span class="hljs-comment"># 2.然后查看数据卷</span><br>docker volume <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 结果</span><br>DRIVER    VOLUME NAME<br><span class="hljs-built_in">local</span>     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f<br><span class="hljs-built_in">local</span>     html<br><br><span class="hljs-comment"># 3.查看数据卷详情</span><br>docker volume inspect html<br><span class="hljs-comment"># 结果</span><br>[<br>    &#123;<br>        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,<br>        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br>        <span class="hljs-string">&quot;Labels&quot;</span>: null,<br>        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,<br>        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;html&quot;</span>,<br>        <span class="hljs-string">&quot;Options&quot;</span>: null,<br>        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span><br>    &#125;<br>]<br><br><span class="hljs-comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span><br>ll /var/lib/docker/volumes/html/_data<br><span class="hljs-comment"># 可以看到与nginx的html目录内容一样，结果如下：</span><br>总用量 8<br>-rw-r--r--. 1 root root 497 12月 28 2021 50x.html<br>-rw-r--r--. 1 root root 615 12月 28 2021 index.html<br><br><span class="hljs-comment"># 5.进入该目录，并随意修改index.html内容</span><br><span class="hljs-built_in">cd</span> /var/lib/docker/volumes/html/_data<br>vi index.html<br><br><span class="hljs-comment"># 6.打开页面，查看效果</span><br><br><span class="hljs-comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span><br>docker <span class="hljs-built_in">exec</span> -it nginx bash<br></code></pre></td></tr></table></figure><h3 id="3-3-挂载本地目录或文件"><a href="#3-3-挂载本地目录或文件" class="headerlink" title="3.3 挂载本地目录或文件"></a>3.3 挂载本地目录或文件</h3><p>数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载本地目录</span><br>-v 本地目录:容器内目录<br><span class="hljs-comment"># 挂载本地文件</span><br>-v 本地文件:容器内文件<br></code></pre></td></tr></table></figure><p>演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 1.删除原来的MySQL容器</span><br>docker <span class="hljs-built_in">rm</span> -f mysql<br><br><span class="hljs-comment"># 2.进入root目录</span><br><span class="hljs-built_in">cd</span> ~<br><br><span class="hljs-comment"># 3.创建并运行新mysql容器，挂载本地目录</span><br>docker run -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=123 \<br>  -v ./mysql/data:/var/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  mysql<br><br><span class="hljs-comment"># 4.查看root目录，可以发现~/mysql/data目录已经自动创建好了</span><br><span class="hljs-built_in">ls</span> -l mysql<br><span class="hljs-comment"># 结果：</span><br>总用量 4<br>drwxr-xr-x. 2 root    root   20 5月  19 15:11 conf<br>drwxr-xr-x. 7 polkitd root 4096 5月  19 15:11 data<br>drwxr-xr-x. 2 root    root   23 5月  19 15:11 init<br><br><span class="hljs-comment"># 查看data目录，会发现里面有大量数据库数据，说明数据库完成了初始化</span><br><span class="hljs-built_in">ls</span> -l data<br><br><span class="hljs-comment"># 5.查看MySQL容器内数据</span><br><span class="hljs-comment"># 5.1.进入MySQL</span><br>docker <span class="hljs-built_in">exec</span> -it mysql mysql -uroot -p123<br><span class="hljs-comment"># 5.2.查看编码表</span><br>show variables like <span class="hljs-string">&quot;%char%&quot;</span>;<br><span class="hljs-comment"># 5.3.结果，发现编码是utf8mb4没有问题</span><br>+--------------------------+--------------------------------+<br>| Variable_name            | Value                          |<br>+--------------------------+--------------------------------+<br>| character_set_client     | utf8mb4                        |<br>| character_set_connection | utf8mb4                        |<br>| character_set_database   | utf8mb4                        |<br>| character_set_filesystem | binary                         |<br>| character_set_results    | utf8mb4                        |<br>| character_set_server     | utf8mb4                        |<br>| character_set_system     | utf8mb3                        |<br>| character_sets_dir       | /usr/share/mysql-8.0/charsets/ |<br>+--------------------------+--------------------------------+<br><br><span class="hljs-comment"># 6.查看数据</span><br><span class="hljs-comment"># 6.1.查看数据库</span><br>show databases;<br><span class="hljs-comment"># 结果，hmall是黑马商城数据库</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| hmall              |<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>5 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br><span class="hljs-comment"># 6.2.切换到hmall数据库</span><br>use hmall;<br><span class="hljs-comment"># 6.3.查看表</span><br>show tables;<br><span class="hljs-comment"># 结果：</span><br>+-----------------+<br>| Tables_in_hmall |<br>+-----------------+<br>| address         |<br>| cart            |<br>| item            |<br>| order           |<br>| order_detail    |<br>| order_logistics |<br>| pay_order       |<br>| user            |<br>+-----------------+<br><span class="hljs-comment"># 6.4.查看address表数据</span><br>+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+<br>| <span class="hljs-built_in">id</span> | user_id | province | city   | town     | mobile      | street        | contact   | is_default | notes |<br>+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+<br>| 59 |       1 | 北京     | 北京   | 朝阳区    | 13900112222 | 金燕龙办公楼   | 李佳诚    | 0          | NULL  |<br>| 60 |       1 | 北京     | 北京   | 朝阳区    | 13700221122 | 修正大厦       | 李佳红    | 0          | NULL  |<br>| 61 |       1 | 上海     | 上海   | 浦东新区  | 13301212233 | 航头镇航头路   | 李佳星    | 1          | NULL  |<br>| 63 |       1 | 广东     | 佛山   | 永春      | 13301212233 | 永春武馆       | 李晓龙    | 0          | NULL  |<br>+----+---------+----------+--------+----------+-------------+---------------+-----------+------------+-------+<br>4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)<br><br></code></pre></td></tr></table></figure><h2 id="4-镜像"><a href="#4-镜像" class="headerlink" title="4. 镜像"></a>4. 镜像</h2><h3 id="4-1-构建自己的镜像"><a href="#4-1-构建自己的镜像" class="headerlink" title="4.1 构建自己的镜像"></a>4.1 构建自己的镜像</h3><p>我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><h3 id="4-2-Dockerfile"><a href="#4-2-Dockerfile" class="headerlink" title="4.2 Dockerfile"></a>4.2 Dockerfile</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td></tr><tr><td>ENV</td><td>设置环境变量，可在后面指令使用</td></tr><tr><td>COPY</td><td>拷贝本地文件到镜像的指定目录</td></tr><tr><td>RUN</td><td>执行 Linux 的 shell 命令，一般是安装过程的命令</td></tr><tr><td>EXPOSE</td><td>指定容器运行时监听的端口，是给镜像使用者看的</td></tr><tr><td>ENTRYPOINT</td><td>镜像中应用的启动命令，容器运行时调用</td></tr></tbody></table><p>有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基础镜像</span><br>FROM openjdk:11.0-jre-buster<br><span class="hljs-comment"># 设定时区</span><br>ENV TZ=Asia/Shanghai<br>RUN <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone<br><span class="hljs-comment"># 拷贝jar包</span><br>COPY docker-demo.jar /app.jar<br><span class="hljs-comment"># 入口</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="5-自定义网络"><a href="#5-自定义网络" class="headerlink" title="5. 自定义网络"></a>5. 自定义网络</h2><p>容器的网络IP其实是一个虚拟的IP，其值<strong>并不固定</strong>与某一个容器绑定</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker network create</td><td>创建一个网络</td></tr><tr><td>docker network ls</td><td>查看所有网络</td></tr><tr><td>docker network rm</td><td>删除指定网络</td></tr><tr><td>docker network prune</td><td>清除未使用的网络</td></tr><tr><td>docker network connect</td><td>使指定容器连接加入某网络</td></tr><tr><td>docker network disconnect</td><td>使指定容器连接离开某网络</td></tr><tr><td>docker network inspect</td><td>查看网络详细信息</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.首先通过命令创建一个网络</span><br>docker network create hmall<br><br><span class="hljs-comment"># 2.然后查看网络</span><br>docker network <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 结果：</span><br>NETWORK ID     NAME      DRIVER    SCOPE<br>639bc44d0a87   bridge    bridge    <span class="hljs-built_in">local</span><br>403f16ec62a2   hmall     bridge    <span class="hljs-built_in">local</span><br>0dc0f72a0fbb   host      host      <span class="hljs-built_in">local</span><br>cd8d3e8df47b   none      null      <span class="hljs-built_in">local</span><br><span class="hljs-comment"># 其中，除了hmall以外，其它都是默认的网络</span><br><br><span class="hljs-comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span><br><span class="hljs-comment"># 这样该网络内的其它容器可以用别名互相访问！</span><br><span class="hljs-comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span><br>docker network connect hmall mysql --<span class="hljs-built_in">alias</span> db<br><span class="hljs-comment"># 3.2.db容器，也就是我们的java项目</span><br>docker network connect hmall <span class="hljs-built_in">dd</span><br><br><span class="hljs-comment"># 4.进入dd容器，尝试利用别名访问db</span><br><span class="hljs-comment"># 4.1.进入容器</span><br>docker <span class="hljs-built_in">exec</span> -it <span class="hljs-built_in">dd</span> bash<br><span class="hljs-comment"># 4.2.用db别名访问</span><br>ping db<br><span class="hljs-comment"># 结果</span><br>PING db (172.18.0.2) 56(84) bytes of data.<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.070 ms<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.056 ms<br><span class="hljs-comment"># 4.3.用容器名访问</span><br>ping mysql<br><span class="hljs-comment"># 结果：</span><br>PING mysql (172.18.0.2) 56(84) bytes of data.<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 <span class="hljs-keyword">time</span>=0.044 ms<br>64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 <span class="hljs-keyword">time</span>=0.054 ms<br></code></pre></td></tr></table></figure><h2 id="6-DockerCompose"><a href="#6-DockerCompose" class="headerlink" title="6. DockerCompose"></a>6. DockerCompose</h2><p>Docker Compose可以帮助我们<strong>实现多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器。</p><p>部署mysql，可以使用docker-compose.yml进行部署</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.8&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./mysql/data:/var/lib/mysql&quot;</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">new</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">new:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">hmall</span><br></code></pre></td></tr></table></figure><p>基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose [OPTIONS] [COMMAND]<br></code></pre></td></tr></table></figure><table>  <thead>    <tr>      <th>类型</th>      <th>参数或指令</th>      <th>说明</th>    </tr>  </thead>  <tbody>    <tr>      <td rowspan="2">Options</td>      <td>-f</td>      <td>指定 compose 文件的路径和名称</td>    </tr>    <tr>      <td>-p</td>      <td>指定 project 名称。project 就是当前 compose 文件中设置的多个 service 的集合，是逻辑概念</td>    </tr>    <tr>     <td rowspan="9">Commands</td>      <td>up</td>      <td>创建并启动所有 service 容器</td>    </tr>    <tr>      <td>down</td>      <td>停止并移除所有容器、网络</td>    </tr>    <tr>      <td>ps</td>      <td>列出所有启动的容器</td>    </tr>    <tr>      <td>logs</td>      <td>查看指定容器的日志</td>    </tr>    <tr>      <td>stop</td>      <td>停止容器</td>    </tr>    <tr>      <td>start</td>      <td>启动容器</td>    </tr>    <tr>      <td>restart</td>      <td>重启容器</td>    </tr>    <tr>      <td>top</td>      <td>查看运行的进程</td>    </tr>    <tr>      <td>exec</td>      <td>在指定的运行中容器中执行命令</td>    </tr>  </tbody></table><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
      <tag>学习</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus学习笔记</title>
    <link href="/2025/03/05/JAVA/SpringCloud/MybatisPlus/"/>
    <url>/2025/03/05/JAVA/SpringCloud/MybatisPlus/</url>
    
    <content type="html"><![CDATA[<h1 align="center">MybatisPlus学习笔记</h1><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><p>实现步骤：</p><ul><li>引入MybatisPlus依赖</li><li>定义Mapper</li></ul><h3 id="1-1-引入依赖"><a href="#1-1-引入依赖" class="headerlink" title="1.1 引入依赖"></a>1.1 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-定义Mapper"><a href="#1-2-定义Mapper" class="headerlink" title="1.2 定义Mapper"></a>1.2 定义Mapper</h3><ul><li>MybatisPlus提供了一个基础的BaseMapper接口</li><li>修改mp-demo中的com.itheima.mp.mapper包下的UserMapper接口，让其继承BaseMapper：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-常见注解"><a href="#2-常见注解" class="headerlink" title="2. 常见注解"></a>2. 常见注解</h2><h3 id="2-1-默认情况"><a href="#2-1-默认情况" class="headerlink" title="2.1 默认情况"></a>2.1 默认情况</h3><p>MybatisPlus就是根据PO实体的信息来推断出表的信息，从而生成SQL的。默认情况下：</p><ul><li>MybatisPlus会把PO实体的类名驼峰转下划线作为表名</li><li>MybatisPlus会把PO实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为主键</li></ul><h3 id="2-2-TableName"><a href="#2-2-TableName" class="headerlink" title="2.2 @TableName"></a>2.2 @TableName</h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><h3 id="2-3-TableId"><a href="#2-3-TableId" class="headerlink" title="2.3 @TableId"></a>2.3 @TableId</h3><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><p>IdType属性的常见值：</p><ul><li>AUTO：利用数据库的id自增长</li><li>INPUT：手动生成id</li><li>ASSIGN_ID：雪花算法生成Long类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="2-4-TableField"><a href="#2-4-TableField" class="headerlink" title="2.4 @TableField"></a>2.4 @TableField</h3><p>普通字段注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField(is_married&quot;)</span><br>    <span class="hljs-keyword">private</span> Boolean isMarried;<br>    <span class="hljs-meta">@TableField(&quot;`concat`&quot;)</span><br>    <span class="hljs-keyword">private</span> String concat;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加@TableField注解的一些特殊情况：</p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以isXXX命名，按照JavaBean的规范，MybatisPlus识别字段时会把is去除，这就导致与数据库不符。</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用@TableField注解给字段名添加转义字符：&#96;&#96;</li></ul><h2 id="3-核心功能"><a href="#3-核心功能" class="headerlink" title="3. 核心功能"></a>3. 核心功能</h2><h3 id="3-1-条件构造器"><a href="#3-1-条件构造器" class="headerlink" title="3.1 条件构造器"></a>3.1 条件构造器</h3><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以id作为where条件以外，还支持更加复杂的where条件。</p><p>Wrapper就是条件构造的抽象类</p><p><img src="/img/blogs/java/springcloud/mp.1.png"></p><h4 id="3-1-1-QueryWrapper"><a href="#3-1-1-QueryWrapper" class="headerlink" title="3.1.1 QueryWrapper"></a>3.1.1 QueryWrapper</h4><p>查询：查询出名字中带o的，存款大于等于1000元的人。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>            .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>)<br>            .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 2.查询数据</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-UpdateWrapper"><a href="#3-1-2-UpdateWrapper" class="headerlink" title="3.1.2 UpdateWrapper"></a>3.1.2 UpdateWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateWrapper</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    <span class="hljs-comment">// 1.生成SQL</span><br>    UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;User&gt;()<br>            .setSql(<span class="hljs-string">&quot;balance = balance - 200&quot;</span>) <span class="hljs-comment">// SET balance = balance - 200</span><br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids); <span class="hljs-comment">// WHERE id in (1, 2, 4)</span><br>        <span class="hljs-comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span><br>    <span class="hljs-comment">// 而是基于UpdateWrapper中的setSQL来更新</span><br>    userMapper.update(<span class="hljs-literal">null</span>, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-LambdaQueryWrapper"><a href="#3-1-3-LambdaQueryWrapper" class="headerlink" title="3.1.3 LambdaQueryWrapper"></a>3.1.3 LambdaQueryWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLambdaQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.lambda()<br>            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(User::getBalance, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 2.查询</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-自定义SQL"><a href="#3-2-自定义SQL" class="headerlink" title="3.2 自定义SQL"></a>3.2 自定义SQL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testCustomWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.准备自定义查询条件</span><br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="hljs-string">&quot;id&quot;</span>, ids);<br><br>    <span class="hljs-comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span><br>    userMapper.deductBalanceByIds(<span class="hljs-number">200</span>, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在UserMapper中自定义SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>    <span class="hljs-meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductBalanceByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;money&quot;)</span> <span class="hljs-type">int</span> money, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Service接口"><a href="#3-3-Service接口" class="headerlink" title="3.3 Service接口"></a>3.3 Service接口</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，封装了一些常用的service模板方法。<br><strong>通用接口为IService</strong>，<strong>默认实现为ServiceImpl</strong>，其中封装的方法可以分为以下几类：</p><ul><li>save：新增</li><li>remove：删除</li><li>update：更新</li><li>get：查询单个结果</li><li>list：查询集合结果</li><li>count：计数</li><li>page：分页查询</li></ul><h4 id="3-3-2-基本用法"><a href="#3-3-2-基本用法" class="headerlink" title="3.3.2 基本用法"></a>3.3.2 基本用法</h4><p>自定义Service接口继承IService以拓展方法。同时，让自定义的Service实现类继承ServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;<br>    <span class="hljs-comment">// 拓展自定义方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编写UserServiceImpl类，继承ServiceImpl，实现UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-Lambda"><a href="#3-3-3-Lambda" class="headerlink" title="3.3.3 Lambda"></a>3.3.3 Lambda</h4><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductBalance</span><span class="hljs-params">(Long id, Integer money)</span> &#123;<br>    <span class="hljs-comment">// 1.查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 2.校验用户状态</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户状态异常！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.校验余额是否充足</span><br>    <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;用户余额不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.扣减余额 update tb_user set balance = balance - ?</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">remainBalance</span> <span class="hljs-operator">=</span> user.getBalance() - money;<br>    lambdaUpdate()<br>            .set(User::getBalance, remainBalance) <span class="hljs-comment">// 更新余额</span><br>            .set(remainBalance == <span class="hljs-number">0</span>, User::getStatus, <span class="hljs-number">2</span>) <span class="hljs-comment">// 动态判断，是否更新status</span><br>            .eq(User::getId, id)<br>            .eq(User::getBalance, user.getBalance()) <span class="hljs-comment">// 乐观锁</span><br>            .update();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-扩展功能"><a href="#4-扩展功能" class="headerlink" title="4. 扩展功能"></a>4. 扩展功能</h2><h3 id="4-1-代码生成"><a href="#4-1-代码生成" class="headerlink" title="4.1 代码生成"></a>4.1 代码生成</h3><p>使用MybatisX插件即可</p><p><a href="https://blog.csdn.net/weixin_47025166/article/details/125362323">SpringBoot中MybatisX插件的简单使用教程（超详细！！）</a></p><h3 id="4-2-静态工具"><a href="#4-2-静态工具" class="headerlink" title="4.2 静态工具"></a>4.2 静态工具</h3><p>有的时候<strong>Service之间也会相互调用</strong>，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：Db，其中的一些静态方法与IService中方法签名基本一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserVO <span class="hljs-title function_">queryUserAndAddressById</span><span class="hljs-params">(Long userId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getById(userId);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.查询收货地址</span><br>    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class)<br>            .eq(Address::getUserId, userId)<br>            .list();<br>    <span class="hljs-comment">// 3.处理vo</span><br>    <span class="hljs-type">UserVO</span> <span class="hljs-variable">userVO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserVO.class);<br>    userVO.setAddresses(BeanUtil.copyToList(addresses, AddressVO.class));<br>    <span class="hljs-keyword">return</span> userVO;<br>&#125;<br></code></pre></td></tr></table></figure><p>在查询地址时，我们采用了Db的静态方法，因此避免了注入AddressService，减少了循环依赖的风险。</p><h3 id="4-3-逻辑删除"><a href="#4-3-逻辑删除" class="headerlink" title="4.3 逻辑删除"></a>4.3 逻辑删除</h3><p>对于一些比较重要的数据，我们不删除数据库中的数据，而是</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li></ul><p>我们要在application.yml中配置逻辑删除字段</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span> <span class="hljs-comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span><br>      <span class="hljs-attr">logic-delete-value:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 逻辑已删除值(默认为 1)</span><br>      <span class="hljs-attr">logic-not-delete-value:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 逻辑未删除值(默认为 0)</span><br></code></pre></td></tr></table></figure><h3 id="4-4-枚举处理器"><a href="#4-4-枚举处理器" class="headerlink" title="4.4 枚举处理器"></a>4.4 枚举处理器</h3><p>MybatisPlus提供了一个处理枚举的类型转换器，可以帮我们把<strong>枚举类型与数据库类型自动转换</strong></p><h4 id="4-4-1-定义枚举"><a href="#4-4-1-定义枚举" class="headerlink" title="4.4.1 定义枚举"></a>4.4.1 定义枚举</h4><p><img src="/img/blogs/java/springcloud/mp.2.png"></p><h4 id="4-4-2-EnumValue"><a href="#4-4-2-EnumValue" class="headerlink" title="4.4.2 @EnumValue"></a>4.4.2 @EnumValue</h4><p>MybatisPlus提供了@EnumValue注解来标记枚举属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnumValue</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br></code></pre></td></tr></table></figure><p>表示value字段的值是数据库值</p><h4 id="4-4-3-配置枚举处理器"><a href="#4-4-3-配置枚举处理器" class="headerlink" title="4.4.3 配置枚举处理器"></a>4.4.3 配置枚举处理器</h4><p>在application.yaml文件中添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br></code></pre></td></tr></table></figure><h3 id="4-5-JSON类型处理器"><a href="#4-5-JSON类型处理器" class="headerlink" title="4.5 JSON类型处理器"></a>4.5 JSON类型处理器</h3><p>数据库的user表中有一个info字段，是JSON类型。而目前User实体类中却是String类型。处理JSON就可以使用JacksonTypeHandler处理器</p><p><strong>使用类型处理器</strong><br>将User类的info字段修改为UserInfo类型，并声明类型处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(typeHandler = JacksonTypeHandler.class)</span><br><span class="hljs-keyword">private</span> UserInfo info;<br></code></pre></td></tr></table></figure><h2 id="5-插件功能-以分页插件为例"><a href="#5-插件功能-以分页插件为例" class="headerlink" title="5. 插件功能(以分页插件为例)"></a>5. 插件功能(以分页插件为例)</h2><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。</p><ul><li>PaginationInnerInterceptor：自动分页</li><li>TenantLineInnerInterceptor：多租户</li><li>DynamicTableNameInnerInterceptor：动态表名</li><li>OptimisticLockerInnerInterceptor：乐观锁</li><li>IllegalSQLInnerInterceptor：sql 性能规范</li><li>BlockAttackInnerInterceptor：防止全表更新与删除</li></ul><h3 id="5-1-配置分页插件"><a href="#5-1-配置分页插件" class="headerlink" title="5.1 配置分页插件"></a>5.1 配置分页插件</h3><p>在项目中新建一个配置类：MybatisConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化核心插件</span><br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">// 添加分页插件</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-分页查询的测试"><a href="#5-2-分页查询的测试" class="headerlink" title="5.2 分页查询的测试"></a>5.2 分页查询的测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPageQuery</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span><br>    Page&lt;User&gt; p = userService.page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 2.总条数</span><br>    System.out.println(<span class="hljs-string">&quot;total = &quot;</span> + p.getTotal());<br>    <span class="hljs-comment">// 3.总页数</span><br>    System.out.println(<span class="hljs-string">&quot;pages = &quot;</span> + p.getPages());<br>    <span class="hljs-comment">// 4.数据</span><br>    List&lt;User&gt; records = p.getRecords();<br>    records.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>SpringCloud</tag>
      
      <tag>MybatisPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苍穹外卖学习笔记(跳过微信支付)</title>
    <link href="/2025/03/03/JAVA/CangqiongTakeout/"/>
    <url>/2025/03/03/JAVA/CangqiongTakeout/</url>
    
    <content type="html"><![CDATA[<h1 align="center">苍穹外卖学习笔记</h1><h1 id="一-项目概述、环境搭建"><a href="#一-项目概述、环境搭建" class="headerlink" title="一. 项目概述、环境搭建"></a>一. 项目概述、环境搭建</h1><h2 id="1-软件开发整体流程"><a href="#1-软件开发整体流程" class="headerlink" title="1. 软件开发整体流程"></a>1. 软件开发整体流程</h2><ol><li><strong>需求分析</strong>: 需求规格说明书、产品原型</li><li><strong>设计</strong>: UI设计、数据库设计、接口设计</li><li><strong>编码</strong>: 项目代码、单元测试</li><li><strong>测试</strong>: 测试用例、测试报告</li><li><strong>上线运维</strong>: 软件环境安装、配置</li></ol><h2 id="2-技术选型"><a href="#2-技术选型" class="headerlink" title="2. 技术选型"></a>2. 技术选型</h2><p>项目中使用到的技术框架和中间件<br><img src="/img/blogs/java/cangqiongtakeout/1.2.1.png"></p><h2 id="3-开发环境搭建"><a href="#3-开发环境搭建" class="headerlink" title="3. 开发环境搭建"></a>3. 开发环境搭建</h2><h3 id="3-1-前端环境搭建-nginx"><a href="#3-1-前端环境搭建-nginx" class="headerlink" title="3.1 前端环境搭建(nginx)"></a>3.1 前端环境搭建(nginx)</h3><p>前端我们就不自己写代码了<br>直接打开<strong>nginx.exe</strong>运行，打开<code>localhost:80</code>端口访问前端页面</p><h3 id="3-2-后端环境搭建"><a href="#3-2-后端环境搭建" class="headerlink" title="3.2 后端环境搭建"></a>3.2 后端环境搭建</h3><h4 id="3-2-1-熟悉项目结构"><a href="#3-2-1-熟悉项目结构" class="headerlink" title="3.2.1 熟悉项目结构"></a>3.2.1 熟悉项目结构</h4><ul><li>后端工程基于<strong>maven</strong>进行项目构建，并且进行<strong>分模块</strong>开发</li><li>用idea打开<code>sky-take-out</code>工程</li></ul><p><img src="/img/blogs/java/cangqiongtakeout/1.3.1.png"></p><table><thead><tr><th>序号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>sky-take-out</td><td>maven父工程，统一管理依赖版本，聚合其他子模块</td></tr><tr><td>2</td><td>sky-common</td><td>子模块，存放公共类，例如：工具类、常量类、异常类等</td></tr><tr><td>3</td><td>sky-pojo</td><td>子模块，存放实体类、VO、DTO等</td></tr><tr><td>4</td><td>sky-server</td><td>子模块，后端服务，存放配置文件、Controller、Service、Mapper等</td></tr></tbody></table><p><img src="/img/blogs/java/cangqiongtakeout/1.3.2.png"></p><p><img src="/img/blogs/java/cangqiongtakeout/1.3.3.png"></p><p><img src="/img/blogs/java/cangqiongtakeout/1.3.4.png"></p><h4 id="3-2-2-使用Git进行版本控制"><a href="#3-2-2-使用Git进行版本控制" class="headerlink" title="3.2.2 使用Git进行版本控制"></a>3.2.2 使用Git进行版本控制</h4><p><a href="https://blog.csdn.net/m0_68356693/article/details/145806694?spm=1001.2014.3001.5501">Git学习笔记</a></p><h5 id="3-2-2-1-创建本地仓库"><a href="#3-2-2-1-创建本地仓库" class="headerlink" title="3.2.2.1 创建本地仓库"></a>3.2.2.1 创建本地仓库</h5><ul><li>点击菜单-VCS-Create Git Repository-找到当前项目目录-点击OK</li><li>将本地文件全部提交到本地仓库(commit)</li></ul><h5 id="3-2-2-2-创建远程仓库"><a href="#3-2-2-2-创建远程仓库" class="headerlink" title="3.2.2.2 创建远程仓库"></a>3.2.2.2 创建远程仓库</h5><p>打开Gitee，点击加号创建远程仓库</p><h5 id="3-2-2-3-将本地文件推送到Git远程仓库"><a href="#3-2-2-3-将本地文件推送到Git远程仓库" class="headerlink" title="3.2.2.3 将本地文件推送到Git远程仓库"></a>3.2.2.3 将本地文件推送到Git远程仓库</h5><p>点击push,输入远程仓库url，输入账号密码，成功push</p><h4 id="3-2-3-数据库环境搭建"><a href="#3-2-3-数据库环境搭建" class="headerlink" title="3.2.3 数据库环境搭建"></a>3.2.3 数据库环境搭建</h4><p>记得在命令行中打开mysql连接：<code>net start mysql</code><br>在navicat打开sql文件，运行创建数据库内容<br><a href="https://blog.csdn.net/tkf021004/article/details/136098343">navicat运行sql文件</a></p><h4 id="3-2-4-前后端联调"><a href="#3-2-4-前后端联调" class="headerlink" title="3.2.4 前后端联调"></a>3.2.4 前后端联调</h4><p><img src="/img/blogs/java/cangqiongtakeout/1.3.5.png"></p><p><strong>nginx反向代理</strong>:就是将前端发送的动态请求由nginx转发到后端服务器</p><p><img src="/img/blogs/java/cangqiongtakeout/1.3.6.png"></p><h3 id="3-3-完善登录功能"><a href="#3-3-完善登录功能" class="headerlink" title="3.3 完善登录功能"></a>3.3 完善登录功能</h3><p>使用md5加密算法将明文123456加密:<code>e10adc3949ba59abbe56e057f20f883e</code></p><ul><li>数据库中修改管理员密码</li><li>java代码修改密码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">password = DigestUtils.md5DigestAsHex(password.getBytes());<br></code></pre></td></tr></table></figure><h2 id="4-导入接口文档"><a href="#4-导入接口文档" class="headerlink" title="4. 导入接口文档"></a>4. 导入接口文档</h2><p>使用Apifox-导入-选择YApi-将json文件导入</p><h2 id="5-Swagger"><a href="#5-Swagger" class="headerlink" title="5. Swagger"></a>5. Swagger</h2><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table><h1 id="二-员工管理、分类管理"><a href="#二-员工管理、分类管理" class="headerlink" title="二. 员工管理、分类管理"></a>二. 员工管理、分类管理</h1><h2 id="1-新增员工"><a href="#1-新增员工" class="headerlink" title="1. 新增员工"></a>1. 新增员工</h2><h3 id="1-1-员工的DTO类-EmployeeDTO"><a href="#1-1-员工的DTO类-EmployeeDTO" class="headerlink" title="1.1 员工的DTO类(EmployeeDTO)"></a>1.1 员工的DTO类(EmployeeDTO)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.dto;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String phone;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> String idNumber;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Controller层"><a href="#1-2-Controller层" class="headerlink" title="1.2 Controller层"></a>1.2 Controller层</h3><p>在EmployeeController中<strong>创建新增员工方法</strong>，接收前端提交的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//package com.sky.controller.admin.EmployeeController;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增员工</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeeDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-meta">@ApiOperation(&quot;新增员工&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;新增员工：&#123;&#125;&quot;</span>,employeeDTO);<br>    employeeService.save(employeeDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Service层"><a href="#1-3-Service层" class="headerlink" title="1.3 Service层"></a>1.3 Service层</h3><h4 id="1-3-1-Service层接口"><a href="#1-3-1-Service层接口" class="headerlink" title="1.3.1 Service层接口"></a>1.3.1 Service层接口</h4><p><strong>在EmployeeService接口中声明新增员工方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package com.sky.server.EmployeeService;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增员工</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeeDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(EmployeeDTO employeeDTO)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-Service层实现类"><a href="#1-3-2-Service层实现类" class="headerlink" title="1.3.2 Service层实现类"></a>1.3.2 Service层实现类</h4><p><strong>在EmployeeServiceImpl中实现新增员工方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//package com.sky.server.impl.EmployeeServiceImpl;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增员工</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeeDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(EmployeeDTO employeeDTO)</span> &#123;<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br><br>    <span class="hljs-comment">//对象属性拷贝</span><br>    BeanUtils.copyProperties(employeeDTO, employee);<br><br>    <span class="hljs-comment">//设置账号的状态，默认正常状态 1表示正常 0表示锁定</span><br>    employee.setStatus(StatusConstant.ENABLE);<br><br>    <span class="hljs-comment">//设置密码，默认密码123456</span><br>    employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));<br><br>    <span class="hljs-comment">//设置当前记录的创建时间和修改时间</span><br>    employee.setCreateTime(LocalDateTime.now());<br>    employee.setUpdateTime(LocalDateTime.now());<br><br>    <span class="hljs-comment">//设置当前记录创建人id和修改人id</span><br>    employee.setCreateUser(BaseContext.getCurrentId());<br>    employee.setUpdateUser(BaseContext.getCurrentId());<br><br>    employeeMapper.insert(employee);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-Mapper层"><a href="#1-4-Mapper层" class="headerlink" title="1.4 Mapper层"></a>1.4 Mapper层</h3><p><strong>在EmployeeMapper中声明insert方法</strong></p><p>中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//package com.sky.EmployeeMapper;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 插入员工数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employee</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user,status) &quot; +</span><br><span class="hljs-meta">        &quot;values &quot; +</span><br><span class="hljs-meta">        &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;,#&#123;status&#125;)&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-5-处理SQL异常抛出"><a href="#1-5-处理SQL异常抛出" class="headerlink" title="1.5 处理SQL异常抛出"></a>1.5 处理SQL异常抛出</h3><ul><li><strong>问题</strong>：当录入的用户名已经存在时，抛出的异常后没有处理</li><li><strong>原因</strong>：username已经添加了唯一约束，不能重复</li><li><strong>解决方案</strong>：通过全局异常处理器处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//package com.sky.handler.GlobalExceptionHandler;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理SQL异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ex</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ExceptionHandler</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">exceptionHandler</span><span class="hljs-params">(SQLIntegrityConstraintViolationException ex)</span>&#123;<br>    <span class="hljs-comment">//Duplicate entry &#x27;zhangsan&#x27; for key &#x27;employee.idx_username&#x27;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> ex.getMessage();<br>    <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;Duplicate entry&quot;</span>))&#123;<br>        String[] split = message.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> split[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> username + MessageConstant.ALREADY_EXISTS;<br>        <span class="hljs-keyword">return</span> Result.error(msg);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> Result.error(MessageConstant.UNKNOWN_ERROR);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后定义添加相应的消息常量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//package com.sky.constant.MessageConstant;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ALREADY_EXISTS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;已存在&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="1-6-ThreadLocal"><a href="#1-6-ThreadLocal" class="headerlink" title="1.6 ThreadLocal"></a>1.6 ThreadLocal</h3><ul><li>ThreadLocal 并不是一个Thread，而是<strong>Thread的局部变量</strong>。</li><li>ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</li></ul><p><strong>常用方法</strong></p><table><thead><tr><th>常用方法</th><th>作用</th></tr></thead><tbody><tr><td>public void set(T value)</td><td>设置当前线程的线程局部变量的值</td></tr><tr><td>public T get()</td><td>返回当前线程所对应的线程局部变量的值</td></tr><tr><td>public void remove()</td><td>移除当前线程的线程局部变量</td></tr></tbody></table><h3 id="1-7-获取当前登录员工的ID"><a href="#1-7-获取当前登录员工的ID" class="headerlink" title="1.7 获取当前登录员工的ID"></a>1.7 获取当前登录员工的ID</h3><ul><li><strong>问题</strong>：员工登录成功后会生成JWT令牌并响应给前端。后续请求中，前端会携带JWT令牌，通过JWT令牌可以解析出当前登录员工id：</li><li><strong>解决方案</strong>：通过ThreadLocal进行传递。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//package com.sky.interceptor.JwtTokenAdminInterceptor;</span><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenAdminInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><span class="hljs-comment">//.............................</span><br>        <span class="hljs-comment">//2、校验令牌</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//.................</span><br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">empId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());<br>            log.info(<span class="hljs-string">&quot;当前员工id：&quot;</span>, empId);<br>            <span class="hljs-comment">/////将用户id存储到ThreadLocal////////</span><br>            BaseContext.setCurrentId(empId);<br>            <span class="hljs-comment">////////////////////////////////////</span><br>            <span class="hljs-comment">//3、通过，放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-comment">//......................</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-员工分页查询"><a href="#2-员工分页查询" class="headerlink" title="2. 员工分页查询"></a>2. 员工分页查询</h2><h3 id="2-1-员工分页查询的DTO"><a href="#2-1-员工分页查询的DTO" class="headerlink" title="2.1 员工分页查询的DTO"></a>2.1 员工分页查询的DTO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.dto;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeePageQueryDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">//员工姓名</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">//页码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> page;<br><br>    <span class="hljs-comment">//每页显示记录数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageSize;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Controller层"><a href="#2-2-Controller层" class="headerlink" title="2.2 Controller层"></a>2.2 Controller层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package com.sky.controller.admin.EmployeeController;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 员工分页查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeePageQueryDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;员工分页查询&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;PageResult&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(EmployeePageQueryDTO employeePageQueryDTO)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;员工分页查询，参数为：&#123;&#125;&quot;</span>, employeePageQueryDTO);<br>    <span class="hljs-type">PageResult</span> <span class="hljs-variable">pageResult</span> <span class="hljs-operator">=</span> employeeService.pageQuery(employeePageQueryDTO);<span class="hljs-comment">//后续定义</span><br>    <span class="hljs-keyword">return</span> Result.success(pageResult);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-Service层"><a href="#2-3-Service层" class="headerlink" title="2.3 Service层"></a>2.3 Service层</h3><h4 id="2-3-1-Service层接口"><a href="#2-3-1-Service层接口" class="headerlink" title="2.3.1 Service层接口"></a>2.3.1 Service层接口</h4><p>在EmployeeService接口中声明pageQuery方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeePageQueryDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>PageResult <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(EmployeePageQueryDTO employeePageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-Service层实现类"><a href="#2-3-2-Service层实现类" class="headerlink" title="2.3.2 Service层实现类"></a>2.3.2 Service层实现类</h4><p>在EmployeeServiceImpl中实现pageQuery方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页查询</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeePageQueryDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;<br>    <span class="hljs-comment">// select * from employee limit 0,10</span><br>    <span class="hljs-comment">//开始分页查询</span><br>    PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());<br><br>    Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> page.getTotal();<br>    List&lt;Employee&gt; records = page.getResult();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(total, records);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Mapper层"><a href="#2-4-Mapper层" class="headerlink" title="2.4 Mapper层"></a>2.4 Mapper层</h3><p>在 EmployeeMapper 中声明 pageQuery 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeePageQueryDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>Page&lt;Employee&gt; <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(EmployeePageQueryDTO employeePageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><p>在 src&#x2F;main&#x2F;resources&#x2F;mapper&#x2F;EmployeeMapper.xml 中编写SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">select</span> id<span class="hljs-operator">=</span>&quot;pageQuery&quot; resultType<span class="hljs-operator">=</span>&quot;com.sky.entity.Employee&quot;<span class="hljs-operator">&gt;</span><br>        <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee<br>        <span class="hljs-operator">&lt;</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;name != null and name != &#x27;&#x27;&quot;<span class="hljs-operator">&gt;</span><br>                <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span> concat(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;name&#125;,<span class="hljs-string">&#x27;%&#x27;</span>)<br>            <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> create_time <span class="hljs-keyword">desc</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-5-日期格式化"><a href="#2-5-日期格式化" class="headerlink" title="2.5 日期格式化"></a>2.5 日期格式化</h3><ul><li><strong>问题</strong>：操作时间字段显示有问题。前端显示的时间格式不标准</li><li><strong>解决方案</strong>：在WebMvcConfiguration中扩展SpringMVC的消息转换器，统一对日期类型进行格式处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扩展Spring MVC框架的消息转化器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> converters</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extendMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;扩展消息转换器...&quot;</span>);<br>    <span class="hljs-comment">//创建一个消息转换器对象</span><br>    <span class="hljs-type">MappingJackson2HttpMessageConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>();<br>    <span class="hljs-comment">//需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据</span><br>    converter.setObjectMapper(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonObjectMapper</span>());<br>    <span class="hljs-comment">//将自己的消息转化器加入容器中</span><br>    converters.add(<span class="hljs-number">0</span>,converter);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-启用禁用员工账号"><a href="#3-启用禁用员工账号" class="headerlink" title="3. 启用禁用员工账号"></a>3. 启用禁用员工账号</h2><h3 id="3-1-Controller层"><a href="#3-1-Controller层" class="headerlink" title="3.1 Controller层"></a>3.1 Controller层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package com.sky.controller.admin.EmployeeController;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启用禁用员工账号</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;启用禁用员工账号&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status,Long id)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;启用禁用员工账号：&#123;&#125;,&#123;&#125;&quot;</span>,status,id);<br>    employeeService.startOrStop(status,id);<span class="hljs-comment">//后绪步骤定义</span><br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Service层"><a href="#3-2-Service层" class="headerlink" title="3.2 Service层"></a>3.2 Service层</h3><h4 id="3-2-1-Service层接口"><a href="#3-2-1-Service层接口" class="headerlink" title="3.2.1 Service层接口"></a>3.2.1 Service层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//package com.sky.service.EmployeeService;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 启用禁用员工账号</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(Integer status, Long id)</span>;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-Service层实现类"><a href="#3-2-2-Service层实现类" class="headerlink" title="3.2.2 Service层实现类"></a>3.2.2 Service层实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//package com.sky.service.impl.EmployeeServiceImpl;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 启用禁用员工账号</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(Integer status, Long id)</span> &#123;<br>       <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> Employee.builder()<br>               .status(status)<br>               .id(id)<br>               .build();<br><br>       employeeMapper.update(employee);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Mapper层"><a href="#3-3-Mapper层" class="headerlink" title="3.3 Mapper层"></a>3.3 Mapper层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//package com.sky.mapper.EmployeeMapper;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据主键动态修改属性</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> employee</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Employee employee)</span>;<br></code></pre></td></tr></table></figure><p>在 EmployeeMapper.xml 中编写SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-keyword">update</span> id<span class="hljs-operator">=</span>&quot;update&quot; parameterType<span class="hljs-operator">=</span>&quot;Employee&quot;<span class="hljs-operator">&gt;</span><br>        <span class="hljs-keyword">update</span> employee<br>        <span class="hljs-operator">&lt;</span><span class="hljs-keyword">set</span><span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;name != null&quot;<span class="hljs-operator">&gt;</span>name <span class="hljs-operator">=</span> #&#123;name&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;username != null&quot;<span class="hljs-operator">&gt;</span>username <span class="hljs-operator">=</span> #&#123;username&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;password != null&quot;<span class="hljs-operator">&gt;</span>password <span class="hljs-operator">=</span> #&#123;password&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;phone != null&quot;<span class="hljs-operator">&gt;</span>phone <span class="hljs-operator">=</span> #&#123;phone&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;sex != null&quot;<span class="hljs-operator">&gt;</span>sex <span class="hljs-operator">=</span> #&#123;sex&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;idNumber != null&quot;<span class="hljs-operator">&gt;</span>id_Number <span class="hljs-operator">=</span> #&#123;idNumber&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;updateTime != null&quot;<span class="hljs-operator">&gt;</span>update_Time <span class="hljs-operator">=</span> #&#123;updateTime&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;updateUser != null&quot;<span class="hljs-operator">&gt;</span>update_User <span class="hljs-operator">=</span> #&#123;updateUser&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>            <span class="hljs-operator">&lt;</span>if test<span class="hljs-operator">=</span>&quot;status != null&quot;<span class="hljs-operator">&gt;</span>status <span class="hljs-operator">=</span> #&#123;status&#125;,<span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>if<span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">set</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> #&#123;id&#125;<br>    <span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">update</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-编辑员工"><a href="#4-编辑员工" class="headerlink" title="4. 编辑员工"></a>4. 编辑员工</h2><h3 id="4-1-回显员工信息功能"><a href="#4-1-回显员工信息功能" class="headerlink" title="4.1 回显员工信息功能"></a>4.1 回显员工信息功能</h3><h4 id="4-1-1-Controller层"><a href="#4-1-1-Controller层" class="headerlink" title="4.1.1 Controller层"></a>4.1.1 Controller层</h4><p>在 EmployeeController 中创建 getById 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id查询员工信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;根据id查询员工信息&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;Employee&gt; <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>       <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeService.getById(id);<br>       <span class="hljs-keyword">return</span> Result.success(employee);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-Service层"><a href="#4-1-2-Service层" class="headerlink" title="4.1.2 Service层"></a>4.1.2 Service层</h4><h5 id="4-1-2-1-Service层接口"><a href="#4-1-2-1-Service层接口" class="headerlink" title="4.1.2.1 Service层接口"></a>4.1.2.1 Service层接口</h5><p>在 EmployeeService 接口中声明 getById 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id查询员工</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>Employee <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h5 id="4-1-2-2-Service层实现类"><a href="#4-1-2-2-Service层实现类" class="headerlink" title="4.1.2.2 Service层实现类"></a>4.1.2.2 Service层实现类</h5><p>在 EmployeeServiceImpl 中实现 getById 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id查询员工</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.getById(id);<br>    employee.setPassword(<span class="hljs-string">&quot;****&quot;</span>);<br>    <span class="hljs-keyword">return</span> employee;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-Mapper层"><a href="#4-1-3-Mapper层" class="headerlink" title="4.1.3 Mapper层"></a>4.1.3 Mapper层</h4><p>在 EmployeeMapper 接口中声明 getById 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id查询员工信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)</span><br>Employee <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-2-修改员工信息功能"><a href="#4-2-修改员工信息功能" class="headerlink" title="4.2 修改员工信息功能"></a>4.2 修改员工信息功能</h3><h4 id="4-2-1-Controller层"><a href="#4-2-1-Controller层" class="headerlink" title="4.2.1 Controller层"></a>4.2.1 Controller层</h4><p>在 EmployeeController 中创建 update 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编辑员工信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeeDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping</span><br><span class="hljs-meta">@ApiOperation(&quot;编辑员工信息&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;编辑员工信息：&#123;&#125;&quot;</span>, employeeDTO);<br>    employeeService.update(employeeDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-2-Service层"><a href="#4-2-2-Service层" class="headerlink" title="4.2.2 Service层"></a>4.2.2 Service层</h4><h5 id="4-2-2-1-Service层接口"><a href="#4-2-2-1-Service层接口" class="headerlink" title="4.2.2.1 Service层接口"></a>4.2.2.1 Service层接口</h5><p>在 EmployeeService 接口中声明 update 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编辑员工信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeeDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(EmployeeDTO employeeDTO)</span>;<br></code></pre></td></tr></table></figure><h5 id="4-2-2-2-Service层实现类"><a href="#4-2-2-2-Service层实现类" class="headerlink" title="4.2.2.2 Service层实现类"></a>4.2.2.2 Service层实现类</h5><p>在 EmployeeServiceImpl 中实现 update 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 编辑员工信息</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> employeeDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(EmployeeDTO employeeDTO)</span> &#123;<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br>    BeanUtils.copyProperties(employeeDTO, employee);<br><br>    employee.setUpdateTime(LocalDateTime.now());<br>    employee.setUpdateUser(BaseContext.getCurrentId());<br><br>    employeeMapper.update(employee);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-3-Mapper层"><a href="#4-2-3-Mapper层" class="headerlink" title="4.2.3 Mapper层"></a>4.2.3 Mapper层</h4><p>在实现<strong>启用禁用员工账号</strong>功能时，已实现employeeMapper.update(employee)，在此不需写Mapper层代码。</p><h2 id="5-菜品分类和套餐分类"><a href="#5-菜品分类和套餐分类" class="headerlink" title="5. 菜品分类和套餐分类"></a>5. 菜品分类和套餐分类</h2><p>直接导入相应代码工程</p><h1 id="三-菜品管理"><a href="#三-菜品管理" class="headerlink" title="三. 菜品管理"></a>三. 菜品管理</h1><h2 id="1-公共字段自动填充"><a href="#1-公共字段自动填充" class="headerlink" title="1. 公共字段自动填充"></a>1. 公共字段自动填充</h2><h3 id="1-1-实现思路"><a href="#1-1-实现思路" class="headerlink" title="1.1 实现思路"></a>1.1 实现思路</h3><p><strong>实现步骤</strong>：</p><ol><li>自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法</li><li>自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值</li><li>在 Mapper 的方法上加入 AutoFill 注解</li></ol><p><strong>技术点</strong>：枚举、注解、AOP、反射</p><h3 id="1-2-自定义注解-AutoFill"><a href="#1-2-自定义注解-AutoFill" class="headerlink" title="1.2 自定义注解 AutoFill"></a>1.2 自定义注解 AutoFill</h3><p>进入到sky-server模块，创建com.sky.annotation包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.annotation;<br><br><span class="hljs-keyword">import</span> com.sky.enumeration.OperationType;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFill &#123;<br>    <span class="hljs-comment">//数据库操作类型：UPDATE INSERT</span><br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-自定义切面-AutoFillAspect"><a href="#1-3-自定义切面-AutoFillAspect" class="headerlink" title="1.3 自定义切面 AutoFillAspect"></a>1.3 自定义切面 AutoFillAspect</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.aspect;<br><br><span class="hljs-keyword">import</span> com.sky.annotation.AutoFill;<br><span class="hljs-keyword">import</span> com.sky.constant.AutoFillConstant;<br><span class="hljs-keyword">import</span> com.sky.context.BaseContext;<br><span class="hljs-keyword">import</span> com.sky.enumeration.OperationType;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.MethodSignature;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义切面，实现公共字段自动填充处理逻辑</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 切入点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前置通知，在通知中进行公共字段的赋值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始进行公共字段自动填充...&quot;</span>);<br><br>        <span class="hljs-comment">//获取到当前被拦截的方法上的数据库操作类型</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="hljs-comment">//方法签名对象</span><br>        <span class="hljs-type">AutoFill</span> <span class="hljs-variable">autoFill</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="hljs-comment">//获得方法上的注解对象</span><br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">operationType</span> <span class="hljs-operator">=</span> autoFill.value();<span class="hljs-comment">//获得数据库操作类型</span><br><br>        <span class="hljs-comment">//获取到当前被拦截的方法的参数--实体对象</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span>(args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">//准备赋值的数据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">currentId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>        <span class="hljs-comment">//根据当前不同的操作类型，为对应的属性通过反射来赋值</span><br>        <span class="hljs-keyword">if</span>(operationType == OperationType.INSERT)&#123;<br>            <span class="hljs-comment">//为4个公共字段赋值</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                <span class="hljs-comment">//通过反射为对象属性赋值</span><br>                setCreateTime.invoke(entity,now);<br>                setCreateUser.invoke(entity,currentId);<br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operationType == OperationType.UPDATE)&#123;<br>            <span class="hljs-comment">//为2个公共字段赋值</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);<br><br>                <span class="hljs-comment">//通过反射为对象属性赋值</span><br>                setUpdateTime.invoke(entity,now);<br>                setUpdateUser.invoke(entity,currentId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-在Mapper接口的方法上加入-AutoFill-注解"><a href="#1-4-在Mapper接口的方法上加入-AutoFill-注解" class="headerlink" title="1.4 在Mapper接口的方法上加入 AutoFill 注解"></a>1.4 在Mapper接口的方法上加入 AutoFill 注解</h3><p>以<strong>CategoryMapper</strong>为例，分别在新增和修改方法添加@AutoFill()注解，也需要<strong>EmployeeMapper</strong>做相同操作；同时注释掉原有的新增和添加代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CategoryMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> category</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Insert(&quot;insert into category(type, name, sort, status, create_time, update_time, create_user, update_user)&quot; +</span><br><span class="hljs-meta">            &quot; VALUES&quot; +</span><br><span class="hljs-meta">            &quot; (#&#123;type&#125;, #&#123;name&#125;, #&#123;sort&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)&quot;)</span><br>    <span class="hljs-meta">@AutoFill(value = OperationType.INSERT)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Category category)</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id修改分类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> category</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@AutoFill(value = OperationType.UPDATE)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Category category)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-文件上传"><a href="#2-文件上传" class="headerlink" title="2. 文件上传"></a>2. 文件上传</h2><ul><li>因为在新增菜品时，需要上传菜品对应的图片(文件)，包括后绪其它功能也会使用到文件上传，故要实现通用的文件上传接口。</li><li>在本项目选用阿里云的OSS服务进行文件存储。</li></ul><h3 id="2-1-定义OSS相关配置"><a href="#2-1-定义OSS相关配置" class="headerlink" title="2.1 定义OSS相关配置"></a>2.1 定义OSS相关配置</h3><p>在sky-server模块</p><ul><li>application-dev.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">alioss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">oss-cn-hangzhou.aliyuncs.com</span><br>    <span class="hljs-attr">bucket-name:</span> <span class="hljs-string">sky-take-out</span><br></code></pre></td></tr></table></figure><ul><li>application.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>    <span class="hljs-comment">#设置环境</span><br><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">alioss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">$&#123;sky.alioss.endpoint&#125;</span><br>    <span class="hljs-attr">bucket-name:</span> <span class="hljs-string">$&#123;sky.alioss.bucket-name&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-OSS工具类对象"><a href="#2-2-OSS工具类对象" class="headerlink" title="2.2 OSS工具类对象"></a>2.2 OSS工具类对象</h3><p>在sky-server模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.config;<br><br><span class="hljs-keyword">import</span> com.sky.properties.AliOssProperties;<br><span class="hljs-keyword">import</span> com.sky.utils.AliOssUtil;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置类，用于创建AliOssUtil对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OssConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> AliOssUtil <span class="hljs-title function_">aliOssUtil</span><span class="hljs-params">(AliOssProperties aliOssProperties)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始创建阿里云文件上传工具类对象：&#123;&#125;&quot;</span>,aliOssProperties);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliOssUtil</span>(aliOssProperties.getEndpoint(),<br>                aliOssProperties.getAccessKeyId(),<br>                aliOssProperties.getAccessKeySecret(),<br>                aliOssProperties.getBucketName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-定义文件上传接口"><a href="#2-3-定义文件上传接口" class="headerlink" title="2.3 定义文件上传接口"></a>2.3 定义文件上传接口</h3><p>在sky-server模块中定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.admin;<br><br><span class="hljs-keyword">import</span> com.sky.constant.MessageConstant;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.utils.AliOssUtil;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/admin/common&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;通用接口&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AliOssUtil aliOssUtil;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件上传</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;文件上传&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;&quot;</span>,file);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//原始文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>            <span class="hljs-comment">//截取原始文件名的后缀 </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">extension</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>            <span class="hljs-comment">//构造新文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + extension;<br><br>            <span class="hljs-comment">//文件的请求路径</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> aliOssUtil.upload(file.getBytes(), objectName);<br>            <span class="hljs-keyword">return</span> Result.success(filePath);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;文件上传失败：&#123;&#125;&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.error(MessageConstant.UPLOAD_FAILED);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-新增菜品"><a href="#3-新增菜品" class="headerlink" title="3. 新增菜品"></a>3. 新增菜品</h2><h3 id="3-1-Controller层-1"><a href="#3-1-Controller层-1" class="headerlink" title="3.1 Controller层"></a>3.1 Controller层</h3><p>进入到sky-server模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.admin;<br><br><span class="hljs-keyword">import</span> com.sky.dto.DishDTO;<br><span class="hljs-keyword">import</span> com.sky.dto.DishPageQueryDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.Dish;<br><span class="hljs-keyword">import</span> com.sky.result.PageResult;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.DishService;<br><span class="hljs-keyword">import</span> com.sky.vo.DishVO;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 菜品管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/admin/dish&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;菜品相关接口&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishService dishService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增菜品</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-meta">@ApiOperation(&quot;新增菜品&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> DishDTO dishDTO)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;新增菜品：&#123;&#125;&quot;</span>, dishDTO);<br>        dishService.saveWithFlavor(dishDTO);<span class="hljs-comment">//后绪步骤开发</span><br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Service层-1"><a href="#3-2-Service层-1" class="headerlink" title="3.2 Service层"></a>3.2 Service层</h3><h4 id="3-2-1-Service层接口-1"><a href="#3-2-1-Service层接口-1" class="headerlink" title="3.2.1 Service层接口"></a>3.2.1 Service层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service;<br><br><span class="hljs-keyword">import</span> com.sky.dto.DishDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.Dish;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DishService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增菜品和对应的口味</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveWithFlavor</span><span class="hljs-params">(DishDTO dishDTO)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-Service层实现类-1"><a href="#3-2-2-Service层实现类-1" class="headerlink" title="3.2.2 Service层实现类"></a>3.2.2 Service层实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service.impl;<br><br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DishService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishMapper dishMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishFlavorMapper dishFlavorMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增菜品和对应的口味</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveWithFlavor</span><span class="hljs-params">(DishDTO dishDTO)</span> &#123;<br><br>        <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dish</span>();<br>        BeanUtils.copyProperties(dishDTO, dish);<br><br>        <span class="hljs-comment">//向菜品表插入1条数据</span><br>        dishMapper.insert(dish);<span class="hljs-comment">//后绪步骤实现</span><br><br>        <span class="hljs-comment">//获取insert语句生成的主键值</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">dishId</span> <span class="hljs-operator">=</span> dish.getId();<br><br>        List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();<br>        <span class="hljs-keyword">if</span> (flavors != <span class="hljs-literal">null</span> &amp;&amp; flavors.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            flavors.forEach(dishFlavor -&gt; &#123;<br>                dishFlavor.setDishId(dishId);<br>            &#125;);<br>            <span class="hljs-comment">//向口味表插入n条数据</span><br>            dishFlavorMapper.insertBatch(flavors);<span class="hljs-comment">//后绪步骤实现</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Mapper层-1"><a href="#3-3-Mapper层-1" class="headerlink" title="3.3 Mapper层"></a>3.3 Mapper层</h3><h4 id="3-3-1-DishMapper-java"><a href="#3-3-1-DishMapper-java" class="headerlink" title="3.3.1 DishMapper.java"></a>3.3.1 DishMapper.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 插入菜品数据</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@AutoFill(value = OperationType.INSERT)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Dish dish)</span>;<br></code></pre></td></tr></table></figure><p>在&#x2F;resources&#x2F;mapper中创建DishMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.DishMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        insert into dish (name, category_id, price, image, description, create_time, update_time, create_user,update_user, status)<br>        values (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;price&#125;, #&#123;image&#125;, #&#123;description&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;, #&#123;status&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-2-DishFlavorMapper-java"><a href="#3-3-2-DishFlavorMapper-java" class="headerlink" title="3.3.2 DishFlavorMapper.java"></a>3.3.2 DishFlavorMapper.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-keyword">import</span> com.sky.entity.DishFlavor;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DishFlavorMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量插入口味数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> flavors</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBatch</span><span class="hljs-params">(List&lt;DishFlavor&gt; flavors)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在&#x2F;resources&#x2F;mapper中创建DishFlavorMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.DishFlavorMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span>&gt;</span><br>        insert into dish_flavor (dish_id, name, value) VALUES<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;flavors&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;df&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            (#&#123;df.dishId&#125;,#&#123;df.name&#125;,#&#123;df.value&#125;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-菜品分页查询"><a href="#4-菜品分页查询" class="headerlink" title="4. 菜品分页查询"></a>4. 菜品分页查询</h2><h3 id="4-1-Controller层"><a href="#4-1-Controller层" class="headerlink" title="4.1  Controller层"></a>4.1  Controller层</h3><p><strong>根据接口定义创建DishController的page分页查询方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品分页查询</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishPageQueryDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;菜品分页查询&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;PageResult&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(DishPageQueryDTO dishPageQueryDTO)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;菜品分页查询:&#123;&#125;&quot;</span>, dishPageQueryDTO);<br>       <span class="hljs-type">PageResult</span> <span class="hljs-variable">pageResult</span> <span class="hljs-operator">=</span> dishService.pageQuery(dishPageQueryDTO);<span class="hljs-comment">//后绪步骤定义</span><br>       <span class="hljs-keyword">return</span> Result.success(pageResult);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Service层"><a href="#4-2-Service层" class="headerlink" title="4.2 Service层"></a>4.2 Service层</h3><h4 id="4-2-1-Service层接口"><a href="#4-2-1-Service层接口" class="headerlink" title="4.2.1 Service层接口"></a>4.2.1 Service层接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品分页查询</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishPageQueryDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   PageResult <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(DishPageQueryDTO dishPageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><h4 id="4-2-2-Service层实现类"><a href="#4-2-2-Service层实现类" class="headerlink" title="4.2.2 Service层实现类"></a>4.2.2 Service层实现类</h4><p><strong>在 DishServiceImpl 中实现分页查询方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品分页查询</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishPageQueryDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(DishPageQueryDTO dishPageQueryDTO)</span> &#123;<br>       PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize());<br>       Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDTO);<span class="hljs-comment">//后绪步骤实现</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(page.getTotal(), page.getResult());<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-Mapper层"><a href="#4-3-Mapper层" class="headerlink" title="4.3 Mapper层"></a>4.3 Mapper层</h3><p><strong>在 DishMapper 接口中声明 pageQuery 方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品分页查询</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishPageQueryDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   Page&lt;DishVO&gt; <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(DishPageQueryDTO dishPageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><p><strong>在 DishMapper.xml 中编写SQL：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pageQuery&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.sky.vo.DishVO&quot;</span>&gt;</span><br>        select d.* , c.name as categoryName from dish d left outer join category c on d.category_id = c.id<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                and d.name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId != null&quot;</span>&gt;</span><br>                and d.category_id = #&#123;categoryId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>                and d.status = #&#123;status&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by d.create_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-删除菜品"><a href="#5-删除菜品" class="headerlink" title="5. 删除菜品"></a>5. 删除菜品</h2><h3 id="5-1-Controller层"><a href="#5-1-Controller层" class="headerlink" title="5.1 Controller层"></a>5.1 Controller层</h3><p><strong>根据删除菜品的接口定义在DishController中创建方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品批量删除</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@DeleteMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;菜品批量删除&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;菜品批量删除：&#123;&#125;&quot;</span>, ids);<br>       dishService.deleteBatch(ids);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-Service层"><a href="#5-2-Service层" class="headerlink" title="5.2 Service层"></a>5.2 Service层</h3><h4 id="5-2-1-Service层接口"><a href="#5-2-1-Service层接口" class="headerlink" title="5.2.1 Service层接口"></a>5.2.1 Service层接口</h4><p><strong>在DishService接口中声明deleteBatch方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品批量删除</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(List&lt;Long&gt; ids)</span>;<br></code></pre></td></tr></table></figure><h4 id="5-2-2-Service层实现类"><a href="#5-2-2-Service层实现类" class="headerlink" title="5.2.2 Service层实现类"></a>5.2.2 Service层实现类</h4><p><strong>在DishServiceImpl中实现deleteBatch方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> SetmealDishMapper setmealDishMapper;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品批量删除</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Transactional</span><span class="hljs-comment">//事务</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> &#123;<br>       <span class="hljs-comment">//判断当前菜品是否能够删除---是否存在起售中的菜品？？</span><br>       <span class="hljs-keyword">for</span> (Long id : ids) &#123;<br>           <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> dishMapper.getById(id);<span class="hljs-comment">//后绪步骤实现</span><br>           <span class="hljs-keyword">if</span> (dish.getStatus() == StatusConstant.ENABLE) &#123;<br>               <span class="hljs-comment">//当前菜品处于起售中，不能删除</span><br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeletionNotAllowedException</span>(MessageConstant.DISH_ON_SALE);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">//判断当前菜品是否能够删除---是否被套餐关联了？？</span><br>       List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);<br>       <span class="hljs-keyword">if</span> (setmealIds != <span class="hljs-literal">null</span> &amp;&amp; setmealIds.size() &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">//当前菜品被套餐关联了，不能删除</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeletionNotAllowedException</span>(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);<br>       &#125;<br><br>       <span class="hljs-comment">//删除菜品表中的菜品数据</span><br>       <span class="hljs-keyword">for</span> (Long id : ids) &#123;<br>           dishMapper.deleteById(id);<br>           <span class="hljs-comment">//删除菜品关联的口味数据</span><br>           dishFlavorMapper.deleteByDishId(id);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-Mapper层"><a href="#5-3-Mapper层" class="headerlink" title="5.3 Mapper层"></a>5.3 Mapper层</h3><p><strong>在DishMapper中声明getById方法，并配置SQL：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据主键查询菜品</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Select(&quot;select * from dish where id = #&#123;id&#125;&quot;)</span><br>   Dish <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><p><strong>创建SetmealDishMapper，声明getSetmealIdsByDishIds方法，并在xml文件中编写SQL：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-keyword">import</span> com.sky.entity.SetmealDish;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Delete;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetmealDishMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据菜品id查询对应的套餐id</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dishIds</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)</span><br>    List&lt;Long&gt; <span class="hljs-title function_">getSetmealIdsByDishIds</span><span class="hljs-params">(List&lt;Long&gt; dishIds)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>SetmealDishMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.SetmealDishMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getSetmealIdsByDishIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>&gt;</span><br>        select setmeal_id from setmeal_dish where dish_id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;dishIds&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;dishId&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>            #&#123;dishId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>在DishMapper.java中声明deleteById方法并配置SQL：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据主键删除菜品数据</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Delete(&quot;delete from dish where id = #&#123;id&#125;&quot;)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><p><strong>在DishFlavorMapper中声明deleteByDishId方法并配置SQL：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据菜品id删除对应的口味数据</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dishId</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Delete(&quot;delete from dish_flavor where dish_id = #&#123;dishId&#125;&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByDishId</span><span class="hljs-params">(Long dishId)</span>;<br></code></pre></td></tr></table></figure><h2 id="6-修改菜品"><a href="#6-修改菜品" class="headerlink" title="6. 修改菜品"></a>6. 修改菜品</h2><h3 id="6-1-Controller层"><a href="#6-1-Controller层" class="headerlink" title="6.1 Controller层"></a>6.1 Controller层</h3><p><strong>根据修改菜品的接口定义在DishController中创建方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改菜品</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;修改菜品&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> DishDTO dishDTO)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;修改菜品：&#123;&#125;&quot;</span>, dishDTO);<br>       dishService.updateWithFlavor(dishDTO);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-Service层"><a href="#6-2-Service层" class="headerlink" title="6.2 Service层"></a>6.2 Service层</h3><h4 id="6-2-1-Service层接口"><a href="#6-2-1-Service层接口" class="headerlink" title="6.2.1 Service层接口"></a>6.2.1 Service层接口</h4><p><strong>在DishService接口中声明updateWithFlavor方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id修改菜品基本信息和对应的口味信息</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateWithFlavor</span><span class="hljs-params">(DishDTO dishDTO)</span>;<br></code></pre></td></tr></table></figure><h4 id="6-2-2-Service层实现类"><a href="#6-2-2-Service层实现类" class="headerlink" title="6.2.2 Service层实现类"></a>6.2.2 Service层实现类</h4><p><strong>在DishServiceImpl中实现updateWithFlavor方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id修改菜品基本信息和对应的口味信息</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateWithFlavor</span><span class="hljs-params">(DishDTO dishDTO)</span> &#123;<br>       <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dish</span>();<br>       BeanUtils.copyProperties(dishDTO, dish);<br><br>       <span class="hljs-comment">//修改菜品表基本信息</span><br>       dishMapper.update(dish);<br><br>       <span class="hljs-comment">//删除原有的口味数据</span><br>       dishFlavorMapper.deleteByDishId(dishDTO.getId());<br><br>       <span class="hljs-comment">//重新插入口味数据</span><br>       List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();<br>       <span class="hljs-keyword">if</span> (flavors != <span class="hljs-literal">null</span> &amp;&amp; flavors.size() &gt; <span class="hljs-number">0</span>) &#123;<br>           flavors.forEach(dishFlavor -&gt; &#123;<br>               dishFlavor.setDishId(dishDTO.getId());<br>           &#125;);<br>           <span class="hljs-comment">//向口味表插入n条数据</span><br>           dishFlavorMapper.insertBatch(flavors);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-Mapper层"><a href="#6-3-Mapper层" class="headerlink" title="6.3 Mapper层"></a>6.3 Mapper层</h3><p><strong>在DishMapper中，声明update方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id动态修改菜品数据</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@AutoFill(value = OperationType.UPDATE)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Dish dish)</span>;<br></code></pre></td></tr></table></figure><p><strong>并在DishMapper.xml文件中编写SQL:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update dish<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span>name = #&#123;name&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId != null&quot;</span>&gt;</span>category_id = #&#123;categoryId&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;price != null&quot;</span>&gt;</span>price = #&#123;price&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span>image = #&#123;image&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;description != null&quot;</span>&gt;</span>description = #&#123;description&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span>status = #&#123;status&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateUser != null&quot;</span>&gt;</span>update_user = #&#123;updateUser&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-菜品起售停售功能"><a href="#7-菜品起售停售功能" class="headerlink" title="7. 菜品起售停售功能"></a>7. 菜品起售停售功能</h2><h3 id="7-1-Controller层"><a href="#7-1-Controller层" class="headerlink" title="7.1  Controller层"></a>7.1  Controller层</h3><p><strong>DishController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 菜品起售停售</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;菜品起售停售&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status, Long id)</span>&#123;<br>    dishService.startOrStop(status,id);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-Service层"><a href="#7-2-Service层" class="headerlink" title="7.2 Service层"></a>7.2 Service层</h3><h4 id="7-2-1-DishService接口"><a href="#7-2-1-DishService接口" class="headerlink" title="7.2.1 DishService接口"></a>7.2.1 DishService接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 菜品起售停售</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(Integer status, Long id)</span>;<br></code></pre></td></tr></table></figure><h4 id="7-2-2-DishServiceImpl实现类"><a href="#7-2-2-DishServiceImpl实现类" class="headerlink" title="7.2.2 DishServiceImpl实现类"></a>7.2.2 DishServiceImpl实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowire</span><br><span class="hljs-keyword">private</span> SetmealMapper setmealMapper;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 菜品起售停售</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(Integer status, Long id)</span> &#123;<br>    <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> Dish.builder()<br>        .id(id)<br>        .status(status)<br>        .build();<br>    dishMapper.update(dish);<br><br>    <span class="hljs-keyword">if</span> (status == StatusConstant.DISABLE) &#123;<br>        <span class="hljs-comment">// 如果是停售操作，还需要将包含当前菜品的套餐也停售</span><br>        List&lt;Long&gt; dishIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dishIds.add(id);<br>        <span class="hljs-comment">// select setmeal_id from setmeal_dish where dish_id in (?,?,?)</span><br>        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(dishIds);<br>        <span class="hljs-keyword">if</span> (setmealIds != <span class="hljs-literal">null</span> &amp;&amp; setmealIds.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Long setmealId : setmealIds) &#123;<br>                <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> Setmeal.builder()<br>                    .id(setmealId)<br>                    .status(StatusConstant.DISABLE)<br>                    .build();<br>                setmealMapper.update(setmeal);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-Mapper层"><a href="#7-3-Mapper层" class="headerlink" title="7.3 Mapper层"></a>7.3 Mapper层</h3><h4 id="7-3-1-SetmealMapper"><a href="#7-3-1-SetmealMapper" class="headerlink" title="7.3.1 SetmealMapper"></a>7.3.1 SetmealMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id修改套餐</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmeal</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AutoFill(OperationType.UPDATE)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Setmeal setmeal)</span>;<br></code></pre></td></tr></table></figure><h4 id="7-3-2-SetmealMapper-xml"><a href="#7-3-2-SetmealMapper-xml" class="headerlink" title="7.3.2 SetmealMapper.xml"></a>7.3.2 SetmealMapper.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.SetmealMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Setmeal&quot;</span>&gt;</span><br>        update setmeal<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                name = #&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId != null&quot;</span>&gt;</span><br>                category_id = #&#123;categoryId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;price != null&quot;</span>&gt;</span><br>                price = #&#123;price&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>                status = #&#123;status&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;description != null&quot;</span>&gt;</span><br>                description = #&#123;description&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span><br>                image = #&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time = #&#123;updateTime&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateUser != null&quot;</span>&gt;</span><br>                update_user = #&#123;updateUser&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="四-套餐管理"><a href="#四-套餐管理" class="headerlink" title="四. 套餐管理"></a>四. 套餐管理</h1><h2 id="1-新增套餐"><a href="#1-新增套餐" class="headerlink" title="1. 新增套餐"></a>1. 新增套餐</h2><h3 id="1-1-Controller层"><a href="#1-1-Controller层" class="headerlink" title="1.1 Controller层"></a>1.1 Controller层</h3><p><strong>DishController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据分类id查询菜品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;根据分类id查询菜品&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;List&lt;Dish&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span>&#123;<br>    List&lt;Dish&gt; list = dishService.list(categoryId);<br>    <span class="hljs-keyword">return</span> Result.success(list);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Service层"><a href="#1-2-Service层" class="headerlink" title="1.2 Service层"></a>1.2 Service层</h3><h4 id="1-2-1-Service层接口"><a href="#1-2-1-Service层接口" class="headerlink" title="1.2.1 Service层接口"></a>1.2.1 Service层接口</h4><p><strong>DishService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据分类id查询菜品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br>List&lt;Dish&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-Service层实现类"><a href="#1-2-2-Service层实现类" class="headerlink" title="1.2.2 Service层实现类"></a>1.2.2 Service层实现类</h4><p><strong>DishServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据分类id查询菜品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> List&lt;Dish&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br>    <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> Dish.builder()<br>        .categoryId(categoryId)<br>        .status(StatusConstant.ENABLE)<br>        .build();<br>    <span class="hljs-keyword">return</span> dishMapper.list(dish);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Mapper层"><a href="#1-3-Mapper层" class="headerlink" title="1.3 Mapper层"></a>1.3 Mapper层</h3><h4 id="1-3-1-DishMapper"><a href="#1-3-1-DishMapper" class="headerlink" title="1.3.1 DishMapper"></a>1.3.1 DishMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态条件查询菜品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br>List&lt;Dish&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Dish dish)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-DishMapper-xml"><a href="#1-3-2-DishMapper-xml" class="headerlink" title="1.3.2 DishMapper.xml"></a>1.3.2 DishMapper.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Dish&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Dish&quot;</span>&gt;</span><br>    select * from dish<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId != null&quot;</span>&gt;</span><br>            and category_id = #&#123;categoryId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by create_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-SetmealController"><a href="#1-4-SetmealController" class="headerlink" title="1.4 SetmealController"></a>1.4 SetmealController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 套餐管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/admin/setmeal&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;套餐相关接口&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetmealController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealService setmealService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-meta">@ApiOperation(&quot;新增套餐&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SetmealDTO setmealDTO)</span> &#123;<br>        setmealService.saveWithDish(setmealDTO);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-Service层"><a href="#1-5-Service层" class="headerlink" title="1.5 Service层"></a>1.5 Service层</h3><h4 id="1-5-1-SetmealService接口"><a href="#1-5-1-SetmealService接口" class="headerlink" title="1.5.1 SetmealService接口"></a>1.5.1 SetmealService接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetmealService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增套餐，同时需要保存套餐和菜品的关联关系</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveWithDish</span><span class="hljs-params">(SetmealDTO setmealDTO)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-SetmealServiceImpl实现类"><a href="#1-5-2-SetmealServiceImpl实现类" class="headerlink" title="1.5.2 SetmealServiceImpl实现类"></a>1.5.2 SetmealServiceImpl实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 套餐业务实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetmealServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SetmealService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealMapper setmealMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealDishMapper setmealDishMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishMapper dishMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增套餐，同时需要保存套餐和菜品的关联关系</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveWithDish</span><span class="hljs-params">(SetmealDTO setmealDTO)</span> &#123;<br>        <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Setmeal</span>();<br>        BeanUtils.copyProperties(setmealDTO, setmeal);<br><br>        <span class="hljs-comment">//向套餐表插入数据</span><br>        setmealMapper.insert(setmeal);<br><br>        <span class="hljs-comment">//获取生成的套餐id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">setmealId</span> <span class="hljs-operator">=</span> setmeal.getId();<br><br>        List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();<br>        setmealDishes.forEach(setmealDish -&gt; &#123;<br>            setmealDish.setSetmealId(setmealId);<br>        &#125;);<br><br>        <span class="hljs-comment">//保存套餐和菜品的关联关系</span><br>        setmealDishMapper.insertBatch(setmealDishes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-6-Mapper层"><a href="#1-6-Mapper层" class="headerlink" title="1.6 Mapper层"></a>1.6 Mapper层</h3><h4 id="1-6-1-SetmealMapper"><a href="#1-6-1-SetmealMapper" class="headerlink" title="1.6.1 SetmealMapper"></a>1.6.1 SetmealMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmeal</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@AutoFill(OperationType.INSERT)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Setmeal setmeal)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-6-2-SetmealMapper-xml"><a href="#1-6-2-SetmealMapper-xml" class="headerlink" title="1.6.2 SetmealMapper.xml"></a>1.6.2 SetmealMapper.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Setmeal&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into setmeal<br>    (category_id, name, price, status, description, image, create_time, update_time, create_user, update_user)<br>    values (#&#123;categoryId&#125;, #&#123;name&#125;, #&#123;price&#125;, #&#123;status&#125;, #&#123;description&#125;, #&#123;image&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;,<br>    #&#123;createUser&#125;, #&#123;updateUser&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-6-3-SetmealDishMapper"><a href="#1-6-3-SetmealDishMapper" class="headerlink" title="1.6.3 SetmealDishMapper"></a>1.6.3 SetmealDishMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量保存套餐和菜品的关联关系</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDishes</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBatch</span><span class="hljs-params">(List&lt;SetmealDish&gt; setmealDishes)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-6-4-SetmealDishMapper-xml"><a href="#1-6-4-SetmealDishMapper-xml" class="headerlink" title="1.6.4 SetmealDishMapper.xml"></a>1.6.4 SetmealDishMapper.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    insert into setmeal_dish<br>    (setmeal_id,dish_id,name,price,copies)<br>    values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;setmealDishes&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;sd&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (#&#123;sd.setmealId&#125;,#&#123;sd.dishId&#125;,#&#123;sd.name&#125;,#&#123;sd.price&#125;,#&#123;sd.copies&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-套餐分页查询"><a href="#2-套餐分页查询" class="headerlink" title="2. 套餐分页查询"></a>2. 套餐分页查询</h2><h3 id="2-1-SetmealController"><a href="#2-1-SetmealController" class="headerlink" title="2.1 SetmealController"></a>2.1 SetmealController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分页查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealPageQueryDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;分页查询&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;PageResult&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(SetmealPageQueryDTO setmealPageQueryDTO)</span> &#123;<br>    <span class="hljs-type">PageResult</span> <span class="hljs-variable">pageResult</span> <span class="hljs-operator">=</span> setmealService.pageQuery(setmealPageQueryDTO);<br>    <span class="hljs-keyword">return</span> Result.success(pageResult);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-SetmealService"><a href="#2-2-SetmealService" class="headerlink" title="2.2 SetmealService"></a>2.2 SetmealService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分页查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealPageQueryDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br>PageResult <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(SetmealPageQueryDTO setmealPageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-SetmealServiceImpl"><a href="#2-3-SetmealServiceImpl" class="headerlink" title="2.3 SetmealServiceImpl"></a>2.3 SetmealServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分页查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealPageQueryDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(SetmealPageQueryDTO setmealPageQueryDTO)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNum</span> <span class="hljs-operator">=</span> setmealPageQueryDTO.getPage();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageSize</span> <span class="hljs-operator">=</span> setmealPageQueryDTO.getPageSize();<br><br>    PageHelper.startPage(pageNum, pageSize);<br>    Page&lt;SetmealVO&gt; page = setmealMapper.pageQuery(setmealPageQueryDTO);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(page.getTotal(), page.getResult());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-SetmealMapper"><a href="#2-4-SetmealMapper" class="headerlink" title="2.4 SetmealMapper"></a>2.4 SetmealMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分页查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealPageQueryDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br>Page&lt;SetmealVO&gt; <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(SetmealPageQueryDTO setmealPageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-5-SetmealMapper-xml"><a href="#2-5-SetmealMapper-xml" class="headerlink" title="2.5 SetmealMapper.xml"></a>2.5 SetmealMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pageQuery&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.sky.vo.SetmealVO&quot;</span>&gt;</span><br>    select<br>    s.*,c.name categoryName<br>    from<br>    setmeal s<br>    left join<br>    category c<br>    on<br>    s.category_id = c.id<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            and s.name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and s.status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId != null&quot;</span>&gt;</span><br>            and s.category_id = #&#123;categoryId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by s.create_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-删除套餐"><a href="#3-删除套餐" class="headerlink" title="3. 删除套餐"></a>3. 删除套餐</h2><h3 id="3-1-SetmealController"><a href="#3-1-SetmealController" class="headerlink" title="3.1 SetmealController"></a>3.1 SetmealController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量删除套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@DeleteMapping</span><br><span class="hljs-meta">@ApiOperation(&quot;批量删除套餐&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;<br>    setmealService.deleteBatch(ids);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-SetmealService"><a href="#3-2-SetmealService" class="headerlink" title="3.2 SetmealService"></a>3.2 SetmealService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量删除套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(List&lt;Long&gt; ids)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-SetmealServiceImpl"><a href="#3-3-SetmealServiceImpl" class="headerlink" title="3.3 SetmealServiceImpl"></a>3.3 SetmealServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量删除套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBatch</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> &#123;<br>    ids.forEach(id -&gt; &#123;<br>        <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> setmealMapper.getById(id);<br>        <span class="hljs-keyword">if</span>(StatusConstant.ENABLE == setmeal.getStatus())&#123;<br>            <span class="hljs-comment">//起售中的套餐不能删除</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeletionNotAllowedException</span>(MessageConstant.SETMEAL_ON_SALE);<br>        &#125;<br>    &#125;);<br><br>    ids.forEach(setmealId -&gt; &#123;<br>        <span class="hljs-comment">//删除套餐表中的数据</span><br>        setmealMapper.deleteById(setmealId);<br>        <span class="hljs-comment">//删除套餐菜品关系表中的数据</span><br>        setmealDishMapper.deleteBySetmealId(setmealId);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-SetmealMapper"><a href="#3-4-SetmealMapper" class="headerlink" title="3.4 SetmealMapper"></a>3.4 SetmealMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Select(&quot;select * from setmeal where id = #&#123;id&#125;&quot;)</span><br>Setmeal <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id删除套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealId</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Delete(&quot;delete from setmeal where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Long setmealId)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-SetmealDishMapper"><a href="#3-5-SetmealDishMapper" class="headerlink" title="3.5 SetmealDishMapper"></a>3.5 SetmealDishMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据套餐id删除套餐和菜品的关联关系</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealId</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Delete(&quot;delete from setmeal_dish where setmeal_id = #&#123;setmealId&#125;&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBySetmealId</span><span class="hljs-params">(Long setmealId)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-修改套餐"><a href="#4-修改套餐" class="headerlink" title="4. 修改套餐"></a>4. 修改套餐</h2><h3 id="4-1-SetmealController"><a href="#4-1-SetmealController" class="headerlink" title="4.1 SetmealController"></a>4.1 SetmealController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询套餐，用于修改页面回显数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;根据id查询套餐&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;SetmealVO&gt; <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>    <span class="hljs-type">SetmealVO</span> <span class="hljs-variable">setmealVO</span> <span class="hljs-operator">=</span> setmealService.getByIdWithDish(id);<br>    <span class="hljs-keyword">return</span> Result.success(setmealVO);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改套餐</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PutMapping</span><br><span class="hljs-meta">@ApiOperation(&quot;修改套餐&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SetmealDTO setmealDTO)</span> &#123;<br>    setmealService.update(setmealDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-SetmealService"><a href="#4-2-SetmealService" class="headerlink" title="4.2 SetmealService"></a>4.2 SetmealService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询套餐和关联的菜品数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br>SetmealVO <span class="hljs-title function_">getByIdWithDish</span><span class="hljs-params">(Long id)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(SetmealDTO setmealDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-SetmealServiceImpl"><a href="#4-3-SetmealServiceImpl" class="headerlink" title="4.3 SetmealServiceImpl"></a>4.3 SetmealServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询套餐和套餐菜品关系</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> SetmealVO <span class="hljs-title function_">getByIdWithDish</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> setmealMapper.getById(id);<br>    List&lt;SetmealDish&gt; setmealDishes = setmealDishMapper.getBySetmealId(id);<br><br>    <span class="hljs-type">SetmealVO</span> <span class="hljs-variable">setmealVO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetmealVO</span>();<br>    BeanUtils.copyProperties(setmeal, setmealVO);<br>    setmealVO.setSetmealDishes(setmealDishes);<br>    <br>    <span class="hljs-keyword">return</span> setmealVO;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改套餐</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(SetmealDTO setmealDTO)</span> &#123;<br>    <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Setmeal</span>();<br>    BeanUtils.copyProperties(setmealDTO, setmeal);<br><br>    <span class="hljs-comment">//1、修改套餐表，执行update</span><br>    setmealMapper.update(setmeal);<br><br>    <span class="hljs-comment">//套餐id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">setmealId</span> <span class="hljs-operator">=</span> setmealDTO.getId();<br><br>    <span class="hljs-comment">//2、删除套餐和菜品的关联关系，操作setmeal_dish表，执行delete</span><br>    setmealDishMapper.deleteBySetmealId(setmealId);<br><br>    List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes();<br>    setmealDishes.forEach(setmealDish -&gt; &#123;<br>        setmealDish.setSetmealId(setmealId);<br>    &#125;);<br>    <span class="hljs-comment">//3、重新插入套餐和菜品的关联关系，操作setmeal_dish表，执行insert</span><br>    setmealDishMapper.insertBatch(setmealDishes);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-SetmealDishMapper"><a href="#4-4-SetmealDishMapper" class="headerlink" title="4.4 SetmealDishMapper"></a>4.4 SetmealDishMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据套餐id查询套餐和菜品的关联关系</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> setmealId</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Select(&quot;select * from setmeal_dish where setmeal_id = #&#123;setmealId&#125;&quot;)</span><br>   List&lt;SetmealDish&gt; <span class="hljs-title function_">getBySetmealId</span><span class="hljs-params">(Long setmealId)</span>;<br></code></pre></td></tr></table></figure><h2 id="5-起售停售套餐"><a href="#5-起售停售套餐" class="headerlink" title="5. 起售停售套餐"></a>5. 起售停售套餐</h2><h3 id="5-1-SetmealController"><a href="#5-1-SetmealController" class="headerlink" title="5.1 SetmealController"></a>5.1 SetmealController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 套餐起售停售</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;套餐起售停售&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status, Long id)</span> &#123;<br>    setmealService.startOrStop(status, id);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-SetmealService"><a href="#5-2-SetmealService" class="headerlink" title="5.2 SetmealService"></a>5.2 SetmealService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 套餐起售、停售</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(Integer status, Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-3-SetmealServiceImpl"><a href="#5-3-SetmealServiceImpl" class="headerlink" title="5.3 SetmealServiceImpl"></a>5.3 SetmealServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 套餐起售、停售</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(Integer status, Long id)</span> &#123;<br>    <span class="hljs-comment">//起售套餐时，判断套餐内是否有停售菜品，有停售菜品提示&quot;套餐内包含未启售菜品，无法启售&quot;</span><br>    <span class="hljs-keyword">if</span>(status == StatusConstant.ENABLE)&#123;<br>        <span class="hljs-comment">//select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = ?</span><br>        List&lt;Dish&gt; dishList = dishMapper.getBySetmealId(id);<br>        <span class="hljs-keyword">if</span>(dishList != <span class="hljs-literal">null</span> &amp;&amp; dishList.size() &gt; <span class="hljs-number">0</span>)&#123;<br>            dishList.forEach(dish -&gt; &#123;<br>                <span class="hljs-keyword">if</span>(StatusConstant.DISABLE == dish.getStatus())&#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetmealEnableFailedException</span>(MessageConstant.SETMEAL_ENABLE_FAILED);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> Setmeal.builder()<br>        .id(id)<br>        .status(status)<br>        .build();<br>    setmealMapper.update(setmeal);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-DishMapper"><a href="#5-4-DishMapper" class="headerlink" title="5.4 DishMapper"></a>5.4 DishMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据套餐id查询菜品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Select(&quot;select a.* from dish a left join setmeal_dish b on a.id = b.dish_id where b.setmeal_id = #&#123;setmealId&#125;&quot;)</span><br>List&lt;Dish&gt; <span class="hljs-title function_">getBySetmealId</span><span class="hljs-params">(Long setmealId)</span>;<br></code></pre></td></tr></table></figure><h1 id="五-Redis"><a href="#五-Redis" class="headerlink" title="五. Redis"></a>五. Redis</h1><h2 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1. Redis简介"></a>1. Redis简介</h2><p>Redis是一个基于<strong>内存</strong>的key-value结构数据库。Redis 是互联网技术领域使用最为广泛的<strong>存储中间件</strong>。</p><p><strong>主要特点：</strong></p><ul><li>基于内存存储，读写性能高  </li><li>适合存储热点数据（热点商品、资讯、新闻）</li><li>企业应用广泛</li></ul><p><strong>启动Redis</strong>:在Redis安装目录cmd以下命令<br><code>redis-server.exe redis.windows.conf</code></p><h2 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2. Redis数据类型"></a>2. Redis数据类型</h2><h3 id="2-1-五种常用数据类型介绍"><a href="#2-1-五种常用数据类型介绍" class="headerlink" title="2.1 五种常用数据类型介绍"></a>2.1 五种常用数据类型介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型:</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set &#x2F; zset</li></ul><h3 id="2-2-各种数据类型特点"><a href="#2-2-各种数据类型特点" class="headerlink" title="2.2 各种数据类型特点"></a>2.2 各种数据类型特点</h3><p><img src="/img/blogs/java/cangqiongtakeout/5.2.1.png"></p><p><strong>解释说明：</strong></p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：也叫散列，类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(sorted set&#x2F;zset)：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素</li></ul><h2 id="3-Redis常用命令"><a href="#3-Redis常用命令" class="headerlink" title="3. Redis常用命令"></a>3. Redis常用命令</h2><h3 id="3-1-字符串操作命令"><a href="#3-1-字符串操作命令" class="headerlink" title="3.1 字符串操作命令"></a>3.1 字符串操作命令</h3><p>Redis 中字符串类型常用命令：</p><ul><li><strong>SET</strong> key value          设置指定key的值</li><li><strong>GET</strong> key                                        获取指定key的值</li><li><strong>SETEX</strong> key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><strong>SETNX</strong> key value                        只有在 key    不存在时设置 key 的值</li></ul><h3 id="3-2-哈希操作命令"><a href="#3-2-哈希操作命令" class="headerlink" title="3.2 哈希操作命令"></a>3.2 哈希操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：</p><ul><li><strong>HSET</strong> key field value             将哈希表 key 中的字段 field 的值设为 value</li><li><strong>HGET</strong> key field                       获取存储在哈希表中指定字段的值</li><li><strong>HDEL</strong> key field                       删除存储在哈希表中的指定字段</li><li><strong>HKEYS</strong> key                              获取哈希表中所有字段</li><li><strong>HVALS</strong> key                              获取哈希表中所有值</li></ul><p><img src="/img/blogs/java/cangqiongtakeout/5.3.1.png"></p><h3 id="3-3-列表操作命令"><a href="#3-3-列表操作命令" class="headerlink" title="3.3 列表操作命令"></a>3.3 列表操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：</p><ul><li><strong>LPUSH</strong> key value1 [value2]         将一个或多个值插入到列表头部</li><li><strong>LRANGE</strong> key start stop                获取列表指定范围内的元素</li><li><strong>RPOP</strong> key                                       移除并获取列表最后一个元素</li><li><strong>LLEN</strong> key                                        获取列表长度</li><li><strong>BRPOP</strong> key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</li></ul><p><img src="/img/blogs/java/cangqiongtakeout/5.3.2.png"></p><h3 id="3-4-集合操作命令"><a href="#3-4-集合操作命令" class="headerlink" title="3.4 集合操作命令"></a>3.4 集合操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：</p><ul><li><strong>SADD</strong> key member1 [member2]            向集合添加一个或多个成员</li><li><strong>SMEMBERS</strong> key                                         返回集合中的所有成员</li><li><strong>SCARD</strong> key                                                  获取集合的成员数</li><li><strong>SINTER</strong> key1 [key2]                                   返回给定所有集合的交集</li><li><strong>SUNION</strong> key1 [key2]                                 返回所有给定集合的并集</li><li><strong>SREM</strong> key member1 [member2]            移除集合中一个或多个成员</li></ul><p><img src="/img/blogs/java/cangqiongtakeout/5.3.3.png"></p><h3 id="3-5-有序集合操作命令"><a href="#3-5-有序集合操作命令" class="headerlink" title="3.5 有序集合操作命令"></a>3.5 有序集合操作命令</h3><p>Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会关联一个double类型的分数。常用命令：</p><p>常用命令：</p><ul><li><strong>ZADD</strong> key score1 member1 [score2 member2]     向有序集合添加一个或多个成员</li><li><strong>ZRANGE</strong> key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员</li><li><strong>ZINCRBY</strong> key increment member                              有序集合中对指定成员的分数加上增量 increment</li><li><strong>ZREM</strong> key member [member …]                                移除有序集合中的一个或多个成员</li></ul><p><img src="/img/blogs/java/cangqiongtakeout/5.3.4.png"></p><h3 id="3-6-通用命令"><a href="#3-6-通用命令" class="headerlink" title="3.6 通用命令"></a>3.6 通用命令</h3><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p><ul><li>KEYS pattern 查找所有符合给定模式( pattern)的 key </li><li>EXISTS key 检查给定 key 是否存在</li><li>TYPE key 返回 key 所储存的值的类型</li><li>DEL key 该命令用于在 key 存在是删除 key</li></ul><h2 id="4-在java中操作Redis"><a href="#4-在java中操作Redis" class="headerlink" title="4. 在java中操作Redis"></a>4. 在java中操作Redis</h2><h3 id="4-1-Spring-Data-Redis"><a href="#4-1-Spring-Data-Redis" class="headerlink" title="4.1 Spring Data Redis"></a>4.1 Spring Data Redis</h3><p>Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，我们重点学习<strong>Spring Data Redis</strong>。</p><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：string数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h3 id="4-2-通过RedisTemplate对象操作Redis"><a href="#4-2-通过RedisTemplate对象操作Redis" class="headerlink" title="4.2 通过RedisTemplate对象操作Redis"></a>4.2 通过RedisTemplate对象操作Redis</h3><p>在test下新建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.test;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.*;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDataRedisTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisTemplate</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(redisTemplate);<br>        <span class="hljs-comment">//string数据操作</span><br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-comment">//hash类型的数据操作</span><br>        <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br>        <span class="hljs-comment">//list类型的数据操作</span><br>        <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br>        <span class="hljs-comment">//set类型数据操作</span><br>        <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br>        <span class="hljs-comment">//zset类型数据操作</span><br>        <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-操作常见类型数据"><a href="#4-3-操作常见类型数据" class="headerlink" title="4.3 操作常见类型数据"></a>4.3 操作常见类型数据</h3><p><strong>1). 操作字符串类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作字符串类型的数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// set get setex setnx</span><br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(city);<br>    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;1234&quot;</span>,<span class="hljs-number">3</span>, TimeUnit.MINUTES);<br>    redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>    redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2). 操作哈希类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作哈希类型的数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//hset hget hdel hkeys hvals</span><br>    <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br><br>    hashOperations.put(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    hashOperations.put(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) hashOperations.get(<span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(name);<br><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> hashOperations.keys(<span class="hljs-string">&quot;100&quot;</span>);<br>    System.out.println(keys);<br><br>    <span class="hljs-type">List</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> hashOperations.values(<span class="hljs-string">&quot;100&quot;</span>);<br>    System.out.println(values);<br><br>    hashOperations.delete(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3). 操作列表类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作列表类型的数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//lpush lrange rpop llen</span><br>    <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br><br>    listOperations.leftPushAll(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>    listOperations.leftPush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br><br>    <span class="hljs-type">List</span> <span class="hljs-variable">mylist</span> <span class="hljs-operator">=</span> listOperations.range(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    System.out.println(mylist);<br><br>    listOperations.rightPop(<span class="hljs-string">&quot;mylist&quot;</span>);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listOperations.size(<span class="hljs-string">&quot;mylist&quot;</span>);<br>    System.out.println(size);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4). 操作集合类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作集合类型的数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//sadd smembers scard sinter sunion srem</span><br>    <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br><br>    setOperations.add(<span class="hljs-string">&quot;set1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>    setOperations.add(<span class="hljs-string">&quot;set2&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>);<br><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">members</span> <span class="hljs-operator">=</span> setOperations.members(<span class="hljs-string">&quot;set1&quot;</span>);<br>    System.out.println(members);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> setOperations.size(<span class="hljs-string">&quot;set1&quot;</span>);<br>    System.out.println(size);<br><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">intersect</span> <span class="hljs-operator">=</span> setOperations.intersect(<span class="hljs-string">&quot;set1&quot;</span>, <span class="hljs-string">&quot;set2&quot;</span>);<br>    System.out.println(intersect);<br><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">union</span> <span class="hljs-operator">=</span> setOperations.union(<span class="hljs-string">&quot;set1&quot;</span>, <span class="hljs-string">&quot;set2&quot;</span>);<br>    System.out.println(union);<br><br>    setOperations.remove(<span class="hljs-string">&quot;set1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5). 操作有序集合类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 操作有序集合类型的数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZset</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//zadd zrange zincrby zrem</span><br>    <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br><br>    zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">10</span>);<br>    zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">12</span>);<br>    zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">9</span>);<br><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">zset1</span> <span class="hljs-operator">=</span> zSetOperations.range(<span class="hljs-string">&quot;zset1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    System.out.println(zset1);<br><br>    zSetOperations.incrementScore(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">10</span>);<br><br>    zSetOperations.remove(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6). 通用命令操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通用命令操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCommon</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//keys exists type del</span><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>    System.out.println(keys);<br><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;set1&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>        <span class="hljs-type">DataType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> redisTemplate.type(key);<br>        System.out.println(type.name());<br>    &#125;<br><br>    redisTemplate.delete(<span class="hljs-string">&quot;mylist&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六-店铺营业状态"><a href="#六-店铺营业状态" class="headerlink" title="六. 店铺营业状态"></a>六. 店铺营业状态</h1><p>营业状态分为<strong>营业中</strong>和<strong>打烊中</strong></p><h2 id="1-设置营业状态"><a href="#1-设置营业状态" class="headerlink" title="1. 设置营业状态"></a>1. 设置营业状态</h2><p>在sky-server模块中，创建ShopController.java</p><p><strong>根据接口定义创建ShopController的setStatus设置营业状态方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.admin;<br><br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PutMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController(&quot;adminShopController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/admin/shop&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;店铺相关接口&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SHOP_STATUS&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置店铺的营业状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;status&#125;&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;设置店铺的营业状态&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">setStatus</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;设置店铺的营业状态为：&#123;&#125;&quot;</span>,status == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;营业中&quot;</span> : <span class="hljs-string">&quot;打烊中&quot;</span>);<br>        redisTemplate.opsForValue().set(KEY,status);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-管理端查询营业状态"><a href="#2-管理端查询营业状态" class="headerlink" title="2. 管理端查询营业状态"></a>2. 管理端查询营业状态</h2><p><strong>根据接口定义创建ShopController的getStatus查询营业状态方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取店铺的营业状态</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/status&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;获取店铺的营业状态&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">Integer</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> (Integer) redisTemplate.opsForValue().get(KEY);<br>       log.info(<span class="hljs-string">&quot;获取到店铺的营业状态为：&#123;&#125;&quot;</span>,status == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;营业中&quot;</span> : <span class="hljs-string">&quot;打烊中&quot;</span>);<br>       <span class="hljs-keyword">return</span> Result.success(status);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-用户端查询营业状态"><a href="#3-用户端查询营业状态" class="headerlink" title="3. 用户端查询营业状态"></a>3. 用户端查询营业状态</h2><p>创建com.sky.controller.user包，在该包下创建ShopController.java</p><p><strong>根据接口定义创建ShopController的getStatus查询营业状态方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-meta">@RestController(&quot;userShopController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/shop&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;店铺相关接口&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SHOP_STATUS&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取店铺的营业状态</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/status&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;获取店铺的营业状态&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> (Integer) redisTemplate.opsForValue().get(KEY);<br>        log.info(<span class="hljs-string">&quot;获取到店铺的营业状态为：&#123;&#125;&quot;</span>,status == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;营业中&quot;</span> : <span class="hljs-string">&quot;打烊中&quot;</span>);<br>        <span class="hljs-keyword">return</span> Result.success(status);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="七-HttpClient"><a href="#七-HttpClient" class="headerlink" title="七. HttpClient"></a>七. HttpClient</h1><p>HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。</p><p><strong>HttpClient作用：</strong></p><ul><li>发送HTTP请求</li><li>接收响应数据</li></ul><p><strong>HttpClient的核心API：</strong></p><ul><li>HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。</li><li>HttpClients：可认为是构建器，可创建HttpClient对象。</li><li>CloseableHttpClient：实现类，实现了HttpClient接口。</li><li>HttpGet：Get方式请求类型。</li><li>HttpPost：Post方式请求类型。</li></ul><p><strong>HttpClient发送请求步骤：</strong></p><ul><li>创建HttpClient对象</li><li>创建Http请求对象</li><li>调用HttpClient的execute方法发送请求</li></ul><h1 id="八-微信登录"><a href="#八-微信登录" class="headerlink" title="八. 微信登录"></a>八. 微信登录</h1><h2 id="1-定义相关配置"><a href="#1-定义相关配置" class="headerlink" title="1. 定义相关配置"></a>1. 定义相关配置</h2><h3 id="1-1-配置微信登录所需配置项"><a href="#1-1-配置微信登录所需配置项" class="headerlink" title="1.1 配置微信登录所需配置项"></a>1.1 配置微信登录所需配置项</h3><p>application-dev.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">wechat:</span><br>    <span class="hljs-attr">appid:</span> <span class="hljs-string">wxffb3637a228223b8</span><br>    <span class="hljs-attr">secret:</span> <span class="hljs-string">84311df9199ecacdf4f12d27b6b9522d</span><br></code></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">wechat:</span><br>    <span class="hljs-attr">appid:</span> <span class="hljs-string">$&#123;sky.wechat.appid&#125;</span><br>    <span class="hljs-attr">secret:</span> <span class="hljs-string">$&#123;sky.wechat.secret&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-2-配置为微信用户生成jwt令牌时使用的配置项"><a href="#1-2-配置为微信用户生成jwt令牌时使用的配置项" class="headerlink" title="1.2 配置为微信用户生成jwt令牌时使用的配置项"></a>1.2 配置为微信用户生成jwt令牌时使用的配置项</h3><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">jwt:</span><br>    <span class="hljs-comment"># 设置jwt签名加密时使用的秘钥</span><br>    <span class="hljs-attr">admin-secret-key:</span> <span class="hljs-string">itcast</span><br>    <span class="hljs-comment"># 设置jwt过期时间</span><br>    <span class="hljs-attr">admin-ttl:</span> <span class="hljs-number">7200000</span><br>    <span class="hljs-comment"># 设置前端传递过来的令牌名称</span><br>    <span class="hljs-attr">admin-token-name:</span> <span class="hljs-string">token</span><br>    <span class="hljs-attr">user-secret-key:</span> <span class="hljs-string">itheima</span><br>    <span class="hljs-attr">user-ttl:</span> <span class="hljs-number">7200000</span><br>    <span class="hljs-attr">user-token-name:</span> <span class="hljs-string">authentication</span><br></code></pre></td></tr></table></figure><h2 id="2-DTO设计"><a href="#2-DTO设计" class="headerlink" title="2. DTO设计"></a>2. DTO设计</h2><p><strong>根据传入参数设计DTO类：</strong></p><img src="assets/image-20221205183625049.png" alt="image-20221205183625049" style="zoom:50%;" /> <p>在sky-pojo模块，UserLoginDTO.java已定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.dto;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * C端用户登录</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserLoginDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String code;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-VO设计"><a href="#3-VO设计" class="headerlink" title="3. VO设计"></a>3. VO设计</h2><p><strong>根据返回数据设计VO类：</strong></p><img src="assets/image-20221205183923272.png" alt="image-20221205183923272" style="zoom:50%;" /> <p>在sky-pojo模块，UserLoginVO.java已定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.vo;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Builder;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserLoginVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String openid;<br>    <span class="hljs-keyword">private</span> String token;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Controller层"><a href="#4-Controller层" class="headerlink" title="4. Controller层"></a>4. Controller层</h2><p><strong>根据接口定义创建UserController的login方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><span class="hljs-keyword">import</span> com.sky.constant.JwtClaimsConstant;<br><span class="hljs-keyword">import</span> com.sky.dto.UserLoginDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.User;<br><span class="hljs-keyword">import</span> com.sky.properties.JwtProperties;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.UserService;<br><span class="hljs-keyword">import</span> com.sky.utils.JwtUtil;<br><span class="hljs-keyword">import</span> com.sky.vo.UserLoginVO;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/user&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;C端用户相关接口&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtProperties jwtProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userLoginDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;微信登录&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;UserLoginVO&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserLoginDTO userLoginDTO)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;微信用户登录：&#123;&#125;&quot;</span>,userLoginDTO.getCode());<br><br>        <span class="hljs-comment">//微信登录</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.wxLogin(userLoginDTO);<span class="hljs-comment">//后绪步骤实现</span><br><br>        <span class="hljs-comment">//为微信用户生成jwt令牌</span><br>        Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        claims.put(JwtClaimsConstant.USER_ID,user.getId());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> JwtUtil.createJWT(jwtProperties.getUserSecretKey(), jwtProperties.getUserTtl(), claims);<br><br>        <span class="hljs-type">UserLoginVO</span> <span class="hljs-variable">userLoginVO</span> <span class="hljs-operator">=</span> UserLoginVO.builder()<br>                .id(user.getId())<br>                .openid(user.getOpenid())<br>                .token(token)<br>                .build();<br>        <span class="hljs-keyword">return</span> Result.success(userLoginVO);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-Service层"><a href="#5-Service层" class="headerlink" title="5. Service层"></a>5. Service层</h2><h3 id="5-1-Service层接口"><a href="#5-1-Service层接口" class="headerlink" title="5.1 Service层接口"></a>5.1 Service层接口</h3><p><strong>创建UserService接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service;<br><br><span class="hljs-keyword">import</span> com.sky.dto.UserLoginDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.User;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userLoginDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    User <span class="hljs-title function_">wxLogin</span><span class="hljs-params">(UserLoginDTO userLoginDTO)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-Service层实现类"><a href="#5-2-Service层实现类" class="headerlink" title="5.2 Service层实现类"></a>5.2 Service层实现类</h3><p>**创建UserServiceImpl实现类：**实现获取微信用户的openid和微信登录功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service.impl;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><span class="hljs-keyword">import</span> com.sky.constant.MessageConstant;<br><span class="hljs-keyword">import</span> com.sky.dto.UserLoginDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.User;<br><span class="hljs-keyword">import</span> com.sky.exception.LoginFailedException;<br><span class="hljs-keyword">import</span> com.sky.mapper.UserMapper;<br><span class="hljs-keyword">import</span> com.sky.properties.WeChatProperties;<br><span class="hljs-keyword">import</span> com.sky.service.UserService;<br><span class="hljs-keyword">import</span> com.sky.utils.HttpClientUtil;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-comment">//微信服务接口地址</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">WX_LOGIN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/jscode2session&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WeChatProperties weChatProperties;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 微信登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userLoginDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">wxLogin</span><span class="hljs-params">(UserLoginDTO userLoginDTO)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">openid</span> <span class="hljs-operator">=</span> getOpenid(userLoginDTO.getCode());<br><br>        <span class="hljs-comment">//判断openid是否为空，如果为空表示登录失败，抛出业务异常</span><br>        <span class="hljs-keyword">if</span>(openid == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginFailedException</span>(MessageConstant.LOGIN_FAILED);<br>        &#125;<br><br>        <span class="hljs-comment">//判断当前用户是否为新用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getByOpenid(openid);<br><br>        <span class="hljs-comment">//如果是新用户，自动完成注册</span><br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>            user = User.builder()<br>                    .openid(openid)<br>                    .createTime(LocalDateTime.now())<br>                    .build();<br>            userMapper.insert(user);<span class="hljs-comment">//后绪步骤实现</span><br>        &#125;<br><br>        <span class="hljs-comment">//返回这个用户对象</span><br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调用微信接口服务，获取微信用户的openid</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getOpenid</span><span class="hljs-params">(String code)</span>&#123;<br>        <span class="hljs-comment">//调用微信接口服务，获得当前微信用户的openid</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;appid&quot;</span>,weChatProperties.getAppid());<br>        map.put(<span class="hljs-string">&quot;secret&quot;</span>,weChatProperties.getSecret());<br>        map.put(<span class="hljs-string">&quot;js_code&quot;</span>,code);<br>        map.put(<span class="hljs-string">&quot;grant_type&quot;</span>,<span class="hljs-string">&quot;authorization_code&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> HttpClientUtil.doGet(WX_LOGIN, map);<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(json);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">openid</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;openid&quot;</span>);<br>        <span class="hljs-keyword">return</span> openid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Mapper层"><a href="#6-Mapper层" class="headerlink" title="6. Mapper层"></a>6. Mapper层</h2><p><strong>创建UserMapper接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-keyword">import</span> com.sky.entity.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据openid查询用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> openid</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot;select * from user where openid = #&#123;openid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getByOpenid</span><span class="hljs-params">(String openid)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建UserMapper.xml映射文件：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        insert into user (openid, name, phone, sex, id_number, avatar, create_time)<br>        values (#&#123;openid&#125;, #&#123;name&#125;, #&#123;phone&#125;, #&#123;sex&#125;, #&#123;idNumber&#125;, #&#123;avatar&#125;, #&#123;createTime&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-编写拦截器"><a href="#7-编写拦截器" class="headerlink" title="7. 编写拦截器"></a>7. 编写拦截器</h2><p>**编写拦截器JwtTokenUserInterceptor：**统一拦截用户端发送的请求并进行jwt校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.interceptor;<br><br><span class="hljs-keyword">import</span> com.sky.constant.JwtClaimsConstant;<br><span class="hljs-keyword">import</span> com.sky.context.BaseContext;<br><span class="hljs-keyword">import</span> com.sky.properties.JwtProperties;<br><span class="hljs-keyword">import</span> com.sky.utils.JwtUtil;<br><span class="hljs-keyword">import</span> io.jsonwebtoken.Claims;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jwt令牌校验的拦截器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtTokenUserInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JwtProperties jwtProperties;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验jwt</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//判断当前拦截到的是Controller的方法还是其他资源</span><br>        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;<br>            <span class="hljs-comment">//当前拦截到的不是动态方法，直接放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//1、从请求头中获取令牌</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(jwtProperties.getUserTokenName());<br><br>        <span class="hljs-comment">//2、校验令牌</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);<br>            <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token);<br>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString());<br>            log.info(<span class="hljs-string">&quot;当前用户的id：&quot;</span>, userId);<br>            BaseContext.setCurrentId(userId);<br>            <span class="hljs-comment">//3、通过，放行</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-comment">//4、不通过，响应401状态码</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在WebMvcConfiguration配置类中注册拦截器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JwtTokenUserInterceptor jwtTokenUserInterceptor;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册自定义拦截器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> registry</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;开始注册自定义拦截器...&quot;</span>);<br>    <span class="hljs-comment">//.........</span><br><br>    registry.addInterceptor(jwtTokenUserInterceptor)<br>            .addPathPatterns(<span class="hljs-string">&quot;/user/**&quot;</span>)<br>            .excludePathPatterns(<span class="hljs-string">&quot;/user/user/login&quot;</span>)<br>            .excludePathPatterns(<span class="hljs-string">&quot;/user/shop/status&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="九-商品浏览功能"><a href="#九-商品浏览功能" class="headerlink" title="九. 商品浏览功能"></a>九. 商品浏览功能</h1><p>这里导入相关代码</p><h2 id="1-Mapper层"><a href="#1-Mapper层" class="headerlink" title="1. Mapper层"></a>1. Mapper层</h2><p><strong>在SetmealMapper.java中添加list和getDishItemBySetmealId两个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 动态条件查询套餐</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> setmeal</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   List&lt;Setmeal&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Setmeal setmeal)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据套餐id查询菜品选项</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> setmealId</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Select(&quot;select sd.name, sd.copies, d.image, d.description &quot; +</span><br><span class="hljs-meta">           &quot;from setmeal_dish sd left join dish d on sd.dish_id = d.id &quot; +</span><br><span class="hljs-meta">           &quot;where sd.setmeal_id = #&#123;setmealId&#125;&quot;)</span><br>   List&lt;DishItemVO&gt; <span class="hljs-title function_">getDishItemBySetmealId</span><span class="hljs-params">(Long setmealId)</span>;<br></code></pre></td></tr></table></figure><p><strong>创建SetmealMapper.xml文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.SetmealMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Setmeal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Setmeal&quot;</span>&gt;</span><br>        select * from setmeal<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;categoryId != null&quot;</span>&gt;</span><br>                and category_id = #&#123;categoryId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>                and status = #&#123;status&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-Service层"><a href="#2-Service层" class="headerlink" title="2. Service层"></a>2. Service层</h2><p><strong>创建SetmealService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service;<br><br><span class="hljs-keyword">import</span> com.sky.dto.SetmealDTO;<br><span class="hljs-keyword">import</span> com.sky.dto.SetmealPageQueryDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.Setmeal;<br><span class="hljs-keyword">import</span> com.sky.result.PageResult;<br><span class="hljs-keyword">import</span> com.sky.vo.DishItemVO;<br><span class="hljs-keyword">import</span> com.sky.vo.SetmealVO;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetmealService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 条件查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmeal</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    List&lt;Setmeal&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Setmeal setmeal)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询菜品选项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    List&lt;DishItemVO&gt; <span class="hljs-title function_">getDishItemById</span><span class="hljs-params">(Long id)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建SetmealServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service.impl;<br><br><span class="hljs-keyword">import</span> com.sky.entity.Setmeal;<br><span class="hljs-keyword">import</span> com.sky.mapper.DishMapper;<br><span class="hljs-keyword">import</span> com.sky.mapper.SetmealDishMapper;<br><span class="hljs-keyword">import</span> com.sky.mapper.SetmealMapper;<br><span class="hljs-keyword">import</span> com.sky.service.SetmealService;<br><span class="hljs-keyword">import</span> com.sky.vo.DishItemVO;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 套餐业务实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetmealServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SetmealService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealMapper setmealMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealDishMapper setmealDishMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishMapper dishMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 条件查询</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmeal</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;Setmeal&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Setmeal setmeal)</span> &#123;<br>        List&lt;Setmeal&gt; list = setmealMapper.list(setmeal);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询菜品选项</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;DishItemVO&gt; <span class="hljs-title function_">getDishItemById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> setmealMapper.getDishItemBySetmealId(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在DishService.java中添加listWithFlavor方法定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 条件查询菜品和口味</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   List&lt;DishVO&gt; <span class="hljs-title function_">listWithFlavor</span><span class="hljs-params">(Dish dish)</span>;<br></code></pre></td></tr></table></figure><p><strong>在DishServiceImpl.java中实现listWithFlavor方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 条件查询菜品和口味</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> List&lt;DishVO&gt; <span class="hljs-title function_">listWithFlavor</span><span class="hljs-params">(Dish dish)</span> &#123;<br>       List&lt;Dish&gt; dishList = dishMapper.list(dish);<br><br>       List&lt;DishVO&gt; dishVOList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>       <span class="hljs-keyword">for</span> (Dish d : dishList) &#123;<br>           <span class="hljs-type">DishVO</span> <span class="hljs-variable">dishVO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishVO</span>();<br>           BeanUtils.copyProperties(d,dishVO);<br><br>           <span class="hljs-comment">//根据菜品id查询对应的口味</span><br>           List&lt;DishFlavor&gt; flavors = dishFlavorMapper.getByDishId(d.getId());<br><br>           dishVO.setFlavors(flavors);<br>           dishVOList.add(dishVO);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> dishVOList;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-Controller层"><a href="#3-Controller层" class="headerlink" title="3. Controller层"></a>3. Controller层</h2><p><strong>创建DishController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><span class="hljs-keyword">import</span> com.sky.constant.StatusConstant;<br><span class="hljs-keyword">import</span> com.sky.entity.Dish;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.DishService;<br><span class="hljs-keyword">import</span> com.sky.vo.DishVO;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController(&quot;userDishController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/dish&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Api(tags = &quot;C端-菜品浏览接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishService dishService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据分类id查询菜品</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;根据分类id查询菜品&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br>        <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dish</span>();<br>        dish.setCategoryId(categoryId);<br>        dish.setStatus(StatusConstant.ENABLE);<span class="hljs-comment">//查询起售中的菜品</span><br><br>        List&lt;DishVO&gt; list = dishService.listWithFlavor(dish);<br><br>        <span class="hljs-keyword">return</span> Result.success(list);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建CategoryController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><span class="hljs-keyword">import</span> com.sky.entity.Category;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.CategoryService;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController(&quot;userCategoryController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/category&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;C端-分类接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CategoryController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CategoryService categoryService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询分类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;查询分类&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;Category&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Integer type)</span> &#123;<br>        List&lt;Category&gt; list = categoryService.list(type);<br>        <span class="hljs-keyword">return</span> Result.success(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建SetmealController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><span class="hljs-keyword">import</span> com.sky.constant.StatusConstant;<br><span class="hljs-keyword">import</span> com.sky.entity.Setmeal;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.SetmealService;<br><span class="hljs-keyword">import</span> com.sky.vo.DishItemVO;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController(&quot;userSetmealController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/setmeal&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;C端-套餐浏览接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetmealController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealService setmealService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 条件查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;根据分类id查询套餐&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;Setmeal&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br>        <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Setmeal</span>();<br>        setmeal.setCategoryId(categoryId);<br>        setmeal.setStatus(StatusConstant.ENABLE);<br><br>        List&lt;Setmeal&gt; list = setmealService.list(setmeal);<br>        <span class="hljs-keyword">return</span> Result.success(list);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据套餐id查询包含的菜品列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/dish/&#123;id&#125;&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;根据套餐id查询包含的菜品列表&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;DishItemVO&gt;&gt; <span class="hljs-title function_">dishList</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>        List&lt;DishItemVO&gt; list = setmealService.getDishItemById(id);<br>        <span class="hljs-keyword">return</span> Result.success(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十-缓存菜品和套餐"><a href="#十-缓存菜品和套餐" class="headerlink" title="十. 缓存菜品和套餐"></a>十. 缓存菜品和套餐</h1><h2 id="1-缓存菜品"><a href="#1-缓存菜品" class="headerlink" title="1. 缓存菜品"></a>1. 缓存菜品</h2><h3 id="1-1-问题分析"><a href="#1-1-问题分析" class="headerlink" title="1.1 问题分析"></a>1.1 问题分析</h3><p>用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问压力随之增大。通过<strong>Redis来缓存菜品数据，减少数据库查询操作</strong>。</p><ul><li>每个分类下的菜品保存一份缓存数据</li><li>数据库中菜品数据有变更时清理缓存数据</li></ul><p>为了保证数据库和Redis中的<strong>数据保持一致</strong>，修改<strong>管理端接口 DishController</strong> 的相关方法，加入清理缓存逻辑。</p><p>需要改造的方法：</p><ul><li>新增菜品</li><li>修改菜品</li><li>批量删除菜品</li><li>起售、停售菜品</li></ul><h3 id="1-2-用户端接口DishController"><a href="#1-2-用户端接口DishController" class="headerlink" title="1.2 用户端接口DishController"></a>1.2 用户端接口DishController</h3><p><strong>修改用户端接口 DishController 的 list 方法，加入缓存处理逻辑：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据分类id查询菜品</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;根据分类id查询菜品&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br><br>       <span class="hljs-comment">//构造redis中的key，规则：dish_分类id</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + categoryId;<br><br>       <span class="hljs-comment">//查询redis中是否存在菜品数据</span><br>       List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);<br>       <span class="hljs-keyword">if</span>(list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-comment">//如果存在，直接返回，无须查询数据库</span><br>           <span class="hljs-keyword">return</span> Result.success(list);<br>       &#125;<br><span class="hljs-comment">////////////////////////////////////////////////////////</span><br>       <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dish</span>();<br>       dish.setCategoryId(categoryId);<br>       dish.setStatus(StatusConstant.ENABLE);<span class="hljs-comment">//查询起售中的菜品</span><br><br>       <span class="hljs-comment">//如果不存在，查询数据库，将查询到的数据放入redis中</span><br>       list = dishService.listWithFlavor(dish);<br>       <span class="hljs-comment">////////////////////////////////////////////////////////</span><br>       redisTemplate.opsForValue().set(key, list);<br><br>       <span class="hljs-keyword">return</span> Result.success(list);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-管理端接口DishController"><a href="#1-3-管理端接口DishController" class="headerlink" title="1.3 管理端接口DishController"></a>1.3 管理端接口DishController</h3><h4 id="1-3-1-抽取清理缓存的方法"><a href="#1-3-1-抽取清理缓存的方法" class="headerlink" title="1.3.1 抽取清理缓存的方法"></a>1.3.1 抽取清理缓存的方法</h4><p>在管理端DishController中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 清理缓存数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> pattern</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanCache</span><span class="hljs-params">(String pattern)</span>&#123;<br>       <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.keys(pattern);<br>       redisTemplate.delete(keys);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-新增菜品优化"><a href="#1-3-2-新增菜品优化" class="headerlink" title="1.3.2 新增菜品优化"></a>1.3.2 新增菜品优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 新增菜品</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;新增菜品&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> DishDTO dishDTO)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;新增菜品：&#123;&#125;&quot;</span>, dishDTO);<br>       dishService.saveWithFlavor(dishDTO);<br><br>       <span class="hljs-comment">//清理缓存数据</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + dishDTO.getCategoryId();<br>       cleanCache(key);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-菜品批量删除优化"><a href="#1-3-3-菜品批量删除优化" class="headerlink" title="1.3.3 菜品批量删除优化"></a>1.3.3 菜品批量删除优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品批量删除</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@DeleteMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;菜品批量删除&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;菜品批量删除：&#123;&#125;&quot;</span>, ids);<br>       dishService.deleteBatch(ids);<br><br>       <span class="hljs-comment">//将所有的菜品缓存数据清理掉，所有以dish_开头的key</span><br>       cleanCache(<span class="hljs-string">&quot;dish_*&quot;</span>);<br><br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-4-修改菜品优化"><a href="#1-3-4-修改菜品优化" class="headerlink" title="1.3.4 修改菜品优化"></a>1.3.4 修改菜品优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改菜品</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> dishDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;修改菜品&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> DishDTO dishDTO)</span> &#123;<br>       log.info(<span class="hljs-string">&quot;修改菜品：&#123;&#125;&quot;</span>, dishDTO);<br>       dishService.updateWithFlavor(dishDTO);<br><br>       <span class="hljs-comment">//将所有的菜品缓存数据清理掉，所有以dish_开头的key</span><br>       cleanCache(<span class="hljs-string">&quot;dish_*&quot;</span>);<br><br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-5-菜品起售停售优化"><a href="#1-3-5-菜品起售停售优化" class="headerlink" title="1.3.5 菜品起售停售优化"></a>1.3.5 菜品起售停售优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 菜品起售停售</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;菜品起售停售&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status, Long id)</span> &#123;<br>       dishService.startOrStop(status, id);<br><br>       <span class="hljs-comment">//将所有的菜品缓存数据清理掉，所有以dish_开头的key</span><br>       cleanCache(<span class="hljs-string">&quot;dish_*&quot;</span>);<br><br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="2-缓存套餐"><a href="#2-缓存套餐" class="headerlink" title="2. 缓存套餐"></a>2. 缓存套餐</h2><h3 id="2-1-Spring-Cache"><a href="#2-1-Spring-Cache" class="headerlink" title="2.1 Spring Cache"></a>2.1 Spring Cache</h3><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><h4 id="2-1-1-常用注解"><a href="#2-1-1-常用注解" class="headerlink" title="2.1.1 常用注解"></a>2.1.1 常用注解</h4><p>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@EnableCaching</td><td>开启缓存注解功能，通常加在启动类上</td></tr><tr><td>@Cacheable</td><td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><h4 id="2-1-2-EnableCaching"><a href="#2-1-2-EnableCaching" class="headerlink" title="2.1.2 @EnableCaching"></a>2.1.2 @EnableCaching</h4><p><strong>启动类上加@EnableCaching:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.EnableCaching;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableCaching</span><span class="hljs-comment">//开启缓存注解功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheDemoApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CacheDemoApplication.class,args);<br>        log.info(<span class="hljs-string">&quot;项目启动成功...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-3-CachePut注解"><a href="#2-1-3-CachePut注解" class="headerlink" title="2.1.3 @CachePut注解"></a>2.1.3 @CachePut注解</h4><p><strong>@CachePut 说明：</strong> </p><ul><li>​作用: 将方法返回值，放入缓存</li><li>​value: 缓存的名称, 每个缓存名称下面可以有很多key</li><li>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</li></ul><p><strong>在save方法上加注解@CachePut</strong></p><p>当前UserController的save方法是用来保存用户信息的，我们希望在该用户信息保存到数据库的同时，也往缓存中缓存一份数据，我们可以在save方法上加上注解 @CachePut，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* CachePut：将方法返回值放入缓存</span><br><span class="hljs-comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span><br><span class="hljs-comment">* key：缓存的key</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-meta">@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)</span><span class="hljs-comment">//key的生成：userCache::1</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>    userMapper.insert(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><p>**说明：**key的写法如下</p><p>#user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ;</p><h4 id="2-1-4-Cacheable注解"><a href="#2-1-4-Cacheable注解" class="headerlink" title="2.1.4 @Cacheable注解"></a>2.1.4 @Cacheable注解</h4><p><strong>@Cacheable 说明:</strong></p><ul><li>​作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中</li><li>​value: 缓存的名称，每个缓存名称下面可以有多个key</li><li>​key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</li></ul><p> <strong>在getById上加注解@Cacheable</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，  *调用方法并将方法返回值放到缓存中</span><br><span class="hljs-comment">* value：缓存的名称，每个缓存名称下面可以有多个key</span><br><span class="hljs-comment">* key：缓存的key</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-meta">@Cacheable(cacheNames = &quot;userCache&quot;,key=&quot;#id&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getById(id);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-5-CacheEvict注解"><a href="#2-1-5-CacheEvict注解" class="headerlink" title="2.1.5 @CacheEvict注解"></a>2.1.5 @CacheEvict注解</h4><p><strong>@CacheEvict 说明：</strong> </p><ul><li>作用: 清理指定缓存</li><li>value: 缓存的名称，每个缓存名称下面可以有多个key</li><li>key: 缓存的key  ———-&gt; 支持Spring的表达式语言SPEL语法</li></ul><p><strong>在 delete 方法上加注解@CacheEvict</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping</span><br><span class="hljs-meta">@CacheEvict(cacheNames = &quot;userCache&quot;,key = &quot;#id&quot;)</span><span class="hljs-comment">//删除某个key对应的缓存数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Long id)</span>&#123;<br>    userMapper.deleteById(id);<br>&#125;<br><br><span class="hljs-meta">@DeleteMapping(&quot;/delAll&quot;)</span><br><span class="hljs-meta">@CacheEvict(cacheNames = &quot;userCache&quot;,allEntries = true)</span><span class="hljs-comment">//删除userCache下所有的缓存数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span>&#123;<br>    userMapper.deleteAll();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-实现思路"><a href="#2-2-实现思路" class="headerlink" title="2.2 实现思路"></a>2.2 实现思路</h3><p><strong>实现步骤：</strong></p><p>1). 导入Spring Cache和Redis相关maven坐标</p><p>2). 在启动类上加入@EnableCaching注解，开启缓存注解功能</p><p>3). 在用户端接口SetmealController的 list 方法上加入@Cacheable注解</p><p>4). 在管理端接口SetmealController的 save、delete、update、startOrStop等方法上加入CacheEvict注解</p><h3 id="2-3-代码开发"><a href="#2-3-代码开发" class="headerlink" title="2.3 代码开发"></a>2.3 代码开发</h3><h4 id="2-3-1-EnableCaching"><a href="#2-3-1-EnableCaching" class="headerlink" title="2.3.1 @EnableCaching"></a>2.3.1 @EnableCaching</h4><p><strong>在启动类上加入@EnableCaching注解，开启缓存注解功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cache.annotation.EnableCaching;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableTransactionManagement</span> <span class="hljs-comment">//开启注解方式的事务管理</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SkyApplication.class, args);<br>        log.info(<span class="hljs-string">&quot;server started&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-用户端接口"><a href="#2-3-2-用户端接口" class="headerlink" title="2.3.2 用户端接口"></a>2.3.2 用户端接口</h4><p><strong>在用户端接口SetmealController的 list 方法上加入@Cacheable注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 条件查询</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> categoryId</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;根据分类id查询套餐&quot;)</span><br>   <span class="hljs-meta">@Cacheable(cacheNames = &quot;setmealCache&quot;,key = &quot;#categoryId&quot;)</span> <span class="hljs-comment">//key: setmealCache::100</span><br>   <span class="hljs-keyword">public</span> Result&lt;List&lt;Setmeal&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Long categoryId)</span> &#123;<br>       <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Setmeal</span>();<br>       setmeal.setCategoryId(categoryId);<br>       setmeal.setStatus(StatusConstant.ENABLE);<br><br>       List&lt;Setmeal&gt; list = setmealService.list(setmeal);<br>       <span class="hljs-keyword">return</span> Result.success(list);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-3-管理端接口"><a href="#2-3-3-管理端接口" class="headerlink" title="2.3.3 管理端接口"></a>2.3.3 管理端接口</h4><p><strong>在管理端接口SetmealController的 save、delete、update、startOrStop等方法上加入CacheEvict注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 新增套餐</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;新增套餐&quot;)</span><br>   <span class="hljs-meta">@CacheEvict(cacheNames = &quot;setmealCache&quot;,key = &quot;#setmealDTO.categoryId&quot;)</span><span class="hljs-comment">//key: setmealCache::100</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SetmealDTO setmealDTO)</span> &#123;<br>       setmealService.saveWithDish(setmealDTO);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 批量删除套餐</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ids</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@DeleteMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;批量删除套餐&quot;)</span><br>   <span class="hljs-meta">@CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;<br>       setmealService.deleteBatch(ids);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改套餐</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> setmealDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping</span><br>   <span class="hljs-meta">@ApiOperation(&quot;修改套餐&quot;)</span><br>   <span class="hljs-meta">@CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SetmealDTO setmealDTO)</span> &#123;<br>       setmealService.update(setmealDTO);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 套餐起售停售</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;套餐起售停售&quot;)</span><br>   <span class="hljs-meta">@CacheEvict(cacheNames = &quot;setmealCache&quot;,allEntries = true)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startOrStop</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer status, Long id)</span> &#123;<br>       setmealService.startOrStop(status, id);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="十一-购物车管理"><a href="#十一-购物车管理" class="headerlink" title="十一. 购物车管理"></a>十一. 购物车管理</h1><h2 id="1-添加购物车"><a href="#1-添加购物车" class="headerlink" title="1. 添加购物车"></a>1. 添加购物车</h2><h3 id="1-1-Controller层-1"><a href="#1-1-Controller层-1" class="headerlink" title="1.1 Controller层"></a>1.1 Controller层</h3><p><strong>根据添加购物车接口创建ShoppingCartController：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><br><span class="hljs-keyword">import</span> com.sky.dto.ShoppingCartDTO;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 购物车</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/shoppingCart&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Api(tags = &quot;C端-购物车接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCartController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ShoppingCartService shoppingCartService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加购物车</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;添加购物车&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ShoppingCartDTO shoppingCartDTO)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;添加购物车：&#123;&#125;&quot;</span>, shoppingCartDTO);<br>        shoppingCartService.addShoppingCart(shoppingCartDTO);<span class="hljs-comment">//后绪步骤实现</span><br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Service层-1"><a href="#1-2-Service层-1" class="headerlink" title="1.2 Service层"></a>1.2 Service层</h3><h4 id="1-2-1-Service层接口-1"><a href="#1-2-1-Service层接口-1" class="headerlink" title="1.2.1 Service层接口"></a>1.2.1 Service层接口</h4><p><strong>创建ShoppingCartService接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service;<br><br><span class="hljs-keyword">import</span> com.sky.dto.ShoppingCartDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.ShoppingCart;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShoppingCartService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加购物车</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShoppingCart</span><span class="hljs-params">(ShoppingCartDTO shoppingCartDTO)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-Service层实现类-1"><a href="#1-2-2-Service层实现类-1" class="headerlink" title="1.2.2 Service层实现类"></a>1.2.2 Service层实现类</h4><p><strong>创建ShoppingCartServiceImpl实现类，并实现add方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service.impl;<br><br><br><span class="hljs-keyword">import</span> com.sky.context.BaseContext;<br><span class="hljs-keyword">import</span> com.sky.dto.ShoppingCartDTO;<br><span class="hljs-keyword">import</span> com.sky.entity.Dish;<br><span class="hljs-keyword">import</span> com.sky.entity.Setmeal;<br><span class="hljs-keyword">import</span> com.sky.entity.ShoppingCart;<br><span class="hljs-keyword">import</span> com.sky.mapper.DishMapper;<br><span class="hljs-keyword">import</span> com.sky.mapper.SetmealMapper;<br><span class="hljs-keyword">import</span> com.sky.service.ShoppingCartService;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeanUtils;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCartServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShoppingCartService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ShoppingCartMapper shoppingCartMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishMapper dishMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealMapper setmealMapper;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加购物车</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShoppingCart</span><span class="hljs-params">(ShoppingCartDTO shoppingCartDTO)</span> &#123;<br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br>        BeanUtils.copyProperties(shoppingCartDTO, shoppingCart);<br>        <span class="hljs-comment">//只能查询自己的购物车数据</span><br>        shoppingCart.setUserId(BaseContext.getCurrentId());<br><br>        <span class="hljs-comment">//判断当前商品是否在购物车中</span><br>        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);<br><br>        <span class="hljs-keyword">if</span> (shoppingCartList != <span class="hljs-literal">null</span> &amp;&amp; shoppingCartList.size() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//如果已经存在，就更新数量，数量加1</span><br>            shoppingCart = shoppingCartList.get(<span class="hljs-number">0</span>);<br>            shoppingCart.setNumber(shoppingCart.getNumber() + <span class="hljs-number">1</span>);<br>            shoppingCartMapper.updateNumberById(shoppingCart);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果不存在，插入数据，数量就是1</span><br><br>            <span class="hljs-comment">//判断当前添加到购物车的是菜品还是套餐</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">dishId</span> <span class="hljs-operator">=</span> shoppingCartDTO.getDishId();<br>            <span class="hljs-keyword">if</span> (dishId != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//添加到购物车的是菜品</span><br>                <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> dishMapper.getById(dishId);<br>                shoppingCart.setName(dish.getName());<br>                shoppingCart.setImage(dish.getImage());<br>                shoppingCart.setAmount(dish.getPrice());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//添加到购物车的是套餐</span><br>                <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> setmealMapper.getById(shoppingCartDTO.getSetmealId());<br>                shoppingCart.setName(setmeal.getName());<br>                shoppingCart.setImage(setmeal.getImage());<br>                shoppingCart.setAmount(setmeal.getPrice());<br>            &#125;<br>            shoppingCart.setNumber(<span class="hljs-number">1</span>);<br>            shoppingCart.setCreateTime(LocalDateTime.now());<br>            shoppingCartMapper.insert(shoppingCart);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Mapper层-1"><a href="#1-3-Mapper层-1" class="headerlink" title="1.3 Mapper层"></a>1.3 Mapper层</h3><p><strong>创建ShoppingCartMapper接口:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-keyword">import</span> com.sky.entity.ShoppingCart;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Delete;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Insert;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Update;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShoppingCartMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 条件查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCart</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    List&lt;ShoppingCart&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(ShoppingCart shoppingCart)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新商品数量</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCart</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Update(&quot;update shopping_cart set number = #&#123;number&#125; where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateNumberById</span><span class="hljs-params">(ShoppingCart shoppingCart)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入购物车数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCart</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Insert(&quot;insert into shopping_cart (name, user_id, dish_id, setmeal_id, dish_flavor, number, amount, image, create_time) &quot; +</span><br><span class="hljs-meta">            &quot; values (#&#123;name&#125;,#&#123;userId&#125;,#&#123;dishId&#125;,#&#123;setmealId&#125;,#&#123;dishFlavor&#125;,#&#123;number&#125;,#&#123;amount&#125;,#&#123;image&#125;,#&#123;createTime&#125;)&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(ShoppingCart shoppingCart)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建ShoppingCartMapper.xml：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.ShoppingCartMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;ShoppingCart&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;ShoppingCart&quot;</span>&gt;</span><br>        select * from shopping_cart<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId != null&quot;</span>&gt;</span><br>                and user_id = #&#123;userId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;dishId != null&quot;</span>&gt;</span><br>                and dish_id = #&#123;dishId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;setmealId != null&quot;</span>&gt;</span><br>                and setmeal_id = #&#123;setmealId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;dishFlavor != null&quot;</span>&gt;</span><br>                and dish_flavor = #&#123;dishFlavor&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by create_time desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-查看购物车"><a href="#2-查看购物车" class="headerlink" title="2. 查看购物车"></a>2. 查看购物车</h2><h3 id="2-1-Controller层"><a href="#2-1-Controller层" class="headerlink" title="2.1 Controller层"></a>2.1 Controller层</h3><p><strong>在ShoppingCartController中创建查看购物车的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 查看购物车</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;查看购物车&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;List&lt;ShoppingCart&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> Result.success(shoppingCartService.showShoppingCart());<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Service层接口"><a href="#2-2-Service层接口" class="headerlink" title="2.2 Service层接口"></a>2.2 Service层接口</h3><p><strong>在ShoppingCartService接口中声明查看购物车的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 查看购物车</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   List&lt;ShoppingCart&gt; <span class="hljs-title function_">showShoppingCart</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-Service层实现类"><a href="#2-3-Service层实现类" class="headerlink" title="2.3 Service层实现类"></a>2.3 Service层实现类</h3><p><strong>在ShoppingCartServiceImpl中实现查看购物车的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 查看购物车</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> List&lt;ShoppingCart&gt; <span class="hljs-title function_">showShoppingCart</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> shoppingCartMapper.list(ShoppingCart.<br>                                      builder().<br>                                      userId(BaseContext.getCurrentId()).<br>                                      build());<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-清空购物车"><a href="#3-清空购物车" class="headerlink" title="3. 清空购物车"></a>3. 清空购物车</h2><h3 id="3-1-Controller层-2"><a href="#3-1-Controller层-2" class="headerlink" title="3.1 Controller层"></a>3.1 Controller层</h3><p><strong>在ShoppingCartController中创建清空购物车的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 清空购物车商品</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@DeleteMapping(&quot;/clean&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;清空购物车商品&quot;)</span><br>   <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">clean</span><span class="hljs-params">()</span>&#123;<br>       shoppingCartService.cleanShoppingCart();<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Service层接口"><a href="#3-2-Service层接口" class="headerlink" title="3.2 Service层接口"></a>3.2 Service层接口</h3><p><strong>在ShoppingCartService接口中声明清空购物车的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 清空购物车商品</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanShoppingCart</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-Service层实现类"><a href="#3-3-Service层实现类" class="headerlink" title="3.3 Service层实现类"></a>3.3 Service层实现类</h3><p><strong>在ShoppingCartServiceImpl中实现清空购物车的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 清空购物车商品</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanShoppingCart</span><span class="hljs-params">()</span> &#123;<br>       shoppingCartMapper.deleteByUserId(BaseContext.getCurrentId());<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-Mapper层"><a href="#3-4-Mapper层" class="headerlink" title="3.4 Mapper层"></a>3.4 Mapper层</h3><p><strong>在ShoppingCartMapper接口中创建删除购物车数据的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据用户id删除购物车数据</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Delete(&quot;delete from shopping_cart where user_id = #&#123;userId&#125;&quot;)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByUserId</span><span class="hljs-params">(Long userId)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-删除购物车中单个商品"><a href="#4-删除购物车中单个商品" class="headerlink" title="4. 删除购物车中单个商品"></a>4. 删除购物车中单个商品</h2><h3 id="4-1-ShoppingCartController"><a href="#4-1-ShoppingCartController" class="headerlink" title="4.1 ShoppingCartController"></a>4.1 ShoppingCartController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除购物车中一个商品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PostMapping(&quot;/sub&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;删除购物车中一个商品&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ShoppingCartDTO shoppingCartDTO)</span>&#123;<br>    log.info(<span class="hljs-string">&quot;删除购物车中一个商品，商品：&#123;&#125;&quot;</span>, shoppingCartDTO);<br>    shoppingCartService.subShoppingCart(shoppingCartDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-ShoppingCartService"><a href="#4-2-ShoppingCartService" class="headerlink" title="4.2 ShoppingCartService"></a>4.2 ShoppingCartService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除购物车中一个商品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">subShoppingCart</span><span class="hljs-params">(ShoppingCartDTO shoppingCartDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-ShoppingCartServiceImpl"><a href="#4-3-ShoppingCartServiceImpl" class="headerlink" title="4.3 ShoppingCartServiceImpl"></a>4.3 ShoppingCartServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除购物车中一个商品</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCartDTO</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subShoppingCart</span><span class="hljs-params">(ShoppingCartDTO shoppingCartDTO)</span> &#123;<br>    <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br>    BeanUtils.copyProperties(shoppingCartDTO,shoppingCart);<br>    <span class="hljs-comment">//设置查询条件，查询当前登录用户的购物车数据</span><br>    shoppingCart.setUserId(BaseContext.getCurrentId());<br><br>    List&lt;ShoppingCart&gt; list = shoppingCartMapper.list(shoppingCart);<br><br>    <span class="hljs-keyword">if</span>(list != <span class="hljs-literal">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>)&#123;<br>        shoppingCart = list.get(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> shoppingCart.getNumber();<br>        <span class="hljs-keyword">if</span>(number == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//当前商品在购物车中的份数为1，直接删除当前记录</span><br>            shoppingCartMapper.deleteById(shoppingCart.getId());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//当前商品在购物车中的份数不为1，修改份数即可</span><br>            shoppingCart.setNumber(shoppingCart.getNumber() - <span class="hljs-number">1</span>);<br>            shoppingCartMapper.updateNumberById(shoppingCart);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-ShoppingCartMapper"><a href="#4-4-ShoppingCartMapper" class="headerlink" title="4.4 ShoppingCartMapper"></a>4.4 ShoppingCartMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id删除购物车数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Delete(&quot;delete from shopping_cart where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h1 id="十二-用户下单和订单支付"><a href="#十二-用户下单和订单支付" class="headerlink" title="十二. 用户下单和订单支付"></a>十二. 用户下单和订单支付</h1><h2 id="1-用户下单"><a href="#1-用户下单" class="headerlink" title="1. 用户下单"></a>1. 用户下单</h2><h3 id="1-1-Controller层-2"><a href="#1-1-Controller层-2" class="headerlink" title="1.1 Controller层"></a>1.1 Controller层</h3><p><strong>创建OrderController并提供用户下单方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.user;<br><br><span class="hljs-keyword">import</span> com.sky.dto.OrdersPaymentDTO;<br><span class="hljs-keyword">import</span> com.sky.dto.OrdersSubmitDTO;<br><span class="hljs-keyword">import</span> com.sky.result.PageResult;<br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.OrderService;<br><span class="hljs-keyword">import</span> com.sky.vo.OrderPaymentVO;<br><span class="hljs-keyword">import</span> com.sky.vo.OrderSubmitVO;<br><span class="hljs-keyword">import</span> com.sky.vo.OrderVO;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController(&quot;userOrderController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/user/order&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Api(tags = &quot;C端-订单接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户下单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersSubmitDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;用户下单&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;OrderSubmitVO&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrdersSubmitDTO ordersSubmitDTO)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;用户下单：&#123;&#125;&quot;</span>, ordersSubmitDTO);<br>        <span class="hljs-type">OrderSubmitVO</span> <span class="hljs-variable">orderSubmitVO</span> <span class="hljs-operator">=</span> orderService.submitOrder(ordersSubmitDTO);<br>        <span class="hljs-keyword">return</span> Result.success(orderSubmitVO);<br>    &#125; <br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Service层-2"><a href="#1-2-Service层-2" class="headerlink" title="1.2 Service层"></a>1.2 Service层</h3><h4 id="1-2-1-Service接口"><a href="#1-2-1-Service接口" class="headerlink" title="1.2.1 Service接口"></a>1.2.1 Service接口</h4><p><strong>创建OrderService接口，并声明用户下单方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service;<br><br><span class="hljs-keyword">import</span> com.sky.dto.*;<br><span class="hljs-keyword">import</span> com.sky.vo.OrderSubmitVO;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户下单</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersSubmitDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    OrderSubmitVO <span class="hljs-title function_">submitOrder</span><span class="hljs-params">(OrdersSubmitDTO ordersSubmitDTO)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-Service层实现类-2"><a href="#1-2-2-Service层实现类-2" class="headerlink" title="1.2.2 Service层实现类"></a>1.2.2 Service层实现类</h4><p><strong>创建OrderServiceImpl实现OrderService接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service.impl;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderDetailMapper orderDetailMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ShoppingCartMapper shoppingCartMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AddressBookMapper addressBookMapper;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户下单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersSubmitDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> OrderSubmitVO <span class="hljs-title function_">submitOrder</span><span class="hljs-params">(OrdersSubmitDTO ordersSubmitDTO)</span> &#123;<br>        <span class="hljs-comment">//异常情况的处理（收货地址为空、超出配送范围、购物车为空）</span><br>        <span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> addressBookMapper.getById(ordersSubmitDTO.getAddressBookId());<br>        <span class="hljs-keyword">if</span> (addressBook == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddressBookBusinessException</span>(MessageConstant.ADDRESS_BOOK_IS_NULL);<br>        &#125;<br><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br>        shoppingCart.setUserId(userId);<br><br>        <span class="hljs-comment">//查询当前用户的购物车数据</span><br>        List&lt;ShoppingCart&gt; shoppingCartList = shoppingCartMapper.list(shoppingCart);<br>        <span class="hljs-keyword">if</span> (shoppingCartList == <span class="hljs-literal">null</span> || shoppingCartList.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCartBusinessException</span>(MessageConstant.SHOPPING_CART_IS_NULL);<br>        &#125;<br><br>        <span class="hljs-comment">//构造订单数据</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        BeanUtils.copyProperties(ordersSubmitDTO,order);<br>        order.setPhone(addressBook.getPhone());<br>        order.setAddress(addressBook.getDetail());<br>        order.setConsignee(addressBook.getConsignee());<br>        order.setNumber(String.valueOf(System.currentTimeMillis()));<br>        order.setUserId(userId);<br>        order.setStatus(Orders.PENDING_PAYMENT);<br>        order.setPayStatus(Orders.UN_PAID);<br>        order.setOrderTime(LocalDateTime.now());<br><br>        <span class="hljs-comment">//向订单表插入1条数据</span><br>        orderMapper.insert(order);<br><br>        <span class="hljs-comment">//订单明细数据</span><br>        List&lt;OrderDetail&gt; orderDetailList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (ShoppingCart cart : shoppingCartList) &#123;<br>            <span class="hljs-type">OrderDetail</span> <span class="hljs-variable">orderDetail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDetail</span>();<br>            BeanUtils.copyProperties(cart, orderDetail);<br>            orderDetail.setOrderId(order.getId());<br>            orderDetailList.add(orderDetail);<br>        &#125;<br><br>        <span class="hljs-comment">//向明细表插入n条数据</span><br>        orderDetailMapper.insertBatch(orderDetailList);<br><br>        <span class="hljs-comment">//清理购物车中的数据</span><br>        shoppingCartMapper.deleteByUserId(userId);<br><br>        <span class="hljs-comment">//封装返回结果</span><br>        <span class="hljs-type">OrderSubmitVO</span> <span class="hljs-variable">orderSubmitVO</span> <span class="hljs-operator">=</span> OrderSubmitVO.builder()<br>                .id(order.getId())<br>                .orderNumber(order.getNumber())<br>                .orderAmount(order.getAmount())<br>                .orderTime(order.getOrderTime())<br>                .build();<br><br>        <span class="hljs-keyword">return</span> orderSubmitVO;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Mapper层-2"><a href="#1-3-Mapper层-2" class="headerlink" title="1.3 Mapper层"></a>1.3 Mapper层</h3><h4 id="1-3-1-创建OrderMapper接口和对应的xml映射文件"><a href="#1-3-1-创建OrderMapper接口和对应的xml映射文件" class="headerlink" title="1.3.1 创建OrderMapper接口和对应的xml映射文件"></a>1.3.1 创建OrderMapper接口和对应的xml映射文件</h4><p>OrderMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入订单数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> order</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Orders order)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.OrderMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Orders&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        insert into orders<br>        (number, status, user_id, address_book_id, order_time, checkout_time, pay_method, pay_status, amount, remark,<br>         phone, address, consignee, estimated_delivery_time, delivery_status, pack_amount, tableware_number,<br>         tableware_status)<br>        values (#&#123;number&#125;, #&#123;status&#125;, #&#123;userId&#125;, #&#123;addressBookId&#125;, #&#123;orderTime&#125;, #&#123;checkoutTime&#125;, #&#123;payMethod&#125;,<br>                #&#123;payStatus&#125;, #&#123;amount&#125;, #&#123;remark&#125;, #&#123;phone&#125;, #&#123;address&#125;, #&#123;consignee&#125;,<br>                #&#123;estimatedDeliveryTime&#125;, #&#123;deliveryStatus&#125;, #&#123;packAmount&#125;, #&#123;tablewareNumber&#125;, #&#123;tablewareStatus&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="1-3-2-创建OrderDetailMapper接口和对应的xml映射文件"><a href="#1-3-2-创建OrderDetailMapper接口和对应的xml映射文件" class="headerlink" title="1.3.2 创建OrderDetailMapper接口和对应的xml映射文件"></a>1.3.2 创建OrderDetailMapper接口和对应的xml映射文件</h4><p>OrderDetailMapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.mapper;<br><br><span class="hljs-keyword">import</span> com.sky.entity.OrderDetail;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderDetailMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量插入订单明细数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderDetails</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBatch</span><span class="hljs-params">(List&lt;OrderDetail&gt; orderDetails)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>OrderDetailMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.sky.mapper.OrderDetailMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        insert into order_detail<br>        (name, order_id, dish_id, setmeal_id, dish_flavor, number, amount, image)<br>        values<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;orderDetails&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;od&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            (#&#123;od.name&#125;,#&#123;od.orderId&#125;,#&#123;od.dishId&#125;,#&#123;od.setmealId&#125;,#&#123;od.dishFlavor&#125;,<br>             #&#123;od.number&#125;,#&#123;od.amount&#125;,#&#123;od.image&#125;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-订单支付"><a href="#2-订单支付" class="headerlink" title="2. 订单支付"></a>2. 订单支付</h2><h3 id="2-1-微信支付流程"><a href="#2-1-微信支付流程" class="headerlink" title="2.1 微信支付流程"></a>2.1 微信支付流程</h3><p><img src="/img/blogs/java/cangqiongtakeout/12.2.1.png"></p><h3 id="2-2-代码导入"><a href="#2-2-代码导入" class="headerlink" title="2.2 代码导入"></a>2.2 代码导入</h3><h4 id="2-2-1-Mapper层"><a href="#2-2-1-Mapper层" class="headerlink" title="2.2.1 Mapper层"></a>2.2.1 Mapper层</h4><p><strong>在OrderMapper.java中添加getByNumberAndUserId和update两个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据订单号和用户id查询订单</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> orderNumber</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Select(&quot;select * from orders where number = #&#123;orderNumber&#125; and user_id= #&#123;userId&#125;&quot;)</span><br>   Orders <span class="hljs-title function_">getByNumberAndUserId</span><span class="hljs-params">(String orderNumber, Long userId)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改订单信息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> orders</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Orders orders)</span>;<br></code></pre></td></tr></table></figure><p><strong>在OrderMapper.xml中添加</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.sky.entity.Orders&quot;</span>&gt;</span><br>        update orders<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;cancelReason != null and cancelReason!=&#x27;&#x27; &quot;</span>&gt;</span><br>                cancel_reason=#&#123;cancelReason&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;rejectionReason != null and rejectionReason!=&#x27;&#x27; &quot;</span>&gt;</span><br>                rejection_reason=#&#123;rejectionReason&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;cancelTime != null&quot;</span>&gt;</span><br>                cancel_time=#&#123;cancelTime&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;payStatus != null&quot;</span>&gt;</span><br>                pay_status=#&#123;payStatus&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;payMethod != null&quot;</span>&gt;</span><br>                pay_method=#&#123;payMethod&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;checkoutTime != null&quot;</span>&gt;</span><br>                checkout_time=#&#123;checkoutTime&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>                status = #&#123;status&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deliveryTime != null&quot;</span>&gt;</span><br>                delivery_time = #&#123;deliveryTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-Service层"><a href="#2-2-2-Service层" class="headerlink" title="2.2.2 Service层"></a>2.2.2 Service层</h4><p><strong>在OrderService.java中添加payment和paySuccess两个方法定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 订单支付</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ordersPaymentDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   OrderPaymentVO <span class="hljs-title function_">payment</span><span class="hljs-params">(OrdersPaymentDTO ordersPaymentDTO)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付成功，修改订单状态</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> outTradeNo</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccess</span><span class="hljs-params">(String outTradeNo)</span>;<br></code></pre></td></tr></table></figure><p><strong>在OrderServiceImpl.java中实现payment和paySuccess两个方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> UserMapper userMapper;<br><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> WeChatPayUtil weChatPayUtil;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 订单支付</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ordersPaymentDTO</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> OrderPaymentVO <span class="hljs-title function_">payment</span><span class="hljs-params">(OrdersPaymentDTO ordersPaymentDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">// 当前登录用户id</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.getById(userId);<br><br>       <span class="hljs-comment">//调用微信支付接口，生成预支付交易单</span><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> weChatPayUtil.pay(<br>               ordersPaymentDTO.getOrderNumber(), <span class="hljs-comment">//商户订单号</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>), <span class="hljs-comment">//支付金额，单位 元</span><br>               <span class="hljs-string">&quot;苍穹外卖订单&quot;</span>, <span class="hljs-comment">//商品描述</span><br>               user.getOpenid() <span class="hljs-comment">//微信用户的openid</span><br>       );<br><br>       <span class="hljs-keyword">if</span> (jsonObject.getString(<span class="hljs-string">&quot;code&quot;</span>) != <span class="hljs-literal">null</span> &amp;&amp; jsonObject.getString(<span class="hljs-string">&quot;code&quot;</span>).equals(<span class="hljs-string">&quot;ORDERPAID&quot;</span>)) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(<span class="hljs-string">&quot;该订单已支付&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-type">OrderPaymentVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> jsonObject.toJavaObject(OrderPaymentVO.class);<br>       vo.setPackageStr(jsonObject.getString(<span class="hljs-string">&quot;package&quot;</span>));<br><br>       <span class="hljs-keyword">return</span> vo;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付成功，修改订单状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> outTradeNo</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccess</span><span class="hljs-params">(String outTradeNo)</span> &#123;<br>       <span class="hljs-comment">// 当前登录用户id</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>       <span class="hljs-comment">// 根据订单号查询当前用户的订单</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getByNumberAndUserId(outTradeNo, userId);<br><br>       <span class="hljs-comment">// 根据订单id更新订单的状态、支付方式、支付状态、结账时间</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> Orders.builder()<br>               .id(ordersDB.getId())<br>               .status(Orders.TO_BE_CONFIRMED)<br>               .payStatus(Orders.PAID)<br>               .checkoutTime(LocalDateTime.now())<br>               .build();<br><br>       orderMapper.update(orders);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-Controller层"><a href="#2-2-3-Controller层" class="headerlink" title="2.2.3 Controller层"></a>2.2.3 Controller层</h4><p><strong>在OrderController.java中添加payment方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 订单支付</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> ordersPaymentDTO</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@PutMapping(&quot;/payment&quot;)</span><br>  <span class="hljs-meta">@ApiOperation(&quot;订单支付&quot;)</span><br>  <span class="hljs-keyword">public</span> Result&lt;OrderPaymentVO&gt; <span class="hljs-title function_">payment</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrdersPaymentDTO ordersPaymentDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      log.info(<span class="hljs-string">&quot;订单支付：&#123;&#125;&quot;</span>, ordersPaymentDTO);<br>      <span class="hljs-type">OrderPaymentVO</span> <span class="hljs-variable">orderPaymentVO</span> <span class="hljs-operator">=</span> orderService.payment(ordersPaymentDTO);<br>      log.info(<span class="hljs-string">&quot;生成预支付交易单：&#123;&#125;&quot;</span>, orderPaymentVO);<br>      <span class="hljs-keyword">return</span> Result.success(orderPaymentVO);<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>导入PayNotifyController.java</strong></p><h3 id="2-3-跳过微信支付"><a href="#2-3-跳过微信支付" class="headerlink" title="2.3 跳过微信支付"></a>2.3 跳过微信支付</h3><p><a href="https://blog.csdn.net/XZY__one/article/details/135818055">跳过微信支付</a></p><h1 id="十三-用户端历史订单模块"><a href="#十三-用户端历史订单模块" class="headerlink" title="十三. 用户端历史订单模块"></a>十三. 用户端历史订单模块</h1><h2 id="1-历史订单查询"><a href="#1-历史订单查询" class="headerlink" title="1. 历史订单查询"></a>1. 历史订单查询</h2><h3 id="1-1-user-OrderController"><a href="#1-1-user-OrderController" class="headerlink" title="1.1 user&#x2F;OrderController"></a>1.1 user&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 历史订单查询</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> status   订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/historyOrders&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;历史订单查询&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;PageResult&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize, Integer status)</span> &#123;<br>    <span class="hljs-type">PageResult</span> <span class="hljs-variable">pageResult</span> <span class="hljs-operator">=</span> orderService.pageQuery4User(page, pageSize, status);<br>    <span class="hljs-keyword">return</span> Result.success(pageResult);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-OrderService"><a href="#1-2-OrderService" class="headerlink" title="1.2 OrderService"></a>1.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户端订单分页查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>PageResult <span class="hljs-title function_">pageQuery4User</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize, Integer status)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3-OrderServiceImpl"><a href="#1-3-OrderServiceImpl" class="headerlink" title="1.3 OrderServiceImpl"></a>1.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户端订单分页查询</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageNum</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">pageQuery4User</span><span class="hljs-params">(<span class="hljs-type">int</span> pageNum, <span class="hljs-type">int</span> pageSize, Integer status)</span> &#123;<br>        <span class="hljs-comment">// 设置分页</span><br>        PageHelper.startPage(pageNum, pageSize);<br><br>        <span class="hljs-type">OrdersPageQueryDTO</span> <span class="hljs-variable">ordersPageQueryDTO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrdersPageQueryDTO</span>();<br>        ordersPageQueryDTO.setUserId(BaseContext.getCurrentId());<br>        ordersPageQueryDTO.setStatus(status);<br><br>        <span class="hljs-comment">// 分页条件查询</span><br>        Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);<br><br>        List&lt;OrderVO&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>        <span class="hljs-comment">// 查询出订单明细，并封装入OrderVO进行响应</span><br>        <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">null</span> &amp;&amp; page.getTotal() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Orders orders : page) &#123;<br>                <span class="hljs-type">Long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> orders.getId();<span class="hljs-comment">// 订单id</span><br><br>                <span class="hljs-comment">// 查询订单明细</span><br>                List&lt;OrderDetail&gt; orderDetails = orderDetailMapper.getByOrderId(orderId);<br><br>                <span class="hljs-type">OrderVO</span> <span class="hljs-variable">orderVO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderVO</span>();<br>                BeanUtils.copyProperties(orders, orderVO);<br>                orderVO.setOrderDetailList(orderDetails);<br><br>                list.add(orderVO);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(page.getTotal(), list);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-OrderMapper"><a href="#1-4-OrderMapper" class="headerlink" title="1.4 OrderMapper"></a>1.4 OrderMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分页条件查询并按下单时间排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersPageQueryDTO</span><br><span class="hljs-comment"> */</span><br>Page&lt;Orders&gt; <span class="hljs-title function_">pageQuery</span><span class="hljs-params">(OrdersPageQueryDTO ordersPageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-5-OrderMapper-xml"><a href="#1-5-OrderMapper-xml" class="headerlink" title="1.5 OrderMapper.xml"></a>1.5 OrderMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pageQuery&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Orders&quot;</span>&gt;</span><br>    select * from orders<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;number != null and number!=&#x27;&#x27;&quot;</span>&gt;</span><br>            and number like concat(&#x27;%&#x27;,#&#123;number&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;phone != null and phone!=&#x27;&#x27;&quot;</span>&gt;</span><br>            and phone like concat(&#x27;%&#x27;,#&#123;phone&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId != null&quot;</span>&gt;</span><br>            and user_id = #&#123;userId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;beginTime != null&quot;</span>&gt;</span><br>            and order_time <span class="hljs-symbol">&amp;gt;</span>= #&#123;beginTime&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;endTime != null&quot;</span>&gt;</span><br>            and order_time <span class="hljs-symbol">&amp;lt;</span>= #&#123;endTime&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by order_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-OrderDetailMapper"><a href="#1-6-OrderDetailMapper" class="headerlink" title="1.6 OrderDetailMapper"></a>1.6 OrderDetailMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据订单id查询订单明细</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> orderId</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Select(&quot;select * from order_detail where order_id = #&#123;orderId&#125;&quot;)</span><br>List&lt;OrderDetail&gt; <span class="hljs-title function_">getByOrderId</span><span class="hljs-params">(Long orderId)</span>;<br></code></pre></td></tr></table></figure><h2 id="2-查询订单详情"><a href="#2-查询订单详情" class="headerlink" title="2. 查询订单详情"></a>2. 查询订单详情</h2><h3 id="2-1-user-OrderController"><a href="#2-1-user-OrderController" class="headerlink" title="2.1 user&#x2F;OrderController"></a>2.1 user&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询订单详情</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/orderDetail/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;查询订单详情&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;OrderVO&gt; <span class="hljs-title function_">details</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-type">OrderVO</span> <span class="hljs-variable">orderVO</span> <span class="hljs-operator">=</span> orderService.details(id);<br>    <span class="hljs-keyword">return</span> Result.success(orderVO);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-OrderService"><a href="#2-2-OrderService" class="headerlink" title="2.2 OrderService"></a>2.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询订单详情</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>OrderVO <span class="hljs-title function_">details</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-OrderServiceImpl"><a href="#2-3-OrderServiceImpl" class="headerlink" title="2.3 OrderServiceImpl"></a>2.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查询订单详情</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> OrderVO <span class="hljs-title function_">details</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 根据id查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> orderMapper.getById(id);<br><br>    <span class="hljs-comment">// 查询该订单对应的菜品/套餐明细</span><br>    List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());<br><br>    <span class="hljs-comment">// 将该订单及其详情封装到OrderVO并返回</span><br>    <span class="hljs-type">OrderVO</span> <span class="hljs-variable">orderVO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderVO</span>();<br>    BeanUtils.copyProperties(orders, orderVO);<br>    orderVO.setOrderDetailList(orderDetailList);<br><br>    <span class="hljs-keyword">return</span> orderVO;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-OrderMapper"><a href="#2-4-OrderMapper" class="headerlink" title="2.4 OrderMapper"></a>2.4 OrderMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据id查询订单</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Select(&quot;select * from orders where id=#&#123;id&#125;&quot;)</span><br>Orders <span class="hljs-title function_">getById</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-取消订单"><a href="#3-取消订单" class="headerlink" title="3. 取消订单"></a>3. 取消订单</h2><h3 id="3-1-user-OrderController"><a href="#3-1-user-OrderController" class="headerlink" title="3.1 user&#x2F;OrderController"></a>3.1 user&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户取消订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/cancel/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;取消订单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    orderService.userCancelById(id);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-OrderService"><a href="#3-2-OrderService" class="headerlink" title="3.2 OrderService"></a>3.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户取消订单</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">userCancelById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><h3 id="3-3-OrderServiceImpl"><a href="#3-3-OrderServiceImpl" class="headerlink" title="3.3 OrderServiceImpl"></a>3.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户取消订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userCancelById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 根据id查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(id);<br><br>    <span class="hljs-comment">// 校验订单是否存在</span><br>    <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_NOT_FOUND);<br>    &#125;<br><br>    <span class="hljs-comment">//订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消</span><br>    <span class="hljs-keyword">if</span> (ordersDB.getStatus() &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>    &#125;<br><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>    orders.setId(ordersDB.getId());<br><br>    <span class="hljs-comment">// 订单处于待接单状态下取消，需要进行退款</span><br>    <span class="hljs-keyword">if</span> (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;<br>        <span class="hljs-comment">//调用微信支付退款接口</span><br>        weChatPayUtil.refund(<br>                ordersDB.getNumber(), <span class="hljs-comment">//商户订单号</span><br>                ordersDB.getNumber(), <span class="hljs-comment">//商户退款单号</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>),<span class="hljs-comment">//退款金额，单位 元</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>));<span class="hljs-comment">//原订单金额</span><br><br>        <span class="hljs-comment">//支付状态修改为 退款</span><br>        orders.setPayStatus(Orders.REFUND);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新订单状态、取消原因、取消时间</span><br>    orders.setStatus(Orders.CANCELLED);<br>    orders.setCancelReason(<span class="hljs-string">&quot;用户取消&quot;</span>);<br>    orders.setCancelTime(LocalDateTime.now());<br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-再来一单"><a href="#4-再来一单" class="headerlink" title="4. 再来一单"></a>4. 再来一单</h2><h3 id="4-1-user-OrderController"><a href="#4-1-user-OrderController" class="headerlink" title="4.1 user&#x2F;OrderController"></a>4.1 user&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 再来一单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/repetition/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;再来一单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">repetition</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>    orderService.repetition(id);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-OrderService"><a href="#4-2-OrderService" class="headerlink" title="4.2 OrderService"></a>4.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 再来一单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">repetition</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-OrderServiceImpl"><a href="#4-3-OrderServiceImpl" class="headerlink" title="4.3 OrderServiceImpl"></a>4.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 再来一单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repetition</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 查询当前用户id</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>    <span class="hljs-comment">// 根据订单id查询当前订单详情</span><br>    List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(id);<br><br>    <span class="hljs-comment">// 将订单详情对象转换为购物车对象</span><br>    List&lt;ShoppingCart&gt; shoppingCartList = orderDetailList.stream().map(x -&gt; &#123;<br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCart</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShoppingCart</span>();<br><br>        <span class="hljs-comment">// 将原订单详情里面的菜品信息重新复制到购物车对象中</span><br>        BeanUtils.copyProperties(x, shoppingCart, <span class="hljs-string">&quot;id&quot;</span>);<br>        shoppingCart.setUserId(userId);<br>        shoppingCart.setCreateTime(LocalDateTime.now());<br><br>        <span class="hljs-keyword">return</span> shoppingCart;<br>    &#125;).collect(Collectors.toList());<br><br>    <span class="hljs-comment">// 将购物车对象批量添加到数据库</span><br>    shoppingCartMapper.insertBatch(shoppingCartList);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-ShoppingCartMapper-1"><a href="#4-4-ShoppingCartMapper-1" class="headerlink" title="4.4 ShoppingCartMapper"></a>4.4 ShoppingCartMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 批量插入购物车数据</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> shoppingCartList</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBatch</span><span class="hljs-params">(List&lt;ShoppingCart&gt; shoppingCartList)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-5-ShoppingCartMapper-xml"><a href="#4-5-ShoppingCartMapper-xml" class="headerlink" title="4.5 ShoppingCartMapper.xml"></a>4.5 ShoppingCartMapper.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertBatch&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        insert into shopping_cart<br>        (name, image, user_id, dish_id, setmeal_id, dish_flavor, number, amount, create_time)<br>        values<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;shoppingCartList&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;sc&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            (#&#123;sc.name&#125;,#&#123;sc.image&#125;,#&#123;sc.userId&#125;,#&#123;sc.dishId&#125;,#&#123;sc.setmealId&#125;,#&#123;sc.dishFlavor&#125;,#&#123;sc.number&#125;,#&#123;sc.amount&#125;,#&#123;sc.createTime&#125;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="十四-商家端订单管理模块"><a href="#十四-商家端订单管理模块" class="headerlink" title="十四. 商家端订单管理模块"></a>十四. 商家端订单管理模块</h1><h2 id="1-订单搜索"><a href="#1-订单搜索" class="headerlink" title="1. 订单搜索"></a>1. 订单搜索</h2><h3 id="1-1-admin-OrderController"><a href="#1-1-admin-OrderController" class="headerlink" title="1.1 admin&#x2F;OrderController"></a>1.1 admin&#x2F;OrderController</h3><p>在admin包下创建OrderController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController(&quot;adminOrderController&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/admin/order&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Api(tags = &quot;订单管理接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单搜索</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersPageQueryDTO</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/conditionSearch&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;订单搜索&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;PageResult&gt; <span class="hljs-title function_">conditionSearch</span><span class="hljs-params">(OrdersPageQueryDTO ordersPageQueryDTO)</span> &#123;<br>        <span class="hljs-type">PageResult</span> <span class="hljs-variable">pageResult</span> <span class="hljs-operator">=</span> orderService.conditionSearch(ordersPageQueryDTO);<br>        <span class="hljs-keyword">return</span> Result.success(pageResult);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-OrderService-1"><a href="#1-2-OrderService-1" class="headerlink" title="1.2 OrderService"></a>1.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 条件搜索订单</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersPageQueryDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>PageResult <span class="hljs-title function_">conditionSearch</span><span class="hljs-params">(OrdersPageQueryDTO ordersPageQueryDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3-OrderServiceImpl-1"><a href="#1-3-OrderServiceImpl-1" class="headerlink" title="1.3 OrderServiceImpl"></a>1.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单搜索</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersPageQueryDTO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> PageResult <span class="hljs-title function_">conditionSearch</span><span class="hljs-params">(OrdersPageQueryDTO ordersPageQueryDTO)</span> &#123;<br>    PageHelper.startPage(ordersPageQueryDTO.getPage(), ordersPageQueryDTO.getPageSize());<br><br>    Page&lt;Orders&gt; page = orderMapper.pageQuery(ordersPageQueryDTO);<br><br>    <span class="hljs-comment">// 部分订单状态，需要额外返回订单菜品信息，将Orders转化为OrderVO</span><br>    List&lt;OrderVO&gt; orderVOList = getOrderVOList(page);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageResult</span>(page.getTotal(), orderVOList);<br>&#125;<br><br><span class="hljs-keyword">private</span> List&lt;OrderVO&gt; <span class="hljs-title function_">getOrderVOList</span><span class="hljs-params">(Page&lt;Orders&gt; page)</span> &#123;<br>    <span class="hljs-comment">// 需要返回订单菜品信息，自定义OrderVO响应结果</span><br>    List&lt;OrderVO&gt; orderVOList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    List&lt;Orders&gt; ordersList = page.getResult();<br>    <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(ordersList)) &#123;<br>        <span class="hljs-keyword">for</span> (Orders orders : ordersList) &#123;<br>            <span class="hljs-comment">// 将共同字段复制到OrderVO</span><br>            <span class="hljs-type">OrderVO</span> <span class="hljs-variable">orderVO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderVO</span>();<br>            BeanUtils.copyProperties(orders, orderVO);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">orderDishes</span> <span class="hljs-operator">=</span> getOrderDishesStr(orders);<br><br>            <span class="hljs-comment">// 将订单菜品信息封装到orderVO中，并添加到orderVOList</span><br>            orderVO.setOrderDishes(orderDishes);<br>            orderVOList.add(orderVO);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> orderVOList;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据订单id获取菜品信息字符串</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> orders</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getOrderDishesStr</span><span class="hljs-params">(Orders orders)</span> &#123;<br>    <span class="hljs-comment">// 查询订单菜品详情信息（订单中的菜品和数量）</span><br>    List&lt;OrderDetail&gt; orderDetailList = orderDetailMapper.getByOrderId(orders.getId());<br><br>    <span class="hljs-comment">// 将每一条订单菜品信息拼接为字符串（格式：宫保鸡丁*3；）</span><br>    List&lt;String&gt; orderDishList = orderDetailList.stream().map(x -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderDish</span> <span class="hljs-operator">=</span> x.getName() + <span class="hljs-string">&quot;*&quot;</span> + x.getNumber() + <span class="hljs-string">&quot;;&quot;</span>;<br>        <span class="hljs-keyword">return</span> orderDish;<br>    &#125;).collect(Collectors.toList());<br><br>    <span class="hljs-comment">// 将该订单对应的所有菜品信息拼接在一起</span><br>    <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot;&quot;</span>, orderDishList);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-各个状态的订单数量统计"><a href="#2-各个状态的订单数量统计" class="headerlink" title="2. 各个状态的订单数量统计"></a>2. 各个状态的订单数量统计</h2><h3 id="2-1-admin-OrderController"><a href="#2-1-admin-OrderController" class="headerlink" title="2.1 admin&#x2F;OrderController"></a>2.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 各个状态的订单数量统计</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/statistics&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;各个状态的订单数量统计&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;OrderStatisticsVO&gt; <span class="hljs-title function_">statistics</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">OrderStatisticsVO</span> <span class="hljs-variable">orderStatisticsVO</span> <span class="hljs-operator">=</span> orderService.statistics();<br>    <span class="hljs-keyword">return</span> Result.success(orderStatisticsVO);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-OrderService-1"><a href="#2-2-OrderService-1" class="headerlink" title="2.2 OrderService"></a>2.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 各个状态的订单数量统计</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>OrderStatisticsVO <span class="hljs-title function_">statistics</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-OrderServiceImpl-1"><a href="#2-3-OrderServiceImpl-1" class="headerlink" title="2.3 OrderServiceImpl"></a>2.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 各个状态的订单数量统计</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> OrderStatisticsVO <span class="hljs-title function_">statistics</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 根据状态，分别查询出待接单、待派送、派送中的订单数量</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">toBeConfirmed</span> <span class="hljs-operator">=</span> orderMapper.countStatus(Orders.TO_BE_CONFIRMED);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">confirmed</span> <span class="hljs-operator">=</span> orderMapper.countStatus(Orders.CONFIRMED);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">deliveryInProgress</span> <span class="hljs-operator">=</span> orderMapper.countStatus(Orders.DELIVERY_IN_PROGRESS);<br><br>    <span class="hljs-comment">// 将查询出的数据封装到orderStatisticsVO中响应</span><br>    <span class="hljs-type">OrderStatisticsVO</span> <span class="hljs-variable">orderStatisticsVO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderStatisticsVO</span>();<br>    orderStatisticsVO.setToBeConfirmed(toBeConfirmed);<br>    orderStatisticsVO.setConfirmed(confirmed);<br>    orderStatisticsVO.setDeliveryInProgress(deliveryInProgress);<br>    <span class="hljs-keyword">return</span> orderStatisticsVO;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-OrderMapper-1"><a href="#2-4-OrderMapper-1" class="headerlink" title="2.4 OrderMapper"></a>2.4 OrderMapper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据状态统计订单数量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Select(&quot;select count(id) from orders where status = #&#123;status&#125;&quot;)</span><br>Integer <span class="hljs-title function_">countStatus</span><span class="hljs-params">(Integer status)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-查询订单详情"><a href="#3-查询订单详情" class="headerlink" title="3. 查询订单详情"></a>3. 查询订单详情</h2><h3 id="3-1-admin-OrderController"><a href="#3-1-admin-OrderController" class="headerlink" title="3.1 admin&#x2F;OrderController"></a>3.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单详情</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/details/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;查询订单详情&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;OrderVO&gt; <span class="hljs-title function_">details</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-type">OrderVO</span> <span class="hljs-variable">orderVO</span> <span class="hljs-operator">=</span> orderService.details(id);<br>    <span class="hljs-keyword">return</span> Result.success(orderVO);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-接单"><a href="#4-接单" class="headerlink" title="4. 接单"></a>4. 接单</h2><h3 id="4-1-admin-OrderController"><a href="#4-1-admin-OrderController" class="headerlink" title="4.1 admin&#x2F;OrderController"></a>4.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/confirm&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;接单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">confirm</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrdersConfirmDTO ordersConfirmDTO)</span> &#123;<br>    orderService.confirm(ordersConfirmDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-OrderService-1"><a href="#4-2-OrderService-1" class="headerlink" title="4.2 OrderService"></a>4.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersConfirmDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(OrdersConfirmDTO ordersConfirmDTO)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-OrderServiceImpl-1"><a href="#4-3-OrderServiceImpl-1" class="headerlink" title="4.3 OrderServiceImpl"></a>4.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersConfirmDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(OrdersConfirmDTO ordersConfirmDTO)</span> &#123;<br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> Orders.builder()<br>            .id(ordersConfirmDTO.getId())<br>            .status(Orders.CONFIRMED)<br>            .build();<br><br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-拒单"><a href="#5-拒单" class="headerlink" title="5. 拒单"></a>5. 拒单</h2><h3 id="5-1-admin-OrderController"><a href="#5-1-admin-OrderController" class="headerlink" title="5.1 admin&#x2F;OrderController"></a>5.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拒单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/rejection&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;拒单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">rejection</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrdersRejectionDTO ordersRejectionDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    orderService.rejection(ordersRejectionDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-OrderService"><a href="#5-2-OrderService" class="headerlink" title="5.2 OrderService"></a>5.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拒单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersRejectionDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">rejection</span><span class="hljs-params">(OrdersRejectionDTO ordersRejectionDTO)</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><h3 id="5-3-OrderServiceImpl"><a href="#5-3-OrderServiceImpl" class="headerlink" title="5.3 OrderServiceImpl"></a>5.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 拒单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersRejectionDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejection</span><span class="hljs-params">(OrdersRejectionDTO ordersRejectionDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 根据id查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(ordersRejectionDTO.getId());<br><br>    <span class="hljs-comment">// 订单只有存在且状态为2（待接单）才可以拒单</span><br>    <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span> || !ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>    &#125;<br><br>    <span class="hljs-comment">//支付状态</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">payStatus</span> <span class="hljs-operator">=</span> ordersDB.getPayStatus();<br>    <span class="hljs-keyword">if</span> (payStatus == Orders.PAID) &#123;<br>        <span class="hljs-comment">//用户已支付，需要退款</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">refund</span> <span class="hljs-operator">=</span> weChatPayUtil.refund(<br>                ordersDB.getNumber(),<br>                ordersDB.getNumber(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>));<br>        log.info(<span class="hljs-string">&quot;申请退款：&#123;&#125;&quot;</span>, refund);<br>    &#125;<br><br>    <span class="hljs-comment">// 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>    orders.setId(ordersDB.getId());<br>    orders.setStatus(Orders.CANCELLED);<br>    orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());<br>    orders.setCancelTime(LocalDateTime.now());<br><br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-取消订单"><a href="#6-取消订单" class="headerlink" title="6. 取消订单"></a>6. 取消订单</h2><h3 id="6-1-admin-OrderController"><a href="#6-1-admin-OrderController" class="headerlink" title="6.1 admin&#x2F;OrderController"></a>6.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 取消订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/cancel&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;取消订单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> OrdersCancelDTO ordersCancelDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    orderService.cancel(ordersCancelDTO);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-OrderService"><a href="#6-2-OrderService" class="headerlink" title="6.2 OrderService"></a>6.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 商家取消订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersCancelDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(OrdersCancelDTO ordersCancelDTO)</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><h3 id="6-3-OrderServiceImpl"><a href="#6-3-OrderServiceImpl" class="headerlink" title="6.3 OrderServiceImpl"></a>6.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 取消订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ordersCancelDTO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(OrdersCancelDTO ordersCancelDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 根据id查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(ordersCancelDTO.getId());<br><br>    <span class="hljs-comment">//支付状态</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">payStatus</span> <span class="hljs-operator">=</span> ordersDB.getPayStatus();<br>    <span class="hljs-keyword">if</span> (payStatus == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//用户已支付，需要退款</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">refund</span> <span class="hljs-operator">=</span> weChatPayUtil.refund(<br>                ordersDB.getNumber(),<br>                ordersDB.getNumber(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-number">0.01</span>));<br>        log.info(<span class="hljs-string">&quot;申请退款：&#123;&#125;&quot;</span>, refund);<br>    &#125;<br><br>    <span class="hljs-comment">// 管理端取消订单需要退款，根据订单id更新订单状态、取消原因、取消时间</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>    orders.setId(ordersCancelDTO.getId());<br>    orders.setStatus(Orders.CANCELLED);<br>    orders.setCancelReason(ordersCancelDTO.getCancelReason());<br>    orders.setCancelTime(LocalDateTime.now());<br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-派送订单"><a href="#7-派送订单" class="headerlink" title="7. 派送订单"></a>7. 派送订单</h2><h3 id="7-1-admin-OrderController"><a href="#7-1-admin-OrderController" class="headerlink" title="7.1 admin&#x2F;OrderController"></a>7.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 派送订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/delivery/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;派送订单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delivery</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    orderService.delivery(id);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-OrderService"><a href="#7-2-OrderService" class="headerlink" title="7.2 OrderService"></a>7.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 派送订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delivery</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="7-3-OrderServiceImpl"><a href="#7-3-OrderServiceImpl" class="headerlink" title="7.3 OrderServiceImpl"></a>7.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 派送订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delivery</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 根据id查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(id);<br><br>    <span class="hljs-comment">// 校验订单是否存在，并且状态为3</span><br>    <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span> || !ordersDB.getStatus().equals(Orders.CONFIRMED)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>    &#125;<br><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>    orders.setId(ordersDB.getId());<br>    <span class="hljs-comment">// 更新订单状态,状态转为派送中</span><br>    orders.setStatus(Orders.DELIVERY_IN_PROGRESS);<br><br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-完成订单"><a href="#8-完成订单" class="headerlink" title="8. 完成订单"></a>8. 完成订单</h2><h3 id="8-1-admin-OrderController"><a href="#8-1-admin-OrderController" class="headerlink" title="8.1 admin&#x2F;OrderController"></a>8.1 admin&#x2F;OrderController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping(&quot;/complete/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;完成订单&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">complete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    orderService.complete(id);<br>    <span class="hljs-keyword">return</span> Result.success();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-OrderService"><a href="#8-2-OrderService" class="headerlink" title="8.2 OrderService"></a>8.2 OrderService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="8-3-OrderServiceImpl"><a href="#8-3-OrderServiceImpl" class="headerlink" title="8.3 OrderServiceImpl"></a>8.3 OrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成订单</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 根据id查询订单</span><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(id);<br><br>    <span class="hljs-comment">// 校验订单是否存在，并且状态为4</span><br>    <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span> || !ordersDB.getStatus().equals(Orders.DELIVERY_IN_PROGRESS)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>    &#125;<br><br>    <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>    orders.setId(ordersDB.getId());<br>    <span class="hljs-comment">// 更新订单状态,状态转为完成</span><br>    orders.setStatus(Orders.COMPLETED);<br>    orders.setDeliveryTime(LocalDateTime.now());<br><br>    orderMapper.update(orders);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十五-Spring-Task-和-订单状态定时处理"><a href="#十五-Spring-Task-和-订单状态定时处理" class="headerlink" title="十五. Spring Task 和 订单状态定时处理"></a>十五. Spring Task 和 订单状态定时处理</h1><h2 id="1-Spring-Task"><a href="#1-Spring-Task" class="headerlink" title="1. Spring Task"></a>1. Spring Task</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><ul><li><strong>Spring Task</strong> 是Spring框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑。</li><li><strong>作用</strong>定时自动执行某段Java代码</li></ul><h3 id="1-2-cron表达式"><a href="#1-2-cron表达式" class="headerlink" title="1.2 cron表达式"></a>1.2 cron表达式</h3><p><strong>cron表达式</strong>其实就是一个字符串，通过cron表达式可以<strong>定义任务触发的时间</strong></p><p>**构成规则：**分为6或7个域，由空格分隔开，每个域代表一个含义</p><p>每个域的含义分别为：秒、分钟、小时、日、月、周、年(可选)</p><p><strong>举例：</strong></p><p>2022年10月12日上午9点整 对应的cron表达式为：<strong>0 0 9 12 10 ? 2022</strong></p><h3 id="1-3-Spring-Task使用步骤"><a href="#1-3-Spring-Task使用步骤" class="headerlink" title="1.3 Spring Task使用步骤"></a>1.3 Spring Task使用步骤</h3><ol><li>导入maven坐标 spring-context</li><li>启动类添加注解 @EnableScheduling 开启任务调度</li><li>自定义定时任务类</li></ol><h2 id="2-订单状态定时处理"><a href="#2-订单状态定时处理" class="headerlink" title="2. 订单状态定时处理"></a>2. 订单状态定时处理</h2><h3 id="2-1-问题分析"><a href="#2-1-问题分析" class="headerlink" title="2.1 问题分析"></a>2.1 问题分析</h3><ul><li>下单后未支付，订单一直处于**“待支付”**状态</li><li>用户收货后管理端未点击完成按钮，订单一直处于**“派送中”**状态</li></ul><p>对于上面两种情况需要通过<strong>定时任务</strong>来修改订单状态，具体逻辑为：</p><ul><li>通过定时任务每分钟检查一次是否存在支付超时订单（下单后超过15分钟仍未支付则判定为支付超时订单），如果存在则修改订单状态为“已取消”</li><li>通过定时任务每天凌晨1点检查一次是否存在“派送中”的订单，如果存在则修改订单状态为“已完成”</li></ul><h3 id="2-2-自定义定时任务类OrderTask"><a href="#2-2-自定义定时任务类OrderTask" class="headerlink" title="2.2 自定义定时任务类OrderTask"></a>2.2 自定义定时任务类OrderTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.task;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义定时任务，实现订单状态定时处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderTask</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理支付超时订单</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 * * * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processTimeoutOrder</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;处理支付超时订单：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().plusMinutes(-<span class="hljs-number">15</span>);<br><br>        <span class="hljs-comment">// select * from orders where status = 1 and order_time &lt; 当前时间-15分钟</span><br>        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrdertimeLT(Orders.PENDING_PAYMENT, time);<br>        <span class="hljs-keyword">if</span>(ordersList != <span class="hljs-literal">null</span> &amp;&amp; ordersList.size() &gt; <span class="hljs-number">0</span>)&#123;<br>            ordersList.forEach(order -&gt; &#123;<br>                order.setStatus(Orders.CANCELLED);<br>                order.setCancelReason(<span class="hljs-string">&quot;支付超时，自动取消&quot;</span>);<br>                order.setCancelTime(LocalDateTime.now());<br>                orderMapper.update(order);<br>            &#125;);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理“派送中”状态的订单</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDeliveryOrder</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;处理派送中订单：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        <span class="hljs-comment">// select * from orders where status = 4 and order_time &lt; 当前时间-1小时</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().plusMinutes(-<span class="hljs-number">60</span>);<br>        List&lt;Orders&gt; ordersList = orderMapper.getByStatusAndOrdertimeLT(Orders.DELIVERY_IN_PROGRESS, time);<br><br>        <span class="hljs-keyword">if</span>(ordersList != <span class="hljs-literal">null</span> &amp;&amp; ordersList.size() &gt; <span class="hljs-number">0</span>)&#123;<br>            ordersList.forEach(order -&gt; &#123;<br>                order.setStatus(Orders.COMPLETED);<br>                orderMapper.update(order);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-在OrderMapper接口中扩展方法"><a href="#2-3-在OrderMapper接口中扩展方法" class="headerlink" title="2.3 在OrderMapper接口中扩展方法"></a>2.3 在OrderMapper接口中扩展方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据状态和下单时间查询订单</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> orderTime</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Select(&quot;select * from orders where status = #&#123;status&#125; and order_time &lt; #&#123;orderTime&#125;&quot;)</span><br>   List&lt;Orders&gt; <span class="hljs-title function_">getByStatusAndOrdertimeLT</span><span class="hljs-params">(Integer status, LocalDateTime orderTime)</span>;<br></code></pre></td></tr></table></figure><h1 id="十六-WebSocket-和-用户来单催单提醒"><a href="#十六-WebSocket-和-用户来单催单提醒" class="headerlink" title="十六. WebSocket 和 用户来单催单提醒"></a>十六. WebSocket 和 用户来单催单提醒</h1><h2 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1. WebSocket"></a>1. WebSocket</h2><p>WebSocket 是基于 TCP 的一种新的<strong>网络协议</strong>。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建<strong>持久性</strong>的连接， 并进行<strong>双向</strong>数据传输。</p><p><strong>HTTP协议和WebSocket协议对比：</strong></p><ul><li>HTTP是<strong>短连接</strong></li><li>WebSocket是<strong>长连接</strong></li><li>HTTP通信是<strong>单向</strong>的，基于请求响应模式</li><li>WebSocket支持<strong>双向</strong>通信</li><li>HTTP和WebSocket底层都是TCP连接</li></ul><h2 id="2-用户来单提醒"><a href="#2-用户来单提醒" class="headerlink" title="2. 用户来单提醒"></a>2. 用户来单提醒</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><ul><li>通过WebSocket实现管理端页面和服务端保持长连接状态</li><li>当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息</li><li>客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语音播报</li><li>约定服务端发送给客户端浏览器的数据格式为JSON，字段包括：type，orderId，content<ul><li>type 为消息类型，1为来单提醒 2为客户催单</li><li>orderId 为订单id</li><li>content 为消息内容</li></ul></li></ul><h3 id="2-2-代码开发"><a href="#2-2-代码开发" class="headerlink" title="2.2 代码开发"></a>2.2 代码开发</h3><p><strong>在OrderServiceImpl中注入WebSocketServer对象，修改paySuccess方法，加入如下代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> WebSocketServer webSocketServer;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付成功，修改订单状态</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> outTradeNo</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paySuccess</span><span class="hljs-params">(String outTradeNo)</span> &#123;<br>       <span class="hljs-comment">// 当前登录用户id</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>       <span class="hljs-comment">// 根据订单号查询当前用户的订单</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getByNumberAndUserId(outTradeNo, userId);<br><br>       <span class="hljs-comment">// 根据订单id更新订单的状态、支付方式、支付状态、结账时间</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> Orders.builder()<br>               .id(ordersDB.getId())<br>               .status(Orders.TO_BE_CONFIRMED)<br>               .payStatus(Orders.PAID)<br>               .checkoutTime(LocalDateTime.now())<br>               .build();<br><br>       orderMapper.update(orders);<br><span class="hljs-comment">//////////////////////////////////////////////</span><br>       <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       map.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//消息类型，1表示来单提醒</span><br>       map.put(<span class="hljs-string">&quot;orderId&quot;</span>, orders.getId());<br>       map.put(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;订单号：&quot;</span> + outTradeNo);<br><br>       <span class="hljs-comment">//通过WebSocket实现来单提醒，向客户端浏览器推送消息</span><br>       webSocketServer.sendToAllClient(JSON.toJSONString(map));<br>       <span class="hljs-comment">///////////////////////////////////////////////////</span><br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-用户催单提醒"><a href="#3-用户催单提醒" class="headerlink" title="3. 用户催单提醒"></a>3. 用户催单提醒</h2><h3 id="3-1-Controller层-3"><a href="#3-1-Controller层-3" class="headerlink" title="3.1 Controller层"></a>3.1 Controller层</h3><p><strong>根据用户催单的接口定义，在user&#x2F;OrderController中创建催单方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户催单</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/reminder/&#123;id&#125;&quot;)</span><br>   <span class="hljs-meta">@ApiOperation(&quot;用户催单&quot;)</span><br>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">reminder</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>       orderService.reminder(id);<br>       <span class="hljs-keyword">return</span> Result.success();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Service层接口-1"><a href="#3-2-Service层接口-1" class="headerlink" title="3.2 Service层接口"></a>3.2 Service层接口</h3><p><strong>在OrderService接口中声明reminder方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户催单</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">reminder</span><span class="hljs-params">(Long id)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-Service层实现类-1"><a href="#3-3-Service层实现类-1" class="headerlink" title="3.3 Service层实现类"></a>3.3 Service层实现类</h3><p><strong>在OrderServiceImpl中实现reminder方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 用户催单</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reminder</span><span class="hljs-params">(Long id)</span> &#123;<br>       <span class="hljs-comment">// 查询订单是否存在</span><br>       <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> orderMapper.getById(id);<br>       <span class="hljs-keyword">if</span> (orders == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_NOT_FOUND);<br>       &#125;<br><br>       <span class="hljs-comment">//基于WebSocket实现催单</span><br>       <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       map.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//2代表用户催单</span><br>       map.put(<span class="hljs-string">&quot;orderId&quot;</span>, id);<br>       map.put(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;订单号：&quot;</span> + orders.getNumber());<br>       webSocketServer.sendToAllClient(JSON.toJSONString(map));<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="十七-数据统计功能"><a href="#十七-数据统计功能" class="headerlink" title="十七. 数据统计功能"></a>十七. 数据统计功能</h1><h2 id="1-营业额统计"><a href="#1-营业额统计" class="headerlink" title="1. 营业额统计"></a>1. 营业额统计</h2><h3 id="1-1-Controller层-3"><a href="#1-1-Controller层-3" class="headerlink" title="1.1 Controller层"></a>1.1 Controller层</h3><p><strong>根据接口定义创建ReportController：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.controller.admin;<br><br><span class="hljs-keyword">import</span> com.sky.result.Result;<br><span class="hljs-keyword">import</span> com.sky.service.ReportService;<br><span class="hljs-keyword">import</span> com.sky.vo.TurnoverReportVO;<br><span class="hljs-keyword">import</span> io.swagger.annotations.Api;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.format.annotation.DateTimeFormat;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> java.time.LocalDate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 报表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/admin/report&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Api(tags = &quot;统计报表相关接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ReportService reportService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 营业额数据统计</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/turnoverStatistics&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;营业额数据统计&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;TurnoverReportVO&gt; <span class="hljs-title function_">turnoverStatistics</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="hljs-params">                    LocalDate begin,</span><br><span class="hljs-params">            <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="hljs-params">                    LocalDate end)</span> &#123;<br>        <span class="hljs-keyword">return</span> Result.success(reportService.getTurnover(begin, end));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Service层接口"><a href="#1-2-Service层接口" class="headerlink" title="1.2 Service层接口"></a>1.2 Service层接口</h3><p><strong>创建ReportService接口，声明getTurnover方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service;<br><br><span class="hljs-keyword">import</span> com.sky.vo.TurnoverReportVO;<br><span class="hljs-keyword">import</span> java.time.LocalDate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReportService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据时间区间统计营业额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    TurnoverReportVO <span class="hljs-title function_">getTurnover</span><span class="hljs-params">(LocalDate beginTime, LocalDate endTime)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-Service层实现类"><a href="#1-3-Service层实现类" class="headerlink" title="1.3 Service层实现类"></a>1.3 Service层实现类</h3><p><strong>创建ReportServiceImpl实现类，实现getTurnover方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.service.impl;<br><br><span class="hljs-keyword">import</span> com.sky.entity.Orders;<br><span class="hljs-keyword">import</span> com.sky.mapper.OrderMapper;<br><span class="hljs-keyword">import</span> com.sky.service.ReportService;<br><span class="hljs-keyword">import</span> com.sky.vo.TurnoverReportVO;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.time.LocalDate;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReportService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderMapper orderMapper;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据时间区间统计营业额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> TurnoverReportVO <span class="hljs-title function_">getTurnover</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span> &#123;<br>        List&lt;LocalDate&gt; dateList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dateList.add(begin);<br><br>        <span class="hljs-keyword">while</span> (!begin.equals(end))&#123;<br>            begin = begin.plusDays(<span class="hljs-number">1</span>);<span class="hljs-comment">//日期计算，获得指定日期后1天的日期</span><br>            dateList.add(begin);<br>        &#125;<br>        <br>       List&lt;Double&gt; turnoverList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (LocalDate date : dateList) &#123;<br>            <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(date, LocalTime.MIN);<br>            <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(date, LocalTime.MAX);<br>            <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;status&quot;</span>, Orders.COMPLETED);<br>        map.put(<span class="hljs-string">&quot;begin&quot;</span>,beginTime);<br>        map.put(<span class="hljs-string">&quot;end&quot;</span>, endTime);<br>            <span class="hljs-type">Double</span> <span class="hljs-variable">turnover</span> <span class="hljs-operator">=</span> orderMapper.sumByMap(map); <br>            turnover = turnover == <span class="hljs-literal">null</span> ? <span class="hljs-number">0.0</span> : turnover;<br>            turnoverList.add(turnover);<br>        &#125;<br><br>        <span class="hljs-comment">//数据封装</span><br>        <span class="hljs-keyword">return</span> TurnoverReportVO.builder()<br>                .dateList(StringUtils.join(dateList,<span class="hljs-string">&quot;,&quot;</span>))<br>                .turnoverList(StringUtils.join(turnoverList,<span class="hljs-string">&quot;,&quot;</span>))<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-Mapper层-1"><a href="#1-4-Mapper层-1" class="headerlink" title="1.4 Mapper层"></a>1.4 Mapper层</h3><p><strong>在OrderMapper接口声明sumByMap方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据动态条件统计营业额</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> map</span><br><span class="hljs-comment">    */</span><br>   Double <span class="hljs-title function_">sumByMap</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure><p><strong>在OrderMapper.xml文件中编写动态SQL：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sumByMap&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;java.lang.Double&quot;</span>&gt;</span><br>        select sum(amount) from orders<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>                and status = #&#123;status&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null&quot;</span>&gt;</span><br>                and order_time <span class="hljs-symbol">&amp;gt;</span>= #&#123;begin&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;end != null&quot;</span>&gt;</span><br>                and order_time <span class="hljs-symbol">&amp;lt;</span>= #&#123;end&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-用户统计"><a href="#2-用户统计" class="headerlink" title="2. 用户统计"></a>2. 用户统计</h2><h3 id="2-1-Controller层-1"><a href="#2-1-Controller层-1" class="headerlink" title="2.1 Controller层"></a>2.1 Controller层</h3><p><strong>根据接口定义，在ReportController中创建userStatistics方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户数据统计</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/userStatistics&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;用户数据统计&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;UserReportVO&gt; <span class="hljs-title function_">userStatistics</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span><br><span class="hljs-params">            <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> Result.success(reportService.getUserStatistics(begin,end));            <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Service层接口-1"><a href="#2-2-Service层接口-1" class="headerlink" title="2.2 Service层接口"></a>2.2 Service层接口</h3><p><strong>在ReportService接口中声明getUserStatistics方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据时间区间统计用户数量</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   UserReportVO <span class="hljs-title function_">getUserStatistics</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-Service层实现类-1"><a href="#2-3-Service层实现类-1" class="headerlink" title="2.3 Service层实现类"></a>2.3 Service层实现类</h3><p><strong>在ReportServiceImpl实现类中实现getUserStatistics方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> UserReportVO <span class="hljs-title function_">getUserStatistics</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span> &#123;<br>       List&lt;LocalDate&gt; dateList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>       dateList.add(begin);<br><br>       <span class="hljs-keyword">while</span> (!begin.equals(end))&#123;<br>           begin = begin.plusDays(<span class="hljs-number">1</span>);<br>           dateList.add(begin);<br>       &#125;<br>       List&lt;Integer&gt; newUserList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//新增用户数</span><br>       List&lt;Integer&gt; totalUserList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//总用户数</span><br><br>       <span class="hljs-keyword">for</span> (LocalDate date : dateList) &#123;<br>           <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(date, LocalTime.MIN);<br>           <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(date, LocalTime.MAX);<br>           <span class="hljs-comment">//新增用户数量 select count(id) from user where create_time &gt; ? and create_time &lt; ?</span><br>           <span class="hljs-type">Integer</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> getUserCount(beginTime, endTime);<br>           <span class="hljs-comment">//总用户数量 select count(id) from user where  create_time &lt; ?</span><br>           <span class="hljs-type">Integer</span> <span class="hljs-variable">totalUser</span> <span class="hljs-operator">=</span> getUserCount(<span class="hljs-literal">null</span>, endTime);<br><br>           newUserList.add(newUser);<br>           totalUserList.add(totalUser);<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> UserReportVO.builder()<br>               .dateList(StringUtils.join(dateList,<span class="hljs-string">&quot;,&quot;</span>))<br>               .newUserList(StringUtils.join(newUserList,<span class="hljs-string">&quot;,&quot;</span>))<br>               .totalUserList(StringUtils.join(totalUserList,<span class="hljs-string">&quot;,&quot;</span>))<br>               .build();<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>在ReportServiceImpl实现类中创建私有方法getUserCount：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据时间区间统计用户数量</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> beginTime</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> endTime</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> Integer <span class="hljs-title function_">getUserCount</span><span class="hljs-params">(LocalDateTime beginTime, LocalDateTime endTime)</span> &#123;<br>       <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       map.put(<span class="hljs-string">&quot;begin&quot;</span>,beginTime);<br>       map.put(<span class="hljs-string">&quot;end&quot;</span>, endTime);<br>       <span class="hljs-keyword">return</span> userMapper.countByMap(map);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-Mapper层-1"><a href="#2-4-Mapper层-1" class="headerlink" title="2.4 Mapper层"></a>2.4 Mapper层</h3><p><strong>在UserMapper接口中声明countByMap方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据动态条件统计用户数量</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> map</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   Integer <span class="hljs-title function_">countByMap</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure><p><strong>在UserMapper.xml文件中编写动态SQL：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;countByMap&quot;</span> resultType=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;<br>        select <span class="hljs-title function_">count</span><span class="hljs-params">(id)</span> from user<br>        &lt;where&gt;<br>            &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;begin != null&quot;</span>&gt;<br>                and create_time &amp;gt;= #&#123;begin&#125;<br>            &lt;/<span class="hljs-keyword">if</span>&gt;<br>            &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;end != null&quot;</span>&gt;<br>                and create_time &amp;lt;= #&#123;end&#125;<br>            &lt;/<span class="hljs-keyword">if</span>&gt;<br>        &lt;/where&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h2 id="3-订单统计"><a href="#3-订单统计" class="headerlink" title="3. 订单统计"></a>3. 订单统计</h2><h3 id="3-1-Controller层-4"><a href="#3-1-Controller层-4" class="headerlink" title="3.1 Controller层"></a>3.1 Controller层</h3><p><strong>在ReportController中根据订单统计接口创建orderStatistics方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单数据统计</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/ordersStatistics&quot;)</span><br>    <span class="hljs-meta">@ApiOperation(&quot;用户数据统计&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;OrderReportVO&gt; <span class="hljs-title function_">orderStatistics</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="hljs-params">                    LocalDate begin,</span><br><span class="hljs-params">            <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="hljs-params">                    LocalDate end)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> Result.success(reportService.getOrderStatistics(begin,end));<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-Service层接口-2"><a href="#3-2-Service层接口-2" class="headerlink" title="3.2 Service层接口"></a>3.2 Service层接口</h3><p><strong>在ReportService接口中声明getOrderStatistics方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据时间区间统计订单数量</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> begin </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> </span><br><span class="hljs-comment">*/</span><br>OrderReportVO <span class="hljs-title function_">getOrderStatistics</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-3-Service层实现类-2"><a href="#3-3-Service层实现类-2" class="headerlink" title="3.3 Service层实现类"></a>3.3 Service层实现类</h3><p><strong>在ReportServiceImpl实现类中实现getOrderStatistics方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据时间区间统计订单数量</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> begin </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> OrderReportVO <span class="hljs-title function_">getOrderStatistics</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span>&#123;<br>List&lt;LocalDate&gt; dateList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    dateList.add(begin);<br><br>    <span class="hljs-keyword">while</span> (!begin.equals(end))&#123;<br>          begin = begin.plusDays(<span class="hljs-number">1</span>);<br>          dateList.add(begin);<br>     &#125;<br>    <span class="hljs-comment">//每天订单总数集合</span><br>     List&lt;Integer&gt; orderCountList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//每天有效订单数集合</span><br>    List&lt;Integer&gt; validOrderCountList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (LocalDate date : dateList) &#123;<br>         <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(date, LocalTime.MIN);<br>         <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(date, LocalTime.MAX);<br>   <span class="hljs-comment">//查询每天的总订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ?</span><br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">orderCount</span> <span class="hljs-operator">=</span> getOrderCount(beginTime, endTime, <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">//查询每天的有效订单数 select count(id) from orders where order_time &gt; ? and order_time &lt; ? and status = ?</span><br>         <span class="hljs-type">Integer</span> <span class="hljs-variable">validOrderCount</span> <span class="hljs-operator">=</span> getOrderCount(beginTime, endTime, Orders.COMPLETED);<br><br>         orderCountList.add(orderCount);<br>         validOrderCountList.add(validOrderCount);<br>        &#125;<br><br>    <span class="hljs-comment">//时间区间内的总订单数</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">totalOrderCount</span> <span class="hljs-operator">=</span> orderCountList.stream().reduce(Integer::sum).get();<br>    <span class="hljs-comment">//时间区间内的总有效订单数</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">validOrderCount</span> <span class="hljs-operator">=</span> validOrderCountList.stream().reduce(Integer::sum).get();<br>    <span class="hljs-comment">//订单完成率</span><br>    <span class="hljs-type">Double</span> <span class="hljs-variable">orderCompletionRate</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">if</span>(totalOrderCount != <span class="hljs-number">0</span>)&#123;<br>         orderCompletionRate = validOrderCount.doubleValue() / totalOrderCount;<br>     &#125;<br>    <span class="hljs-keyword">return</span> OrderReportVO.builder()<br>                .dateList(StringUtils.join(dateList, <span class="hljs-string">&quot;,&quot;</span>))<br>                .orderCountList(StringUtils.join(orderCountList, <span class="hljs-string">&quot;,&quot;</span>))<br>                .validOrderCountList(StringUtils.join(validOrderCountList, <span class="hljs-string">&quot;,&quot;</span>))<br>                .totalOrderCount(totalOrderCount)<br>                .validOrderCount(validOrderCount)<br>                .orderCompletionRate(orderCompletionRate)<br>                .build();<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在ReportServiceImpl实现类中提供私有方法getOrderCount：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 根据时间区间统计指定状态的订单数量</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> beginTime</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> endTime</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Integer <span class="hljs-title function_">getOrderCount</span><span class="hljs-params">(LocalDateTime beginTime, LocalDateTime endTime, Integer status)</span> &#123;<br><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>map.put(<span class="hljs-string">&quot;status&quot;</span>, status);<br>map.put(<span class="hljs-string">&quot;begin&quot;</span>,beginTime);<br>map.put(<span class="hljs-string">&quot;end&quot;</span>, endTime);<br><span class="hljs-keyword">return</span> orderMapper.countByMap(map);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-Mapper层-1"><a href="#3-4-Mapper层-1" class="headerlink" title="3.4 Mapper层"></a>3.4 Mapper层</h3><p><strong>在OrderMapper接口中声明countByMap方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*根据动态条件统计订单数量</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> map</span><br><span class="hljs-comment">*/</span><br>Integer <span class="hljs-title function_">countByMap</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure><p><strong>在OrderMapper.xml文件中编写动态SQL：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;countByMap&quot;</span> resultType=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>&gt;<br>        select <span class="hljs-title function_">count</span><span class="hljs-params">(id)</span> from orders<br>        &lt;where&gt;<br>            &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;status != null&quot;</span>&gt;<br>                <span class="hljs-type">and</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> #&#123;status&#125;<br>            &lt;/<span class="hljs-keyword">if</span>&gt;<br>            &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;begin != null&quot;</span>&gt;<br>                and order_time &amp;gt;= #&#123;begin&#125;<br>            &lt;/<span class="hljs-keyword">if</span>&gt;<br>            &lt;<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;end != null&quot;</span>&gt;<br>                and order_time &amp;lt;= #&#123;end&#125;<br>            &lt;/<span class="hljs-keyword">if</span>&gt;<br>        &lt;/where&gt;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><h2 id="4-销量排名Top10"><a href="#4-销量排名Top10" class="headerlink" title="4. 销量排名Top10"></a>4. 销量排名Top10</h2><h3 id="4-1-Controller层-1"><a href="#4-1-Controller层-1" class="headerlink" title="4.1 Controller层"></a>4.1 Controller层</h3><p><strong>在ReportController中根据销量排名接口创建top10方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 销量排名统计</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@GetMapping(&quot;/top10&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;销量排名统计&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;SalesTop10ReportVO&gt; <span class="hljs-title function_">top10</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span><br><span class="hljs-params">    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span>&#123;<br><span class="hljs-keyword">return</span> Result.success(reportService.getSalesTop10(begin,end));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Service层接口"><a href="#4-2-Service层接口" class="headerlink" title="4.2 Service层接口"></a>4.2 Service层接口</h3><p><strong>在ReportService接口中声明getSalesTop10方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 查询指定时间区间内的销量排名top10 </span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br>SalesTop10ReportVO <span class="hljs-title function_">getSalesTop10</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span>;<br></code></pre></td></tr></table></figure><h3 id="4-3-Service层实现类"><a href="#4-3-Service层实现类" class="headerlink" title="4.3 Service层实现类"></a>4.3 Service层实现类</h3><p><strong>在ReportServiceImpl实现类中实现getSalesTop10方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定时间区间内的销量排名top10</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-keyword">public</span> SalesTop10ReportVO <span class="hljs-title function_">getSalesTop10</span><span class="hljs-params">(LocalDate begin, LocalDate end)</span>&#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">beginTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(begin, LocalTime.MIN);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(end, LocalTime.MAX);<br>        List&lt;GoodsSalesDTO&gt; goodsSalesDTOList = orderMapper.getSalesTop10(beginTime, endTime);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">nameList</span> <span class="hljs-operator">=</span> StringUtils.join(goodsSalesDTOList.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList()),<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">numberList</span> <span class="hljs-operator">=</span> StringUtils.join(goodsSalesDTOList.stream().map(GoodsSalesDTO::getNumber).collect(Collectors.toList()),<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> SalesTop10ReportVO.builder()<br>                .nameList(nameList)<br>                .numberList(numberList)<br>                .build();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-Mapper层"><a href="#4-4-Mapper层" class="headerlink" title="4.4 Mapper层"></a>4.4 Mapper层</h3><p><strong>在OrderMapper接口中声明getSalesTop10方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 查询商品销量排名</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment">*/</span><br>List&lt;GoodsSalesDTO&gt; <span class="hljs-title function_">getSalesTop10</span><span class="hljs-params">(LocalDateTime begin, LocalDateTime end)</span>;<br></code></pre></td></tr></table></figure><p><strong>在OrderMapper.xml文件中编写动态SQL：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getSalesTop10&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.sky.dto.GoodsSalesDTO&quot;</span>&gt;</span><br>        select od.name name,sum(od.number) number from order_detail od ,orders o<br>        where od.order_id = o.id<br>            and o.status = 5<br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null&quot;</span>&gt;</span><br>                and order_time <span class="hljs-symbol">&amp;gt;</span>= #&#123;begin&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;end != null&quot;</span>&gt;</span><br>                and order_time <span class="hljs-symbol">&amp;lt;</span>= #&#123;end&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        group by name<br>        order by number desc<br>        limit 0, 10<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="十八-Apache-POI-和-导出运营数据"><a href="#十八-Apache-POI-和-导出运营数据" class="headerlink" title="十八. Apache POI 和 导出运营数据"></a>十八. Apache POI 和 导出运营数据</h1><h2 id="1-Apache-POI"><a href="#1-Apache-POI" class="headerlink" title="1. Apache POI"></a>1. Apache POI</h2><p>一般情况下，POI 都是用于操作 Excel 文件。</p><h3 id="1-1-将数据写入Excel文件"><a href="#1-1-将数据写入Excel文件" class="headerlink" title="1.1 将数据写入Excel文件"></a>1.1 将数据写入Excel文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.test;<br><br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFCell;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFRow;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">POITest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于POI向Excel文件写入数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//在内存中创建一个Excel文件对象</span><br>        <span class="hljs-type">XSSFWorkbook</span> <span class="hljs-variable">excel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>();<br>        <span class="hljs-comment">//创建Sheet页</span><br>        <span class="hljs-type">XSSFSheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> excel.createSheet(<span class="hljs-string">&quot;itcast&quot;</span>);<br><br>        <span class="hljs-comment">//在Sheet页中创建行，0表示第1行</span><br>        <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">row1</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//创建单元格并在单元格中设置值，单元格编号也是从0开始，1表示第2个单元格</span><br>        row1.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>);<br>        row1.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;城市&quot;</span>);<br><br>        <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">row2</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">1</span>);<br>        row2.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;张三&quot;</span>);<br>        row2.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;北京&quot;</span>);<br><br>        <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">row3</span> <span class="hljs-operator">=</span> sheet.createRow(<span class="hljs-number">2</span>);<br>        row3.createCell(<span class="hljs-number">1</span>).setCellValue(<span class="hljs-string">&quot;李四&quot;</span>);<br>        row3.createCell(<span class="hljs-number">2</span>).setCellValue(<span class="hljs-string">&quot;上海&quot;</span>);<br><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast.xlsx&quot;</span>));<br>        <span class="hljs-comment">//通过输出流将内存中的Excel文件写入到磁盘上</span><br>        excel.write(out);<br><br>        <span class="hljs-comment">//关闭资源</span><br>        out.flush();<br>        out.close();<br>        excel.close();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        write();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-读取Excel文件中的数据"><a href="#1-2-读取Excel文件中的数据" class="headerlink" title="1.2 读取Excel文件中的数据"></a>1.2 读取Excel文件中的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.test;<br><br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFCell;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFRow;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">POITest</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于POI读取Excel文件</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:\\itcast.xlsx&quot;</span>));<br>        <span class="hljs-comment">//通过输入流读取指定的Excel文件</span><br>        <span class="hljs-type">XSSFWorkbook</span> <span class="hljs-variable">excel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(in);<br>        <span class="hljs-comment">//获取Excel文件的第1个Sheet页</span><br>        <span class="hljs-type">XSSFSheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> excel.getSheetAt(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">//获取Sheet页中的最后一行的行号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRowNum</span> <span class="hljs-operator">=</span> sheet.getLastRowNum();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= lastRowNum; i++) &#123;<br>            <span class="hljs-comment">//获取Sheet页中的行</span><br>            <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">titleRow</span> <span class="hljs-operator">=</span> sheet.getRow(i);<br>            <span class="hljs-comment">//获取行的第2个单元格</span><br>            <span class="hljs-type">XSSFCell</span> <span class="hljs-variable">cell1</span> <span class="hljs-operator">=</span> titleRow.getCell(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//获取单元格中的文本内容</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">cellValue1</span> <span class="hljs-operator">=</span> cell1.getStringCellValue();<br>            <span class="hljs-comment">//获取行的第3个单元格</span><br>            <span class="hljs-type">XSSFCell</span> <span class="hljs-variable">cell2</span> <span class="hljs-operator">=</span> titleRow.getCell(<span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//获取单元格中的文本内容</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">cellValue2</span> <span class="hljs-operator">=</span> cell2.getStringCellValue();<br><br>            System.out.println(cellValue1 + <span class="hljs-string">&quot; &quot;</span> +cellValue2);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭资源</span><br>        in.close();<br>        excel.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-导出运营数据Excel报表"><a href="#2-导出运营数据Excel报表" class="headerlink" title="2. 导出运营数据Excel报表"></a>2. 导出运营数据Excel报表</h2><h3 id="2-1-实现步骤"><a href="#2-1-实现步骤" class="headerlink" title="2.1 实现步骤"></a>2.1 实现步骤</h3><ol><li>设计Excel模板文件</li><li>查询近30天的运营数据</li><li>将查询到的运营数据写入模板文件</li><li>通过输出流将Excel文件下载到客户端浏览器</li></ol><h3 id="2-2-Controller层-1"><a href="#2-2-Controller层-1" class="headerlink" title="2.2 Controller层"></a>2.2 Controller层</h3><p><strong>根据接口定义，在ReportController中创建export方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 导出运营数据报表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/export&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;导出运营数据报表&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">export</span><span class="hljs-params">(HttpServletResponse response)</span>&#123;<br>    reportService.exportBusinessData(response);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-Service层接口"><a href="#2-3-Service层接口" class="headerlink" title="2.3 Service层接口"></a>2.3 Service层接口</h3><p><strong>在ReportService接口中声明导出运营数据报表的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 导出近30天的运营数据报表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">exportBusinessData</span><span class="hljs-params">(HttpServletResponse response)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-4-Service层实现类"><a href="#2-4-Service层实现类" class="headerlink" title="2.4 Service层实现类"></a>2.4 Service层实现类</h3><p><strong>在ReportServiceImpl实现类中实现导出运营数据报表的方法:</strong></p><p>提前将资料中的<strong>运营数据报表模板.xlsx</strong>拷贝到项目的resources&#x2F;template目录中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**导出近30天的运营数据报表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exportBusinessData</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> LocalDate.now().minusDays(<span class="hljs-number">30</span>);<br>    <span class="hljs-type">LocalDate</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> LocalDate.now().minusDays(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//查询概览运营数据，提供给Excel模板文件</span><br>    <span class="hljs-type">BusinessDataVO</span> <span class="hljs-variable">businessData</span> <span class="hljs-operator">=</span> workspaceService.getBusinessData(LocalDateTime.of(begin,LocalTime.MIN), LocalDateTime.of(end, LocalTime.MAX));<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;template/运营数据报表模板.xlsx&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//基于提供好的模板文件创建一个新的Excel表格对象</span><br>        <span class="hljs-type">XSSFWorkbook</span> <span class="hljs-variable">excel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XSSFWorkbook</span>(inputStream);<br>        <span class="hljs-comment">//获得Excel文件中的一个Sheet页</span><br>        <span class="hljs-type">XSSFSheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> excel.getSheet(<span class="hljs-string">&quot;Sheet1&quot;</span>);<br><br>        sheet.getRow(<span class="hljs-number">1</span>).getCell(<span class="hljs-number">1</span>).setCellValue(begin + <span class="hljs-string">&quot;至&quot;</span> + end);<br>        <span class="hljs-comment">//获得第4行</span><br>        <span class="hljs-type">XSSFRow</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> sheet.getRow(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//获取单元格</span><br>        row.getCell(<span class="hljs-number">2</span>).setCellValue(businessData.getTurnover());<br>        row.getCell(<span class="hljs-number">4</span>).setCellValue(businessData.getOrderCompletionRate());<br>        row.getCell(<span class="hljs-number">6</span>).setCellValue(businessData.getNewUsers());<br>        row = sheet.getRow(<span class="hljs-number">4</span>);<br>        row.getCell(<span class="hljs-number">2</span>).setCellValue(businessData.getValidOrderCount());<br>        row.getCell(<span class="hljs-number">4</span>).setCellValue(businessData.getUnitPrice());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> begin.plusDays(i);<br>           <span class="hljs-comment">//准备明细数据</span><br>            businessData = workspaceService.getBusinessData(LocalDateTime.of(date,LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX));<br>            row = sheet.getRow(<span class="hljs-number">7</span> + i);<br>            row.getCell(<span class="hljs-number">1</span>).setCellValue(date.toString());<br>            row.getCell(<span class="hljs-number">2</span>).setCellValue(businessData.getTurnover());<br>            row.getCell(<span class="hljs-number">3</span>).setCellValue(businessData.getValidOrderCount());<br>            row.getCell(<span class="hljs-number">4</span>).setCellValue(businessData.getOrderCompletionRate());<br>            row.getCell(<span class="hljs-number">5</span>).setCellValue(businessData.getUnitPrice());<br>            row.getCell(<span class="hljs-number">6</span>).setCellValue(businessData.getNewUsers());<br>        &#125;<br>        <span class="hljs-comment">//通过输出流将文件下载到客户端浏览器中</span><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        excel.write(out);<br>        <span class="hljs-comment">//关闭资源</span><br>        out.flush();<br>        out.close();<br>        excel.close();<br><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>javase</tag>
      
      <tag>苍穹外卖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苍穹外卖订单支付跳过微信支付及解决后续订单取消、拒单等问题</title>
    <link href="/2025/03/03/JAVA/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96DebugAndResolve/"/>
    <url>/2025/03/03/JAVA/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96DebugAndResolve/</url>
    
    <content type="html"><![CDATA[<h1 align="center">苍穹外卖订单支付跳过微信支付及解决后续订单取消、拒单等问题</h1><h2 id="1-导入订单支付代码"><a href="#1-导入订单支付代码" class="headerlink" title="1. 导入订单支付代码"></a>1. 导入订单支付代码</h2><p>在完成用户下单相关模块任务后，导入黑马资料中提供的订单支付代码(根据课程教学导入)。<br><strong>注意：不要再配置微信支付相关的application.yml和application-dev.yml文件</strong></p><p><img src="/img/blogs/java/cangqiongtakeout/solve.1.png"></p><h2 id="2-跳过微信支付"><a href="#2-跳过微信支付" class="headerlink" title="2. 跳过微信支付"></a>2. 跳过微信支付</h2><p><a href="https://blog.csdn.net/XZY__one/article/details/135818055">跳过微信支付</a></p><p>按照上面文章做即可跳过微信支付模块，但是后续在写用户端和商家端订单取消、商家端拒单等接口时出错，请按照下面的步骤进行修改即可修复</p><h2 id="3-用户端取消订单接口出错"><a href="#3-用户端取消订单接口出错" class="headerlink" title="3. 用户端取消订单接口出错"></a>3. 用户端取消订单接口出错</h2><p>在Service层实现类<strong>OrderServiceImpl</strong>中注释以下代码(该段代码依然调用了微信支付相关接口，所以要注释掉)</p><p><img src="/img/blogs/java/cangqiongtakeout/solve.2.png"></p><p>修改后的userCancelById(用户取消订单)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户取消订单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">userCancelById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 根据id查询订单</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(id);<br><br>        <span class="hljs-comment">// 校验订单是否存在</span><br>        <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_NOT_FOUND);<br>        &#125;<br><br>        <span class="hljs-comment">//订单状态 1待付款 2待接单 3已接单 4派送中 5已完成 6已取消</span><br>        <span class="hljs-keyword">if</span> (ordersDB.getStatus() &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>        &#125;<br><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        orders.setId(ordersDB.getId());<br><br>        <span class="hljs-comment">// 订单处于待接单状态下取消，需要进行退款</span><br>        <span class="hljs-keyword">if</span> (ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;<br><span class="hljs-comment">//            //调用微信支付退款接口</span><br><span class="hljs-comment">//            weChatPayUtil.refund(</span><br><span class="hljs-comment">//                    ordersDB.getNumber(), //商户订单号</span><br><span class="hljs-comment">//                    ordersDB.getNumber(), //商户退款单号</span><br><span class="hljs-comment">//                    new BigDecimal(0.01),//退款金额，单位 元</span><br><span class="hljs-comment">//                    new BigDecimal(0.01));//原订单金额</span><br><br>            <span class="hljs-comment">//支付状态修改为 退款</span><br>            orders.setPayStatus(Orders.REFUND);<br>        &#125;<br><br>        <span class="hljs-comment">// 更新订单状态、取消原因、取消时间</span><br>        orders.setStatus(Orders.CANCELLED);<br>        orders.setCancelReason(<span class="hljs-string">&quot;用户取消&quot;</span>);<br>        orders.setCancelTime(LocalDateTime.now());<br>        orderMapper.update(orders);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-商家端拒单接口出错"><a href="#4-商家端拒单接口出错" class="headerlink" title="4. 商家端拒单接口出错"></a>4. 商家端拒单接口出错</h2><h3 id="4-1-注释微信支付相关接口"><a href="#4-1-注释微信支付相关接口" class="headerlink" title="4.1 注释微信支付相关接口"></a>4.1 注释微信支付相关接口</h3><p>在Service层实现类<strong>OrderServiceImpl</strong>中注释以下代码(该段代码依然调用了微信支付相关接口，所以要注释掉)</p><p><img src="/img/blogs/java/cangqiongtakeout/solve.3.png"></p><h3 id="4-2-更新语句放在if语句中"><a href="#4-2-更新语句放在if语句中" class="headerlink" title="4.2 更新语句放在if语句中"></a>4.2 更新语句放在if语句中</h3><ol><li>然后，把更新语句放在if语句中，如果支付状态是已支付，就更新订单状态等数据</li><li>此外要把创建的orders对象放到if语句之上</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">//支付状态</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">payStatus</span> <span class="hljs-operator">=</span> ordersDB.getPayStatus();<br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        <span class="hljs-keyword">if</span> (payStatus == Orders.PAID) &#123;<br><span class="hljs-comment">//            //用户已支付，需要退款</span><br><span class="hljs-comment">//            String refund = weChatPayUtil.refund(</span><br><span class="hljs-comment">//                    ordersDB.getNumber(),</span><br><span class="hljs-comment">//                    ordersDB.getNumber(),</span><br><span class="hljs-comment">//                    new BigDecimal(0.01),</span><br><span class="hljs-comment">//                    new BigDecimal(0.01));</span><br><span class="hljs-comment">//            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);</span><br><br>            <span class="hljs-comment">// 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间</span><br>            orders.setId(ordersDB.getId());<br>            orders.setStatus(Orders.CANCELLED);<br>            orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());<br>            orders.setCancelTime(LocalDateTime.now());<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-修改后的rejection-拒单-方法"><a href="#4-3-修改后的rejection-拒单-方法" class="headerlink" title="4.3 修改后的rejection(拒单)方法"></a>4.3 修改后的rejection(拒单)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拒单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersRejectionDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejection</span><span class="hljs-params">(OrdersRejectionDTO ordersRejectionDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 根据id查询订单</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(ordersRejectionDTO.getId());<br><br>        <span class="hljs-comment">// 订单只有存在且状态为2（待接单）才可以拒单</span><br>        <span class="hljs-keyword">if</span> (ordersDB == <span class="hljs-literal">null</span> || !ordersDB.getStatus().equals(Orders.TO_BE_CONFIRMED)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderBusinessException</span>(MessageConstant.ORDER_STATUS_ERROR);<br>        &#125;<br><br>        <span class="hljs-comment">//支付状态</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">payStatus</span> <span class="hljs-operator">=</span> ordersDB.getPayStatus();<br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        <span class="hljs-keyword">if</span> (payStatus == Orders.PAID) &#123;<br><span class="hljs-comment">//            //用户已支付，需要退款</span><br><span class="hljs-comment">//            String refund = weChatPayUtil.refund(</span><br><span class="hljs-comment">//                    ordersDB.getNumber(),</span><br><span class="hljs-comment">//                    ordersDB.getNumber(),</span><br><span class="hljs-comment">//                    new BigDecimal(0.01),</span><br><span class="hljs-comment">//                    new BigDecimal(0.01));</span><br><span class="hljs-comment">//            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);</span><br><br>            <span class="hljs-comment">// 拒单需要退款，根据订单id更新订单状态、拒单原因、取消时间</span><br>            orders.setId(ordersDB.getId());<br>            orders.setStatus(Orders.CANCELLED);<br>            orders.setRejectionReason(ordersRejectionDTO.getRejectionReason());<br>            orders.setCancelTime(LocalDateTime.now());<br>        &#125;<br><br>        orderMapper.update(orders);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-商家端取消订单接口出错"><a href="#5-商家端取消订单接口出错" class="headerlink" title="5. 商家端取消订单接口出错"></a>5. 商家端取消订单接口出错</h2><ul><li>在Service层实现类<strong>OrderServiceImpl</strong>中</li><li>与上面拒单接口出错原因一样，修改的步骤也一样，直接放修改后的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取消订单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ordersCancelDTO</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(OrdersCancelDTO ordersCancelDTO)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 根据id查询订单</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">ordersDB</span> <span class="hljs-operator">=</span> orderMapper.getById(ordersCancelDTO.getId());<br><br>        <span class="hljs-comment">//支付状态</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">payStatus</span> <span class="hljs-operator">=</span> ordersDB.getPayStatus();<br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orders</span>();<br>        <span class="hljs-keyword">if</span> (payStatus == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">//            //用户已支付，需要退款</span><br><span class="hljs-comment">//            String refund = weChatPayUtil.refund(</span><br><span class="hljs-comment">//                    ordersDB.getNumber(),</span><br><span class="hljs-comment">//                    ordersDB.getNumber(),</span><br><span class="hljs-comment">//                    new BigDecimal(0.01),</span><br><span class="hljs-comment">//                    new BigDecimal(0.01));</span><br><span class="hljs-comment">//            log.info(&quot;申请退款：&#123;&#125;&quot;, refund);</span><br><br><br>            <span class="hljs-comment">// 管理端取消订单需要退款，根据订单id更新订单状态、取消原因、取消时间</span><br>            orders.setId(ordersCancelDTO.getId());<br>            orders.setStatus(Orders.CANCELLED);<br>            orders.setCancelReason(ordersCancelDTO.getCancelReason());<br>            orders.setCancelTime(LocalDateTime.now());<br>        &#125;<br>        orderMapper.update(orders);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-用户下单提醒功能出错"><a href="#6-用户下单提醒功能出错" class="headerlink" title="6. 用户下单提醒功能出错"></a>6. 用户下单提醒功能出错</h2><p>按照视频教学添加的代码无法完成用户下单后，商家端界面提醒的功能</p><ul><li><strong>原因</strong>：我们跳过微信支付功能，导致也跳过了PayNotifyController接口功能，所以<strong>在OrderServiceImpl类中的paySuccess方法从始至终都不会被调用</strong>，我们添加的代码自然也不会实现。</li><li><strong>解决方法</strong>：将用户下单提醒功能代码添加到<strong>OrderServiceImpl类中的payment方法</strong>即可</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>map.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// 消息类型，1表示来单提醒</span><br><span class="hljs-comment">//获取订单id</span><br>Orders orders=orderMapper.getByNumberAndUserId(orderNumber, userId);<br>map.put(<span class="hljs-string">&quot;orderId&quot;</span>, orders.getId());<br>map.put(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;订单号：&quot;</span> + orderNumber);<br><br><span class="hljs-comment">// 通过WebSocket实现来单提醒，向客户端浏览器推送消息</span><br>webSocketServer.sendToAllClient(JSON.toJSONString(map));<br>log.info(<span class="hljs-string">&quot;来单提醒：&#123;&#125;&quot;</span>, JSON.toJSONString(map));<br></code></pre></td></tr></table></figure><p><strong>添加位置如下</strong>：</p><p><img src="/img/blogs/java/cangqiongtakeout/solve.4.png"></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>javase</tag>
      
      <tag>苍穹外卖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记</title>
    <link href="/2025/02/23/DeveloperTools/git/"/>
    <url>/2025/02/23/DeveloperTools/git/</url>
    
    <content type="html"><![CDATA[<h1 align="center">Git学习笔记</h1><h1 id="1-git介绍"><a href="#1-git介绍" class="headerlink" title="1. git介绍"></a>1. git介绍</h1><p>Git是一个分布式版本控制工具，用于管理开发过程中的源代码文件(Java类、xml文件、html页面等)</p><ul><li>Git仓库分为两种：<ul><li>本地仓库: 开发人员自己电脑上的Git仓库</li><li>远程仓库: 远程服务器上的Git仓库</li></ul></li></ul><p><img src="/img/blogs/git/1.1.png"></p><ul><li>commit:提交,将本地文件和版本信息保存到本地仓库</li><li>push:推送,将本地仓库文件和版本信息上传到远程仓库</li><li>pull:拉取,将远程仓库文件和版本信息下载到本地仓库</li></ul><h1 id="2-Git代码托管服务"><a href="#2-Git代码托管服务" class="headerlink" title="2. Git代码托管服务"></a>2. Git代码托管服务</h1><p>Git存在两种类型的仓库(本地仓库和远程仓库),借助互联网上提供的一些代码托管服务实现搭建Git远程仓库</p><ul><li>使用gitee作为代码托管服务<br><a href="https://gitee.com/">gitee</a></li></ul><h1 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3. Git常用命令"></a>3. Git常用命令</h1><h2 id="3-1-Git全局设置"><a href="#3-1-Git全局设置" class="headerlink" title="3.1 Git全局设置"></a>3.1 Git全局设置</h2><h3 id="3-1-1-配置用户名和邮箱"><a href="#3-1-1-配置用户名和邮箱" class="headerlink" title="3.1.1 配置用户名和邮箱"></a>3.1.1 配置用户名和邮箱</h3><p>在Git命令行中执行下面命令:</p><ul><li>设置用户信息(用户名和邮箱随意设置)<ul><li><code>git config --global user.name &quot;ranzier&quot;</code></li><li><code>git config --global user.email &quot;ranzier@la.com&quot;</code></li></ul></li><li>查看配置信息<ul><li><code>git config --list</code></li></ul></li></ul><h3 id="3-1-2-获取Git仓库–从远程仓库克隆"><a href="#3-1-2-获取Git仓库–从远程仓库克隆" class="headerlink" title="3.1.2 获取Git仓库–从远程仓库克隆"></a>3.1.2 获取Git仓库–从远程仓库克隆</h3><ol><li>在本地初始化一个Git仓库(不常用)</li><li>从远程仓库克隆(常用)</li></ol><p>命令：<code>git clone [远程仓库地址]</code></p><h2 id="3-2-Git一些概念"><a href="#3-2-Git一些概念" class="headerlink" title="3.2 Git一些概念"></a>3.2 Git一些概念</h2><h3 id="3-2-1-工作区、版本库、暂存区概念"><a href="#3-2-1-工作区、版本库、暂存区概念" class="headerlink" title="3.2.1 工作区、版本库、暂存区概念"></a>3.2.1 工作区、版本库、暂存区概念</h3><ul><li>版本库: 前面看到的.git隐藏文件夹就是版本库,版本库中存储了很多配置信息、日志信息和文件版本信息等</li><li>工作区: 包含.git文件夹的目录就是工作区,也称为工作目录,主要用于存放开发的代码</li><li>暂存区: .git文件夹中有很多文件,其中有一个index文件就是暂存区,也可以叫做stage。暂存区是一个临时保存修改文件的地方</li></ul><p><img src="/img/blogs/git/3.1.png"></p><h3 id="3-2-2-Git工作区中文件的状态"><a href="#3-2-2-Git工作区中文件的状态" class="headerlink" title="3.2.2 Git工作区中文件的状态"></a>3.2.2 Git工作区中文件的状态</h3><p>Git工作区中的文件存在两种状态:</p><ul><li>untracked未跟踪(未被纳入版本控制)</li><li>tracked已跟踪(被纳入版本控制)<ol><li>Unmodified 未修改状态</li><li>Modified已修改状态</li><li>Staged已暂存状态</li></ol></li></ul><h2 id="3-3-本地仓库操作"><a href="#3-3-本地仓库操作" class="headerlink" title="3.3 本地仓库操作"></a>3.3 本地仓库操作</h2><p>本地仓库常用命令如下:</p><ul><li>git status: 查看文件状态</li><li>git add: 将文件的修改加入暂存区</li><li>git reset: 将暂存区的文件取消暂存或者是切换到指定版本</li><li>git commit: 将暂存区的文件修改提交到版本库</li><li>git log: 查看日志</li></ul><h2 id="3-4-远程仓库操作"><a href="#3-4-远程仓库操作" class="headerlink" title="3.4 远程仓库操作"></a>3.4 远程仓库操作</h2><ul><li>git remote  查看远程仓库</li><li>git remote add   添加远程仓库</li><li>git clone   从远程仓库克隆</li><li>git pull  从远程仓库拉取</li><li>git push  推送到远程仓库</li></ul><ol><li><p>添加远程仓库</p><ul><li>运行<code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库,同时指定一个可以引用的简写。</li></ul></li><li><p>从远程仓库拉取</p><ul><li><code>git pull</code>命令的作用是从远程仓库获取最新版本并合并到本地仓库,命令格式:<code>git pull [short-name] [branch-name]</code></li></ul></li></ol><h2 id="3-5-分支操作"><a href="#3-5-分支操作" class="headerlink" title="3.5 分支操作"></a>3.5 分支操作</h2><ul><li>使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线。</li><li>同一个仓库可以有多个分支,各个分支相互独立,互不干扰。</li><li>通过<strong>git init</strong>命令创建本地仓库时默认会创建一个<strong>master分支</strong>。</li></ul><p>分支命令</p><ul><li><p>git branch  查看分支</p></li><li><p>git branch [name] 创建分支</p></li><li><p>git checkout [name] 切换分支</p></li><li><p>git push [shortName] [name] 推送至远程仓库分支</p></li><li><p>git merge [name]  合并分支</p></li><li><p>查看分支</p><ul><li>git branch  列出所有本地分支</li><li>git branch -r 列出所有远程分支</li><li>git branch -a 列出所有本地分支和远程分支</li></ul></li></ul><h2 id="3-6-标签操作"><a href="#3-6-标签操作" class="headerlink" title="3.6 标签操作"></a>3.6 标签操作</h2><ul><li>Git中的标签,指的是<code>某个分支某个特定时间点的状态</code>。通过标签,可以很方便的切换到标记时的状态。</li><li>比较有代表性的是人们会使用这个功能来标记发布结点(v1.0、v1.2等)。</li></ul><p>标签命令：</p><ul><li>git tag 列出已有的标签</li><li>git tag [name]  创建标签</li><li>git push [shortName] [name] 将标签推送至远程仓库</li><li>git checkout -b [branch] [name] 检出标签</li></ul><h1 id="4-在IDEA中使用Git"><a href="#4-在IDEA中使用Git" class="headerlink" title="4. 在IDEA中使用Git"></a>4. 在IDEA中使用Git</h1><p><a href="https://jhguo.blog.csdn.net/article/details/128949057?spm=1001.2014.3001.5502">在IDEA中使用Git</a></p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>开发工具</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习笔记</title>
    <link href="/2025/02/22/JAVA/javaweb/"/>
    <url>/2025/02/22/JAVA/javaweb/</url>
    
    <content type="html"><![CDATA[<h1 align="center">JavaWeb学习笔记</h1><h1 id="一-前端开发"><a href="#一-前端开发" class="headerlink" title="一. 前端开发"></a>一. 前端开发</h1><h2 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1. HTML"></a>1. HTML</h2><p><a href="https://ranzier.github.io/2024/10/31/FrontEnd/HTML%E7%AC%94%E8%AE%B0/">HTML学习笔记</a></p><h2 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2. CSS"></a>2. CSS</h2><p><a href="https://ranzier.github.io/2024/10/31/FrontEnd/CSS%E7%AC%94%E8%AE%B0/">CSS学习笔记</a></p><h2 id="3-JavaScript"><a href="#3-JavaScript" class="headerlink" title="3. JavaScript"></a>3. JavaScript</h2><p><a href="https://ranzier.github.io/2024/12/18/FrontEnd/JS%E7%AC%94%E8%AE%B0/">JavaScript学习笔记</a></p><h2 id="4-Vue"><a href="#4-Vue" class="headerlink" title="4. Vue"></a>4. Vue</h2><h4 id="A-Vue简介"><a href="#A-Vue简介" class="headerlink" title="A. Vue简介"></a>A. Vue简介</h4><p>Vue是一套前端<strong>框架</strong>，免除JS的DOM操作，简化书写</p><ul><li>新建HTML页面,引入Vue.js文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在JS代码区域,创建Vue核心对象,定义数据模型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>        <span class="hljs-attr">data</span>: &#123;<br>            <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello Vue!&quot;</span><br>            &#125;<br>        &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>编写视图</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    &#123;&#123; message &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-Vue常用指令"><a href="#B-Vue常用指令" class="headerlink" title="B. Vue常用指令"></a>B. Vue常用指令</h4><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值,如设置href,css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-if&#x2F;v-else-if&#x2F;v-else</td><td>条件性的渲染某元素,判定为true时渲染,否则不渲染</td></tr><tr><td>v-show</td><td>根据条件展示某元素,区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染,遍历容器的元素或者对象的属性</td></tr></tbody></table><ol><li><p><strong>v-bind</strong>：用来绑定 HTML 标签的属性，比如动态改变 <code>href</code>，<code>src</code>，<code>class</code>，<code>style</code> 等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>v-model</strong>：用于在表单元素上实现双向数据绑定，通常用于 <code>input</code>、<code>textarea</code> 或 <code>select</code> 元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>v-on</strong>：绑定事件处理程序，可以监听用户的交互操作，如点击、鼠标移入等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>v-if&#x2F;v-else-if&#x2F;v-else</strong>：用于条件渲染，如果条件为真，渲染元素，否则不渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span>这是一个条件渲染的段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>v-show</strong>：与 <code>v-if</code> 类似，不过 <code>v-show</code> 不会移除 DOM 元素，而是通过控制 <code>display</code> 样式来显示或隐藏元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isVisible&quot;</span>&gt;</span>这段内容根据条件展示<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>v-for</strong>：用于列表渲染，遍历数组或对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="C-Vue生命周期"><a href="#C-Vue生命周期" class="headerlink" title="C. Vue生命周期"></a>C. Vue生命周期</h4><p>Vue的生命周期指Vue对象创建和销毁的过程<br><code>mounted</code>: 挂载完成，Vue初始化成功，HTML页面渲染成功(发送请求到服务端，加载数据)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Vue挂载完毕,发送请求获取数据&quot;</span>);</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Ajax"><a href="#5-Ajax" class="headerlink" title="5. Ajax"></a>5. Ajax</h2><h4 id="A-介绍"><a href="#A-介绍" class="headerlink" title="A. 介绍"></a>A. 介绍</h4><p>Asynchronous JavaScript And XML(异步的JavaScript和XML)<br><strong>作用</strong></p><ul><li>数据交换: 通过Ajax可以向服务器发送请求和接收服务器响应的数据</li><li>异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分页面的技术。如搜索联想功能</li></ul><h4 id="B-Axios"><a href="#B-Axios" class="headerlink" title="B. Axios"></a>B. Axios</h4><p>对原生的Ajax进行封装，简化书写，快速开发</p><ol><li>引入Axios的JS文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用Axios发送请求，并获取响应结果</li></ol><ul><li>axios.get(url [, config])</li><li>axios.delete(url [, config])</li><li>axios.post(url [, data[, config]])</li><li>axios.put(url [, data[, config]])</li></ul><p><strong>发送GET请求</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">axios.get(&quot;http://yapi.smart-xwork.cn/mock/169327/emp/list&quot;).then((result) =&gt; &#123;<br>    console.log(result.data);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>发送POST请求</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">axios.post(&quot;http://yapi.smart-xwork.cn/mock/169327/emp/deleteByld&quot;,&quot;id=1&quot;).then((result) =&gt; &#123;<br>    console.log(result.data);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="6-前端工程化"><a href="#6-前端工程化" class="headerlink" title="6. 前端工程化"></a>6. 前端工程化</h2><h4 id="A-YAPI-接口文档管理平台"><a href="#A-YAPI-接口文档管理平台" class="headerlink" title="A. YAPI(接口文档管理平台)"></a>A. YAPI(接口文档管理平台)</h4><p><a href="https://yapi.pro/">YAPI官网</a></p><h4 id="B-Vue项目创建"><a href="#B-Vue项目创建" class="headerlink" title="B. Vue项目创建"></a>B. Vue项目创建</h4><p>新建一个文件夹，在该文件夹中打开cmd，输入<code>vue ui</code><br><a href="https://blog.csdn.net/Monsters___/article/details/126552454?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522c9c78d176b906f788231ea91150061aa%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=c9c78d176b906f788231ea91150061aa&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126552454-null-null.142%5Ev101%5Epc_search_result_base2&utm_term=vue%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA&spm=1018.2226.3001.4187">创建vue项目</a></p><h4 id="C-Element"><a href="#C-Element" class="headerlink" title="C. Element"></a>C. Element</h4><p><a href="https://element.eleme.cn/#/zh-CN">Element官网</a><br>Vue组件库，用于创建更好看的组件(下图右边是基于Element)</p><p><img src="/img/blogs/java/javaweb/1.6.1.png"></p><h5 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h5><ul><li><p>安装ElementUI组件库(在当前工程的目录下),在命令行执行指令:<br><code>npm install element-ui@2.15.3</code></p></li><li><p>引入ElementUI组件库</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementUI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementUI</span>);<br></code></pre></td></tr></table></figure><ul><li>访问官网，复制组件代码，调整</li></ul><h5 id="2-常用组件"><a href="#2-常用组件" class="headerlink" title="2. 常用组件"></a>2. 常用组件</h5><ul><li><p>Table表格<br><a href="https://element.eleme.cn/#/zh-CN/component/table">表格</a></p></li><li><p>pagination分页<br><a href="https://element.eleme.cn/#/zh-CN/component/pagination">分页</a></p></li><li><p>Dialog对话框<br><a href="https://element.eleme.cn/#/zh-CN/component/dialog">对话框</a></p></li><li><p>Form表单<br><a href="https://element.eleme.cn/#/zh-CN/component/form">表单</a></p></li></ul><h4 id="D-Vue路由"><a href="#D-Vue路由" class="headerlink" title="D. Vue路由"></a>D. Vue路由</h4><p>前端路由：URL中的hash(#号)与组件之间的对应关系</p><ul><li><code>VueRouter</code>:路由器类,根据路由请求在路由视图中动态渲染选中的组件</li><li><code>&lt;router-link&gt;</code>:请求链接组件,浏览器会解析成<code>&lt;a&gt;</code></li><li><code>&lt;router-view&gt;</code>:动态视图组件,用来渲染展示与路由路径对应的组件</li></ul><h4 id="E-打包部署"><a href="#E-打包部署" class="headerlink" title="E. 打包部署"></a>E. 打包部署</h4><p><a href="https://nginx.org/">nginx官网</a></p><h1 id="二-Maven"><a href="#二-Maven" class="headerlink" title="二. Maven"></a>二. Maven</h1><p>是管理和构建java项目的工具<br><a href="https://maven.apache.org/">Maven官网</a></p><h2 id="1-Maven介绍"><a href="#1-Maven介绍" class="headerlink" title="1. Maven介绍"></a>1. Maven介绍</h2><p><img src="/img/blogs/java/javaweb/2.1.1.png"></p><h2 id="2-在idea中创建Maven项目和导入Maven项目"><a href="#2-在idea中创建Maven项目和导入Maven项目" class="headerlink" title="2. 在idea中创建Maven项目和导入Maven项目"></a>2. 在idea中创建Maven项目和导入Maven项目</h2><p><strong>创建</strong><br><img src="/img/blogs/java/javaweb/2.2.1.png"></p><p><strong>导入</strong><br><img src="/img/blogs/java/javaweb/2.2.2.png"></p><h2 id="3-依赖管理"><a href="#3-依赖管理" class="headerlink" title="3. 依赖管理"></a>3. 依赖管理</h2><p>依赖：就指项目运行所需要的jar包，一个项目可以引入多个依赖</p><h4 id="A-依赖配置-导入jar包"><a href="#A-依赖配置-导入jar包" class="headerlink" title="A. 依赖配置(导入jar包)"></a>A. 依赖配置(导入jar包)</h4><ol><li>在pom.xml中编写<code>&lt;dependencies&gt;</code>标签</li><li>在<code>&lt;dependencies&gt;</code>标签中 使用<code>&lt;dependency&gt;</code>引入坐标</li><li>定义坐标的 groupld,artifactld, version</li><li>点击刷新按钮,引入最新加入的坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-依赖传递和排除依赖"><a href="#B-依赖传递和排除依赖" class="headerlink" title="B. 依赖传递和排除依赖"></a>B. 依赖传递和排除依赖</h4><p>依赖具有传递性<br><img src="/img/blogs/java/javaweb/2.3.1.png"></p><p><strong>排除依赖</strong><br>使用<code>&lt;exclusions&gt;&lt;/exclusions&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="C-依赖范围"><a href="#C-依赖范围" class="headerlink" title="C. 依赖范围"></a>C. 依赖范围</h4><p>依赖的jar包，在默认情况下，可以在任何地方使用<br>可以通过<code>&lt;scope&gt;&lt;/scope&gt;</code>设置其作用范围</p><table><thead><tr><th>scope值</th><th>主程序(main)</th><th>测试程序(test)</th><th>打包(运行)</th><th>示例</th></tr></thead><tbody><tr><td>compile(默认)</td><td>Y</td><td>Y</td><td>Y</td><td>log4j</td></tr><tr><td>test</td><td>N</td><td>Y</td><td>N</td><td>junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>N</td><td>servlet-api</td></tr><tr><td>runtime</td><td>N</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr></tbody></table><h4 id="D-生命周期"><a href="#D-生命周期" class="headerlink" title="D. 生命周期"></a>D. 生命周期</h4><p>Maven中有3套相互独立的生命周期:</p><ul><li>clean:清理工作。</li><li>default:核心工作,如:编译、测试、打包、安装、部署等。</li><li>site:生成报告、发布站点等。</li></ul><h1 id="三-Web入门"><a href="#三-Web入门" class="headerlink" title="三. Web入门"></a>三. Web入门</h1><h2 id="1-SpringBootWeb入门"><a href="#1-SpringBootWeb入门" class="headerlink" title="1. SpringBootWeb入门"></a>1. SpringBootWeb入门</h2><ol><li>创建springboot工程，勾选spring web<br><img src="/img/blogs/java/javaweb/3.1.1.png"></li></ol><p><img src="/img/blogs/java/javaweb/3.1.2.png"></p><ol start="2"><li>创建请求处理类HelloController,添加请求处理方法hello,添加注释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloControll</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello-world&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World ~&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World ~&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的启动类必须是请求处理类的父包</p><ol start="3"><li>运行启动类，打开浏览器测试<br>打开localhost:8080&#x2F;hello-world端口</li></ol><h2 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. HTTP协议</h2><h4 id="A-介绍-1"><a href="#A-介绍-1" class="headerlink" title="A. 介绍"></a>A. 介绍</h4><p>Hyper Text Transfer Protocol(超文本传输协议)<br>规定浏览器和服务器之间数据传输的规则</p><ul><li>基于TCP协议</li><li>基于请求-响应模型</li><li>是无状态的协议：每次请求-响应都是独立的</li></ul><h4 id="B-请求协议"><a href="#B-请求协议" class="headerlink" title="B. 请求协议"></a>B. 请求协议</h4><p><img src="/img/blogs/java/javaweb/3.2.1.png"></p><h4 id="C-响应协议"><a href="#C-响应协议" class="headerlink" title="C. 响应协议"></a>C. 响应协议</h4><p><img src="/img/blogs/java/javaweb/3.2.2.png"></p><p><img src="/img/blogs/java/javaweb/3.2.3.png"></p><p><img src="/img/blogs/java/javaweb/3.2.4.png"></p><h2 id="3-WEB服务器-Tomcat"><a href="#3-WEB服务器-Tomcat" class="headerlink" title="3. WEB服务器-Tomcat"></a>3. WEB服务器-Tomcat</h2><p>一个轻量级的WEB服务器，是一个软件程序，对HTTP协议的操作进行封装，也称为web容器、servlet容器</p><h2 id="4-请求响应"><a href="#4-请求响应" class="headerlink" title="4. 请求响应"></a>4. 请求响应</h2><h4 id="A-请求"><a href="#A-请求" class="headerlink" title="A. 请求"></a>A. 请求</h4><h5 id="1-简单参数"><a href="#1-简单参数" class="headerlink" title="1. 简单参数"></a>1. 简单参数</h5><p>SpringBoot方式：参数名与形参变量名相同，定义形参即可接收参数,会自动进行类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name , Integer age)</span> &#123;<br>    System.out.println(name + <span class="hljs-string">&quot; : &quot;</span> + age);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RequestParam注解</p><ul><li>方法形参名称与请求参数名称不匹配,通过该注解完成映射</li><li>该注解的require属性默认是true,代表请求参数必须传递</li></ul><h5 id="2-实体参数"><a href="#2-实体参数" class="headerlink" title="2. 实体参数"></a>2. 实体参数</h5><p><strong>简单实体对象</strong>：请求参数名和形参对象属性名相同，定义POJO接收即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/simplePojo&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplePojo</span><span class="hljs-params">(User user)</span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建user类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中：GET: <code>http://localhost:8080/simpleParam?name=abc&amp;age=111</code></p><p><strong>复杂实体对象</strong>：请求参数名和形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Address address;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>&#123;<br>    <span class="hljs-keyword">private</span> String province;<br>    <span class="hljs-keyword">private</span> String city;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET:<code>http://localhost:8080/simpleParam?name=abc&amp;age=111&amp;address.province=北京&amp;address.city=北京</code></p><h5 id="3-数组集合参数"><a href="#3-数组集合参数" class="headerlink" title="3. 数组集合参数"></a>3. 数组集合参数</h5><p><strong>数组参数</strong>：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(String[] hobby)</span>&#123;<br>    System.out.println(Arrays.toString(hobby));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET: <code>http://localhost:8080/arrayParam?hobby=game&amp;hobby=java</code></p><p><strong>集合参数</strong>：请求参数名与形参中数组变量名相同，通过@RequestParam绑定参数关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">listParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt; hobby)</span> &#123;<br>    System.out.println(hobby);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET: <code>http://localhost:8080/listParam?hobby=game&amp;hobby=java&amp;hobby=sing</code></p><h5 id="4-日期参数"><a href="#4-日期参数" class="headerlink" title="4. 日期参数"></a>4. 日期参数</h5><p>使用@DateTimeFormat注解完成日期参数格式转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dateParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dateParam</span><span class="hljs-params">(<span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span> &#123;<br>    System.out.println(updateTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET:<code>http://localhost:8080/dateParam?updateTime=2025-1-1 13:14:05</code></p><h5 id="5-json参数"><a href="#5-json参数" class="headerlink" title="5. json参数"></a>5. json参数</h5><p><strong>JSON参数</strong>：JSON数据键名与形参对象属性名相同,定义POJO类型形参即可接收参数,需要使用@RequestBody标识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/jsonParam&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET:<code>http://localhost:8080/jsonParam</code></p><h5 id="6-路径参数"><a href="#6-路径参数" class="headerlink" title="6. 路径参数"></a>6. 路径参数</h5><p><strong>路径参数</strong>：通过请求URL直接传递参数,使用{ .. }来标识该路径参数,需要使用@PathVariable获取路径参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<br>    System.out.println(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET:<code>http://localhost:8080/path/1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam2</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id, <span class="hljs-meta">@PathVariable</span> String name)</span>&#123;<br>    System.out.println(id+<span class="hljs-string">&quot; : &quot;</span> +name);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>postman中:GET:<code>http://localhost:8080/path/1/abc</code></p><h4 id="B-响应"><a href="#B-响应" class="headerlink" title="B. 响应"></a>B. 响应</h4><h5 id="1-ResponseBody"><a href="#1-ResponseBody" class="headerlink" title="1. @ResponseBody"></a>1. @ResponseBody</h5><ul><li>类型:方法注解、类注解</li><li>位置:Controller方法上&#x2F;类上</li><li>作用:将方法返回值直接响应,如果返回值类型是<strong>实体对象&#x2F;集合</strong>,将会转换为<strong>JSON格式</strong>响应</li><li>说明:@RestController&#x3D;@Controller+@ResponseBody;</li></ul><h5 id="2-统一响应结果"><a href="#2-统一响应结果" class="headerlink" title="2. 统一响应结果"></a>2. 统一响应结果</h5><p><code>Result(code,msg,data)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-comment">//响应码,1代表成功;0代表失败</span><br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-comment">//提示信息</span><br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-comment">//返回的数据</span><br>    <span class="hljs-keyword">private</span> Object data;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-分层解耦"><a href="#5-分层解耦" class="headerlink" title="5. 分层解耦"></a>5. 分层解耦</h2><p><a href="https://blog.csdn.net/qq_41071754/article/details/129903630?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522887c301fb2e8bb5eab3e420bd5cd0932%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=887c301fb2e8bb5eab3e420bd5cd0932&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-6-129903630-null-null.142%5Ev101%5Epc_search_result_base2&utm_term=javaweb%E7%9A%84%E5%88%86%E5%B1%82%E8%A7%A3%E8%80%A6&spm=1018.2226.3001.4187">别人的笔记</a></p><h4 id="A-三层架构"><a href="#A-三层架构" class="headerlink" title="A. 三层架构"></a>A. 三层架构</h4><p><img src="/img/blogs/java/javaweb/3.5.1.png"></p><p><img src="/img/blogs/java/javaweb/3.5.2.png"></p><h4 id="B-解耦"><a href="#B-解耦" class="headerlink" title="B. 解耦"></a>B. 解耦</h4><ul><li><p>内聚:软件中各个功能模块内部的功能联系。</p></li><li><p>耦合:衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</p></li><li><p>高内聚低耦合</p></li><li><p>控制反转:Inversion Of Control,简称IOC。<strong>对象的创建控制权由程序自身转移到外部(容器)</strong>,这种思想称为控制反转。</p></li><li><p>依赖注入:Dependency Injection,简称DI。<strong>容器为应用程序提供运行时,所依赖的资源</strong>称之为依赖注入。</p></li><li><p>Bean对象:<strong>IOC容器中创建、管理的对象</strong>,称之为bean。</p></li></ul><h4 id="C-IOC控制反转"><a href="#C-IOC控制反转" class="headerlink" title="C. IOC控制反转"></a>C. IOC控制反转</h4><p>Bean的声明<br>要把某个对象交给IOC容器管理，需要在对应的类上加上以下注解之一：</p><table><thead><tr><th>注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td>@Componert</td><td>声明bean的基础注解</td><td>不属于以下三类时,用此注解</td></tr><tr><td>@Controller</td><td>@Component的衍生注解</td><td>标注在控制器类上</td></tr><tr><td>@Service</td><td>@Component的衍生注解</td><td>标注在业务类上</td></tr><tr><td>@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问类上(由于与mybatis整合,用的少)</td></tr></tbody></table><p>注意事项：</p><ul><li><p>声明bean的时候,可以通过value属性指定bean的名字,如果没有指定,默认为类名首字母小写。</p></li><li><p>使用以上四个注解都可以声明bean,但是在springboot集成web开发中,声明控制器bean只能用@Controller。</p></li><li><p>@SpringBootApplication具有包扫描作用，默认扫描当前包及其子包</p></li></ul><h4 id="D-DI依赖注入"><a href="#D-DI依赖注入" class="headerlink" title="D. DI依赖注入"></a>D. DI依赖注入</h4><ul><li>@Autowired:默认按照类型自动装配。</li><li>如果同类型的bean存在多个:<ul><li>@Primary</li><li>@Autowired+@Qualifier(“bean的名称”)</li><li>@Resource(name&#x3D;”bean的名称”)</li></ul></li><li>@Resource 与 @Autowired区别<ul><li>@Autowired 是spring框架提供的注解,而@Resource是JDK提供的注解。</li><li>@Autowired 默认是按照类型注入,而@Resource默认是按照名称注入。</li></ul></li></ul><h1 id="四-MySQL数据库"><a href="#四-MySQL数据库" class="headerlink" title="四. MySQL数据库"></a>四. MySQL数据库</h1><h2 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1. 数据库概述"></a>1. 数据库概述</h2><h4 id="A-数据库介绍"><a href="#A-数据库介绍" class="headerlink" title="A. 数据库介绍"></a>A. 数据库介绍</h4><ul><li>数据库：DataBase(DB),是存储和管理数据的仓库</li><li>数据库管理系统:DataBase Management System(DBMS),操纵和管理数据库的大型软件。</li><li>SQL: Structured Query Language,操作关系型数据库的编程语言,定义了一套操作关系型数据库统一标准。</li></ul><p>mysql启动：<code>net start mysql</code><br>mysql关闭: <code>net stop mysql</code><br>mysql连接：<code>mysql -u用户名 -p密码 /mysql -h数据库服务器IP地址 -P端口号</code><br><code>mysql -uroot -p123456 / mysql -h192.168.150.101 -P3306 -uroot -p123456</code></p><h4 id="B-MySQL数据模型和SQL简介"><a href="#B-MySQL数据模型和SQL简介" class="headerlink" title="B. MySQL数据模型和SQL简介"></a>B. MySQL数据模型和SQL简介</h4><h5 id="1-MySQL数据模型"><a href="#1-MySQL数据模型" class="headerlink" title="1. MySQL数据模型"></a>1. MySQL数据模型</h5><p>关系型数据库：建立在关系模型基础上，由多张相互连接的<strong>二维表</strong>组成的数据库</p><h5 id="2-SQL简介"><a href="#2-SQL简介" class="headerlink" title="2. SQL简介"></a>2. SQL简介</h5><ul><li>SQL语句可以单行或多行书写,以<strong>分号</strong>结尾。</li><li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句<strong>不区分大小写</strong>。</li><li>注释:<br>  单行注释: <code>-- 注释内容</code>或<code>#注释内容</code>(MySQL特有)<br>  多行注释:&#x2F;* 注释内容 *&#x2F;</li></ul><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言,用来定义数据库对象(数据库,表,字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言,用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言,用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言,用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table><h2 id="2-DDL语句"><a href="#2-DDL语句" class="headerlink" title="2. DDL语句"></a>2. DDL语句</h2><p>数据定义语言</p><h4 id="A-操作数据库"><a href="#A-操作数据库" class="headerlink" title="A. 操作数据库"></a>A. 操作数据库</h4><ul><li>查询所有数据库：<code>show databases;</code></li><li>查询当前数据库：<code>select database();</code></li><li>使用数据库:<code>use 数据库名;</code></li><li>创建数据库:<code>create database [if not exists] 数据库名;</code></li><li>删除数据库:<code>drop database[if exists] 数据库名;</code></li></ul><h4 id="B-表操作-创建"><a href="#B-表操作-创建" class="headerlink" title="B. 表操作-创建"></a>B. 表操作-创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span> 表名(<br>    字段<span class="hljs-number">1</span> 字段类型[约束][comment 字段<span class="hljs-number">1</span>注释],<br>    ...<br>    字段n 字段类型[约束][comment 字段n注释]<br>)[comment 表注释];<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span> tb_user<br>(<br>    id       <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;ID,唯一标识&#x27;</span>,<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>    name     <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age      <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    gender   <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>)comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="C-约束"><a href="#C-约束" class="headerlink" title="C. 约束"></a>C. 约束</h4><ul><li>概念:约束是作用于表中字段上的规则,用于限制存储在表中的数据。</li><li>目的:保证数据库中数据的正确性、有效性和完整性。</li></ul><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段值不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证字段的所有数据都是唯一、不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识,要求非空且唯一</td><td>primary key</td></tr><tr><td>默认约束</td><td>保存数据时,如果未指定该字段值,则采用默认值</td><td>default</td></tr><tr><td>外键约束</td><td>让两张表的数据建立连接,保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create table</span> tb_user<br>(<br>    id       <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> comment <span class="hljs-string">&#x27;ID,唯一标识&#x27;</span>,<br>    username <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>    name     <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age      <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    gender   <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;男&#x27;</span> comment <span class="hljs-string">&#x27;性别&#x27;</span><br>)comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="D-数据类型"><a href="#D-数据类型" class="headerlink" title="D. 数据类型"></a>D. 数据类型</h4><p>三大类数据类型：<code>数值类型</code>,<code>字符串类型</code>,<code>日期类型</code></p><p><strong>数值类型</strong></p><table><thead><tr><th>类型</th><th>描述</th><th>存储大小</th><th>取值范围</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>小整数</td><td>1字节</td><td>-128 到 127（有符号） &#x2F; 0 到 255（无符号）</td></tr><tr><td><code>SMALLINT</code></td><td>较小的整数</td><td>2字节</td><td>-32,768 到 32,767（有符号） &#x2F; 0 到 65,535（无符号）</td></tr><tr><td><code>MEDIUMINT</code></td><td>中等大小的整数</td><td>3字节</td><td>-8,388,608 到 8,388,607（有符号） &#x2F; 0 到 16,777,215（无符号）</td></tr><tr><td><code>INT</code></td><td>标准整数</td><td>4字节</td><td>-2,147,483,648 到 2,147,483,647（有符号） &#x2F; 0 到 4,294,967,295（无符号）</td></tr><tr><td><code>BIGINT</code></td><td>大整数</td><td>8字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（有符号） &#x2F; 0 到 18,446,744,073,709,551,615（无符号）</td></tr><tr><td><code>FLOAT</code></td><td>单精度浮动点数</td><td>4字节</td><td>-3.402823466E+38 到 3.402823466E+38（可选精度）</td></tr><tr><td><code>DOUBLE</code></td><td>双精度浮动点数</td><td>8字节</td><td>-1.7976931348623157E+308 到 1.7976931348623157E+308</td></tr><tr><td><code>DECIMAL</code></td><td>精确的定点数（用于高精度运算）</td><td>根据定义大小</td><td>精确存储数字，指定精度和小数位数，例如 <code>DECIMAL(10,2)</code></td></tr></tbody></table><p><strong>日期和时间类型</strong></p><table><thead><tr><th>类型</th><th>描述</th><th>存储大小</th><th>取值范围</th></tr></thead><tbody><tr><td><code>DATE</code></td><td>存储日期（年-月-日）</td><td>3字节</td><td>‘1000-01-01’ 到 ‘9999-12-31’</td></tr><tr><td><code>TIME</code></td><td>存储时间（时:分:秒）</td><td>3字节</td><td>‘-838:59:59’ 到 ‘838:59:59’</td></tr><tr><td><code>DATETIME</code></td><td>存储日期和时间（年-月-日 时:分:秒）</td><td>8字节</td><td>‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td></tr><tr><td><code>TIMESTAMP</code></td><td>存储日期和时间，自动记录插入&#x2F;更新时的时间</td><td>4字节</td><td>‘1970-01-01 00:00:01’ 到 ‘2038-01-19 03:14:07’</td></tr><tr><td><code>YEAR</code></td><td>存储年份（四位数）</td><td>1字节</td><td>1901 到 2155</td></tr></tbody></table><p><strong>字符串类型</strong></p><table><thead><tr><th>类型</th><th>描述</th><th>存储大小</th><th>取值范围</th></tr></thead><tbody><tr><td><code>CHAR(n)</code></td><td>固定长度字符串</td><td>n 字节（固定长度）</td><td>存储 n 个字符（最大 255）</td></tr><tr><td><code>VARCHAR(n)</code></td><td>可变长度字符串</td><td>n 字节（实际长度）</td><td>存储 n 个字符（最大 65,535）</td></tr><tr><td><code>TEXT</code></td><td>长文本（适用于较大的文本数据）</td><td>2 字节 + 数据长度</td><td>最大 65,535 个字符</td></tr><tr><td><code>TINYTEXT</code></td><td>极小文本（适用于较小的文本数据）</td><td>1 字节 + 数据长度</td><td>最大 255 个字符</td></tr><tr><td><code>MEDIUMTEXT</code></td><td>中等大小文本</td><td>3 字节 + 数据长度</td><td>最大 16,777,215 个字符</td></tr><tr><td><code>LONGTEXT</code></td><td>超大文本</td><td>4 字节 + 数据长度</td><td>最大 4,294,967,295 个字符</td></tr><tr><td><code>BLOB</code></td><td>二进制大对象（用于存储二进制数据，如图片）</td><td>2 字节 + 数据长度</td><td>最大 65,535 字节（与 TEXT 类似）</td></tr><tr><td><code>TINYBLOB</code></td><td>极小二进制对象</td><td>1 字节 + 数据长度</td><td>最大 255 字节</td></tr><tr><td><code>MEDIUMBLOB</code></td><td>中等大小二进制对象</td><td>3 字节 + 数据长度</td><td>最大 16,777,215 字节</td></tr><tr><td><code>LONGBLOB</code></td><td>超大二进制对象</td><td>4 字节 + 数据长度</td><td>最大 4,294,967,295 字节</td></tr></tbody></table><h4 id="E-表结构-查询修改删除"><a href="#E-表结构-查询修改删除" class="headerlink" title="E. 表结构-查询修改删除"></a>E. 表结构-查询修改删除</h4><p>一般都是用图形化页面工具<br><strong>查询</strong></p><ul><li>查询当前数据库所有表:<code>show tables;</code></li><li>查询表结构:<code>desc 表名;</code></li><li>查询建表语句:<code>show create table 表名;</code></li></ul><p><strong>修改</strong></p><ul><li>添加字段:<code>alter table 表名 add 字段名 类型(长度)[comment 注释][约束];</code></li><li>修改字段类型:<code>alter table 表名 modify 字段名 新数据类型(长度);</code></li><li>修改字段名和字段类型:<code>alter table 表名 change 旧字段名 新字段名 类型(长度)[comment注释][约束];</code></li><li>删除字段:<code>alter table 表名 drop column 字段名;</code></li><li>修改表名:<code>rename table 表名 to 新表名;</code></li></ul><p><strong>删除</strong><br>    <code>drop table [if exists] 表名;</code></p><h2 id="3-DML语句"><a href="#3-DML语句" class="headerlink" title="3. DML语句"></a>3. DML语句</h2><p>数据操作语言，用来对数据库中表的数据记录进行增删改操作<br>添加<code>INSERT</code>,修改<code>UPDATE</code>,删除<code>DELETE</code></p><h4 id="A-添加-INSERT"><a href="#A-添加-INSERT" class="headerlink" title="A. 添加-INSERT"></a>A. 添加-INSERT</h4><ul><li>指定字段添加数据:<code>insert into 表名(字段名1,字段名2)values(值1,值2);</code></li><li>全部字段添加数据:<code>insert into 表名 values(值1,值2,…);</code></li><li>批量添加数据(指定字段):<code>insert into 表名(字段名1,字段名2)values(值1,值2),(值1,值2);</code></li><li>批量添加数据(全部字段):<code>insert into 表名 values(值1,值2,…),(值1,值2, …. );</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向tb_emp表的username、name、gender字段插入数据</span><br><span class="hljs-keyword">insert into</span> tb_emp(username, name, gender, create_time, update_time) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;wuji&#x27;</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">1</span>, now(), now());<br><br><span class="hljs-comment">-- 向tb_emp表的所有字段插入数据</span><br><span class="hljs-keyword">insert into</span> tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time)<span class="hljs-keyword">values</span> (<span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;zhirou&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;1.jpg&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2010-01-01&#x27;</span>, now(), now());<br><br><span class="hljs-comment">--批量向tb_emp表的username、name、gender字段插入数据</span><br><span class="hljs-keyword">insert into</span> tb_emp(username, name, gender, create_time, update_time)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;weifuwang&#x27;</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">1</span>, now(), now()),<br>       (<span class="hljs-string">&#x27;fengzi&#x27;</span>, <span class="hljs-string">&#x27;张三疯&#x27;</span>, <span class="hljs-number">1</span>, now(), now());<br></code></pre></td></tr></table></figure><h4 id="B-修改-UPDATE"><a href="#B-修改-UPDATE" class="headerlink" title="B. 修改-UPDATE"></a>B. 修改-UPDATE</h4><p>语法：<code>update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件];</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 将tb_emp表中id为1的员工，姓名name字段更新为’张三’</span><br><span class="hljs-keyword">update</span> tb_emp <span class="hljs-keyword">set</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;张三&#x27;</span>,update_time<span class="hljs-operator">=</span>now() <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 将tb_emp表的所有员工入职日期更新为’2010-01-01’</span><br><span class="hljs-keyword">update</span> tb_emp <span class="hljs-keyword">set</span> entrydate<span class="hljs-operator">=</span><span class="hljs-string">&#x27;2010-01-01&#x27;</span>,update_time<span class="hljs-operator">=</span>now();<br></code></pre></td></tr></table></figure><ul><li>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</li></ul><h4 id="C-删除-DELETE"><a href="#C-删除-DELETE" class="headerlink" title="C. 删除-DELETE"></a>C. 删除-DELETE</h4><p>语法：<code>delete from 表名  [where  条件];</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除tb_emp表中id为1的员工</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 删除tb_emp表中所有员工 </span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_emp;<br></code></pre></td></tr></table></figure><h2 id="4-DQL语句"><a href="#4-DQL语句" class="headerlink" title="4. DQL语句"></a>4. DQL语句</h2><p>数据查询语言，用于查询数据库表中的记录</p><h4 id="A-语法"><a href="#A-语法" class="headerlink" title="A. 语法"></a>A. 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>字段列表<br><span class="hljs-keyword">FROM</span><br>表名列表<br><span class="hljs-keyword">WHERE</span><br>条件列表<br><span class="hljs-keyword">GROUP</span>  <span class="hljs-keyword">BY</span><br>分组字段列表<br><span class="hljs-keyword">HAVING</span><br>分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h4 id="B-基本查询"><a href="#B-基本查询" class="headerlink" title="B. 基本查询"></a>B. 基本查询</h4><ul><li>查询多个字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, 字段<span class="hljs-number">3</span> <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><ul><li>查询所有字段（通配符）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>设置别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span> [ <span class="hljs-keyword">as</span> 别名<span class="hljs-number">1</span> ] , 字段<span class="hljs-number">2</span> [ <span class="hljs-keyword">as</span> 别名<span class="hljs-number">2</span> ]  <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><ul><li>去除重复记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> 字段列表 <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询指定字段 name，entrydate并返回</span><br><span class="hljs-keyword">select</span> name,entrydate <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 查询返回所有字段</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 查询所有员工的 name,entrydate，并起别名(姓名、入职日期)</span><br><span class="hljs-comment">-- 方式1：</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">AS</span> 姓名, entrydate <span class="hljs-keyword">AS</span> 入职日期 <span class="hljs-keyword">from</span> tb_emp;<br><span class="hljs-comment">-- 方式2： 别名中有特殊字符时，使用&#x27;&#x27;或&quot;&quot;包含</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;姓 名&#x27;</span>, entrydate <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;入职日期&#x27;</span> <span class="hljs-keyword">from</span> tb_emp;<br><span class="hljs-comment">-- 方式3：</span><br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">AS</span> &quot;姓名&quot;, entrydate <span class="hljs-keyword">AS</span> &quot;入职日期&quot; <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 查询已有的员工关联了哪几种职位(不要重复)</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> job <span class="hljs-keyword">from</span> tb_emp;<br></code></pre></td></tr></table></figure><h4 id="C-条件查询"><a href="#C-条件查询" class="headerlink" title="C. 条件查询"></a>C. 条件查询</h4><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表 <span class="hljs-keyword">from</span>  表名  <span class="hljs-keyword">where</span>  条件列表 ; <span class="hljs-comment">-- 条件列表：意味着可以有多个条件</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td>between … and …</td><td>在某个范围之内(含最小、最大值)</td></tr><tr><td>in(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like 占位符</td><td>模糊匹配(_匹配单个字符, %匹配任意个字符)</td></tr><tr><td>is null</td><td>是null</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>and 或 &amp;&amp;</td><td>并且 (多个条件同时成立)</td></tr><tr><td>or 或</td><td>或者 (多个条件任意一个成立)</td></tr><tr><td>not 或 !</td><td>非 , 不是</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询 姓名 为 杨逍 的员工</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;杨逍&#x27;</span>;<br><br><span class="hljs-comment">-- 查询 id小于等于5 的员工信息</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;=</span><span class="hljs-number">5</span>;<br><br><span class="hljs-comment">-- 查询 没有分配职位 的员工信息</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> job <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> ;<br><br><span class="hljs-comment">-- 查询 密码不等于 ‘123456’ 的员工信息</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> password <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><br><span class="hljs-comment">-- 查询 入职日期 在 ‘2000-01-01’ (包含) 到 ‘2010-01-01’(包含) 之间的员工信息</span><br><span class="hljs-comment">-- 方式1：</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> entrydate<span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;2000-01-01&#x27;</span> <span class="hljs-keyword">and</span> entrydate<span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;2010-01-01&#x27;</span>;<br><span class="hljs-comment">-- 方式2： between...and</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> entrydate <span class="hljs-keyword">between</span> <span class="hljs-string">&#x27;2000-01-01&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;2010-01-01&#x27;</span>;<br><br><span class="hljs-comment">-- 查询 职位是2 (讲师), 3 (学工主管), 4 (教研主管)的员工信息</span><br><span class="hljs-comment">-- 方式1：使用or连接多个条件</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> job<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">or</span> job<span class="hljs-operator">=</span><span class="hljs-number">3</span> <span class="hljs-keyword">or</span> job<span class="hljs-operator">=</span><span class="hljs-number">4</span>;<br><span class="hljs-comment">-- 方式2：in关键字</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> job <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">-- 查询姓名为两个字的员工信息</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__&#x27;</span>;  <span class="hljs-comment">-- 通配符 &quot;_&quot; 代表任意1个字符</span><br><br><span class="hljs-comment">-- 查询姓‘张’的员工信息</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;张%&#x27;</span>;  <span class="hljs-comment">-- 通配符 &quot;%&quot; 代表任意个字符（0个 ~ 多个）</span><br></code></pre></td></tr></table></figure><h4 id="D-聚合函数"><a href="#D-聚合函数" class="headerlink" title="D. 聚合函数"></a>D. 聚合函数</h4><p>之前我们做的查询都是横向查询，就是根据条件一行一行的进行判断，而使用聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  聚合函数(字段列表)  <span class="hljs-keyword">from</span>  表名 ;<br></code></pre></td></tr></table></figure><table><thead><tr><th>聚合函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量，按照列去统计有多少行的数据</td></tr><tr><td>max</td><td>最大值，计算指定列的最大值</td></tr><tr><td>min</td><td>最小值，计算指定列的最小值</td></tr><tr><td>avg</td><td>平均值，计算指定列的平均值</td></tr><tr><td>sum</td><td>求和，计算指定列的数值和，如果不是数值类型，那么计算结果为0</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 统计该企业员工数量</span><br><span class="hljs-comment">-- count(字段)</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">from</span> tb_emp;<span class="hljs-comment">-- 结果：29</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(job) <span class="hljs-keyword">from</span> tb_emp;<span class="hljs-comment">-- 结果：28 （聚合函数对NULL值不做计算）</span><br><span class="hljs-comment">-- count(常量)</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">from</span> tb_emp;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">from</span> tb_emp;<br><span class="hljs-comment">-- count(*)  推荐此写法（MySQL底层进行了优化）</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 统计该企业最早入职的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(entrydate) <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 统计该企业最迟入职的员工</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">max</span>(entrydate) <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 统计该企业员工 ID 的平均值</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(id) <span class="hljs-keyword">from</span> tb_emp;<br><br><span class="hljs-comment">-- 统计该企业员工的 ID 之和</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(id) <span class="hljs-keyword">from</span> tb_emp;<br></code></pre></td></tr></table></figure><h4 id="E-分组查询"><a href="#E-分组查询" class="headerlink" title="E. 分组查询"></a>E. 分组查询</h4><ul><li>分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。</li><li>分组查询通常会使用聚合函数进行计算。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <span class="hljs-keyword">from</span>  表名  [<span class="hljs-keyword">where</span> 条件]  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组字段名  [<span class="hljs-keyword">having</span> 分组后过滤条件];<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据性别分组 , 统计男性和女性员工的数量</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender; <span class="hljs-comment">-- 按照gender字段进行分组（gender字段下相同的数据归为一组）</span><br><br><span class="hljs-comment">-- 查询入职时间在 ‘2015-01-01’ (包含) 以前的员工 , 并对结果根据职位分组 , 获取员工数量大于等于2的职位</span><br><span class="hljs-keyword">select</span> job, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&lt;=</span> <span class="hljs-string">&#x27;2015-01-01&#x27;</span>   <span class="hljs-comment">-- 分组前条件</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job                      <span class="hljs-comment">-- 按照job字段分组</span><br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>;             <span class="hljs-comment">-- 分组后条件</span><br></code></pre></td></tr></table></figure><ul><li>where与having区别（面试题）<ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li><li>执行顺序：where &gt; 聚合函数 &gt; having</li></ul></li></ul><h4 id="F-排序查询"><a href="#F-排序查询" class="headerlink" title="F. 排序查询"></a>F. 排序查询</h4><p>有升序排序，也有降序排序。<br>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <br><span class="hljs-keyword">from</span>   表名   <br>[<span class="hljs-keyword">where</span>  条件列表] <br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>  分组字段] <br><span class="hljs-keyword">order</span>  <span class="hljs-keyword">by</span>  字段<span class="hljs-number">1</span>  排序方式<span class="hljs-number">1</span> , 字段<span class="hljs-number">2</span>  排序方式<span class="hljs-number">2</span> … ;<br></code></pre></td></tr></table></figure><p>排序方式：</p><ul><li>ASC ：升序（默认值）</li><li>DESC：降序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 根据入职时间对公司的员工进行升序排序，入职时间相同，再按照更新时间进行降序排序</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> entrydate <span class="hljs-keyword">ASC</span> , update_time <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h4 id="G-分页查询"><a href="#G-分页查询" class="headerlink" title="G. 分页查询"></a>G. 分页查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表  <span class="hljs-keyword">from</span>   表名  limit  起始索引, 查询记录数 ;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 从起始索引0开始查询员工数据, 每页展示5条记录</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br>limit <span class="hljs-number">0</span> , <span class="hljs-number">5</span>; <span class="hljs-comment">-- 从索引0开始，向后取5条记录</span><br><br><span class="hljs-comment">-- 查询 第3页 员工数据, 每页展示5条记录</span><br><span class="hljs-keyword">select</span> id, username, password, name, gender, image, job, entrydate, create_time, update_time<br><span class="hljs-keyword">from</span> tb_emp<br>limit <span class="hljs-number">10</span> , <span class="hljs-number">5</span>; <span class="hljs-comment">-- 从索引10开始，向后取5条记录</span><br></code></pre></td></tr></table></figure><ul><li>注意事项:<br>  起始索引从0开始。 计算公式 ： 起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数</li></ul><h2 id="5-多表设计"><a href="#5-多表设计" class="headerlink" title="5. 多表设计"></a>5. 多表设计</h2><p>一对多(多对一)，多对多，一对一</p><h4 id="A-一对多"><a href="#A-一对多" class="headerlink" title="A. 一对多"></a>A. 一对多</h4><h5 id="1-设计多表"><a href="#1-设计多表" class="headerlink" title="1. 设计多表"></a>1. 设计多表</h5><p>创建部门表和员工表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database db03;<br>use db03;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">create table</span> tb_dept<br>(<br>    id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary key</span> auto_increment comment <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not null</span> <span class="hljs-keyword">unique</span>  comment <span class="hljs-string">&#x27;部门名称&#x27;</span>,<br>    create_time datetime <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    update_time datetime <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;修改时间&#x27;</span><br>) comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><br><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">create table</span> tb_emp<br>(<br>    id          <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary key</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>,<br>    username    <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)      <span class="hljs-keyword">not null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>    password    <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;123456&#x27;</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>    name        <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)      <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    gender      tinyint unsigned <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;性别, 说明: 1 男, 2 女&#x27;</span>,<br>    image       <span class="hljs-type">varchar</span>(<span class="hljs-number">300</span>) comment <span class="hljs-string">&#x27;图像&#x27;</span>,<br>    job         tinyint unsigned comment <span class="hljs-string">&#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管&#x27;</span>,<br>    entrydate   <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>    dept_id     <span class="hljs-type">int</span> unsigned comment <span class="hljs-string">&#x27;部门ID&#x27;</span>, <span class="hljs-comment">-- 员工的归属部门</span><br>    create_time datetime         <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>    update_time datetime         <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;修改时间&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。</li></ul><h5 id="2-外键约束"><a href="#2-外键约束" class="headerlink" title="2. 外键约束"></a>2. 外键约束</h5><ul><li>让两张表的数据建立连接，<strong>保证数据的一致性和完整性</strong>。</li><li>对应的关键字：<code>foreign key</code></li></ul><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时指定</span><br><span class="hljs-keyword">create table</span> 表名(<br>字段名    数据类型,<br>...<br>[<span class="hljs-keyword">constraint</span>]   [外键名称]  <span class="hljs-keyword">foreign  key</span> (外键字段名)   <span class="hljs-keyword">references</span>   主表 (主表列名)<br>);<br><br><span class="hljs-comment">-- 建完表后，添加外键</span><br><span class="hljs-keyword">alter table</span>  表名  <span class="hljs-keyword">add constraint</span>  外键名称  <span class="hljs-keyword">foreign key</span>(外键字段名) <span class="hljs-keyword">references</span> 主表(主表列名);<br></code></pre></td></tr></table></figure><p>通过SQL语句操作，为员工表的dept_id 建立外键约束，来关联部门表的主键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改表： 添加外键约束</span><br><span class="hljs-keyword">alter table</span> tb_emp  <br><span class="hljs-keyword">add  constraint</span>  fk_dept_id  <span class="hljs-keyword">foreign key</span> (dept_id)  <span class="hljs-keyword">references</span>  tb_dept(id);<br></code></pre></td></tr></table></figure><h5 id="3-物理外键和逻辑外键"><a href="#3-物理外键和逻辑外键" class="headerlink" title="3. 物理外键和逻辑外键"></a>3. 物理外键和逻辑外键</h5><p>物理外键概念：使用foreign key定义外键关联另外一张表。<br>缺点：</p><ul><li>影响增、删、改的效率（需要检查外键关系）。</li><li>仅用于单节点数据库，不适用与分布式、集群场景。</li><li>容易引发数据库的死锁问题，消耗性能。</li></ul><p>逻辑外键概念：在业务层逻辑中，解决外键关联。</p><ul><li>通过逻辑外键，就可以很方便的解决上述问题。</li></ul><p><strong>在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key</strong></p><h4 id="B-一对一"><a href="#B-一对一" class="headerlink" title="B. 一对一"></a>B. 一对一</h4><p>在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><ul><li>一对一的应用场景： 用户表(基本信息+身份信息)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 用户基本信息表</span><br><span class="hljs-keyword">create table</span> tb_user(<br>    id <span class="hljs-type">int</span> unsigned  <span class="hljs-keyword">primary key</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    gender tinyint unsigned <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;性别, 1 男  2 女&#x27;</span>,<br>    phone <span class="hljs-type">char</span>(<span class="hljs-number">11</span>) comment <span class="hljs-string">&#x27;手机号&#x27;</span>,<br>    degree <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;学历&#x27;</span><br>) comment <span class="hljs-string">&#x27;用户基本信息表&#x27;</span>;<br><br><br><span class="hljs-comment">-- 用户身份信息表</span><br><span class="hljs-keyword">create table</span> tb_user_card(<br>    id <span class="hljs-type">int</span> unsigned  <span class="hljs-keyword">primary key</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>,<br>    nationality <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;民族&#x27;</span>,<br>    birthday <span class="hljs-type">date</span> <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;生日&#x27;</span>,<br>    idcard <span class="hljs-type">char</span>(<span class="hljs-number">18</span>) <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>    issued <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;签发机关&#x27;</span>,<br>    expire_begin <span class="hljs-type">date</span> <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;有效期限-开始&#x27;</span>,<br>    expire_end <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;有效期限-结束&#x27;</span>,<br>    user_id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">not null</span> <span class="hljs-keyword">unique</span> comment <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br>    <span class="hljs-keyword">constraint</span> fk_user_id <span class="hljs-keyword">foreign key</span> (user_id) <span class="hljs-keyword">references</span> tb_user(id)<br>) comment <span class="hljs-string">&#x27;用户身份信息表&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="C-多对多"><a href="#C-多对多" class="headerlink" title="C. 多对多"></a>C. 多对多</h4><ul><li>学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。</li><li>学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。</li></ul><p><img src="/img/blogs/java/javaweb/4.5.1.png"></p><ul><li>中间表包含两个外键，分别关联两方主键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 学生表</span><br><span class="hljs-keyword">create table</span> tb_student(<br>    id <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">primary key</span> comment <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    <span class="hljs-keyword">no</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;学号&#x27;</span><br>) comment <span class="hljs-string">&#x27;学生表&#x27;</span>;<br><br><br><span class="hljs-comment">-- 课程表</span><br><span class="hljs-keyword">create table</span> tb_course(<br>   id <span class="hljs-type">int</span> auto_increment <span class="hljs-keyword">primary key</span> comment <span class="hljs-string">&#x27;主键ID&#x27;</span>,<br>   name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;课程名称&#x27;</span><br>) comment <span class="hljs-string">&#x27;课程表&#x27;</span>;<br><br><br><span class="hljs-comment">-- 学生课程表（中间表）</span><br><span class="hljs-keyword">create table</span> tb_student_course(<br>   id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;主键&#x27;</span> <span class="hljs-keyword">primary key</span>,<br>   student_id <span class="hljs-type">int</span> <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;学生ID&#x27;</span>,<br>   course_id  <span class="hljs-type">int</span> <span class="hljs-keyword">not null</span> comment <span class="hljs-string">&#x27;课程ID&#x27;</span>,<br>   <span class="hljs-keyword">constraint</span> fk_courseid <span class="hljs-keyword">foreign key</span> (course_id) <span class="hljs-keyword">references</span> tb_course (id),<br>   <span class="hljs-keyword">constraint</span> fk_studentid <span class="hljs-keyword">foreign key</span> (student_id) <span class="hljs-keyword">references</span> tb_student (id)<br>)comment <span class="hljs-string">&#x27;学生课程中间表&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="6-多表查询"><a href="#6-多表查询" class="headerlink" title="6. 多表查询"></a>6. 多表查询</h2><p>指从多张表中查询数据</p><h4 id="A-笛卡尔积"><a href="#A-笛卡尔积" class="headerlink" title="A. 笛卡尔积"></a>A. 笛卡尔积</h4><ul><li><p>笛卡尔乘积是指在数学中，两个集合(A集合和B集合)的所有组合情况。<br><img src="/img/blogs/java/javaweb/4.6.1.png"></p></li><li><p>在多表查询时，需要消除无效的笛卡尔积，只<strong>保留表关联部分的数据</strong></p></li></ul><h4 id="B-内连接查询"><a href="#B-内连接查询" class="headerlink" title="B. 内连接查询"></a>B. 内连接查询</h4><p>查询两表或多表中交集部分数据,分为<code>隐式内连接</code>和<code>显式内连接</code></p><ul><li>隐式内连接语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span>   <span class="hljs-keyword">where</span>  条件 ... ;<br></code></pre></td></tr></table></figure><ul><li>显式内连接语法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span>  [ <span class="hljs-keyword">inner</span> ]  <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span>  连接条件 ... ;<br></code></pre></td></tr></table></figure><p>查询员工的姓名及所属的部门名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 隐式内连接实现</span><br><span class="hljs-keyword">select</span> tb_emp.name , tb_dept.name <span class="hljs-comment">-- 分别查询两张表中的数据</span><br><span class="hljs-keyword">from</span> tb_emp , tb_dept <span class="hljs-comment">-- 关联两张表</span><br><span class="hljs-keyword">where</span> tb_emp.dept_id <span class="hljs-operator">=</span> tb_dept.id; <span class="hljs-comment">-- 消除笛卡尔积</span><br><br><span class="hljs-comment">-- 显式内连接实现</span><br><span class="hljs-keyword">select</span> tb_emp.name , tb_dept.name<br><span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> tb_dept<br><span class="hljs-keyword">on</span> tb_emp.dept_id <span class="hljs-operator">=</span> tb_dept.id;<br></code></pre></td></tr></table></figure><h4 id="C-多表查询时给表起别名"><a href="#C-多表查询时给表起别名" class="headerlink" title="C. 多表查询时给表起别名"></a>C. 多表查询时给表起别名</h4><p><code>tableA as 别名1 , tableB as 别名2 ;</code><br><code>tableA 别名1 , tableB 别名2 ;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.name , dept.name<br><span class="hljs-keyword">from</span> tb_emp emp <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> tb_dept dept<br><span class="hljs-keyword">on</span> emp.dept_id <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure><h4 id="D-外连接查询"><a href="#D-外连接查询" class="headerlink" title="D. 外连接查询"></a>D. 外连接查询</h4><p>外连接分为两种：<code>左外连接</code> 和 <code>右外连接</code></p><ul><li>左外连接相当于查询表1(左表)的所有数据,包含表1和表2交集部分</li><li>右外连接相当于查询表2(右表)的所有数据,包含表1和表2交集部分</li></ul><p><strong>左外连接语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span>  <span class="hljs-keyword">left</span>  [ <span class="hljs-keyword">outer</span> ]  <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span>  连接条件 ... ;<br></code></pre></td></tr></table></figure><p><strong>右外连接语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  字段列表   <span class="hljs-keyword">from</span>   表<span class="hljs-number">1</span>  <span class="hljs-keyword">right</span>  [ <span class="hljs-keyword">outer</span> ]  <span class="hljs-keyword">join</span> 表<span class="hljs-number">2</span>  <span class="hljs-keyword">on</span>  连接条件 ... ;<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询员工表中所有员工的姓名, 和对应的部门名称</span><br><span class="hljs-comment">-- 左外连接：以left join关键字左边的表为主表，查询主表中所有数据，以及和主表匹配的右边表中的数据</span><br><span class="hljs-keyword">select</span> emp.name , dept.name<br><span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">AS</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tb_dept <span class="hljs-keyword">AS</span> dept <br>     <span class="hljs-keyword">on</span> emp.dept_id <span class="hljs-operator">=</span> dept.id;<br><br><br><span class="hljs-comment">-- 查询部门表中所有部门的名称, 和对应的员工名称</span><br><span class="hljs-comment">-- 右外连接</span><br><span class="hljs-keyword">select</span> dept.name , emp.name<br><span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">AS</span> emp <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span>  tb_dept <span class="hljs-keyword">AS</span> dept<br>     <span class="hljs-keyword">on</span> emp.dept_id <span class="hljs-operator">=</span> dept.id;<br></code></pre></td></tr></table></figure><h4 id="E-子查询-嵌套查询"><a href="#E-子查询-嵌套查询" class="headerlink" title="E. 子查询(嵌套查询)"></a>E. 子查询(嵌套查询)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  <span class="hljs-operator">*</span>  <span class="hljs-keyword">FROM</span>   t1   <span class="hljs-keyword">WHERE</span>  column1 <span class="hljs-operator">=</span>  (<span class="hljs-keyword">SELECT</span>  column1  <span class="hljs-keyword">FROM</span>  t2 ... );<br></code></pre></td></tr></table></figure><p>分为</p><ol><li>标量子查询（子查询结果为单个值[一行一列]）</li><li>列子查询（子查询结果为一列，但可以是多行）</li><li>行子查询（子查询结果为一行，但可以是多列）</li><li>表子查询（子查询结果为多行多列[相当于子查询结果是一张表]）</li></ol><ul><li>子查询可以书写的位置：<code>where之后</code>,<code>from之后</code>,<code>select之后</code></li></ul><h5 id="1-标量子查询"><a href="#1-标量子查询" class="headerlink" title="1. 标量子查询"></a>1. 标量子查询</h5><p>子查询返回的结果是单个值(数字、字符串、日期等)</p><ul><li>查询”教研部”的所有员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.查询&quot;教研部&quot;部门ID</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;教研部&#x27;</span>;    <span class="hljs-comment">--查询结果：2</span><br><span class="hljs-comment">-- 2.根据&quot;教研部&quot;部门ID, 查询员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">-- 合并出上两条SQL语句</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;教研部&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-列子查询"><a href="#2-列子查询" class="headerlink" title="2. 列子查询"></a>2. 列子查询</h5><p>子查询返回的结果是一列(可以是多行)</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr></tbody></table><ul><li>查询”教研部”和”咨询部”的所有员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.查询&quot;销售部&quot;和&quot;市场部&quot;的部门ID</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;教研部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;咨询部&#x27;</span>;    <span class="hljs-comment">-- 查询结果：3,2</span><br><span class="hljs-comment">-- 2.根据部门ID, 查询员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">-- 合并以上两条SQL语句</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;教研部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;咨询部&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-行子查询"><a href="#3-行子查询" class="headerlink" title="3. 行子查询"></a>3. 行子查询</h5><p>子查询返回的结果是一行(可以是多行)<br>常用的操作符：<code>= 、&lt;&gt; 、IN 、NOT IN</code></p><ul><li>查询与”韦一笑”的入职日期及职位都相同的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询&quot;韦一笑&quot;的入职日期 及 职位</span><br><span class="hljs-keyword">select</span> entrydate , job <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;韦一笑&#x27;</span>;  <span class="hljs-comment">-- 查询结果： 2007-01-01 , 2</span><br><span class="hljs-comment">-- 查询与&quot;韦一笑&quot;的入职日期及职位相同的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> (entrydate,job) <span class="hljs-operator">=</span> (<span class="hljs-string">&#x27;2007-01-01&#x27;</span>,<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">-- 合并以上两条SQL语句</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> (entrydate,job) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> entrydate , job <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;韦一笑&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="4-表子查询"><a href="#4-表子查询" class="headerlink" title="4. 表子查询"></a>4. 表子查询</h5><p>子查询返回的结果是多行多列，常作为临时表</p><ul><li>查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>;<br><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id ;<br></code></pre></td></tr></table></figure><h2 id="7-事务"><a href="#7-事务" class="headerlink" title="7. 事务"></a>7. 事务</h2><h4 id="A-事务的介绍"><a href="#A-事务的介绍" class="headerlink" title="A. 事务的介绍"></a>A. 事务的介绍</h4><p>事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><ul><li>事务作用：保证<code>在一个事务中多次操作数据库表中数据时</code>，<code>要么全都成功,要么全都失败</code>。</li></ul><h4 id="B-事务的操作"><a href="#B-事务的操作" class="headerlink" title="B. 事务的操作"></a>B. 事务的操作</h4><table><thead><tr><th>SQL语句</th><th>描述</th></tr></thead><tbody><tr><td>start transaction; &#x2F; begin ;</td><td>开启手动控制事务</td></tr><tr><td>commit;</td><td>提交事务</td></tr><tr><td>rollback;</td><td>回滚事务</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">start</span> transaction ;<br><br><span class="hljs-comment">-- 删除学工部</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_dept <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 删除学工部的员工</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 提交事务 (成功时执行)</span><br><span class="hljs-keyword">commit</span> ;<br><br><span class="hljs-comment">-- 回滚事务 (出错时执行)</span><br><span class="hljs-keyword">rollback</span> ;<br></code></pre></td></tr></table></figure><h4 id="C-事务的四大特性-ACID"><a href="#C-事务的四大特性-ACID" class="headerlink" title="C. 事务的四大特性(ACID)"></a>C. 事务的四大特性(ACID)</h4><ul><li>原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="8-索引"><a href="#8-索引" class="headerlink" title="8. 索引"></a>8. 索引</h2><h4 id="A-索引的介绍"><a href="#A-索引的介绍" class="headerlink" title="A. 索引的介绍"></a>A. 索引的介绍</h4><p>索引是帮助数据库<code>高效获取数据</code>的<code>数据结构</code>,使用索引可以<code>提高查询的效率</code></p><p>优点：</p><ul><li><code>提高数据查询的效率</code>，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。</li></ul><p>缺点：</p><ul><li>索引会<code>占用存储空间</code>。</li><li>索引大大提高了查询效率，同时却也<code>降低了insert、update、delete的效率</code>。</li></ul><h4 id="B-索引的数据结构"><a href="#B-索引的数据结构" class="headerlink" title="B. 索引的数据结构"></a>B. 索引的数据结构</h4><p>MySQL中用<code>B+树索引</code>数据结构，B+Tree(多路平衡搜索树)</p><p><img src="/img/blogs/java/javaweb/4.8.1.png"></p><p>B+Tree结构：</p><ul><li>每一个节点，可以存储多个key（有n个key，就有n个指针）</li><li>节点分为：叶子节点、非叶子节点<ul><li>叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上</li><li>非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key+指针</li></ul></li><li>为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询</li></ul><h4 id="C-语法"><a href="#C-语法" class="headerlink" title="C. 语法"></a>C. 语法</h4><ol><li>创建索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span>  [ <span class="hljs-keyword">unique</span> ]  index 索引名 <span class="hljs-keyword">on</span>  表名 (字段名,... ) ;<br></code></pre></td></tr></table></figure><ol start="2"><li>查看索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span>  index  <span class="hljs-keyword">from</span>  表名;<br></code></pre></td></tr></table></figure><ol start="3"><li>删除索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span>  index  索引名  <span class="hljs-keyword">on</span>  表名;<br></code></pre></td></tr></table></figure><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 为tb_emp表的name字段建立一个索引</span><br><span class="hljs-keyword">create</span> index idx_emp_name <span class="hljs-keyword">on</span> tb_emp(name);<br><br><span class="hljs-comment">-- 查询 tb_emp 表的索引信息</span><br><span class="hljs-keyword">show</span>  index  <span class="hljs-keyword">from</span>  tb_emp;<br><br><span class="hljs-comment">-- 删除 tb_emp 表中name字段的索引</span><br><span class="hljs-keyword">drop</span> index idx_emp_name <span class="hljs-keyword">on</span> tb_emp;<br></code></pre></td></tr></table></figure><h1 id="五-MyBatis"><a href="#五-MyBatis" class="headerlink" title="五. MyBatis"></a>五. MyBatis</h1><h2 id="1-MyBatis简介"><a href="#1-MyBatis简介" class="headerlink" title="1. MyBatis简介"></a>1. MyBatis简介</h2><p>MyBatis就是用Java程序操作数据库<br><img src="/img/blogs/java/javaweb/5.1.1.png"></p><ol><li><strong>application.properties</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//驱动类名称</span><br>spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<br><span class="hljs-comment">//数据库连接的url</span><br>spring.datasource.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/mybatis</span><br><span class="hljs-comment">//连接数据库的用户名</span><br>spring.datasource.username=root<br><span class="hljs-comment">//连接数据库的密码</span><br>spring.datasource.password=<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Mapper接口（编写SQL语句）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select id, name, age, gender, phone from user&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-JDBC-了解"><a href="#2-JDBC-了解" class="headerlink" title="2. JDBC(了解)"></a>2. JDBC(了解)</h2><p>就是使用Java语言操作关系型数据库的一套API</p><ul><li>使用SpringBoot+Mybatis的方式操作数据库，能够提升开发效率、降低资源浪费</li></ul><h2 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3. 数据库连接池"></a>3. 数据库连接池</h2><h4 id="A-数据库连接池介绍"><a href="#A-数据库连接池介绍" class="headerlink" title="A. 数据库连接池介绍"></a>A. 数据库连接池介绍</h4><ul><li><p>数据库连接池是个<strong>容器，负责分配、管理数据库连接</strong>(Connection)</p></li><li><p>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p></li><li><p>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏<br><img src="/img/blogs/java/javaweb/5.3.1.png"></p></li><li><p>数据库连接池的好处：</p><ul><li><strong>资源重用</strong></li><li><strong>提升系统响应速度</strong></li><li>避免数据库连接遗漏</li></ul></li></ul><h4 id="B-实现数据库连接池"><a href="#B-实现数据库连接池" class="headerlink" title="B. 实现数据库连接池"></a>B. 实现数据库连接池</h4><p>官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口）<br>功能：获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br></code></pre></td></tr></table></figure><p><strong>想把默认的数据库连接池切换为Druid数据库连接池</strong></p><ol><li>在pom.xml文件中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Druid连接池依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在application.properties中引入数据库连接配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.datasource.druid.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/mybatis</span><br>spring.datasource.druid.username=root<br>spring.datasource.druid.password=<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="4-lombok工具包"><a href="#4-lombok工具包" class="headerlink" title="4. lombok工具包"></a>4. lombok工具包</h2><p>Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td>@ToString</td><td>会给类自动生成易阅读的toString方法</td></tr><tr><td>@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法</td></tr><tr><td><strong>@Data</strong></td><td>提供了更综合的生成代码功能（@Getter + @Setter + @ToString+@EqualsAndHashCode）</td></tr><tr><td><strong>@NoArgsConstructo</strong></td><td>为实体类生成无参的构造器方法</td></tr><tr><td><strong>@AllArgsConstructor</strong></td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法</td></tr></tbody></table><p>在pom.xml文件中引入依赖(lombok)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Mybatis基础操作"><a href="#5-Mybatis基础操作" class="headerlink" title="5. Mybatis基础操作"></a>5. Mybatis基础操作</h2><h4 id="A-准备"><a href="#A-准备" class="headerlink" title="A. 准备"></a>A. 准备</h4><p><a href="https://blog.csdn.net/sinat_38316216/article/details/142700670?spm=1001.2014.3001.5502">准备工作</a></p><h4 id="B-删除"><a href="#B-删除" class="headerlink" title="B. 删除"></a>B. 删除</h4><h5 id="1-功能实现"><a href="#1-功能实现" class="headerlink" title="1. 功能实现"></a>1. 功能实现</h5><p>根据主键删除数据</p><ol><li>接口方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span> <span class="hljs-comment">//使用#&#123;key&#125;方式获取方法中的参数值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在单元测试类中通过@Autowired注解注入EmpMapper类型对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisCrudApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//从Spring的IOC容器中，获取类型是EmpMapper的对象并注入</span><br>    <span class="hljs-keyword">private</span> EmpMapper empMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDel</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//调用删除方法</span><br>        empMapper.delete(<span class="hljs-number">16</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-MyBatis的日志输出"><a href="#2-MyBatis的日志输出" class="headerlink" title="2. MyBatis的日志输出"></a>2. MyBatis的日志输出</h5><ol><li>打开application.properties文件</li><li>开启mybatis的日志，并指定输出到控制台<br> <code>mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code></li></ol><h5 id="3-预编译SQL"><a href="#3-预编译SQL" class="headerlink" title="3. 预编译SQL"></a>3. 预编译SQL</h5><ul><li>性能更高</li><li>更安全(防止SQL注入)</li></ul><p>在项目开发中，建议使用<code>#{}</code>，生成预编译SQL，防止SQL注入安全。</p><h4 id="C-新增"><a href="#C-新增" class="headerlink" title="C. 新增"></a>C. 新增</h4><h5 id="1-功能实现-1"><a href="#1-功能实现-1" class="headerlink" title="1. 功能实现"></a>1. 功能实现</h5><ol><li>接口方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br><br>    <span class="hljs-meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Emp emp)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisCrudApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmpMapper empMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建员工对象</span><br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>();<br>        emp.setUsername(<span class="hljs-string">&quot;tom&quot;</span>);<br>        emp.setName(<span class="hljs-string">&quot;汤姆&quot;</span>);<br>        emp.setImage(<span class="hljs-string">&quot;1.jpg&quot;</span>);<br>        emp.setGender((<span class="hljs-type">short</span>)<span class="hljs-number">1</span>);<br>        emp.setJob((<span class="hljs-type">short</span>)<span class="hljs-number">1</span>);<br>        emp.setEntrydate(LocalDate.of(<span class="hljs-number">2000</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));<br>        emp.setCreateTime(LocalDateTime.now());<br>        emp.setUpdateTime(LocalDateTime.now());<br>        emp.setDeptId(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//调用添加方法</span><br>        empMapper.insert(emp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-主键返回"><a href="#2-主键返回" class="headerlink" title="2. 主键返回"></a>2. 主键返回</h5><p>在数据添加成功后，需要获取插入数据库数据的主键<br>如果我们想要拿到主键值，需要在Mapper接口中的方法上添加一个<code>Options注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br></code></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-comment">//会自动将生成的主键值，赋值给emp对象的id属性</span><br>    <span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Emp emp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="D-更新-修改"><a href="#D-更新-修改" class="headerlink" title="D. 更新(修改)"></a>D. 更新(修改)</h4><ol><li>接口方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id修改员工信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> emp</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Update(&quot;update emp set username=#&#123;username&#125;, name=#&#123;name&#125;, gender=#&#123;gender&#125;, image=#&#123;image&#125;, job=#&#123;job&#125;, entrydate=#&#123;entrydate&#125;, dept_id=#&#123;deptId&#125;, update_time=#&#123;updateTime&#125; where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Emp emp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>测试类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisCrudApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmpMapper empMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//要修改的员工信息</span><br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Emp</span>();<br>        emp.setId(<span class="hljs-number">23</span>);<br>        emp.setUsername(<span class="hljs-string">&quot;songdaxia&quot;</span>);<br>        emp.setPassword(<span class="hljs-literal">null</span>);<br>        emp.setName(<span class="hljs-string">&quot;老宋&quot;</span>);<br>        emp.setImage(<span class="hljs-string">&quot;2.jpg&quot;</span>);<br>        emp.setGender((<span class="hljs-type">short</span>)<span class="hljs-number">1</span>);<br>        emp.setJob((<span class="hljs-type">short</span>)<span class="hljs-number">2</span>);<br>        emp.setEntrydate(LocalDate.of(<span class="hljs-number">2012</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));<br>        emp.setCreateTime(<span class="hljs-literal">null</span>);<br>        emp.setUpdateTime(LocalDateTime.now());<br>        emp.setDeptId(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//调用方法，修改员工数据</span><br>        empMapper.update(emp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="E-查询"><a href="#E-查询" class="headerlink" title="E. 查询"></a>E. 查询</h4><h5 id="1-根据ID查询"><a href="#1-根据ID查询" class="headerlink" title="1. 根据ID查询"></a>1. 根据ID查询</h5><ol><li>接口方法：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getById</span><span class="hljs-params">(Integer id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>测试类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisCrudApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmpMapper empMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetById</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> empMapper.getById(<span class="hljs-number">1</span>);<br>        System.out.println(emp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>而在测试的过程中，我们会发现有几个字段(deptId、createTime、updateTime)是没有数据值的</li></ul><h5 id="2-数据封装"><a href="#2-数据封装" class="headerlink" title="2. 数据封装"></a>2. 数据封装</h5><ul><li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</li><li>如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。</li></ul><p><img src="/img/blogs/java/javaweb/5.5.1.png"></p><ol><li>起别名:在SQL语句中,对不一样的列名起别名,别名和实体类属性名一样。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id deptld, create_time createTime, update_time updateTime from emp where id = #&#123;id&#125; &quot;)</span><br><span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getByld</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>手动结果映射:通过@Results及@Result进行手动结果映射。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@Results(&#123;</span><br><span class="hljs-meta">    @Result(column =&quot;dept_id&quot;, property = &quot;deptld&quot;),</span><br><span class="hljs-meta">    @Result(column =&quot;create_time&quot;, property = &quot;createTime&quot;),</span><br><span class="hljs-meta">    @Result(column =&quot;update_time&quot;, property = &quot;updateTime&quot;)&#125;)</span><br><span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getByld</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>开启驼峰命名(推荐)：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在application.properties中添加：</span><br>mybatis.configuration.map-underscore-to-camel-<span class="hljs-keyword">case</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h5 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h5><p>解决SQL注入风险,使用MySQL提供的字符串拼接函数：<code>concat(&#39;%&#39; , &#39;关键字&#39; , &#39;%&#39;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from emp &quot; +</span><br><span class="hljs-meta">            &quot;where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &quot; +</span><br><span class="hljs-meta">            &quot;and gender = #&#123;gender&#125; &quot; +</span><br><span class="hljs-meta">            &quot;and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span><br><span class="hljs-meta">            &quot;order by update_time desc&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-XML映射文件"><a href="#6-XML映射文件" class="headerlink" title="6. XML映射文件"></a>6. XML映射文件</h2><p>Mybatis的开发有两种方式：</p><ol><li>注解</li><li>XML</li></ol><p>在Mybatis中使用XML映射文件方式开发，需要符合一定的规范：</p><ol><li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）</li><li>XML映射文件的namespace属性为Mapper接口全限定名一致</li><li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>              and gender = #&#123;gender&#125;<br>              and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        order by update_time desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>MybatisX</code>是一款基于IDEA的快速开发Mybatis的插件</p><h2 id="7-MyBatis动态SQL"><a href="#7-MyBatis动态SQL" class="headerlink" title="7. MyBatis动态SQL"></a>7. MyBatis动态SQL</h2><p>SQL语句会随着用户的输入或外部条件的变化而变化，我们称为：动态SQL</p><h4 id="A"><a href="#A" class="headerlink" title="A. &lt;if&gt;"></a>A. <code>&lt;if&gt;</code></h4><ul><li><code>&lt;if&gt;</code>用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL</li><li><code>&lt;where&gt;</code>:只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</li><li><code>&lt;set&gt;</code>：动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;条件表达式&quot;</span>&gt;</span><br>   //要拼接的sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>原来的SQL语句</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>              and gender = #&#123;gender&#125;<br>              and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>动态SQL语句</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- if做为where标签的子元素 --&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                 and gender = #&#123;gender&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//只有性别</span><br>    List&lt;Emp&gt; list = empMapper.list(<span class="hljs-literal">null</span>, (<span class="hljs-type">short</span>)<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">for</span>(Emp emp : list)&#123;<br>        System.out.println(emp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-foreach"><a href="#B-foreach" class="headerlink" title="B. foreach"></a>B. <code>foreach</code></h4><p>员工删除功能（既支持删除单条记录，又支持批量删除）<br>使用<code>&lt;foreach&gt;</code>遍历deleteByIds方法中传递的参数ids集合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;集合名称&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;集合遍历出来的元素/项&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;每一次遍历使用的分隔符&quot;</span> </span><br><span class="hljs-tag">         <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;遍历开始前拼接的片段&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>    delete from emp where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="C-sql-include"><a href="#C-sql-include" class="headerlink" title="C. sql&amp;include"></a>C. <code>sql&amp;include</code></h4><p>我们可以<code>对重复的代码片段进行抽取</code>，将其通过<code>&lt;sql&gt;</code>标签封装到一个SQL片段，然后再通过<code>&lt;include&gt;</code>标签进行引用。</p><ul><li><code>&lt;sql&gt;</code>：定义可重用的SQL片段</li><li><code>&lt;include&gt;</code>：通过属性refid，指定包含的SQL片段</li></ul><ol><li>SQL片段： 抽取重复的代码</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>&gt;</span><br> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>通过<code>&lt;include&gt;</code>标签在原来抽取的地方进行引用</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>            and gender = #&#123;gender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>            and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="六-事务管理"><a href="#六-事务管理" class="headerlink" title="六. 事务管理"></a>六. 事务管理</h1><h2 id="1-事务回顾"><a href="#1-事务回顾" class="headerlink" title="1. 事务回顾"></a>1. 事务回顾</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么<code>同时成功，要么同时失败</code>。</p><p>事务的操作主要有三步：</p><ol><li>开启事务（一组操作开始前，开启事务）：start transaction &#x2F; begin;</li><li>提交事务（这组操作全部成功后，提交事务）：commit ;</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;</li></ol><h2 id="2-Spring事务管理"><a href="#2-Spring事务管理" class="headerlink" title="2. Spring事务管理"></a>2. Spring事务管理</h2><p>Transactional注解<br>@Transactional作用：就是在当前这个方法执行开始之前来开启事务，<code>方法执行完毕之后提交事务</code>。如果在这个方法执行的过程当中<code>出现了异常，就会进行事务的回滚操作</code></p><p>@Transactional注解：我们一般会<code>在业务层当中来控制事务</code>，因为在业务层当中，一个业务功能可能会包含多个数据访问的操作。在业务层来控制事务，我们就可以将多个数据访问操作控制在一个事务范围内。</p><p>@Transactional注解书写位置：</p><ul><li>方法:当前方法交给spring进行事务管理</li><li>类:当前类中所有的方法都交由spring进行事务管理</li><li>接口:接口下所有的实现类当中所有的方法都交给spring 进行事务管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeptService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DeptMapper deptMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmpMapper empMapper;<br><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span>  <span class="hljs-comment">//当前方法添加了事务管理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-comment">//根据部门id删除部门信息</span><br>        deptMapper.deleteById(id);<br>        <br>        <span class="hljs-comment">//模拟：异常发生</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//删除部门下的所有员工信息</span><br>        empMapper.deleteByDeptId(id);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在application.yml配置文件中开启事务管理日志，这样就可以在控制看到和事务相关的日志信息了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#spring事务管理日志</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">org.springframework.jdbc.support.JdbcTransactionManager:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h2 id="3-rollbackFor-异常回滚"><a href="#3-rollbackFor-异常回滚" class="headerlink" title="3. rollbackFor(异常回滚)"></a>3. rollbackFor(异常回滚)</h2><p>在Spring的事务管理中，默认只有<code>运行时异常 RuntimeException</code>才会回滚。如果还需要回滚指定类型的异常，可以通过<code>rollbackFor</code>属性来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeptService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DeptMapper deptMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmpMapper empMapper;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor=Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>&#123;<br>        <span class="hljs-comment">//根据部门id删除部门信息</span><br>        deptMapper.deleteById(id);<br>        <span class="hljs-comment">//模拟：异常发生</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> id/<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//删除部门下的所有员工信息</span><br>        empMapper.deleteByDeptId(id);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-propagation"><a href="#4-propagation" class="headerlink" title="4. propagation"></a>4. propagation</h2><h4 id="A-事务传播行为"><a href="#A-事务传播行为" class="headerlink" title="A. 事务传播行为"></a>A. 事务传播行为</h4><p>就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。<br>例如：两个事务方法，一个A方法，一个B方法。在这两个方法上都添加了@Transactional注解，就代表这两个方法都具有事务，而在A方法当中又去调用了B方法。<br><img src="/img/blogs/java/javaweb/6.4.1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span> (propagation = Propagation.REQUIRED<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span> <span class="hljs-params">()</span> &#123;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>常用属性值</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED</td><td>【默认值】需要事务，有则加入，无则创建新事务</td></tr><tr><td>REQUIRES_NEW</td><td>需要新事务，无论有无，总是创建新事务</td></tr></tbody></table><ul><li>REQUIRED ：大部分情况下都是用该传播行为即</li><li>REQUIRES_NEW ：当我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</li></ul><h1 id="七-AOP"><a href="#七-AOP" class="headerlink" title="七. AOP"></a>七. AOP</h1><h2 id="1-AOP基础"><a href="#1-AOP基础" class="headerlink" title="1. AOP基础"></a>1. AOP基础</h2><h4 id="A-AOP介绍"><a href="#A-AOP介绍" class="headerlink" title="A. AOP介绍"></a>A. AOP介绍</h4><p>面向特定方法编程</p><ul><li><p>AOP常见的应用场景如下：</p><ul><li>记录系统的操作日志</li><li>权限控制</li><li>事务管理</li></ul></li><li><p>AOP面向切面编程的一些优势：</p><ul><li>代码无侵入：没有修改原始的业务方法，就已经对原始的业务方法进行了功能的增强或者是功能的改变</li><li>减少了重复代码</li><li>提高开发效率</li><li>维护方便</li></ul></li></ul><h4 id="B-AOP核心概念"><a href="#B-AOP核心概念" class="headerlink" title="B. AOP核心概念"></a>B. AOP核心概念</h4><ul><li>连接点:JoinPoint,可以被AOP控制的方法(暗含方法执行时的相关信息)</li><li>通知:Advice,指哪些重复的逻辑,也就是共性功能(最终体现为一个方法)</li><li>切入点:PointCut,匹配连接点的条件,通知仅会在切入点方法执行时被应用</li><li>切面:Aspect,描述通知与切入点的对应关系(通知+切入点)</li><li>目标对象:Target,通知所应用的对象</li></ul><p>Spring的AOP底层是基于动态代理技术来实现的，也就是说在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象。在代理对象当中就会对目标对象当中的原始方法进行功能的增强。</p><h2 id="2-AOP进阶"><a href="#2-AOP进阶" class="headerlink" title="2. AOP进阶"></a>2. AOP进阶</h2><h4 id="A-通知类型"><a href="#A-通知类型" class="headerlink" title="A. 通知类型"></a>A. 通知类型</h4><p>Spring中AOP的通知类型：</p><ol><li>@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li><li>@Before：前置通知，此注解标注的通知方法在目标方法前被执行</li><li>@After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</li><li>@AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</li><li>@AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect1</span> &#123;<br><br>    <span class="hljs-comment">//切入点方法（公共的切入点表达式）</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//前置通知（引用切入点）</span><br>    <span class="hljs-meta">@Before(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;before ...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-comment">//环绕通知</span><br>    <span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.info(<span class="hljs-string">&quot;around before ...&quot;</span>);<br><br>        <span class="hljs-comment">//调用目标对象的原始方法执行</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proceedingJoinPoint.proceed();<br>        <span class="hljs-comment">//原始方法在执行时：发生异常</span><br>        <span class="hljs-comment">//后续代码不在执行</span><br><br>        log.info(<span class="hljs-string">&quot;around after ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//后置通知</span><br>    <span class="hljs-meta">@After(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;after ...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//返回后通知（程序在正常执行的情况下，会执行的后置通知）</span><br>    <span class="hljs-meta">@AfterReturning(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;afterReturning ...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//异常通知（程序在出现异常的情况下，执行的后置通知）</span><br>    <span class="hljs-meta">@AfterThrowing(&quot;pt()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;afterThrowing ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-通知顺序"><a href="#B-通知顺序" class="headerlink" title="B. 通知顺序"></a>B. 通知顺序</h4><ul><li>不同的切面类当中，默认情况下通知的执行顺序是与切面类的<code>类名字母排序</code>是有关系的</li><li>可以在切面类上面加上<code>@Order注解</code>，来控制不同的切面类通知的执行顺序</li></ul><h4 id="C-切入点表达式"><a href="#C-切入点表达式" class="headerlink" title="C. 切入点表达式"></a>C. 切入点表达式</h4><p>主要用来决定项目中的哪些方法需要加入通知</p><h5 id="1-execution"><a href="#1-execution" class="headerlink" title="1. execution"></a>1. execution</h5><p>execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：<br><code>execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws 异常?)</code>（带?的可以省略）</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(JoinPoint joinPoint)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>可以使用通配符描述切入点</p><ol><li><code>*</code>：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</li><li><code>..</code> ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</li></ol><h5 id="2-annotation"><a href="#2-annotation" class="headerlink" title="2. @annotation"></a>2. @annotation</h5><p>用于匹配标识有特定注解的方法<br><code>@annotation(com.itheima.anno.Log)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;@annotation(com.itheima.anno.Log)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">()</span> &#123;<br>    log.info(<span class="hljs-string">&quot;before..&quot;</span>) ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="D-连接点"><a href="#D-连接点" class="headerlink" title="D. 连接点"></a>D. 连接点</h4><p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint类型</li><li>对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型</li></ul><h1 id="八-Springboot原理篇"><a href="#八-Springboot原理篇" class="headerlink" title="八. Springboot原理篇"></a>八. Springboot原理篇</h1><h2 id="1-配置优先级"><a href="#1-配置优先级" class="headerlink" title="1. 配置优先级"></a>1. 配置优先级</h2><p>SpringBoot项目当中支持的三类配置文件和两种配置方法：</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml</li><li>Java系统属性配置 (格式： -Dkey&#x3D;value)(-Dserver.port&#x3D;9000)</li><li>命令行参数 （格式：–key&#x3D;value）(–server.port&#x3D;10010)</li></ul><p>配置优先级排名（从高到低）：</p><ol><li>命令行参数</li><li>Java系统属性配置</li><li>properties配置文件</li><li>yml配置文件(常用)</li><li>yaml配置文件</li></ol><h2 id="2-Bean管理"><a href="#2-Bean管理" class="headerlink" title="2. Bean管理"></a>2. Bean管理</h2><h4 id="A-获取Bean"><a href="#A-获取Bean" class="headerlink" title="A. 获取Bean"></a>A. 获取Bean</h4><p>默认情况下，SpringBoot项目在启动的时候会自动的创建IOC容器(也称为Spring容器)，并且在启动的过程当中会自动的将bean对象都创建好，存放在IOC容器当中。应用程序在运行时需要依赖什么bean对象，就直接进行依赖注入就可以了。<br>而在Spring容器中提供了一些方法，可以主动从IOC容器中获取到bean对象，下面介绍3种常用方式：</p><ol><li>根据name获取bean<br> <code>Object getBean(String name)</code></li><li>根据类型获取bean<br> <code>&lt;T&gt; T getBean(Class&lt;T&gt; requiredType)</code></li><li>根据name获取bean（带类型转换）<br> <code>&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType)</code></li></ol><h4 id="B-Bean作用域"><a href="#B-Bean作用域" class="headerlink" title="B. Bean作用域"></a>B. Bean作用域</h4><ul><li>在Spring中支持五种作用域，后三种在web环境才生效：</li></ul><table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td>singleton</td><td>容器内同名称的bean只有一个实例（单例）（默认）</td></tr><tr><td>prototype</td><td>每次使用该bean时会创建新的实例（非单例）</td></tr></tbody></table><ul><li>可以借助Spring中的<code>@Scope注解</code>来进行配置作用域</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="C-第三方bean"><a href="#C-第三方bean" class="headerlink" title="C. 第三方bean"></a>C. 第三方bean</h4><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到@Bean注解。</p><ol><li>在启动类上添加@Bean标识的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringbootWebConfig2Application.class, args);<br>    &#125;<br><br>    <span class="hljs-comment">//声明第三方bean</span><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span><br>    <span class="hljs-keyword">public</span> SAXReader <span class="hljs-title function_">saxReader</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在配置类中定义@Bean标识的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类  (在配置类当中对第三方bean进行集中的配置管理)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;<br>    <span class="hljs-comment">//声明第三方bean</span><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span><br>          <span class="hljs-comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span><br>    <span class="hljs-keyword">public</span> SAXReader <span class="hljs-title function_">reader</span><span class="hljs-params">(DeptService deptService)</span>&#123;<br>        System.out.println(deptService);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-SpringBoot原理"><a href="#3-SpringBoot原理" class="headerlink" title="3. SpringBoot原理"></a>3. SpringBoot原理</h2><h4 id="A-起步依赖"><a href="#A-起步依赖" class="headerlink" title="A. 起步依赖"></a>A. 起步依赖</h4><p>原理就是maven的依赖传递</p><h4 id="B-自动配置"><a href="#B-自动配置" class="headerlink" title="B. 自动配置"></a>B. 自动配置</h4><h5 id="1-自动配置的概述"><a href="#1-自动配置的概述" class="headerlink" title="1. 自动配置的概述"></a>1. 自动配置的概述</h5><p>SpringBoot的自动配置就是当Spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><h5 id="2-自动配置的原理"><a href="#2-自动配置的原理" class="headerlink" title="2. 自动配置的原理"></a>2. 自动配置的原理</h5><p>方案一： <code>@ComponentScan组件扫描</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ComponentScan(&#123;&quot;com.itheima&quot;,&quot;com.example&quot;&#125;)</span> <span class="hljs-comment">//指定要扫描的包</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>方案二：<code>@Import导入</code>.使用@Import导入的类会被Spring加载到IOC容器中</p><ul><li>导入普通类,交给IOC管理</li><li>导入配置类</li><li>导入ImportSelector接口实现类</li><li>@EnableXxxx注解，封装@Import注解</li></ul><p><strong>@Conditional注解</strong>：</p><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。</li><li>位置：方法、类</li><li>@Conditional本身是一个父注解，派生出大量的子注解：<ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnClass(name=&quot;io.jsonwebtoken.Jwts&quot;)</span><span class="hljs-comment">//当前环境存在指定的这个类时,才声明该bean</span><br><span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123; ... &#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><span class="hljs-comment">//当不存在当前类型的bean时,才声明该bean</span><br><span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123; ... &#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnProperty(name=&quot;name&quot;,havingValue=&quot;itheima&quot;)</span><span class="hljs-comment">//配置文件中存在对应的属性和值,才注册bean到IOC容器。</span><br><span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="4-WEB后端开发总结"><a href="#4-WEB后端开发总结" class="headerlink" title="4. WEB后端开发总结"></a>4. WEB后端开发总结</h2><p><img src="/img/blogs/java/javaweb/8.4.1.png"></p><p><img src="/img/blogs/java/javaweb/8.4.2.png"></p><h1 id="九-Maven高级"><a href="#九-Maven高级" class="headerlink" title="九. Maven高级"></a>九. Maven高级</h1><h2 id="1-分模块设计与开发"><a href="#1-分模块设计与开发" class="headerlink" title="1. 分模块设计与开发"></a>1. 分模块设计与开发</h2><p>将项目按照功能拆分为若干个子模块，方便项目的管理维护、扩展，方便模块间的相互调用、资源共享</p><h2 id="2-继承与聚合"><a href="#2-继承与聚合" class="headerlink" title="2. 继承与聚合"></a>2. 继承与聚合</h2><h4 id="A-继承"><a href="#A-继承" class="headerlink" title="A. 继承"></a>A. 继承</h4><h5 id="1-继承的介绍"><a href="#1-继承的介绍" class="headerlink" title="1. 继承的介绍"></a>1. 继承的介绍</h5><ul><li>概念:继承描述的是两个工程间的关系,与java中的继承相似,子工程可以继承父工程中的配置信息,常见于依赖关系的继承。</li><li>作用:简化依赖配置、统一管理依赖</li><li>实现 :<code>&lt;parent&gt; ..&lt;/parent&gt;</code></li></ul><p><img src="/img/blogs/java/javaweb/9.2.1.png"></p><h5 id="2-继承关系实现"><a href="#2-继承关系实现" class="headerlink" title="2. 继承关系实现"></a>2. 继承关系实现</h5><ol><li>创建maven模块tlias-parent,该工程为父工程,设置打包方式pom(默认jar)。</li><li>在子工程的pom.xml文件中,配置继承关系。</li><li>在父工程中配置各个工程共有的依赖(子工程会自动继承父工程的依赖)。</li></ol><p><img src="/img/blogs/java/javaweb/9.2.2.png"></p><h5 id="3-版本锁定"><a href="#3-版本锁定" class="headerlink" title="3. 版本锁定"></a>3. 版本锁定</h5><p>在maven中,可以在父工程的pom文件中通过<code>&lt;dependencyManagement&gt;</code>来统一管理依赖版本。</p><p>在父工程中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- JWT令牌 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/blogs/java/javaweb/9.2.3.png"></p><p><code>&lt;dependencyManagement&gt;</code>与<code>&lt;dependencies&gt;</code>的区别是什么?</p><ul><li><code>&lt;dependencies&gt;</code>是直接依赖,在父工程配置了依赖,子工程会直接继承下来。</li><li><code>&lt;dependencyManagement&gt;</code>是统一管理依赖版本,不会直接依赖,还需要在子工程中引入所需依赖(无需指定版本)</li></ul><h4 id="B-聚合"><a href="#B-聚合" class="headerlink" title="B. 聚合"></a>B. 聚合</h4><ul><li><p>将多个模块组成一个整体，同时进行项目的构建</p></li><li><p>聚合工程：一个不具有业务功能的空工程(有且只有一个pom文件)</p></li><li><p>作用：快速构建项目</p></li><li><p>maven中可以通过<code>&lt;modules&gt;</code>设置当前聚合工程所包含的子模块名称</p></li></ul><p>父工程(聚合工程)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 聚合 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span> .. /tlias-pojo<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span> .. /tlias-utils<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span> .. /tlias-web-management<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="C-继承与聚合的关联"><a href="#C-继承与聚合的关联" class="headerlink" title="C. 继承与聚合的关联"></a>C. 继承与聚合的关联</h4><ul><li><p>作用</p><ul><li>聚合用于快速构建项目</li><li>继承用于简化依赖配置、统一管理依赖</li></ul></li><li><p>相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom,可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块,并无实际的模块内容</li></ul></li><li><p>不同点:</p><ul><li>聚合是在聚合工程中配置关系,聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系,父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h2 id="3-私服"><a href="#3-私服" class="headerlink" title="3. 私服"></a>3. 私服</h2><p>私服是一种特殊的远程仓库,它是架设在<code>局域网内的仓库服务</code>,用来代理位于外部的中央仓库,用于解决团队内部的资源共享与资源同步问题。</p><p><img src="/img/blogs/java/javaweb/9.3.1.png"></p><p>依赖查找顺序：<br>本地仓库-&gt;私服-&gt;中央仓库</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>javaweb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE学习笔记</title>
    <link href="/2025/02/11/JAVA/javase/"/>
    <url>/2025/02/11/JAVA/javase/</url>
    
    <content type="html"><![CDATA[<h1 id="一-JAVA基础语法"><a href="#一-JAVA基础语法" class="headerlink" title="一. JAVA基础语法"></a>一. JAVA基础语法</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><ul><li>单行注释： <code>//</code></li><li>多行注释： <code>/* */</code></li><li>文档注释： <code>/** */</code></li></ul><h2 id="2-字面量"><a href="#2-字面量" class="headerlink" title="2. 字面量"></a>2. 字面量</h2><p>分为整数类型、小数类型、字符串类型、字符类型、布尔类型和空类型</p><ul><li>特殊字符<ul><li><code>&#39;\t&#39;</code>: 制表符，把前面字符串的长度补齐到8或者8的整数倍，让数据对齐</li><li><code>&#39;\r&#39;</code>:回车符</li><li><code>&#39;\n&#39;</code>:换行符</li></ul></li></ul><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p><code>数据类型 变量名 = 数据值;</code></p><h2 id="4-计算机存储规则"><a href="#4-计算机存储规则" class="headerlink" title="4. 计算机存储规则"></a>4. 计算机存储规则</h2><p>任意数据都是用二进制的形式存储的</p><h2 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5. 数据类型"></a>5. 数据类型</h2><h4 id="A-基本数据类型"><a href="#A-基本数据类型" class="headerlink" title="A. 基本数据类型"></a>A. 基本数据类型</h4><table>    <tr>        <th>数据类型</th>         <th>关键字</th>     </tr>    <tr>        <td rowspan="4">整数</td>        <td>byte</td>    </tr>    <tr>        <td>short</td>    </tr>    <tr>        <td>int</td>    </tr>        <tr>        <td>long</td>    </tr>    <tr>        <td rowspan="2">浮点数</td>        <td>float</td>    </tr>    <tr>        <td>double</td>    </tr>    <tr>        <td>字符</td>        <td>char</td>    </tr>    <tr>        <td>布尔</td>        <td>boolean</td>    </tr></table><h4 id="B-引用数据类型"><a href="#B-引用数据类型" class="headerlink" title="B. 引用数据类型"></a>B. 引用数据类型</h4><h2 id="6-标识符"><a href="#6-标识符" class="headerlink" title="6. 标识符"></a>6. 标识符</h2><p>自己给变量、类等起名字</p><ul><li>由数字、字母、下划线和美元符($)组成</li><li>小驼峰命名(方法、变量)<ol><li>标识符为一个单词，全部小写：<code>name</code></li><li>标识符为多个单词组成，第一个单词首字母小写，其他单词首字母大写：<code>firstName</code></li></ol></li><li>大驼峰命名(类名)<ol><li>标识符为一个单词，首字母大写：<code>Student</code></li><li>标识符由多个单词组成，每个单词首字母大写：<code>GoodStudent</code></li></ol></li></ul><h2 id="7-键盘录入"><a href="#7-键盘录入" class="headerlink" title="7. 键盘录入"></a>7. 键盘录入</h2><p>用<code>Scanner</code>类接收键盘输入的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//2.创建对象</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入第一个数字&quot;</span>);<br>        <span class="hljs-comment">//3.接收数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;请输入第二个数字”);</span><br><span class="hljs-string">        int number2 = sc.nextInt() ;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        System.out.println(number1 + number2);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8. 运算符"></a>8. 运算符</h2><h4 id="A-算术运算符"><a href="#A-算术运算符" class="headerlink" title="A. 算术运算符"></a>A. 算术运算符</h4><p>+、-、*、&#x2F;、%(取模)</p><ul><li>类型转换<ol><li>隐式转换：把取值范围小的数值自动转成取值范围大的数据(byte&#x3D;&gt;short&#x3D;&gt;int&#x3D;&gt;long&#x3D;&gt;float&#x3D;&gt;double)</li><li>强制转换：<code>目标数据类型 变量名 = (目标数据类型)被强转的数据;</code><br>例：</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">12.3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)a; <span class="hljs-comment">//强制转换</span><br></code></pre></td></tr></table></figure><ul><li>字符串相加<br>“+”: 100 + “100” &#x2F;&#x2F;“100100”</li><li>字符相加：会把字符通过ASCII码表查询到相应数字再进行计算</li></ul><h4 id="B-自增自减运算符"><a href="#B-自增自减运算符" class="headerlink" title="B. 自增自减运算符"></a>B. 自增自减运算符</h4><p>++、–</p><h4 id="C-赋值运算符"><a href="#C-赋值运算符" class="headerlink" title="C. 赋值运算符"></a>C. 赋值运算符</h4><p>&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p><h4 id="D-关系运算符"><a href="#D-关系运算符" class="headerlink" title="D. 关系运算符"></a>D. 关系运算符</h4><p>&#x3D;&#x3D;,!&#x3D;,&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;</p><h4 id="E-逻辑运算符"><a href="#E-逻辑运算符" class="headerlink" title="E. 逻辑运算符"></a>E. 逻辑运算符</h4><p>&amp;(与),|(或),^(异或),!(非)</p><ul><li>短路逻辑运算符(如果左边能确定整个表达式的结果，右边不执行)<ol><li>&amp;&amp;(短路与)</li><li>||(短路或)</li></ol></li></ul><h4 id="F-三元运算符"><a href="#F-三元运算符" class="headerlink" title="F. 三元运算符"></a>F. 三元运算符</h4><p><code>关系表达式?表达式1:表达式2;</code></p><h4 id="G-运算符优先级"><a href="#G-运算符优先级" class="headerlink" title="G. 运算符优先级"></a>G. 运算符优先级</h4><p>()优先于所有</p><h2 id="9-流程控制语句"><a href="#9-流程控制语句" class="headerlink" title="9. 流程控制语句"></a>9. 流程控制语句</h2><h4 id="A-顺序结构"><a href="#A-顺序结构" class="headerlink" title="A. 顺序结构"></a>A. 顺序结构</h4><p>代码按顺序依次执行</p><h4 id="B-分支结构"><a href="#B-分支结构" class="headerlink" title="B. 分支结构"></a>B. 分支结构</h4><h5 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1. if语句"></a>1. if语句</h5><p>格式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式)&#123;<br>    语句体;<br>&#125;<br></code></pre></td></tr></table></figure><p>格式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式)&#123;<br>    语句体<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span>&#123;<br>    语句体<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>格式三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式<span class="hljs-number">1</span>)&#123;<br>    语句体<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(关系表达式<span class="hljs-number">2</span>)&#123;<br>    语句体<span class="hljs-number">2</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span>&#123;<br>    语句体n;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2. switch语句"></a>2. switch语句</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>        语句体<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        语句体<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        语句体n;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>default可以省略，语法不会有问题，但不建议省略</li><li>default习惯写在最下面</li><li>case穿透：语句中没有写break，程序会一直执行</li></ul><h4 id="C-循环结构"><a href="#C-循环结构" class="headerlink" title="C. 循环结构"></a>C. 循环结构</h4><h5 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1. for循环"></a>1. for循环</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化语句;条件判断语句;条件控制语句)&#123;<br>    循环体语句;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>键盘录入两个数字，表示一个范围，统计这个范围中，既能被3整除，又能被5整除数字有多少个。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">addNum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入两个整数：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> num1; i &lt;= num2; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>                count++;<br>                System.out.println(i + <span class="hljs-string">&quot;,&quot;</span>);<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;这样的数字有&quot;</span> + count + <span class="hljs-string">&quot;个&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2. while循环"></a>2. while循环</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化语句;<br><span class="hljs-keyword">while</span>(条件判断语句)&#123;<br>    循环体语句;<br>    条件控制语句;<br>&#125;<br>循环下面的其他语句<br></code></pre></td></tr></table></figure><h5 id="3-无限循环"><a href="#3-无限循环" class="headerlink" title="3. 无限循环"></a>3. 无限循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<br>    System.out.println(<span class="hljs-string">&quot;一直循环&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>))&#123;<br>    System.out.println(<span class="hljs-string">&quot;一直循环&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-循环跳转控制语句"><a href="#4-循环跳转控制语句" class="headerlink" title="4. 循环跳转控制语句"></a>4. 循环跳转控制语句</h5><ul><li>continue: 结束本次循环，继续下次循环</li><li>break: 结束整个循环</li></ul><h2 id="10-数组"><a href="#10-数组" class="headerlink" title="10. 数组"></a>10. 数组</h2><h4 id="A-数组的介绍"><a href="#A-数组的介绍" class="headerlink" title="A. 数组的介绍"></a>A. 数组的介绍</h4><p>数组是一种容器，可以存储同类数据类型的多个值。</p><h4 id="B-数组的定义和初始化"><a href="#B-数组的定义和初始化" class="headerlink" title="B. 数组的定义和初始化"></a>B. 数组的定义和初始化</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 [] 数组名;<br><span class="hljs-type">int</span> [] array;<br></code></pre></td></tr></table></figure><h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h5><ul><li>静态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[]&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,....&#125;;<br><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">// 简化格式</span><br>数据类型[] 数组名 = &#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,...&#125;;<br><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li>动态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[数组长度];<br><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h4 id="3-数组元素访问"><a href="#3-数组元素访问" class="headerlink" title="3. 数组元素访问"></a>3. 数组元素访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<span class="hljs-comment">//1</span><br>System.out.println(arr[<span class="hljs-number">1</span>]);<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h4 id="4-数组的遍历"><a href="#4-数组的遍历" class="headerlink" title="4. 数组的遍历"></a>4. 数组的遍历</h4><p>用循环获取数组变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>    System.out.println(arr[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-数组的内存图"><a href="#5-数组的内存图" class="headerlink" title="5. 数组的内存图"></a>5. 数组的内存图</h4><h5 id="JAVA内存分配"><a href="#JAVA内存分配" class="headerlink" title="JAVA内存分配"></a>JAVA内存分配</h5><ul><li>栈： 方法运行时使用的内存，比如main方法运行进入方法栈执行</li><li>堆： 存储对象或数组，<strong>new</strong>来创建，存储在堆内存</li><li>方法区： 存储可以运行的class文件</li><li>寄存器： 给CPU使用</li></ul><h2 id="11-方法"><a href="#11-方法" class="headerlink" title="11. 方法"></a>11. 方法</h2><h4 id="A-什么是方法"><a href="#A-什么是方法" class="headerlink" title="A. 什么是方法"></a>A. 什么是方法</h4><p>方法是程序运行中最小的执行单元</p><h4 id="B-方法的定义格式和调用"><a href="#B-方法的定义格式和调用" class="headerlink" title="B. 方法的定义格式和调用"></a>B. 方法的定义格式和调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名(参数)&#123;<br>    方法体;<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br><span class="hljs-comment">//调用</span><br>方法名();<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        getSum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>); <span class="hljs-comment">//调用</span><br>    &#125;<br>    <span class="hljs-comment">//定义</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> num1 + num2;<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-方法重载"><a href="#C-方法重载" class="headerlink" title="C. 方法重载"></a>C. 方法重载</h4><p>在同一个类中，方法名相同，参数不同的方法。不看返回值类型。</p><ul><li>参数不同：个数不同、类型不同、顺序不同</li></ul><h2 id="12-二维数组"><a href="#12-二维数组" class="headerlink" title="12. 二维数组"></a>12. 二维数组</h2><ul><li>二维数组的静态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[][] 数组名 = <span class="hljs-keyword">new</span> 数据类型[][]&#123;&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>&#125;,&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-comment">// 简化格式</span><br>数据类型[][] 数组名 = &#123;&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>&#125;,&#123;元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-type">int</span>[][] array = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><ul><li>二维数组的动态初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[][] 数组名 = <span class="hljs-keyword">new</span> 数据类型[m][n];<br><span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br></code></pre></td></tr></table></figure><ul><li>遍历二维数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; arr.length; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; j &lt; arr[i].length; j++)&#123;<br>        System.out.print(arr[i][j] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二-JAVA进阶"><a href="#二-JAVA进阶" class="headerlink" title="二. JAVA进阶"></a>二. JAVA进阶</h1><h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h2><h4 id="A-设计对象并使用"><a href="#A-设计对象并使用" class="headerlink" title="A. 设计对象并使用"></a>A. 设计对象并使用</h4><h5 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h5><ul><li>类：是对象共同特征的描述</li><li>对象：真实存在的具体东西</li><li>必须先设计类，才能获得对象</li></ul><h5 id="2-定义类"><a href="#2-定义类" class="headerlink" title="2. 定义类"></a>2. 定义类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名&#123;<br>    <span class="hljs-number">1</span>、成员变量（代表属性，一般是名词）<br>    <span class="hljs-number">2</span>、成员方法（代表行为，一般是动词）<br>    <span class="hljs-number">3</span>、构造器<br>    <span class="hljs-number">4</span>、代码块<br>    <span class="hljs-number">5</span>、内部类<br>&#125;<br><br><span class="hljs-comment">// 获取类的对象</span><br>类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br><br>对象名.成员变量<span class="hljs-comment">//访问属性</span><br>对象名.方法名(...)<span class="hljs-comment">//访问行为</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>&#123;<br>    <span class="hljs-comment">//属性(成员变量)</span><br>    String brand;<br>    <span class="hljs-type">double</span> price;<br>    <span class="hljs-comment">//行为(方法)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playGame</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 获取类的对象</span><br><span class="hljs-type">Phone</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phone</span>();<br></code></pre></td></tr></table></figure><h5 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h5><ul><li>Javabean类：用来描述一类事物的类，是不写main方法的</li><li>测试类：编写main方法的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//javabean类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriend</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String gender;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉觉...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shopping</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;逛商场ing&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlfriendTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GirlFriend</span> <span class="hljs-variable">gf1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GirlFriend</span>();<br>        gf1.name = <span class="hljs-string">&quot;小李子&quot;</span>;<br>        gf1.age = <span class="hljs-number">18</span>;<br>        gf1.gender = <span class="hljs-string">&quot;female&quot;</span>;<br>        System.out.println(gf1.name);<br>        System.out.println(gf1.age);<br>        System.out.println(gf1.gender);<br><br>        gf1.sleep();<br>        gf1.shopping();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-封装"><a href="#B-封装" class="headerlink" title="B. 封装"></a>B. 封装</h4><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong></p><h4 id="C-private关键字-保证数据的安全性"><a href="#C-private关键字-保证数据的安全性" class="headerlink" title="C. private关键字(保证数据的安全性)"></a>C. private关键字(保证数据的安全性)</h4><ul><li>是一个权限修饰符</li><li>可以修饰成员(成员变量和成员方法)</li><li>被private修饰的成员只能在<strong>本类中</strong>才能访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//确保age成员变量的值是正确范围内的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriend</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">18</span> &amp;&amp; a &lt;= <span class="hljs-number">50</span>) &#123;<br>            age = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;非法数据&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="D-this关键字"><a href="#D-this关键字" class="headerlink" title="D. this关键字"></a>D. this关键字</h4><p>区别成员变量和局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GirlFriend</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <span class="hljs-comment">//成员变量age</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//局部变量age</span><br>        System.out.println(<span class="hljs-built_in">this</span>.age); <span class="hljs-comment">//如果只打印age会触发就近原则打印局部变量age;使用this.age才会打印成员变量age</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用场景</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;  <span class="hljs-comment">//给成员变量age赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="E-构造方法"><a href="#E-构造方法" class="headerlink" title="E. 构造方法"></a>E. 构造方法</h4><p>在创建对象的时候给成员变量进行赋值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    修饰符 类名(参数)&#123;<br>        方法体;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//空参构造，系统默认会有</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-comment">//带参构造</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小李&quot;</span>,<span class="hljs-number">20</span>); <span class="hljs-comment">//调用带参构造进行赋值</span><br></code></pre></td></tr></table></figure><ul><li>方法名与类名相同</li><li>没有返回值类型，没有返回值</li><li>无论是否使用，都要写上空参构造和带参构造</li></ul><h4 id="F-标准JavaBean"><a href="#F-标准JavaBean" class="headerlink" title="F. 标准JavaBean"></a>F. 标准JavaBean</h4><ul><li>类名<strong>见名知意</strong></li><li>成员变量使用private修饰</li><li>提供两种构造方法(无参的和带全部参)</li><li>成员方法：提供每个成员变量对应的setXX()和getXX()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//空参构造方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, String password, <span class="hljs-type">int</span> age)</span> &#123;  <span class="hljs-comment">//带全部参构造方法</span><br>        <span class="hljs-built_in">this</span>.username = username;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="G-基本数据类型和引用数据类型"><a href="#G-基本数据类型和引用数据类型" class="headerlink" title="G. 基本数据类型和引用数据类型"></a>G. 基本数据类型和引用数据类型</h4><ul><li>基本数据类型（如 int、double、char 等）直接存储在栈内存中，它们的值是实际的数据。</li><li>引用数据类型（如类、数组等）在栈内存中存储的是对象的引用（存储的是地址值），而对象本身存储在堆内存中。</li></ul><h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><h4 id="A-String"><a href="#A-String" class="headerlink" title="A. String"></a>A. String</h4><p>java.lang.String类</p><ul><li>字符串的内容是不会发生改变的，它的对象在创建后不能被更改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.使用直接赋值的方式获取一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(s1);<span class="hljs-comment">//abc</span><br><br><span class="hljs-comment">//2.使用new的方式来获取一个字符串对象. 空参构造:可以获取一个空白的字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>System.out.println(<span class="hljs-string">&quot;@&quot;</span> + s2 + <span class="hljs-string">&quot;!&quot;</span>);<span class="hljs-comment">//&quot;&quot;</span><br><br><span class="hljs-comment">//3. 传递一个字符数组,根据字符数组的内容再创建一个新的字符串对象</span><br><span class="hljs-type">char</span>[] chs = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span> ,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chs);<br>System.out.println(s4);<span class="hljs-comment">//abcd</span><br><br><span class="hljs-comment">//4.传递一个字节数组,根据字节数组的内容再创建一个新的字符串对象</span><br><span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br>System.out.println(s5);<span class="hljs-comment">//abcd</span><br></code></pre></td></tr></table></figure><h4 id="B-字符串常用方法"><a href="#B-字符串常用方法" class="headerlink" title="B. 字符串常用方法"></a>B. 字符串常用方法</h4><h5 id="1-字符串比较"><a href="#1-字符串比较" class="headerlink" title="1. 字符串比较"></a>1. 字符串比较</h5><ul><li>equals(要比较的字符串)： 完全一样才是true</li><li>equalsIgnoreCase(要比较的字符串): 忽略大小写</li></ul><h5 id="2-遍历字符串"><a href="#2-遍历字符串" class="headerlink" title="2. 遍历字符串"></a>2. 遍历字符串</h5><ul><li>charAt(int index): 根据索引返回字符</li><li>length(): 返回此字符串的长度</li></ul><p>键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符和数字字符出现的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入一个字符串&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br><br><span class="hljs-type">int</span> <span class="hljs-variable">bigCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">smallCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">numberCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>        smallCount++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>        bigCount++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        numberCount++;<br>    &#125;<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;小写字母有:&quot;</span> + smallCount + <span class="hljs-string">&quot;个&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;大写字母有:&quot;</span> + bigCount + <span class="hljs-string">&quot;个&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;数字字母有:&quot;</span> + numberCount + <span class="hljs-string">&quot;个&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-字符串屏蔽"><a href="#3-字符串屏蔽" class="headerlink" title="3. 字符串屏蔽"></a>3. 字符串屏蔽</h5><ul><li>substring(int beginIndex, int endIndex): 截取，截取范围是[beginIndex, endIndex)</li><li>substring(int beginIndex): 截取到末尾</li><li>replace(旧值,新值)： 替换</li></ul><p>手机号码屏蔽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;13112349468&quot;</span>;<br><span class="hljs-comment">//截取手机号码前面三位</span><br><span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> phoneNumber.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//截取手机号码后面四位</span><br><span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> phoneNumber.substring(<span class="hljs-number">7</span>);<br><span class="hljs-comment">//拼接</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> start + <span class="hljs-string">&quot; **** &quot;</span> + end;<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p>敏感词屏蔽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String talk=<span class="hljs-string">&quot;你玩的真好,以后不要再玩了,TMD,CNM&quot;</span>;<br><span class="hljs-comment">//定义一个敏感词库</span><br>String[] arr = &#123;<span class="hljs-string">&quot;TMD&quot;</span>, <span class="hljs-string">&quot;CNM&quot;</span>, <span class="hljs-string">&quot;SB&quot;</span>, <span class="hljs-string">&quot;MLGB&quot;</span>&#125;;<br><span class="hljs-comment">//循环得到数组中的每一个敏感词,依次进行替换</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    talk = talk.replace(arr[i], <span class="hljs-string">&quot;***&quot;</span>);<br>&#125;<br>System.out.println(talk);<br></code></pre></td></tr></table></figure><h4 id="C-StringBuilder"><a href="#C-StringBuilder" class="headerlink" title="C. StringBuilder"></a>C. StringBuilder</h4><p>可以看成一个容器，创建之后里面的内容是可变的</p><ul><li>用于提高字符串的操作效率</li><li>使用场景：1.<strong>字符串的拼接</strong> 2.<strong>字符串的反转</strong></li></ul><h5 id="1-StringBuilder构造方法"><a href="#1-StringBuilder构造方法" class="headerlink" title="1. StringBuilder构造方法"></a>1. StringBuilder构造方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder()</td><td>创建一个空白可变字符串对象，不含有任何内容</td></tr><tr><td>public StringBuilder(String str)</td><td>根据字符串的内容，创建可变字符串对象</td></tr></tbody></table><h5 id="2-StringBuilder常用方法"><a href="#2-StringBuilder常用方法" class="headerlink" title="2. StringBuilder常用方法"></a>2. StringBuilder常用方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder append(任意类型)</td><td>添加数据，返回对象本身</td></tr><tr><td>public StringBuilder reverse()</td><td>反转容器中的内容</td></tr><tr><td>public int length()</td><td>返回长度</td></tr><tr><td>public String toString</td><td>通过toString()可以实现把Stringbuilder转换为String</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>        <span class="hljs-comment">//添加</span><br>        sb.append(<span class="hljs-string">&quot;123&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;abc&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;scasc&quot;</span>).append(<span class="hljs-string">&quot;qwer&quot;</span>).append(<span class="hljs-string">&quot;zxcv&quot;</span>);<span class="hljs-comment">//链式编程</span><br>        System.out.println(sb);<br>        <span class="hljs-comment">//反转</span><br>        sb.reverse();<br>        System.out.println(sb);<br>        <span class="hljs-comment">//获取长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sb.length();<br>        System.out.println(len);<br>        <span class="hljs-comment">//把StringBuilder变回String类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sb.toString();<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="D-StringJoiner"><a href="#D-StringJoiner" class="headerlink" title="D. StringJoiner"></a>D. StringJoiner</h4><p>主要用于<strong>字符串的拼接</strong></p><h5 id="1-StringJoiner构造方法"><a href="#1-StringJoiner构造方法" class="headerlink" title="1. StringJoiner构造方法"></a>1. StringJoiner构造方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringJoiner(间隔符号)</td><td>创建一个StringJoiner对象，指定拼接时的间隔符号</td></tr><tr><td>public StringJoiner(间隔符号,开始符号,结束符号)</td><td>创建一个StringJoiner对象，指定拼接时的间隔符号、开始符号、结束符号</td></tr></tbody></table><h5 id="2-StringJoiner成员方法"><a href="#2-StringJoiner成员方法" class="headerlink" title="2. StringJoiner成员方法"></a>2. StringJoiner成员方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public StringJoiner add(添加的内容)</td><td>添加数据，并返回对象本身</td></tr><tr><td>public int length()</td><td>返回长度</td></tr><tr><td>public String toString()</td><td>返回一个字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringJoiner</span> <span class="hljs-variable">sj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(<span class="hljs-string">&quot;, &quot;</span>, <span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>);<br><span class="hljs-comment">//添加元素</span><br>sj.add(<span class="hljs-string">&quot;aaa&quot;</span>).add(<span class="hljs-string">&quot;bbb&quot;</span>).add(<span class="hljs-string">&quot;ccc&quot;</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sj.length();<br>System.out.println(len);<span class="hljs-comment">//15</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sj.toString();<br>System.out.println(str);<span class="hljs-comment">//[aaa, bbb, ccc]</span><br></code></pre></td></tr></table></figure><h2 id="3-集合"><a href="#3-集合" class="headerlink" title="3. 集合"></a>3. 集合</h2><h4 id="A-数组和集合的区别"><a href="#A-数组和集合的区别" class="headerlink" title="A. 数组和集合的区别"></a>A. 数组和集合的区别</h4><table><thead><tr><th>区别</th><th>数组</th><th>集合</th></tr></thead><tbody><tr><td>长度</td><td>数组长度固定</td><td>集合长度可变</td></tr><tr><td>存储类型</td><td>可以存基本数据类型和引用数据类型</td><td>只能存引用数据类型</td></tr></tbody></table><h4 id="B-创建集合对象"><a href="#B-创建集合对象" class="headerlink" title="B. 创建集合对象"></a>B. 创建集合对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="C-ArrayList成员方法"><a href="#C-ArrayList成员方法" class="headerlink" title="C. ArrayList成员方法"></a>C. ArrayList成员方法</h4><p>增删改查</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素,返回值表示是否添加成功</td></tr><tr><td>boolean remove(E e)</td><td>删除指定元素,返回值表示是否删除成功</td></tr><tr><td>E remove(int index)</td><td>删除指定索引的元素,返回被删除元素</td></tr><tr><td>E set(int index,E e)</td><td>修改指定索引下的元素,返回原来的元素</td></tr><tr><td>E get(int index)</td><td>获取指定索引的元素</td></tr><tr><td>int size()</td><td>集合的长度,也就是集合中元素的个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraylistStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//添加元素</span><br>        list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;bbb&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;ccc&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;ddd&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">//删除元素</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-string">&quot;ccc&quot;</span>);<span class="hljs-comment">//根据指定元素删除</span><br>        System.out.println(list);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> list.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//根据索引删除元素</span><br>        System.out.println(list);<br><br>        <span class="hljs-comment">//修改元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;ccc&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">//查询元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>        System.out.println(s);<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> list.get(i);<br>            System.out.println(str1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-面向对象进阶"><a href="#4-面向对象进阶" class="headerlink" title="4. 面向对象进阶"></a>4. 面向对象进阶</h2><h4 id="A-static"><a href="#A-static" class="headerlink" title="A. static"></a>A. static</h4><p>表示静态，是java中一个修饰符，可以修饰成员方法、成员变量</p><h5 id="1-静态变量：被static修饰的成员变量"><a href="#1-静态变量：被static修饰的成员变量" class="headerlink" title="1. 静态变量：被static修饰的成员变量"></a>1. 静态变量：被static修饰的成员变量</h5><ul><li>特点：被该类所有对象<strong>共享</strong></li><li>不属于对象，属于类；随着类的加载而加载，优先于对象存在</li><li>调用方法<ol><li>类名调用(推荐)</li><li>对象名调用</li></ol></li></ul><h5 id="2-静态方法：被static修饰的成员方法"><a href="#2-静态方法：被static修饰的成员方法" class="headerlink" title="2. 静态方法：被static修饰的成员方法"></a>2. 静态方法：被static修饰的成员方法</h5><p>多用于测试类、工具类中，javabean类中很少会用</p><ul><li>调用方法<ol><li>类名调用(推荐)</li><li>对象名调用</li></ol></li></ul><h5 id="3-static的注意事项"><a href="#3-static的注意事项" class="headerlink" title="3. static的注意事项"></a>3. static的注意事项</h5><ul><li>静态方法中只能访问静态(静态变量和静态方法)</li><li>非静态方法可以访问所有</li><li>静态方法中没有this关键字</li></ul><h5 id="4-main方法"><a href="#4-main方法" class="headerlink" title="4. main方法"></a>4. main方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;helloworld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>public: 被JVM调用,访问权限足够大</li><li>static: 被JVM调用,不用创建对象,直接类名访问</li><li>void: 因为main方法是静态的,所以测试类中其他方法也需要是静态的。<br>被JVM调用,不需要给JVM返回值</li><li>main: 一个通用的名称,虽然不是关键字,但是被JVM识别</li><li>String[] args: 用于接收键盘录入数据，已经没有用了</li></ul><h4 id="B-继承"><a href="#B-继承" class="headerlink" title="B. 继承"></a>B. 继承</h4><h5 id="1-什么是继承"><a href="#1-什么是继承" class="headerlink" title="1. 什么是继承"></a>1. 什么是继承</h5><ul><li>封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为</li><li>java中提供<strong>extends</strong>用于一个类和另一个类建立起继承关系<br><code>public class Student extends Preson{}</code><br><code>public class 子类 extends 父类{}</code></li><li>Student称为子类(派生类)，Person称为父类(基类或超类)</li><li>使用继承的好处<ol><li>可以把多个子类中重复的代码抽取到父类中，提高代码的复用性</li><li>子类可以在父类的基础上增加其他功能，使子类更强大</li></ol></li><li>什么时候用继承：当类与类之间，<strong>存在相同的内容</strong>，并<strong>满足子类是父类的一种</strong>，就可以考虑使用继承</li></ul><h5 id="2-继承的特点"><a href="#2-继承的特点" class="headerlink" title="2. 继承的特点"></a>2. 继承的特点</h5><p><strong>Java只支持单继承，不支持多继承，但支持多层继承</strong></p><ul><li>单继承： 一个子类只能继承一个父类</li><li>多继承：子类不能同时继承多个父类(不支持！)</li><li>多层继承：子类A继承父类B，父类B可以继承父类C</li><li>JAVA中所有每个类都直接或间接的继承于Object类</li><li>子类只能访问父类中非私有的成员</li></ul><h5 id="3-子类能继承父类哪些内容"><a href="#3-子类能继承父类哪些内容" class="headerlink" title="3. 子类能继承父类哪些内容"></a>3. 子类能继承父类哪些内容</h5><table><thead><tr><th>父类中的内容</th><th>非私有</th><th>private</th></tr></thead><tbody><tr><td>构造方法</td><td>不能继承</td><td>不能继承</td></tr><tr><td>成员变量</td><td>能继承</td><td>能继承</td></tr><tr><td>成员方法</td><td>能继承</td><td>不能继承</td></tr></tbody></table><ul><li>父类中的<strong>构造方法不能</strong>被子类继承</li><li>父类中的<strong>成员变量可以</strong>被子类继承，但私有的变量不能直接被使用</li><li>父类中的虚方法才能被子类继承<ul><li>虚方法表：非private,非static,非final</li></ul></li></ul><h5 id="4-继承中成员变量的访问特点"><a href="#4-继承中成员变量的访问特点" class="headerlink" title="4. 继承中成员变量的访问特点"></a>4. 继承中成员变量的访问特点</h5><ul><li>就近原则：谁离我近，我就用谁</li><li>先在局部位置找，本类成员位置找，父类成员位置找，逐级往上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Fu&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Zi&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ziShow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ziShow&quot;</span>;<br>        System.out.println(name);<span class="hljs-comment">//ziShow</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name);<span class="hljs-comment">//Zi</span><br>        System.out.println(<span class="hljs-built_in">super</span>.name);<span class="hljs-comment">//Fu</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-继承中成员方法的访问特点"><a href="#5-继承中成员方法的访问特点" class="headerlink" title="5. 继承中成员方法的访问特点"></a>5. 继承中成员方法的访问特点</h5><ul><li>直接调用满足就近原则：谁离我近，我就用谁</li><li>super调用，直接访问父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;吃米饭,吃菜&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;喝开水&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//留学生</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OverseasStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lunch</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.eat();<span class="hljs-comment">//吃意大利面</span><br>        <span class="hljs-built_in">this</span>.drink();<span class="hljs-comment">//喝凉水</span><br><br>        <span class="hljs-built_in">super</span>.eat();<span class="hljs-comment">//吃米饭,吃菜</span><br>        <span class="hljs-built_in">super</span>.drink();<span class="hljs-comment">//喝开水</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;吃意大利面&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;喝凉水&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-方法的重写"><a href="#6-方法的重写" class="headerlink" title="6. 方法的重写"></a>6. 方法的重写</h5><p>当父类的方法不能满足子类现在的需求时，需要进行方法重写</p><ul><li>书写格式： 当继承体系中，子类出现了和父类中一模一样的方法声明，就称子类这个方法是重写的方法</li><li><strong>@Override</strong>重写注解(建议加上)：放在重写后的方法上，校验子类重写的语法是否正确</li><li>重写方法的名称、形参列表必须和父类一致，<strong>重写的方法尽量与父类保持一致</strong></li></ul><h5 id="7-构造方法的访问特点"><a href="#7-构造方法的访问特点" class="headerlink" title="7. 构造方法的访问特点"></a>7. 构造方法的访问特点</h5><ul><li>父类中的构造方法不会被子类继承</li><li>子类中所有的构造方法默认先访问父类中的无参构造，再执行自己</li><li>子类可以通过super调用父类的构造方法</li><li>子类构造方法的第一行有一个默认的super();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类的无参构造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//子类构造方法中隐藏的super()去访问父类的无参构造</span><br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;子类的无参构造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-this和super"><a href="#8-this和super" class="headerlink" title="8. this和super"></a>8. this和super</h5><ul><li>this: 理解成一个变量，表示当前方法调用者的地址值</li><li>super: 代表父类存储空间</li></ul><table><thead><tr><th>关键字</th><th>访问成员变量</th><th>访问成员方法</th><th>访问构造方法</th></tr></thead><tbody><tr><td>this</td><td>this.成员变量<br>访问本类成员变量</td><td>this.成员方法(…)<br>访问本类成员方法</td><td>this(…)<br>访问本类构造方法</td></tr><tr><td>super</td><td>super.成员变量<br>访问父类成员变量</td><td>super.成员方法(…)<br>访问父类成员方法</td><td>super(…)<br>访问父类构造方法</td></tr></tbody></table><h5 id="9-带有继承结构的标准Javabean类"><a href="#9-带有继承结构的标准Javabean类" class="headerlink" title="9. 带有继承结构的标准Javabean类"></a>9. 带有继承结构的标准Javabean类</h5><p>父类：员工</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> salary;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSalary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSalary</span><span class="hljs-params">(<span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-comment">//工作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Employee worked!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//吃饭</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Employee eat!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类1：经理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> bouns;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Manager</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary, <span class="hljs-type">double</span> bouns)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id, name, salary);<br>        <span class="hljs-built_in">this</span>.bouns = bouns;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getBouns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bouns;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBouns</span><span class="hljs-params">(<span class="hljs-type">double</span> bouns)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bouns = bouns;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;管理其他人&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类2：厨师</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cook</span><span class="hljs-params">(String id, String name, <span class="hljs-type">double</span> salary)</span> &#123;<br>        <span class="hljs-built_in">super</span>(id, name, salary);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;厨师在做饭&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-多态"><a href="#C-多态" class="headerlink" title="C. 多态"></a>C. 多态</h4><h5 id="1-什么是多态"><a href="#1-什么是多态" class="headerlink" title="1. 什么是多态"></a>1. 什么是多态</h5><ul><li>同类型的对象，表现出的不同形态(对象的多种形态)</li><li>多态的表现形式：<code>父类类型 对象名称 = 子类对象;</code>，<code>Animal a = new Dog();</code></li><li>多态的前提<ul><li>有继承关系</li><li>有父类引用指向子类对象</li><li>有方法重写</li></ul></li></ul><h5 id="2-多态调用成员的特点"><a href="#2-多态调用成员的特点" class="headerlink" title="2. 多态调用成员的特点"></a>2. 多态调用成员的特点</h5><ul><li>调用<strong>成员变量</strong>的特点：编译看左边，运行也看左边</li><li>调用<strong>成员方法</strong>的特点：编译看左边，运行看右边</li></ul><h5 id="3-多态的优势和缺点"><a href="#3-多态的优势和缺点" class="headerlink" title="3. 多态的优势和缺点"></a>3. 多态的优势和缺点</h5><ul><li>优势：定义方法时，使用父类型作为参数，<strong>可以接收所有子类对象</strong>，体现多态的扩展性和便利</li><li>缺点：不能使用子类的特有功能(方法)</li><li>如果想要调用子类特有的方法，使用强制类型转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先判断a是否为Dog类型,如果是,则强转成Dog类型,转换之后变量名为d</span><br><span class="hljs-comment">//如果不是,则不强转,结果是false</span><br>        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog d) &#123;<br>        d.lookHome();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat c)&#123;<br>            c.catchMouse();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;没有这个类型,无法转换&quot;</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="D-包"><a href="#D-包" class="headerlink" title="D. 包"></a>D. 包</h4><p>包就是文件夹。用来管理不同功能的类。</p><ul><li>导包的规则<ul><li>使用同一个包中的类不需要导包</li><li>使用java.lang包中的类不需要导包</li><li>其他都需要导包</li><li>如果同时使用两个包中的同名类，需要用全类名(含包名)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.study<br><br><span class="hljs-keyword">import</span> java.study.Student  <span class="hljs-comment">//导入java.study包中的Student类</span><br></code></pre></td></tr></table></figure><h4 id="E-final"><a href="#E-final" class="headerlink" title="E. final"></a>E. final</h4><table><thead><tr><th>final修饰</th><th>作用</th></tr></thead><tbody><tr><td>方法</td><td>表明该方法是最终方法，不能被重写</td></tr><tr><td>类</td><td>表明该类是最终类，不能被继承</td></tr><tr><td>变量</td><td>此时是常量</td></tr></tbody></table><ul><li>final修改基本数据类型:记录的值不能发生改变</li><li>final修饰引用数据类型:记录的地址值不能发生改变,内部的属性值还是可以改变的</li></ul><h4 id="F-权限修饰符"><a href="#F-权限修饰符" class="headerlink" title="F. 权限修饰符"></a>F. 权限修饰符</h4><p>用来控制一个成员能够被访问的范围<br>四种：private&lt;默认(空着不写)&lt;protected&lt;public</p><table><thead><tr><th>修饰符</th><th>同一个类中</th><th>同一个包中其他类</th><th>不同包下的子类</th><th>不同包下的无关类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td></td><td></td><td></td></tr><tr><td>默认(空着不写)</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><ul><li>实际开发一般只用private和public<ul><li>成员变量私有</li><li>方法公开</li></ul></li></ul><h4 id="G-静态代码块"><a href="#G-静态代码块" class="headerlink" title="G. 静态代码块"></a>G. 静态代码块</h4><p>做数据的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>&#123;<br>    <span class="hljs-keyword">static</span> ArrayList&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-comment">//添加一些用户信息</span><br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>,<span class="hljs-string">&quot;301001200101011234&quot;</span>,<span class="hljs-string">&quot;13812341234&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="H-抽象类"><a href="#H-抽象类" class="headerlink" title="H. 抽象类"></a>H. 抽象类</h4><p>如果一个类中存在抽象方法，那么该类就必须声明为抽象类</p><h5 id="1-抽象类的定义"><a href="#1-抽象类的定义" class="headerlink" title="1. 抽象类的定义"></a>1. 抽象类的定义</h5><p>将共性的行为(方法)抽取到父类之后。由于每个子类执行的内容是不一样，所以在父类中不能确定具体的方法体。该方法就可以定义为抽象类。<br>抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 返回值类型 方法名(参数列表);<br></code></pre></td></tr></table></figure><p>抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> class 类名&#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-抽象类的特点"><a href="#2-抽象类的特点" class="headerlink" title="2. 抽象类的特点"></a>2. 抽象类的特点</h5><ul><li>抽象类不能实例化(创建对象)</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>可以有构造方法</li><li>抽象类的子类<ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul></li></ul><h4 id="I-接口"><a href="#I-接口" class="headerlink" title="I. 接口"></a>I. 接口</h4><h5 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1. 接口的定义"></a>1. 接口的定义</h5><ul><li>使用<code>interface</code>定义<br><code>public interface 接口名{}</code></li><li>接口不能实例化(不能创建对象)</li><li>接口和类之间是实现关系，通过<code>implements</code>表示<br><code>public class 类名 implements 接口名{}</code></li><li>接口的子类(实现类)<ul><li>要么重写接口中所有抽象方法</li><li>要么是抽象类</li></ul></li><li>接口和类的实现关系，可以单实现，也可以多实现<br><code>public class 类名 implements 接口名1, 接口名2{}</code></li><li>实现类还可以在继承一个类的同时实现多个接口<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2{}</code></li></ul><h5 id="2-接口中成员的特点"><a href="#2-接口中成员的特点" class="headerlink" title="2. 接口中成员的特点"></a>2. 接口中成员的特点</h5><table><thead><tr><th>成员</th><th>特点</th></tr></thead><tbody><tr><td>成员变量</td><td>只能是常量<br>public static final</td></tr><tr><td>构造方法</td><td>没有</td></tr><tr><td>成员方法</td><td>只能是抽象方法<br>public abstract</td></tr></tbody></table><h5 id="3-接口和类之间的关系"><a href="#3-接口和类之间的关系" class="headerlink" title="3. 接口和类之间的关系"></a>3. 接口和类之间的关系</h5><ul><li>类和类的关系<br>  继承关系</li><li>类和接口的关系<br>  实现关系，可以单实现，可以多实现，可以在继承一个类时实现多个接口</li><li>接口和接口的关系<br>  继承关系，可以单继承，可以多继承</li></ul><h5 id="4-接口中的默认方法"><a href="#4-接口中的默认方法" class="headerlink" title="4. 接口中的默认方法"></a>4. 接口中的默认方法</h5><p><code>public default 返回值类型 方法名(参数列表){}</code></p><ul><li>默认方法不是抽象方法,所以不强制被重写。但是如果被重写,重写的时候去掉default关键字</li><li>public可以省略,default不能省略</li><li>如果实现了多个接口,多个接口中存在相同名字的默认方法,子类就必须对该方法进行重写</li></ul><h5 id="5-接口中的静态方法"><a href="#5-接口中的静态方法" class="headerlink" title="5. 接口中的静态方法"></a>5. 接口中的静态方法</h5><p><code>public static 返回值类型 方法名(参数列表){}</code><br><code>public static void show(){}</code></p><ul><li>静态方法只能通过接口名调用,不能通过实现类名或者对象名调用</li><li>public可以省略,static不能省略</li></ul><h5 id="6-接口中的私有方法"><a href="#6-接口中的私有方法" class="headerlink" title="6. 接口中的私有方法"></a>6. 接口中的私有方法</h5><p><code>private 返回值类型 方法名(参数列表){}</code><br><code>private void show(){}</code></p><p><code>private static 返回值类型 方法名(参数列表){}</code><br><code>private static void method(){}</code></p><h5 id="7-接口的应用"><a href="#7-接口的应用" class="headerlink" title="7. 接口的应用"></a>7. 接口的应用</h5><p>各种行为的规则，是行为的抽象</p><h5 id="8-接口的适配器设计模式"><a href="#8-接口的适配器设计模式" class="headerlink" title="8. 接口的适配器设计模式"></a>8. 接口的适配器设计模式</h5><p>当一个接口中抽象方法过多,但是我只要使用其中一部分的时候,就可以适配器设计模式</p><ul><li>书写步骤:<ol><li>编写中间类XXXAdapter,实现对应的接口</li><li>对接口中的抽象方法进行空实现</li><li>让真正的实现类继承中间类,并重写需要用的方法</li><li>为了避免其他类创建适配器类的对象,中间的适配器类用abstract进行修饰</li></ol></li></ul><h4 id="J-内部类"><a href="#J-内部类" class="headerlink" title="J. 内部类"></a>J. 内部类</h4><h5 id="1-内部类的定义"><a href="#1-内部类的定义" class="headerlink" title="1. 内部类的定义"></a>1. 内部类的定义</h5><p>在一个类的里面再定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;  <span class="hljs-comment">//外部类</span><br>    String carName;<br>    <span class="hljs-type">int</span> carAge;<br>    <span class="hljs-type">int</span> carColor;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>&#123;   <span class="hljs-comment">//内部类</span><br>        String engineName;<br>        <span class="hljs-type">int</span> engineAge;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部类可以直接访问外部类的成员(包括私有)</li><li>外部类必须创建对象访问内部类的成员</li></ul><h5 id="2-成员内部类-了解"><a href="#2-成员内部类-了解" class="headerlink" title="2. 成员内部类(了解)"></a>2. 成员内部类(了解)</h5><ul><li>写在成员位置，属于外部类的成员</li><li>可以被修饰符修饰</li></ul><p>创建对象方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类名.内部类名 对象名 =<span class="hljs-keyword">new</span> 外部类对象.内部类对象;<br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><p>成员内部类如何获取外部类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>            System.out.println(Outer.<span class="hljs-built_in">this</span>.a);<span class="hljs-comment">//10</span><br>            System.out.println(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">//20</span><br>            System.out.println(a); <span class="hljs-comment">//30</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-静态内部类-了解"><a href="#3-静态内部类-了解" class="headerlink" title="3. 静态内部类(了解)"></a>3. 静态内部类(了解)</h5><p>静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建静态内部对象方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> 外部类名.内部类名;<br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<br></code></pre></td></tr></table></figure><p>调用静态方法：<code>外部类名.内部类名.方法名();</code></p><h5 id="4-匿名内部类-重点"><a href="#4-匿名内部类-重点" class="headerlink" title="4. 匿名内部类(重点)"></a>4. 匿名内部类(重点)</h5><ul><li>本质是隐藏了名字的内部类</li><li>整体就是一个类的子类对象或者接口的实现类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名或接口名()&#123;<br>    重写方法;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Inter</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//重写方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;重写了eat方法&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用场景：当方法的参数是接口或类时，如果实现类只要使用一次，就可以用匿名内部类简化代码</li></ul><h2 id="5-常用API"><a href="#5-常用API" class="headerlink" title="5. 常用API"></a>5. 常用API</h2><h4 id="A-Math"><a href="#A-Math" class="headerlink" title="A. Math"></a>A. Math</h4><p>提供数学计算的工具类</p><h4 id="B-System"><a href="#B-System" class="headerlink" title="B. System"></a>B. System</h4><p>提供与系统相关的方法</p><ul><li>exit(): 停止虚拟机</li><li>currentTimeMillis(): 获取当前时间的毫秒值</li><li>arraycopy():  拷贝数组</li></ul><h4 id="C-Runtime"><a href="#C-Runtime" class="headerlink" title="C. Runtime"></a>C. Runtime</h4><p>当前虚拟机的运行环境</p><h4 id="D-Object"><a href="#D-Object" class="headerlink" title="D. Object"></a>D. Object</h4><p>Object是Java的顶级父类。所有的类都直接或间接继承于Object类</p><ul><li>只有无参构造</li><li>toString(): 返回字符串</li><li>equals(Object obj): 比较两个对象是否相等,比较的是地址值</li></ul><h4 id="E-对象克隆-对象复制"><a href="#E-对象克隆-对象复制" class="headerlink" title="E. 对象克隆(对象复制)"></a>E. 对象克隆(对象复制)</h4><p>把A对象的属性值完全拷贝给B对象<br><code>protected Object clone(int a)</code></p><ul><li>浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来</li><li>深克隆：<ol><li>基本数据类型拷贝过来</li><li>字符串复用</li><li>引用数据类型会重新创建新的</li></ol></li></ul><h4 id="F-Objects"><a href="#F-Objects" class="headerlink" title="F. Objects"></a>F. Objects</h4><ul><li>equals(Object a,Object b):先做非空判断，比较两个对象</li><li>isNull(Object obj): 判断对象是否为NULL,是返回true</li><li>nonNull(Object obj): 判断对象是否为NULL，是返回false</li></ul><h4 id="G-BigInteger"><a href="#G-BigInteger" class="headerlink" title="G. BigInteger"></a>G. BigInteger</h4><p>获取大整数并进行数学运算</p><h4 id="H-BigDecima"><a href="#H-BigDecima" class="headerlink" title="H. BigDecima"></a>H. BigDecima</h4><p>用于小数的精确计算，用于表示很大的小数</p><h4 id="I-正则表达式"><a href="#I-正则表达式" class="headerlink" title="I. 正则表达式"></a>I. 正则表达式</h4><ul><li>校验字符串是否满足一定的规则，校验数据格式的合法性</li><li>可以在一段文本中查找满足条件的字符串</li></ul><p>在<code>java.util.regex</code>包中</p><ul><li>Pattern:表示正则表达式</li><li>Matcher:文本匹配器，按照正则表达式的规则读取字符串</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abdbdfewgewgewvwrebwebtehrejtmiymolpurjergergew&quot;</span>;<br><br><span class="hljs-type">Pattern</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;a\\d&#123;0,2&#125;&quot;</span>); <span class="hljs-comment">//定义正则表达式</span><br><span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.Matcher(str); <span class="hljs-comment">//m在str中找到符合p规则的字符串</span><br><br><span class="hljs-keyword">while</span>(m.find())&#123;<span class="hljs-comment">//判断是否有符合的小串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> m.group();  <span class="hljs-comment">//获取小串</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="J-JDK7前的时间相关类"><a href="#J-JDK7前的时间相关类" class="headerlink" title="J. JDK7前的时间相关类"></a>J. JDK7前的时间相关类</h4><h5 id="1-Date"><a href="#1-Date" class="headerlink" title="1. Date"></a>1. Date</h5><p>描述时间，精确到毫秒<br>从1970-1-1 0：0：0秒开始</p><h5 id="2-SimpleDateFormat"><a href="#2-SimpleDateFormat" class="headerlink" title="2. SimpleDateFormat"></a>2. SimpleDateFormat</h5><p>把时间变成我们喜欢的格式</p><h5 id="3-Calendar"><a href="#3-Calendar" class="headerlink" title="3. Calendar"></a>3. Calendar</h5><p>代表系统当前时间的日历对象，可以单独修改、获取时间中的年月日</p><h4 id="K-JDK8新增时间相关类"><a href="#K-JDK8新增时间相关类" class="headerlink" title="K. JDK8新增时间相关类"></a>K. JDK8新增时间相关类</h4><table><thead><tr><th>类名</th><th>作用</th></tr></thead><tbody><tr><td>ZoneId</td><td>时区</td></tr><tr><td>Instant</td><td>时间戳</td></tr><tr><td>ZoneDateTime</td><td>带时区的时间</td></tr><tr><td>DateTimeFormatter</td><td>用于时间的格式化和解析</td></tr><tr><td>LocalDate</td><td>年、月、日</td></tr><tr><td>LocalTime</td><td>时、分、秒</td></tr><tr><td>LocalDateTime</td><td>年月日、时分秒</td></tr><tr><td>Duration</td><td>时间间隔(秒，纳秒)</td></tr><tr><td>Period</td><td>时间间隔(年、月、日)</td></tr><tr><td>ChronoUnit</td><td>时间间隔(所有单位)</td></tr></tbody></table><h4 id="L-包装类"><a href="#L-包装类" class="headerlink" title="L. 包装类"></a>L. 包装类</h4><ul><li>把基本数据类型变成引用数据类型，也就是把基本数据类型变成一个对象</li><li>用一个对象把数据包装起来</li></ul><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h4 id="M-Integer"><a href="#M-Integer" class="headerlink" title="M. Integer"></a>M. Integer</h4><ul><li>parseInt(String s)：将字符串参数转为十进制整数</li><li>toString()：将一个整数转换为字符串表示形式。</li><li>valueOf(String s)：将字符串转换为Integer对象。</li><li>intValue()：将Integer对象转换为基本数据类型int。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(str);  <span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> Integer.valueOf(str);  <span class="hljs-comment">// 将字符串转换为Integer对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> integer.toString();  <span class="hljs-comment">// 将Integer对象转换为字符串</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> integer.intValue();  <span class="hljs-comment">// 将Integer对象转换为基本数据类型int</span><br></code></pre></td></tr></table></figure><h2 id="6-基本算法"><a href="#6-基本算法" class="headerlink" title="6. 基本算法"></a>6. 基本算法</h2><h4 id="A-查找"><a href="#A-查找" class="headerlink" title="A. 查找"></a>A. 查找</h4><p>七种查找：基本查找、二分查找、插值查找、斐波那契查找、分块查找、哈希查找、树表查找</p><h5 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">basicSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> number)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] == number) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h5><p>前提条件：数组中的数据必须是<strong>有序的</strong></p><ul><li>min和max表示当前要查找的范围</li><li>mid是在min和max中间的</li><li>如果要查找的元素在mid的左边，缩小范围时，min不变,max&#x3D;mid-1</li><li>如果要查找的元素在mid的右边，缩小范围时，max不变,max&#x3D;mid+1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> number)</span> &#123;<br>     <span class="hljs-comment">//定义两个变量记录要查找的范围</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br><br>     <span class="hljs-comment">//利用循环不断的去找要查找的数据</span><br>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         <span class="hljs-keyword">if</span> (min &gt; max) &#123;<br>             <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-comment">//找到min和max的中间位置</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (min + max) / <span class="hljs-number">2</span>;<br>         <span class="hljs-comment">//拿着mid指向的元素跟要查找的元素进行比较</span><br>         <span class="hljs-keyword">if</span> (arr[mid] &gt; number) &#123;<br>             <span class="hljs-comment">//number在mid的左边</span><br>             max = mid - <span class="hljs-number">1</span>;<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; number) &#123;<br>             <span class="hljs-comment">//number在mid的右边</span><br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> mid;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h5 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="3. 分块查找"></a>3. 分块查找</h5><ul><li>原则：<ol><li>前一块中的最大数据小于后一块中所有数据(块内无序，块间有序)</li><li>块数数量一般等于数字的个数开根号。16个数字分为4左右</li></ol></li><li>核心思路：先确定要查找的元素在哪一块，然后在块内查找<br>要创建一个块类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Block</span> &#123;<br><span class="hljs-comment">/*block的索引，用来标识块中元素*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> index;<br>    <span class="hljs-comment">/*该block的开始位置*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start; <br>    <span class="hljs-comment">/*块元素长度，在该例子中0代表空元素，不计入block长度*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> length;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Block</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.index = index;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.length = length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-排序"><a href="#B-排序" class="headerlink" title="B. 排序"></a>B. 排序</h4><p>十种排序算法：冒泡排序、选择排序、插入排序、快速排序、希尔排序、归并排序、堆排序、基数排序、桶排序、计数排序</p><h5 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h5><p>相邻的数据两两比较，小的在前面，大的放后面</p><ul><li>相邻的元素两两比较，大的放右边，小的放左边</li><li>第一轮比较完毕之后，最大值就已经确定，后面依次类推继续比较</li><li>如果数组有n个数据，总共执行n-1轮代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>            arr[j] = arr[j + <span class="hljs-number">1</span>];<br>            arr[j + <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h5><p>从0索引开始，拿着每一个索引上的元素和后面的元素依次比较，小的放前面，大的放后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &gt; arr[j]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h5><ul><li>把数组分为已排序和未排序两部分</li><li>从第二个元素开始，将未排序元素逐个插入到已排序部分的合适位置，直到整个数组都有序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><span class="hljs-comment">//找到无序的哪一组数组是从哪个索引开始的</span><br><span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>        startIndex = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//遍历从startIndex开始到最后一个元素,依次得到无序的哪一组数据中的每一个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<span class="hljs-comment">//记录当前要插入数据的索引</span><br>    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>        arr[j] = arr[j - <span class="hljs-number">1</span>];<br>        arr[j - <span class="hljs-number">1</span>] = temp;<br>        j--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-递归算法"><a href="#4-递归算法" class="headerlink" title="4. 递归算法"></a>4. 递归算法</h5><ul><li>要有终止条件</li><li>要找到递归方程</li></ul><h5 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h5><ol><li>选择一个基准元素</li><li>将数组分成两部分，小于基准的元素在左边，大于基准的元素在右边。</li><li>递归地对左边和右边的子数组进行快速排序。</li><li>直到子数组的大小为 1 或 0 时停止递归。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-comment">// 获取基准元素的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br>        <br>        <span class="hljs-comment">// 递归排序左边子数组</span><br>        quickSort(arr, low, pivotIndex - <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-comment">// 递归排序右边子数组</span><br>        quickSort(arr, pivotIndex + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 分区函数，返回基准元素的正确位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-comment">// 选择最右边的元素作为基准</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[high];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 遍历数组，调整元素位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low; j &lt; high; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>            i++;<br>            <span class="hljs-comment">// 交换 arr[i] 和 arr[j]</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将基准元素放到正确的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>    arr[i + <span class="hljs-number">1</span>] = arr[high];<br>    arr[high] = temp;<br>    <br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回基准元素的索引</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-Arrays"><a href="#C-Arrays" class="headerlink" title="C. Arrays"></a>C. Arrays</h4><table><thead><tr><th>常用方法</th><th>作用</th></tr></thead><tbody><tr><td>String toString(数组)</td><td>把数组拼接成一个字符串</td></tr><tr><td>int binarySearch(数组,查找的元素)</td><td>二分查找法查找元素</td></tr><tr><td>int[] copyof(原数组,新数组长度)</td><td>拷贝数组</td></tr><tr><td>int[] copyOfRange(原数组,起始索引,结束索引)</td><td>拷贝数组(指定范围)</td></tr><tr><td>void fill(数组,元素)</td><td>填充数组</td></tr><tr><td>void sort(数组)</td><td>按照默认方式进行数组排序</td></tr><tr><td>void sort(数组,排序规则)</td><td>按照指定的规则排序</td></tr></tbody></table><h4 id="D-Lambda表达式"><a href="#D-Lambda表达式" class="headerlink" title="D. Lambda表达式"></a>D. Lambda表达式</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>()对应着方法的形参</li><li>-&gt;固定格式</li><li>{}对应方法的方法体</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">method(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Swim</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swimming</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在游泳 ~~~ &quot;</span>);<br>    &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>转为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">method(<br>    ()-&gt;&#123;<br>        System.out.println(<span class="hljs-string">&quot;正在游泳 ~~~ &quot;</span>);<br>        &#125;<br>);<br></code></pre></td></tr></table></figure><ul><li>使用前提：必须是接口的匿名内部类，接口中只能有一个抽象方法</li></ul><h2 id="7-集合进阶"><a href="#7-集合进阶" class="headerlink" title="7. 集合进阶"></a>7. 集合进阶</h2><h4 id="A-集合体系结构"><a href="#A-集合体系结构" class="headerlink" title="A. 集合体系结构"></a>A. 集合体系结构</h4><ul><li>单列集合(Collection)：每次只能添加一个元素<ul><li>List系列集合:添加的元素是有序、可重复、有索引</li><li>Set系列集合:添加的元素是无序、不重复、无索引</li></ul></li></ul><p><img src="/img/blogs/java/javase/2.7.1.png"></p><p><img src="/img/blogs/java/javase/2.7.2.png"></p><ul><li>双列集合(Map)：每次添加一对元素</li></ul><h4 id="B-Collection"><a href="#B-Collection" class="headerlink" title="B. Collection"></a>B. Collection</h4><p>单列集合的祖宗<strong>接口</strong></p><h5 id="1-常用方法"><a href="#1-常用方法" class="headerlink" title="1. 常用方法"></a>1. 常用方法</h5><table><thead><tr><th>常用方法</th><th>作用</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加</td></tr><tr><td>void clear()</td><td>清空</td></tr><tr><td>boolean remove(E e)</td><td>删除</td></tr><tr><td>boolean contains(Object obj)</td><td>判断是否包含</td></tr><tr><td>boolean isEmpty()</td><td>判断是否为空</td></tr><tr><td>int size()</td><td>集合长度</td></tr></tbody></table><h5 id="2-Collection的遍历方式"><a href="#2-Collection的遍历方式" class="headerlink" title="2. Collection的遍历方式"></a>2. Collection的遍历方式</h5><ul><li><strong>迭代器遍历</strong><br>类是<strong>Iterator</strong>，迭代器是集合专用的遍历方式<br>如果在遍历的过程中需要删除元素，最好使用迭代器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it = list.iterator();<span class="hljs-comment">//创建指针，指向集合第一个位置</span><br><br><span class="hljs-keyword">while</span>(it.hasNext())&#123; <span class="hljs-comment">//循环判断是否有元素</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> it.next();  <span class="hljs-comment">//获取元素，移动指针</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>增强for遍历</strong><br>所有的单列集合和数组才能用增强for遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型 变量名:数组或者集合)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s : list)&#123;<br>    System.out.println(s);   <span class="hljs-comment">//变量s代表集合中每个数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改增强for中的变量s，s是第三方变量，不会改变集合中的原本数据</p><ul><li><strong>lambda表达式遍历</strong></li></ul><h4 id="C-List集合"><a href="#C-List集合" class="headerlink" title="C. List集合"></a>C. List集合</h4><h5 id="1-List集合的特点"><a href="#1-List集合的特点" class="headerlink" title="1. List集合的特点"></a>1. List集合的特点</h5><ul><li>有序：存和取的元素顺序一致</li><li>有索引：可以通过索引操作元素</li><li>可重复：存储的元素可以重复</li></ul><h5 id="2-List集合的特有方法"><a href="#2-List集合的特有方法" class="headerlink" title="2. List集合的特有方法"></a>2. List集合的特有方法</h5><p>增删改查对应的方法</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index, E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的元素,返回被删除的元素</td></tr><tr><td>E set(int index, E element)</td><td>修改指定索引处的元素,返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引处的元素</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>       <span class="hljs-comment">// 1. 增加元素</span><br>       list.add(<span class="hljs-string">&quot;Apple&quot;</span>); <br>       list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>       list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Orange&quot;</span>); <span class="hljs-comment">// 在索引1处插入元素</span><br>       System.out.println(<span class="hljs-string">&quot;添加元素后的列表: &quot;</span> + list); <span class="hljs-comment">// 输出: [Apple, Orange, Banana]</span><br><br>       <span class="hljs-comment">// 2. 删除元素</span><br>       list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// 删除索引1的元素（&quot;Orange&quot;）</span><br>       list.remove(<span class="hljs-string">&quot;Banana&quot;</span>); <span class="hljs-comment">// 删除指定元素（&quot;Banana&quot;）</span><br>       System.out.println(<span class="hljs-string">&quot;删除元素后的列表: &quot;</span> + list); <span class="hljs-comment">// 输出: [Apple]</span><br><br>       <span class="hljs-comment">// 3. 修改元素</span><br>       list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Grapes&quot;</span>); <span class="hljs-comment">// 将索引0的元素修改为&quot;Grapes&quot;</span><br>       System.out.println(<span class="hljs-string">&quot;修改元素后的列表: &quot;</span> + list); <span class="hljs-comment">// 输出: [Grapes]</span><br><br>       <span class="hljs-comment">// 4. 查询元素</span><br>       list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>       list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>       list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;当前列表: &quot;</span> + list); <span class="hljs-comment">// 输出: [Grapes, Apple, Banana, Apple]</span><br></code></pre></td></tr></table></figure><h5 id="3-List集合的遍历方式"><a href="#3-List集合的遍历方式" class="headerlink" title="3. List集合的遍历方式"></a>3. List集合的遍历方式</h5><p>五种遍历方式</p><ul><li>迭代器遍历</li><li>列表迭代器</li><li>普通for循环</li><li>增强for</li><li>Lamada表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      list.add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>      list.add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>      list.add(<span class="hljs-string">&quot;Orange&quot;</span>);<br><br>      <span class="hljs-comment">// 1. 使用 for 循环遍历</span><br>      System.out.println(<span class="hljs-string">&quot;1. 使用 for 循环遍历:&quot;</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>          System.out.println(list.get(i));<br>      &#125;<br><br>      <span class="hljs-comment">// 2. 使用增强 for 循环遍历</span><br>      System.out.println(<span class="hljs-string">&quot;2. 使用增强 for 循环遍历:&quot;</span>);<br>      <span class="hljs-keyword">for</span> (String fruit : list) &#123;<br>          System.out.println(fruit);<br>      &#125;<br><br>      <span class="hljs-comment">// 3. 使用 迭代器Iterator 遍历</span><br>      System.out.println(<span class="hljs-string">&quot;3. 使用 Iterator 遍历:&quot;</span>);<br>      Iterator&lt;String&gt; iterator = list.iterator();<br>      <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>          System.out.println(iterator.next());<br>      &#125;<br><br>      <span class="hljs-comment">// 4. 使用 列表迭代器ListIterator 遍历</span><br>      System.out.println(<span class="hljs-string">&quot;4. 使用 ListIterator 正向遍历:&quot;</span>);<br>      ListIterator&lt;String&gt; listIterator = list.listIterator();<br>      <span class="hljs-keyword">while</span> (listIterator.hasNext()) &#123;<br>          System.out.println(listIterator.next());<br>      &#125;<br><br>      System.out.println(<span class="hljs-string">&quot;4. 使用 ListIterator 反向遍历:&quot;</span>);<br>      <span class="hljs-keyword">while</span> (listIterator.hasPrevious()) &#123;<br>          System.out.println(listIterator.previous());<br>      &#125;<br><br>      <span class="hljs-comment">// 5. 使用 Lamada表达式forEach 方法遍历</span><br>      System.out.println(<span class="hljs-string">&quot;5. 使用 forEach 方法遍历:&quot;</span>);<br>      list.forEach(fruit -&gt; System.out.println(fruit));<br></code></pre></td></tr></table></figure><h4 id="D-ArrayList集合底层原理-动态数组"><a href="#D-ArrayList集合底层原理-动态数组" class="headerlink" title="D. ArrayList集合底层原理(动态数组)"></a>D. ArrayList集合底层原理(动态数组)</h4><ol><li>利用空参创建的集合，在底层会创建一个默认长度为0的数组</li><li>添加第一个元素，底层会创建一个新的长度为10的数组</li><li>存满时，会扩容1.5倍</li><li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li></ol><h4 id="E-LinkedList集合"><a href="#E-LinkedList集合" class="headerlink" title="E. LinkedList集合"></a>E. LinkedList集合</h4><p>底层数据结构是双向链表，查询慢，增删快</p><h4 id="F-泛型"><a href="#F-泛型" class="headerlink" title="F. 泛型"></a>F. 泛型</h4><p>用来检查存储数据的数据类型</p><ul><li>泛型的格式：&lt;数据类型&gt;</li><li>注意：泛型只能支持<strong>引用数据类型</strong></li></ul><h5 id="1-泛型的好处"><a href="#1-泛型的好处" class="headerlink" title="1. 泛型的好处"></a>1. 泛型的好处</h5><ul><li>统一数据类型</li><li>避免强制类型转换可能出现的异常</li></ul><h5 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2. 泛型类"></a>2. 泛型类</h5><p>当一个类中，某个变量的数据类型不确定，就可以定义带有泛型的类<br><code>public class ArrayList&lt;E&gt;{}</code>E理解为变量，代表数据类型</p><h5 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3. 泛型方法"></a>3. 泛型方法</h5><p>当方法中形参类型不确定时<br>    1. 使用类名后面定义的泛型<br>    2. 在方法申明上定义自己的泛型</p><p><code>public&lt;T&gt; void show(T t){}</code>T理解为变量，记录数据类型</p><h5 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4. 泛型接口"></a>4. 泛型接口</h5><p><code>修饰符 interface 接口名&lt;类型&gt;{}</code><br><code>public interface List&lt;E&gt;{}</code></p><h5 id="5-泛型的继承和通配符"><a href="#5-泛型的继承和通配符" class="headerlink" title="5. 泛型的继承和通配符"></a>5. 泛型的继承和通配符</h5><ul><li>泛型不具备继承性，但数据具备继承性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Ye&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Ye</span>());<br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fu</span>());<br>list1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>());<br></code></pre></td></tr></table></figure><p>希望:本方法虽然不确定类型,但是以后我希望只能传递Ye Fu Zi(这三个继承体系的数据类型)</p><p>此时我们就可以使用泛型的通配符:<br>    ?也表示不确定的类型，他可以进行类型的限定<br>    <strong>?extends E</strong>:表示可以传递E或者E所有的子类类型<br>    <strong>?super E</strong>:表示可以传递E或者E所有的父类类型</p><p>应用场景:<br>    1.如果我们在定义类、方法、接口的时候,如果类型不确定,就可以定义泛型类、泛型方法、泛型接口。<br>    2.如果类型不确定,但是能知道以后只能传递某个继承体系中的,就可以泛型的通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(ArrayList&lt;? extends Ye&gt; list)</span>&#123;<br>    <span class="hljs-comment">//此时泛型的数据类型只能是Ye的子类类型(包括Ye,Fu,Zi)</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(ArrayList&lt;? <span class="hljs-built_in">super</span> Fu&gt; list)</span>&#123;<br>    <span class="hljs-comment">//此时泛型的数据类型只能是Fu的父类类型(包括Ye和Fu)</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="G-Set系列集合"><a href="#G-Set系列集合" class="headerlink" title="G. Set系列集合"></a>G. Set系列集合</h4><p>无序、不重复、无索引<br><strong>Set接口的方法和Collection的API一致</strong></p><ul><li><p>无序：存取顺序不一致</p></li><li><p>不重复：可以去除重复</p></li><li><p>无索引：没有带索引的方法，不能用普通for循环遍历</p></li><li><p>HashSet:无序、不重复、无索引</p></li><li><p>LinkedHashSet: <strong>有序</strong>、不重复、无索引</p></li><li><p>TreeSet:<strong>可排序</strong>、不重复、无索引</p></li></ul><h4 id="H-HashSet"><a href="#H-HashSet" class="headerlink" title="H. HashSet"></a>H. HashSet</h4><p>HashSet集合底层采取<strong>哈希表</strong>存储数据<br>哈希表组成：数组+链表+红黑树</p><h5 id="1-哈希值"><a href="#1-哈希值" class="headerlink" title="1. 哈希值"></a>1. 哈希值</h5><ul><li>根据hashCode方法算出来的int类型的整数</li><li>该方法定义在Object类中,所有对象都可以调用,默认使用地址值进行计算</li><li>一般情况下,会重写hashCode方法,利用对象内部的属性值计算哈希值</li></ul><h5 id="2-对象的哈希值特点"><a href="#2-对象的哈希值特点" class="headerlink" title="2. 对象的哈希值特点"></a>2. 对象的哈希值特点</h5><ul><li>如果没有重写hashCode方法,不同对象计算出的哈希值是不同的</li><li>如果已经重写hashcode方法,不同的对象只要属性值相同,计算出的哈希值就是一样的</li><li>在小部分情况下,不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。(哈希碰撞)</li></ul><h5 id="3-HashSet底层原理"><a href="#3-HashSet底层原理" class="headerlink" title="3. HashSet底层原理"></a>3. HashSet底层原理</h5><p><img src="/img/blogs/java/javase/2.7.3.png"></p><h5 id="4-HashSet的三个问题"><a href="#4-HashSet的三个问题" class="headerlink" title="4. HashSet的三个问题"></a>4. HashSet的三个问题</h5><ul><li>问题1：HashSet为什么存和取的顺序不一样<br>  哈希值大小不同，挂在链表上的数据的顺序不一致</li><li>问题2：HashSet为什么没有索引<br>  因为不单单是靠数组存储的，还有链表和红黑树无法确定索引</li><li>问题3：HashSet利用什么机制保证数据去重的<br>  HashCode()方法和equals()方法</li></ul><h4 id="I-LinkedHashSet"><a href="#I-LinkedHashSet" class="headerlink" title="I. LinkedHashSet"></a>I. LinkedHashSet</h4><p><strong>有序</strong>、不重复、无索引<br>底层仍然是哈希表，每个元素额外多加一个双链表的机制记录存储的顺序</p><h4 id="J-TreeSet"><a href="#J-TreeSet" class="headerlink" title="J. TreeSet"></a>J. TreeSet</h4><p>不重复、无索引、<strong>可排序</strong></p><ul><li>可排序：按照元素从小到大排序(因为基于<strong>红黑树</strong>实现)</li></ul><h5 id="1-TreeSet集合排序规则"><a href="#1-TreeSet集合排序规则" class="headerlink" title="1. TreeSet集合排序规则"></a>1. TreeSet集合排序规则</h5><ul><li>对于数值类型:Integer,Double,默认按照从小到大的顺序进行排序。</li><li>对于字符、字符串类型:按照字符在<strong>ASCII码表</strong>中的数字升序进行排序。</li></ul><h5 id="2-TreeSet的两种比较规则"><a href="#2-TreeSet的两种比较规则" class="headerlink" title="2. TreeSet的两种比较规则"></a>2. TreeSet的两种比较规则</h5><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><p>默认排序：Javabean类实现Comparable接口指定比较规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建三个学生对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>( name: <span class="hljs-string">&quot;zhangsan&quot;</span>, age: <span class="hljs-number">23</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>( name: <span class="hljs-string">&quot;lisi&quot;</span>, age: <span class="hljs-number">24</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>( name: <span class="hljs-string">&quot;wangwu&quot;</span>, age: <span class="hljs-number">25</span>);<br><span class="hljs-comment">//2.创建集合对象</span><br>TreeSet&lt;Student&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br><span class="hljs-comment">//3.添加元素</span><br>ts.add(s1);<br>ts.add(s2);<br>ts.add(s3);<br><span class="hljs-comment">//4.打印集合</span><br>System.out.println(ts);<span class="hljs-comment">//23,24,25</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>    <span class="hljs-comment">//指定排序的规则</span><br>    <span class="hljs-comment">//只看年龄,我想要按照年龄的升序进行排列</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAge() - o.getAge();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>this:表示当前要添加的元素</li><li>o:表示已经在红黑树存在的元素</li><li>返回值:<br>  负数:认为要添加的元素是小的,存左边<br>  正数:认为要添加的元素是大的,存右边<br>  0:认为要添加的元素已经存在,舍弃</li></ul><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><p>比较器排序：创建TreeSet对象时，传递比较器Comparator指定规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 要求:存入四个字符串,“c”,“ab”,“df”,&quot;qwer”</span><br><span class="hljs-comment">//按照长度排序,如果一样长则按照首字母排序</span><br>TreeSet&lt;String&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span>&#123;<br>         <span class="hljs-comment">// 按照长度排序</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> o1.length() - o2.length();<br>         <span class="hljs-comment">//如果一样长则按照首字母排序</span><br>         i = i == <span class="hljs-number">0</span> ? o1.compareTo(o2) : i;<br>         <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="K-单列集合总结"><a href="#K-单列集合总结" class="headerlink" title="K. 单列集合总结"></a>K. 单列集合总结</h4><ol><li>如果想要集合中的元素可重复<br> 用ArrayList集合,基于数组的。(用的最多)</li><li>如果想要集合中的元素可重复,而且当前的<strong>增删操作明显多于查询</strong><br>用LinkedList集合,基于链表的。</li><li>如果想对集合中的元素<strong>去重</strong><br>用HashSet集合,基于哈希表的。(用的最多)</li><li>如果想对集合中的元素<strong>去重</strong>,而且<strong>保证存取顺序</strong><br>用LinkedHashSet集合,基于哈希表和双链表,效率低于HashSet。</li><li>如果想对集合中的元素进行<strong>排序</strong><br>用TreeSet集合,基于红黑树。后续也可以用List集合实现排序。</li></ol><h4 id="L-双列集合的特点"><a href="#L-双列集合的特点" class="headerlink" title="L. 双列集合的特点"></a>L. 双列集合的特点</h4><ul><li>双列集合一次需要存一对数据,分别为键和值</li><li>键不能重复,值可以重复</li><li>键和值是一一对应的,每一个键只能找到自己对应的值</li><li>键+值这个整体 我们称之为“键值对”或者“键值对对象”,在Java中叫做“<strong>Entry对象</strong>”</li></ul><p><img src="/img/blogs/java/javase/2.7.4.png"></p><h4 id="M-Map集合"><a href="#M-Map集合" class="headerlink" title="M. Map集合"></a>M. Map集合</h4><p>Map是双列集合的顶层接口，功能是全部双列集合都可以继承的</p><h5 id="1-Map常见API"><a href="#1-Map常见API" class="headerlink" title="1. Map常见API"></a>1. Map常见API</h5><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>V put(K key,V value)</td><td>添加元素</td></tr><tr><td>V remove(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void clear()</td><td>移除所有的键值对元素</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度,也就是集合中键值对的个数</td></tr></tbody></table><ul><li>put(): 添加数据时，如果键是存在的，则会把原有的键值对对象覆盖，返回被覆盖的值</li></ul><h5 id="2-Map的遍历方式-键找值"><a href="#2-Map的遍历方式-键找值" class="headerlink" title="2. Map的遍历方式(键找值)"></a>2. Map的遍历方式(键找值)</h5><p>将键放在单列集合中，通过单列集合依次遍历找值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建Map集合的对象</span><br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">//2.添加元素</span><br>map.put(<span class="hljs-string">&quot;尹志平&quot;</span>,<span class="hljs-string">&quot;小龙女&quot;</span>);<br>map.put(<span class="hljs-string">&quot;郭靖&quot;</span>,<span class="hljs-string">&quot;穆念慈&quot;</span>);<br>map.put(<span class="hljs-string">&quot;欧阳克&quot;</span>,<span class="hljs-string">&quot;黄蓉&quot;</span>);<br><br><span class="hljs-comment">//3.1获取所有的键,把这些键放到一个单列集合当中</span><br>Set&lt;String&gt; keys = map.keySet();<br><span class="hljs-comment">//3.2遍历单列集合,得到每一个键</span><br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br>    <span class="hljs-comment">//3.3 利用map集合中的键获取对应的值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br>    System.out.println(key + <span class="hljs-string">&quot; = &quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-Map的遍历方式-键值对"><a href="#3-Map的遍历方式-键值对" class="headerlink" title="3. Map的遍历方式(键值对)"></a>3. Map的遍历方式(键值对)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建Map集合的对象</span><br>Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">//2.添加元素</span><br>map.put(<span class="hljs-string">&quot;标枪选手&quot;</span>,<span class="hljs-string">&quot;马超&quot;</span>);<br>map.put(<span class="hljs-string">&quot;人物挂件&quot;</span>,<span class="hljs-string">&quot;明世隐&quot;</span>);<br>map.put(<span class="hljs-string">&quot;御龙骑士&quot;</span>,<span class="hljs-string">&quot;尹志平&quot;</span>);<br><br><span class="hljs-comment">//通过键值对对象进行遍历</span><br><span class="hljs-comment">//3.1 通过一个方法获取所有的键值对对象,返回一个Set集合</span><br>Set&lt;Map. Entry&lt;String, String&gt;&gt; entries = map.entrySet();<br><span class="hljs-comment">//3.2 遍历entries这个集合,去得到里面的每一个键值对对象</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;<br>    <span class="hljs-comment">//3.3 利用entry调用get方法获取键和值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> entry.getValue();<br>    System.out.println(key + <span class="hljs-string">&quot;=&quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="N-HashMap"><a href="#N-HashMap" class="headerlink" title="N. HashMap"></a>N. HashMap</h4><p>是Map里面的一个实现类<br>由键决定：无序、不重复、无索引</p><h5 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h5><ul><li>HashMap底层是<strong>哈希表</strong>结构的(与HashSet一样)</li><li>依赖hashCode方法和equals方法保证键的唯一</li><li>如果键存储的是自定义对象，需要重写hashCode和equals方法</li><li>如果值存储自定义对象,不需要重写hashCode和equals方法</li></ul><h4 id="O-LinkedHashMap"><a href="#O-LinkedHashMap" class="headerlink" title="O. LinkedHashMap"></a>O. LinkedHashMap</h4><p>由键决定：<strong>有序</strong>、不重复、无索引</p><ul><li>有序：保证存储和取出的元素顺序一致(额外加了一个双链表机制记录存储的顺序)</li></ul><h4 id="P-TreeMap"><a href="#P-TreeMap" class="headerlink" title="P. TreeMap"></a>P. TreeMap</h4><p>TreeMap跟TreeSet底层原理一样,都是<strong>红黑树</strong>结构的。<br>由键决定特性:不重复、无索引、可排序</p><ul><li>可排序:<strong>对键进行排序</strong></li><li>注意:默认按照键的从小到大进行排序,也可以自己规定键的排序规则<ul><li>实现Comparable接口,指定比较规则。</li><li>创建集合时传递Comparator比较器对象,指定比较规则。</li></ul></li></ul><h5 id="统计字符串中每一个字符出现的次数"><a href="#统计字符串中每一个字符出现的次数" class="headerlink" title="统计字符串中每一个字符出现的次数"></a>统计字符串中每一个字符出现的次数</h5><p>可以使用HashMap或者TreeMap进行统计；</p><ul><li>键：代表要统计的内容</li><li>值：表示次数</li><li>如果题目中没有要求对结果进行排序使用HashMap，要排序的话使用TreeMap</li></ul><h4 id="Q-可变参数"><a href="#Q-可变参数" class="headerlink" title="Q. 可变参数"></a>Q. 可变参数</h4><p>方法的形参的个数是可以变化的<br>格式：<code>属性类型...名字</code><br><code>int...args</code><br><code>public static int getSum(int...args){}</code></p><ul><li>形参列表中可变参数只能有一个</li><li>可变参数必须放在形参列表的最后面</li></ul><h4 id="R-Collections"><a href="#R-Collections" class="headerlink" title="R. Collections"></a>R. Collections</h4><p>Collections不是集合，是集合的工具类</p><table><thead><tr><th>常用方法</th><th>作用</th></tr></thead><tbody><tr><td>public static <T> boolean addAll(Collection<T> c, T… elements)</td><td>批量添加元素</td></tr><tr><td>public static void shuffle(List&lt;?&gt; list)</td><td>打乱List集合元素的顺序</td></tr></tbody></table><h4 id="S-不可变集合"><a href="#S-不可变集合" class="headerlink" title="S. 不可变集合"></a>S. 不可变集合</h4><p>不可以被修改的集合，长度不能变，内容不能变(只能查询，不能增删改)</p><ul><li>List、Set、Map接口中,都存在静态的<strong>of</strong>方法可以创建不可变集合</li></ul><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>static <E> List<E> of(E…elements)</td><td>创建一个具有指定元素的List集合对象</td></tr><tr><td>static <E> Set<E> of(E…elements)</td><td>创建一个具有指定元素的Set集合对象</td></tr><tr><td>static &lt;K, V&gt; Map&lt;K, V&gt; of(E…elements)</td><td>创建一个具有指定元素的Map集合对象</td></tr></tbody></table><p>三种方式的细节</p><ul><li>List: 直接用</li><li>Set:元素不能重复</li><li>Map:元素不能重复、键值对数量最多是10个。<ul><li>超过10个用ofEntries方法</li></ul></li></ul><h2 id="8-数据结构"><a href="#8-数据结构" class="headerlink" title="8. 数据结构"></a>8. 数据结构</h2><p>数据结构是计算机底层存储、组织数据的方式</p><h4 id="A-栈"><a href="#A-栈" class="headerlink" title="A. 栈"></a>A. 栈</h4><p>后进先出，先进后出</p><h4 id="B-队列"><a href="#B-队列" class="headerlink" title="B. 队列"></a>B. 队列</h4><p>先进先出，后进后出</p><h4 id="C-数组"><a href="#C-数组" class="headerlink" title="C. 数组"></a>C. 数组</h4><p>元素在内存中是连续存储的</p><ul><li>查询速度快：查询数据通过地址值和索引定位</li><li>删除效率低：要将数据删除需将后面所有数据前移</li><li>添加效率低：添加一个数据，后面所有数据都要后移</li></ul><h4 id="D-链表"><a href="#D-链表" class="headerlink" title="D. 链表"></a>D. 链表</h4><p>每个节点都是独立的对象，在内存中不连续；每个节点包含数据值和下一个节点的地址</p><ul><li>查询慢：要从链表头节点开始查询</li><li>增删快</li></ul><h4 id="E-树"><a href="#E-树" class="headerlink" title="E. 树"></a>E. 树</h4><p>父节点，左子节点，右子节点，左子树，右子树</p><ul><li>度：每个节点的子节点数量(二叉树的度小于等于2&gt;)</li><li>树高：树的总层数</li><li>根节点：最顶层的节点</li></ul><h5 id="1-二叉查找树"><a href="#1-二叉查找树" class="headerlink" title="1. 二叉查找树"></a>1. 二叉查找树</h5><ul><li>任意节点左子树上的值都小于当前节点</li><li>任意节点右子树上的值都大于当前节点</li></ul><p><img src="/img/blogs/java/javase/2.8.1.png"></p><ol><li>添加节点</li></ol><ul><li>小的存左边</li><li>大的存右边</li><li>一样的不存</li></ul><ol start="2"><li>查找节点<br>小的在左边，大的在右边</li></ol><h5 id="2-二叉树的遍历方式"><a href="#2-二叉树的遍历方式" class="headerlink" title="2. 二叉树的遍历方式"></a>2. 二叉树的遍历方式</h5><p>前序遍历，中序遍历，后序遍历，层序遍历</p><ol><li>前序遍历(根左右)<br>从根节点开始，依次按照当前节点，左子节点，右子节点顺序遍历</li><li>中序遍历(左根右)<br>从左子节点开始，依次按照左子节点，当前节点，右子节点顺序遍历</li><li>后序遍历(左右根)<br>从左子节点开始，依次按照左子节点，右子节点，当前节点顺序遍历</li><li>层序遍历<br>从根节点开始一层一层的遍历</li></ol><h5 id="3-平衡二叉树"><a href="#3-平衡二叉树" class="headerlink" title="3. 平衡二叉树"></a>3. 平衡二叉树</h5><p>查找效率更高<br>任意节点左右子树高度差不超过1 (旋转机制)</p><h6 id="平衡二叉树的左旋"><a href="#平衡二叉树的左旋" class="headerlink" title="平衡二叉树的左旋"></a>平衡二叉树的左旋</h6><p><img src="/img/blogs/java/javase/2.8.2.png"></p><p><img src="/img/blogs/java/javase/2.8.3.png"></p><h6 id="平衡二叉树的右旋"><a href="#平衡二叉树的右旋" class="headerlink" title="平衡二叉树的右旋"></a>平衡二叉树的右旋</h6><p><img src="/img/blogs/java/javase/2.8.4.png"></p><p><img src="/img/blogs/java/javase/2.8.5.png"></p><h6 id="平衡二叉树需要旋转的四种情况"><a href="#平衡二叉树需要旋转的四种情况" class="headerlink" title="平衡二叉树需要旋转的四种情况"></a>平衡二叉树需要旋转的四种情况</h6><p>左左、左右、右右、右左</p><ol><li>左左(一次右旋)：当根节点左子树的左子树有节点插入，导致二叉树不平衡</li><li>左右(先局部左旋，再整体右旋)：当根节点左子树的右子树有节点插入，导致二叉树不平衡</li><li>右右(一次左旋)：当根节点右子树的右子树有节点插入，导致二叉树不平衡</li><li>右左(先局部右旋，再整体左旋)：当根节点右子树的左子树有节点插入，导致二叉树不平衡</li></ol><h5 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h5><p>是一种特殊的二叉查找树，每个节点都有存储位表示节点的颜色(红或黑)</p><ul><li>是二叉查找树</li><li>但不是高度平衡的</li><li>特有的红黑规则</li></ul><p>红黑规则：</p><p><img src="/img/blogs/java/javase/2.8.6.png"></p><p>添加节点的规则：<br>    默认颜色：添加节点默认是红色的(效率高)</p><p><img src="/img/blogs/java/javase/2.8.7.png"></p><h2 id="9-Stream流"><a href="#9-Stream流" class="headerlink" title="9. Stream流"></a>9. Stream流</h2><h4 id="A-Stream流介绍"><a href="#A-Stream流介绍" class="headerlink" title="A. Stream流介绍"></a>A. Stream流介绍</h4><ul><li>作用: 结合Lambda表达式，简化集合、数组的操作</li><li>使用步骤：<ol><li>先得到一条Stream流(流水线)，并把数据放上去</li><li>利用Stream流的API进行操作<ul><li>中间方法(过滤 转换)：方法调用完毕之后，还可以调用其他方法</li><li>终结方法(统计 打印): 最后一步，调用完毕之后，不能调用其他方法</li></ul></li><li>使用中间方法对流水线上的数据进行操作</li><li>使用终结方法对流水线上的数据进行操作</li></ol></li></ul><h4 id="B-获取Stream流"><a href="#B-获取Stream流" class="headerlink" title="B. 获取Stream流"></a>B. 获取Stream流</h4><table><thead><tr><th>获取方式</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>单列集合</td><td>default Stream<E> stream()</td><td>Collection中的默认方法</td></tr><tr><td>双列集合</td><td>无</td><td>无法直接使用stream流</td></tr><tr><td>数组</td><td>public static <T> Stream<T> stream(T[] array)</td><td>Arrays工具类中的静态方法</td></tr><tr><td>一堆零散数据</td><td>public static<T> Stream<T> of(T … values)</td><td>Stream接口中的静态方法</td></tr></tbody></table><ul><li>单列集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAlL(list, <span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>);<br>list.stream().forEach(s -&gt; System.out.println(s));<span class="hljs-comment">//获取</span><br></code></pre></td></tr></table></figure><ul><li>双列集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建双列集合</span><br>HashMap&lt;String, Integer&gt; hm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//2.添加数据</span><br>hm.put(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">111</span>);<br>hm.put(<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-number">222</span>);<br>hm.put(<span class="hljs-string">&quot;ccc&quot;</span>,<span class="hljs-number">333</span>);<br>hm.put(<span class="hljs-string">&quot;ddd&quot;</span>,<span class="hljs-number">444</span>);<br><br><span class="hljs-comment">//3.第一种获取stream流</span><br>hm.keySet().stream().forEach(s -&gt; System.out.println(s));<br><span class="hljs-comment">//4.第二种获取stream流</span><br>hm. entrySet().stream().forEach(s-&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><ul><li>数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建数组</span><br><span class="hljs-type">int</span>[] arr1= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br>String[] arr2 = &#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-comment">//2.获取stream流</span><br>Arrays.stream(arr1).forEach(s-&gt; System.out.println(s));<br>Arrays.stream(arr2).forEach(s-&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><ul><li>零散数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>).forEach(s-&gt; System.out.println(s));<br>Stream.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>).forEach(s-&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><h4 id="C-Stream流的中间方法"><a href="#C-Stream流的中间方法" class="headerlink" title="C. Stream流的中间方法"></a>C. Stream流的中间方法</h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>Stream<T> filter(Predicate&lt;? super T&gt; predicate)</td><td>过滤</td></tr><tr><td>Stream<T> limit(long maxSize)</td><td>获取前几个元素</td></tr><tr><td>Stream<T> skip(long n)</td><td>跳过前几个元素</td></tr><tr><td>Stream<T> distinct()</td><td>元素去重,依赖(hashCode和equals方法)</td></tr><tr><td>static <T> Stream<T> concat(Stream a, Stream b)</td><td>合并a和b两个流为一个流</td></tr><tr><td>Stream<R> map(Function&lt;T, R&gt; mapper)</td><td>转换流中的数据类型</td></tr></tbody></table><ul><li>注意1: 中间方法,返回新的Stream流,原来的Stream流只能使用一次,建议使用链式编程</li><li>注意2: 修改Stream流中的数据,不会影响原来集合或者数组中的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到集合中以张开头并且是三个字的姓名</span><br>list.stream()<br>    .filter(s -&gt; s.startsWith(<span class="hljs-string">&quot;张&quot;</span>))<br>    .filter(s -&gt; s.length() == <span class="hljs-number">3</span>)<br>    .forEach(s -&gt; System.out.println(s));<br><br>list.stream().limit(<span class="hljs-number">3</span>).forEach(s -&gt; System.out.println(s)); <span class="hljs-comment">//获取集合前三个元素</span><br>list.stream().skip(<span class="hljs-number">4</span>) .forEach(s -&gt; System.out.println(s));<span class="hljs-comment">//跳过前四个元素</span><br><br><br>list1.stream().distinct().forEach(s -&gt; System.out.println(s));<span class="hljs-comment">//对list1集合去重</span><br>Stream.concat(list1.stream(),list2.stream()).forEach(s -&gt; System.out.println(s));<span class="hljs-comment">//合并list1和list2集合</span><br><br>list.stream()<br>    .map(s-&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;-&quot;</span>) [<span class="hljs-number">1</span>]))<br>    .forEach(s-&gt; System.out.println(s));<span class="hljs-comment">//将集合中-之后的数字提取出来打印</span><br></code></pre></td></tr></table></figure><h4 id="D-Stream流的终结方法"><a href="#D-Stream流的终结方法" class="headerlink" title="D. Stream流的终结方法"></a>D. Stream流的终结方法</h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void forEach(Consumer action)</td><td>遍历</td></tr><tr><td>long count()</td><td>统计</td></tr><tr><td>toArray()</td><td>收集流中的数据,放到数组中</td></tr><tr><td>collect(Collector collector)</td><td>收集流中的数据,放到集合中(List Set Map)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">list.stream().forEach(s -&gt; System.out.println(s)); <span class="hljs-comment">//遍历打印</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.stream().count();<span class="hljs-comment">//统计集合元素个数</span><br><br>Object[] arr1 = list.stream().toArray();<span class="hljs-comment">//收集流中的数据放在数组中</span><br></code></pre></td></tr></table></figure><ul><li>collect方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我要把所有的男性收集起来</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-string">&quot;张无忌-男-15&quot;</span>,<span class="hljs-string">&quot;周芷若-女-14&quot;</span>,<span class="hljs-string">&quot;赵敏-女-13&quot;</span>,<span class="hljs-string">&quot;张强-男-20&quot;</span>,<span class="hljs-string">&quot;张三丰-男-100&quot;</span>,<span class="hljs-string">&quot;张翠山-男-40&quot;</span>,<span class="hljs-string">&quot;张良-男-35&quot;</span>,<span class="hljs-string">&quot;王二麻子-男-37&quot;</span>,<span class="hljs-string">&quot;谢广坤-男-41&quot;</span>);<br><br><span class="hljs-comment">//收集List集合当中</span><br>List&lt;String&gt; newList1 = list.stream()<br>    .filter(s -&gt; <span class="hljs-string">&quot;男&quot;</span>.equals(s.split(<span class="hljs-string">&quot;-&quot;</span>) [<span class="hljs-number">1</span>]))<br>    .collect(Collectors.toList());<br><br><span class="hljs-comment">//收集Set集合当中,会去重</span><br>Set&lt;String&gt; newList2 = list.stream().filter(s -&gt; <span class="hljs-string">&quot;男&quot;</span>.equals(s.split(<span class="hljs-string">&quot;-&quot;</span>) [<span class="hljs-number">1</span>]))<br>    .collect(Collectors.toSet());<br><br><span class="hljs-comment">//收集到Map集合中，键对应名字，值对应年龄</span><br>Map&lt;String, Integer&gt; map2 = list.stream()<br>    .filter(s -&gt; <span class="hljs-string">&quot;y&#x27;&quot;</span>.equals(s.split(<span class="hljs-string">&quot;-&quot;</span>) [<span class="hljs-number">1</span>]))<br>    .collect(Collectors.toMap(<br>        s -&gt; s.split(<span class="hljs-string">&quot;-&quot;</span>) [<span class="hljs-number">0</span>],<br>        s -&gt; Integer.parseInt(s.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">2</span>])));<br></code></pre></td></tr></table></figure><h2 id="10-方法引用"><a href="#10-方法引用" class="headerlink" title="10. 方法引用"></a>10. 方法引用</h2><p>把已经有的方法拿过来用，当做函数式接口中抽象方法的方法体</p><ol><li>引用处需要是函数式接口</li><li>被引用的方法需要已经存在</li><li>被引用方法的形参和返回值需要跟抽象方法的形参和返回值保持一致</li></ol><h4 id="A-引用静态方法"><a href="#A-引用静态方法" class="headerlink" title="A. 引用静态方法"></a>A. 引用静态方法</h4><p>格式： <code>类名::静态方法</code><br>示例： <code>Integer::parseInt</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将集合中数字变成int类型</span><br><span class="hljs-comment">//1.创建集合并添加元素</span><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br><br>list.stream()<br>    .map(Integer::parseInt)<br>    .forEach(s-&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><h4 id="B-引用成员方法"><a href="#B-引用成员方法" class="headerlink" title="B. 引用成员方法"></a>B. 引用成员方法</h4><p>格式： <code>对象::成员方法</code></p><ol><li>其他类:<code>其他类对象::方法名</code></li><li>本类:<code>this::方法名</code>(引用处不能是静态方法)</li><li>父类:<code>super::方法名</code>(引用处不能是静态方法)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringOperation</span> <span class="hljs-variable">so</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringOperation</span>();<br>list.stream().filter(so::stringJudge)  <span class="hljs-comment">//调用StringOperation类中的stringJudge方法</span><br>    .forEach(s-&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><h4 id="C-引用构造方法"><a href="#C-引用构造方法" class="headerlink" title="C. 引用构造方法"></a>C. 引用构造方法</h4><p>格式： <code>类名::new</code><br>示例： <code>Student::new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list, <span class="hljs-string">&quot;张无忌,15&quot;</span>,<span class="hljs-string">&quot;周芷若,14&quot;</span>,<span class="hljs-string">&quot;赵敏,13&quot;</span>)<br><br><span class="hljs-comment">//封装成Student对象并收集到List集合中</span><br>List&lt;Student&gt; newList2 = list.stream().map(Student::<span class="hljs-keyword">new</span>).collect(Collectors.tolist());<br>System.out.println(newList2);<br></code></pre></td></tr></table></figure><h4 id="D-类名引用成员方法"><a href="#D-类名引用成员方法" class="headerlink" title="D. 类名引用成员方法"></a>D. 类名引用成员方法</h4><p>格式： <code>类名::成员方法</code><br>示例： <code>String::substring</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>);<br><br><span class="hljs-comment">//拿着流里面的每一个数据,去调用String类中的toUpperCase方法,方法的返回值就是转换之后的结果。|</span><br>list.stream().map(String::toUpperCase).forEach(s -&gt; System.out.println(s));<br></code></pre></td></tr></table></figure><h4 id="E-引用数组的构造方法"><a href="#E-引用数组的构造方法" class="headerlink" title="E. 引用数组的构造方法"></a>E. 引用数组的构造方法</h4><p>格式： <code>数据类型[]::new</code><br>示例： <code>int[]::new</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//收集到数组当中</span><br>Integer[] arr2 = list.stream().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br>System.out.println(Arrays.toString(arr2));<br></code></pre></td></tr></table></figure><h1 id="三-JAVA核心"><a href="#三-JAVA核心" class="headerlink" title="三. JAVA核心"></a>三. JAVA核心</h1><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h2><h4 id="A-异常体系介绍"><a href="#A-异常体系介绍" class="headerlink" title="A. 异常体系介绍"></a>A. 异常体系介绍</h4><p>异常(Exception)就是程序出现的问题</p><p><img src="/img/blogs/java/javase/3.1.1.png"></p><h4 id="B-编译时异常和运行时异常"><a href="#B-编译时异常和运行时异常" class="headerlink" title="B. 编译时异常和运行时异常"></a>B. 编译时异常和运行时异常</h4><p><img src="/img/blogs/java/javase/3.1.2.png"></p><ul><li>编译时异常：为了提醒程序员代码有问题</li><li>运行时异常(仅有RuntimeException)：代码运行出错产生异常</li></ul><h4 id="C-异常的作用"><a href="#C-异常的作用" class="headerlink" title="C. 异常的作用"></a>C. 异常的作用</h4><ol><li>用来查询bug的关键参考信息</li><li>可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况</li></ol><h4 id="D-异常的处理方式"><a href="#D-异常的处理方式" class="headerlink" title="D. 异常的处理方式"></a>D. 异常的处理方式</h4><h5 id="1-JVM默认处理方式"><a href="#1-JVM默认处理方式" class="headerlink" title="1. JVM默认处理方式"></a>1. JVM默认处理方式</h5><p>在控制台提示异常问题，代码不在运行</p><h5 id="2-自己处理-捕获异常try…catch"><a href="#2-自己处理-捕获异常try…catch" class="headerlink" title="2. 自己处理(捕获异常try…catch)"></a>2. 自己处理(捕获异常try…catch)</h5><p>当代码出现异常，<strong>可以让程序继续往下执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    可能出现异常的代码;<br>&#125;<span class="hljs-keyword">catch</span>(异常类名 变量名)&#123;<br>    异常的处理代码;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">try</span>&#123;<br>    System.out.println(arr[<span class="hljs-number">10</span>]);    <span class="hljs-comment">//可能出现异常的代码;</span><br>&#125;<span class="hljs-keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;<br>    <span class="hljs-comment">//如果出现了ArrayIndexOutOfBoundsException异常,我该如何处理</span><br>    System.out.println(<span class="hljs-string">&quot;索引越界了&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;看看我执行了吗?&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="3-自己处理-灵魂四问"><a href="#3-自己处理-灵魂四问" class="headerlink" title="3. 自己处理(灵魂四问)"></a>3. 自己处理(灵魂四问)</h5><p><strong>灵魂一问:如果try中没有遇到问题,怎么执行?</strong><br>    正常执行</p><p><strong>灵魂二问:如果try中可能会遇到多个问题,怎么执行?</strong><br>    会写多个catch与之对应<br>细节:如果我们要捕获多个异常,这些异常中如果存在父子关系的话,那么父类一定要写在下面</p><p><strong>灵魂三问:如果try中遇到的问题没有被捕获,怎么执行?</strong><br>    相当于try..catch白写了，最终交给虚拟机处理</p><p><strong>灵魂四问:如果try中遇到了问题,那么try下面的其他代码还会执行吗?</strong><br>    下面的代码就不会执行了,直接跳转到对应的catch当中,执行catch里面的语句体</p><h5 id="4-抛出处理-throw和throws"><a href="#4-抛出处理-throw和throws" class="headerlink" title="4. 抛出处理(throw和throws)"></a>4. 抛出处理(throw和throws)</h5><p><strong>throws</strong><br>写在方法定义处，表示声明一个异常,编译时异常必须要写<br><code>public void 方法()throws 异常类名1,异常类名2 ... {}</code></p><p><strong>throw</strong><br>写在方法中，结束方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">void</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//下面代码就不执行了</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="E-异常的常见方法"><a href="#E-异常的常见方法" class="headerlink" title="E. 异常的常见方法"></a>E. 异常的常见方法</h4><p>Throwable的成员方法<br>    public void printStackTrace(): 把异常的错误信息输出在控制台</p><h4 id="F-自定义异常"><a href="#F-自定义异常" class="headerlink" title="F. 自定义异常"></a>F. 自定义异常</h4><p>为了让控制台的报错信息见名知意</p><ol><li>定义异常类</li><li>写继承关系</li><li>空参构造和带参构造</li></ol><h2 id="2-File"><a href="#2-File" class="headerlink" title="2. File"></a>2. File</h2><p>File对象表示路径，可以是文件和文件夹</p><h4 id="A-File类的构造方法"><a href="#A-File类的构造方法" class="headerlink" title="A. File类的构造方法"></a>A. File类的构造方法</h4><table><thead><tr><th>构造方法</th><th>作用</th></tr></thead><tbody><tr><td>public File(String pathname)</td><td>根据文件路径创建文件对象</td></tr><tr><td>public File(String parent, String child)</td><td>根据父路径名字符串和子路径名字符串创建文件对象</td></tr><tr><td>public File(File parent, String child)</td><td>根据父路径对应文件对象和子路径名字符串创建文件对象</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.根据字符串表示的路径,变成File对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\alienware\\Desktop\\a.txt&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(str);<br>System.out.println(f1);<br><br><span class="hljs-comment">//2.父级路径:C:\Users\alienware\Desktop</span><br><span class="hljs-comment">//子级路径:a.txt</span><br><span class="hljs-type">String</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\alienware\\Desktop&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a.txt&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parent, child);<br>System.out.println(f2);<br><br><span class="hljs-comment">//3.把一个File表示的路径和String表示路径进行拼接</span><br><span class="hljs-type">File</span> <span class="hljs-variable">parent2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C:\\Users\\alienware\\Desktop&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">child2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a.txt&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">f4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parent2,child2);<br>System.out.println(f4);<br></code></pre></td></tr></table></figure><h4 id="B-File类的常见成员方法"><a href="#B-File类的常见成员方法" class="headerlink" title="B. File类的常见成员方法"></a>B. File类的常见成员方法</h4><h5 id="1-判断和获取"><a href="#1-判断和获取" class="headerlink" title="1. 判断和获取"></a>1. 判断和获取</h5><table><thead><tr><th>常见方法</th><th>作用</th></tr></thead><tbody><tr><td>public boolean isDirectory()</td><td>判断此路径名表示的File是否为文件夹</td></tr><tr><td>public boolean isFile()</td><td>判断此路径名表示的File是否为文件</td></tr><tr><td>public boolean exists()</td><td>判断此路径名表示的File是否存在</td></tr><tr><td>public long length()</td><td>返回文件的大小(字节数量)</td></tr><tr><td>public String getAbsolutePath()</td><td>返回文件的绝对路径</td></tr><tr><td>public String getPath()</td><td>返回定义文件时使用的路径</td></tr><tr><td>public String getName()</td><td>返回文件的名称,带后缀</td></tr><tr><td>public long lastModified()</td><td>返回文件的最后修改时间(时间毫秒值)</td></tr></tbody></table><h5 id="2-创建和删除"><a href="#2-创建和删除" class="headerlink" title="2. 创建和删除"></a>2. 创建和删除</h5><table><thead><tr><th>常见方法</th><th>作用</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建一个新的空的文件</td></tr><tr><td>public boolean mkdir()</td><td>创建单级文件夹</td></tr><tr><td>public boolean mkdirs()</td><td>创建多级文件夹</td></tr><tr><td>public boolean delete()</td><td>删除文件、空文件夹</td></tr></tbody></table><h5 id="3-获取并遍历"><a href="#3-获取并遍历" class="headerlink" title="3. 获取并遍历"></a>3. 获取并遍历</h5><table><thead><tr><th>常见方法</th><th>作用</th></tr></thead><tbody><tr><td>public File[] listFiles()</td><td>获取当前该路径下所有内容</td></tr></tbody></table><h2 id="3-IO流"><a href="#3-IO流" class="headerlink" title="3. IO流"></a>3. IO流</h2><h4 id="A-IO流的概述"><a href="#A-IO流的概述" class="headerlink" title="A. IO流的概述"></a>A. IO流的概述</h4><p>用于读写文件中的数据<br>输出流(output)： 程序–&gt;文件<br>输入流(input)： 文件–&gt;程序</p><p><img src="/img/blogs/java/javase/3.3.1.png"></p><h4 id="B-IO流的体系"><a href="#B-IO流的体系" class="headerlink" title="B. IO流的体系"></a>B. IO流的体系</h4><p><img src="/img/blogs/java/javase/3.3.2.png"></p><h4 id="C-字节输出流-FileOutputStream"><a href="#C-字节输出流-FileOutputStream" class="headerlink" title="C. 字节输出流(FileOutputStream)"></a>C. 字节输出流(FileOutputStream)</h4><p>操作本地文件的字节输出流，可以把程序中的数据写出到本地文件中</p><h5 id="1-书写步骤："><a href="#1-书写步骤：" class="headerlink" title="1. 书写步骤："></a>1. 书写步骤：</h5><ol><li>创建字节输出流对象</li><li>写数据</li><li>释放资源</li></ol><h5 id="2-字节输出流的细节"><a href="#2-字节输出流的细节" class="headerlink" title="2. 字节输出流的细节:"></a>2. 字节输出流的细节:</h5><ol><li>创建字节输出流对象<br> 细节1:参数是字符串表示的路径或者是File对象都是可以的<br> 细节2:如果文件不存在会创建一个新的文件,但是要保证父级路径是存在的。<br> 细节3:如果文件已经存在,则会覆盖清空文件</li><li>写数据<br> 细节:write方法的参数是整数,但是实际上写到本地文件中的是整数在ASCII上对应的字符</li></ol><h5 id="3-FileOutputStream的三种方法"><a href="#3-FileOutputStream的三种方法" class="headerlink" title="3. FileOutputStream的三种方法"></a>3. FileOutputStream的三种方法</h5><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void write(int b)</td><td>一次写一个字节数据</td></tr><tr><td>void write(byte[] b)</td><td>一次写一个字节数组数据</td></tr><tr><td>void write(byte[] b, int off, int len)</td><td>一次写一个字节数组的部分数据</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;myio\\a.txt&quot;</span>);<br><br><span class="hljs-comment">//2.写出数据</span><br>fos.write(<span class="hljs-number">97</span>); <span class="hljs-comment">// a</span><br>fos.write(<span class="hljs-number">98</span>); <span class="hljs-comment">// b</span><br><span class="hljs-type">byte</span>[] bytes = &#123;<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">101</span>&#125;;<br>fos.write(bytes) ;<br>fos.write(bytes, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// b c</span><br><br><span class="hljs-comment">//3.释放资源</span><br>fos.close();<br></code></pre></td></tr></table></figure><h5 id="4-换行和续写"><a href="#4-换行和续写" class="headerlink" title="4. 换行和续写"></a>4. 换行和续写</h5><p><strong>换行符:</strong></p><ul><li>windows: \r\n</li><li>Linux: \n</li><li>Mac: \r</li></ul><p><strong>续写:</strong><br>如果想要续写,打开续写开关即可<br>开关位置:创建对象的第二个参数<br>    默认false:表示关闭续写,此时创建对象会清空文件<br>    手动传递true:表示打开续写,此时创建对象不会清空文件</p><h4 id="D-字节输入流-FileInputStream"><a href="#D-字节输入流-FileInputStream" class="headerlink" title="D. 字节输入流(FileInputStream)"></a>D. 字节输入流(FileInputStream)</h4><p>操作本地文件的字节输出流，可以把本地文件中的数据读取到程序中</p><h5 id="1-书写步骤：-1"><a href="#1-书写步骤：-1" class="headerlink" title="1. 书写步骤："></a>1. 书写步骤：</h5><ol><li>创建字节输入流对象</li><li>读数据</li><li>释放资源</li></ol><h5 id="2-FileInputStream的细节"><a href="#2-FileInputStream的细节" class="headerlink" title="2. FileInputStream的细节"></a>2. FileInputStream的细节</h5><ol><li>创建字节输入流对象<br> 如果文件不存在，就直接报错</li><li>读取数据<br> 一次读一个字节，读的是ASCII码对应的数字<br> 读到文件末尾，read方法返回-1</li></ol><h5 id="3-FileInputStream循环读取"><a href="#3-FileInputStream循环读取" class="headerlink" title="3. FileInputStream循环读取"></a>3. FileInputStream循环读取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;myio\\a.txt&quot;</span>);<br><span class="hljs-comment">//2.循环读取</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = fis.read()) != -<span class="hljs-number">1</span>) &#123;<br>    System.out.println((<span class="hljs-type">char</span>) b);<br>&#125;<br><span class="hljs-comment">//3.释放资源</span><br>fis.close();<br></code></pre></td></tr></table></figure><h5 id="4-文件拷贝"><a href="#4-文件拷贝" class="headerlink" title="4. 文件拷贝"></a>4. 文件拷贝</h5><p>使用字节流拷贝的速度很慢：因为一次只读取一个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\itheima\\movie.mp4&quot;</span>);<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;myio\\copy.mp4&quot;</span>);<br><span class="hljs-comment">//2.拷贝</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span>((b = fis.read()) != -<span class="hljs-number">1</span>)&#123;<br>    fos.write(b);<span class="hljs-comment">//核心思想:边读边写</span><br>&#125;<br><span class="hljs-comment">//3.释放资源 规则:先开的最后关闭</span><br>fos.close();<br>fis.close();<br></code></pre></td></tr></table></figure><h5 id="5-FileInputStream一次读取多个字节"><a href="#5-FileInputStream一次读取多个字节" class="headerlink" title="5. FileInputStream一次读取多个字节"></a>5. FileInputStream一次读取多个字节</h5><p><code>public int read(byte[] buffer)</code>: 一次读取一个字节数组数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\itheima\\movie.mp4&quot;</span>);<br><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;myio\\copy.mp4&quot;</span>);<br><span class="hljs-comment">//2.拷贝</span><br><span class="hljs-type">int</span> len;<br><span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">5</span>];<br><span class="hljs-keyword">while</span>((len = fis.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>    fos.write(bytes,<span class="hljs-number">0</span>,len);  <span class="hljs-comment">//读多少写多少</span><br>&#125;<br><span class="hljs-comment">//3.释放资源</span><br>fos.close();<br>fis.close();<br></code></pre></td></tr></table></figure><h4 id="E-字符集"><a href="#E-字符集" class="headerlink" title="E. 字符集"></a>E. 字符集</h4><p>ASCII字符集、GBK字符集、Unicode字符集</p><ul><li>ASCII字符集：一个英文占一个字节</li><li>GBK字符集：一个英文占一个字节，一个中文占两个字节</li><li>Unicode字符集:<br>  UTF-8编码规则：用1~4个字节保存(英文一个字节，中文三个字节)</li></ul><h4 id="F-字符输入流-FileReader"><a href="#F-字符输入流-FileReader" class="headerlink" title="F. 字符输入流(FileReader)"></a>F. 字符输入流(FileReader)</h4><h5 id="1-读取步骤"><a href="#1-读取步骤" class="headerlink" title="1. 读取步骤"></a>1. 读取步骤</h5><ol><li>创建字符输入流对象</li></ol><table><thead><tr><th>构造方法</th><th>作用</th></tr></thead><tbody><tr><td>public FileReader(File file)</td><td>创建字符输入流关联本地文件</td></tr><tr><td>public FileReader(String pathname)</td><td>创建字符输入流关联本地文件</td></tr></tbody></table><ol start="2"><li>读取数据</li></ol><table><thead><tr><th>成员方法</th><th>作用</th></tr></thead><tbody><tr><td>public int read()</td><td>读取数据,读到末尾返回-1</td></tr><tr><td>public int read(char[] buffer)</td><td>读取多个数据,读到末尾返回-1</td></tr></tbody></table><ol start="3"><li>释放资源</li></ol><h5 id="2-空参read读取数据"><a href="#2-空参read读取数据" class="headerlink" title="2. 空参read读取数据"></a>2. 空参read读取数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建对象</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;myio\\a.txt&quot;</span>);<br><span class="hljs-comment">//2. 读取数据</span><br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span>((ch = fr.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.print((<span class="hljs-type">char</span>)ch);<br>&#125;<br><span class="hljs-comment">//3. 释放资源</span><br>fr.close();<br></code></pre></td></tr></table></figure><h5 id="3-带参read读取数据"><a href="#3-带参read读取数据" class="headerlink" title="3. 带参read读取数据"></a>3. 带参read读取数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;myio\\a.txt&quot;</span>);<br><span class="hljs-comment">//2.读取数据</span><br><span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len = fr.read(chars)) != -<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//把数组中的数据变成字符串再进行打印</span><br>    System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars,<span class="hljs-number">0</span>,len));<br>&#125;<br><span class="hljs-comment">//3.释放资源</span><br>fr.close();<br></code></pre></td></tr></table></figure><h4 id="G-字符输出流-FileWriter"><a href="#G-字符输出流-FileWriter" class="headerlink" title="G. 字符输出流(FileWriter)"></a>G. 字符输出流(FileWriter)</h4><p>书写步骤：</p><ol><li>创建字符输出流对象</li><li>写数据</li><li>释放资源</li></ol><table><thead><tr><th>构造方法</th><th>作用</th></tr></thead><tbody><tr><td>public FileWriter(File file)</td><td>创建字符输出流关联本地文件</td></tr><tr><td>public FileWriter(String pathname)</td><td>创建字符输出流关联本地文件</td></tr><tr><td>public FileWriter(File file, boolean append)</td><td>创建字符输出流关联本地文件,续写</td></tr><tr><td>public FileWriter(String pathname, boolean append)</td><td>创建字符输出流关联本地文件,续写</td></tr></tbody></table><table><thead><tr><th>成员方法</th><th>作用</th></tr></thead><tbody><tr><td>void write(int c)</td><td>写出一个字符</td></tr><tr><td>void write(String str)</td><td>写出一个字符串</td></tr><tr><td>void write(String str, int off, int len)</td><td>写出一个字符串的一部分</td></tr><tr><td>void write(char[] cbuf)</td><td>写出一个字符数组</td></tr><tr><td>void write(char[] cbuf, int off, int len)</td><td>写出字符数组的一部分</td></tr></tbody></table><h4 id="H-字节流和字符流的使用场景"><a href="#H-字节流和字符流的使用场景" class="headerlink" title="H. 字节流和字符流的使用场景"></a>H. 字节流和字符流的使用场景</h4><p>字节流： 可以拷贝任意类型的文件<br>字符流：<br>    读取纯文本文件中的数据<br>    往纯文本文件中写数据</p><h4 id="I-缓冲流"><a href="#I-缓冲流" class="headerlink" title="I. 缓冲流"></a>I. 缓冲流</h4><p><img src="/img/blogs/java/javase/3.3.3.png"></p><h5 id="1-字节缓冲流"><a href="#1-字节缓冲流" class="headerlink" title="1. 字节缓冲流"></a>1. 字节缓冲流</h5><p>字节缓冲输入流的构造方法:<br><code>public BufferedInputStream(InputStream is)</code><br>字节缓冲输出流的构造方法:<br><code>public BufferedOutputStream(OutputStream os)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建缓冲流的对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;myio\\a.txt&quot;</span>));<br><span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;myio\\copy.txt&quot;</span>));<br><span class="hljs-comment">//2.循环读取并写到目的地</span><br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = bis.read()) != -<span class="hljs-number">1</span>) &#123;<br>    bos.write(b);<br>&#125;<br><span class="hljs-comment">//3.释放资源</span><br>bos.close();<br>bis.close();<br></code></pre></td></tr></table></figure><h5 id="2-字符缓冲流"><a href="#2-字符缓冲流" class="headerlink" title="2. 字符缓冲流"></a>2. 字符缓冲流</h5><p><strong>字符缓冲输入流</strong><br>    构造方法: <code>public BufferedReader(Reader r)</code><br>    特有方法: <code>public String readLine()</code> 读一整行</p><p><strong>字符缓冲输出流</strong><br>    构造方法: <code>public BufferedWriter(Writer r)</code><br>    特有方法: <code>public void newLine()</code> 跨平台的换行</p><h4 id="J-转换流"><a href="#J-转换流" class="headerlink" title="J. 转换流"></a>J. 转换流</h4><p>是字符流和字节流之间的桥梁<br>字节流使用字符流中的方法就需要转换流</p><h4 id="K-序列化流-反序列化流"><a href="#K-序列化流-反序列化流" class="headerlink" title="K. 序列化流&#x2F;反序列化流"></a>K. 序列化流&#x2F;反序列化流</h4><h5 id="1-序列化流-对象操作输出流"><a href="#1-序列化流-对象操作输出流" class="headerlink" title="1. 序列化流&#x2F;对象操作输出流"></a>1. 序列化流&#x2F;对象操作输出流</h5><p>可以把java中的对象写到本地文件中<br>构造方法: <code>public ObjectOutputStream(OutputStream out)</code>把基本流变成高级流<br>成员方法: <code>public final void writeObject(Object obj)</code>把对象序列化(写出)到文件中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">23</span>);<br><span class="hljs-comment">//2.创建序列化流的对象/对象操作输出流</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;myio\\a.txt&quot;</span>));<br><span class="hljs-comment">//3.写出数据</span><br>oos.writeObject(stu);<br><span class="hljs-comment">//4.释放资源</span><br>oos.close();<br></code></pre></td></tr></table></figure><h5 id="2-反序列化流-对象操作输入流"><a href="#2-反序列化流-对象操作输入流" class="headerlink" title="2. 反序列化流&#x2F;对象操作输入流"></a>2. 反序列化流&#x2F;对象操作输入流</h5><p>可以把序列化到本地文件中的对象读取到程序中<br>构造方法: <code>public ObjectInputStream(InputStream out)</code>把基本流变成高级流<br>成员方法: <code>public Object readObject()</code>把序列化到本地文件中的对象,读取到程序中来</p><h5 id="3-序列化流的细节"><a href="#3-序列化流的细节" class="headerlink" title="3. 序列化流的细节"></a>3. 序列化流的细节</h5><p>序列化对象不能修改Javabean类，否则不能反序列化<br>解决方案：在javabean类中添加版本号<br>    <code>private static final long serialVersionUID = -6357601841666449654L;</code></p><h4 id="L-打印流"><a href="#L-打印流" class="headerlink" title="L. 打印流"></a>L. 打印流</h4><ul><li>只有写，没有读</li><li>PrintStream和PrintWriter两个类</li></ul><h5 id="1-字节打印流"><a href="#1-字节打印流" class="headerlink" title="1. 字节打印流"></a>1. 字节打印流</h5><table><thead><tr><th>构造方法</th><th>作用</th></tr></thead><tbody><tr><td>public PrintStream(OutputStream&#x2F;File&#x2F;String)</td><td>关联字节输出流&#x2F;文件&#x2F;文件路径</td></tr><tr><td>public PrintStream(String fileName, Charset charset)</td><td>指定字符编码</td></tr><tr><td>public PrintStream(OutputStreamout, boolean autoFlush)</td><td>自动刷新</td></tr><tr><td>public PrintStream(OutputStream out, boolean autoFlush, String encoding)</td><td>指定字符编码且自动刷新</td></tr></tbody></table><table><thead><tr><th>成员方法</th><th>作用</th></tr></thead><tbody><tr><td>public void write(int b)</td><td>常规方法:规则跟之前一样,将指定的字节写出</td></tr><tr><td>public void println(Xxx xx)</td><td>特有方法:打印任意数据,自动刷新,自动换行</td></tr><tr><td>public void print(Xxx xx)</td><td>特有方法:打印任意数据,不换行</td></tr><tr><td>public void printf(String format, Object … args)</td><td>特有方法:带有占位符的打印语句,不换行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建字节打印流的对象</span><br><span class="hljs-type">PrintStream</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>( <span class="hljs-string">&quot;myio\\a.txt&quot;</span>),<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-comment">//2.写出数据</span><br>ps.println(<span class="hljs-number">97</span>);<span class="hljs-comment">//写出+自动刷新+自动换行</span><br>ps.print(<span class="hljs-literal">true</span>);<br>ps.println();<br>ps.printf(<span class="hljs-string">&quot;%s爱上了%s&quot;</span>,<span class="hljs-string">&quot;阿珍&quot;</span>,<span class="hljs-string">&quot;阿强&quot;</span>);<br><span class="hljs-comment">//3.释放资源</span><br>ps.close();<br></code></pre></td></tr></table></figure><h5 id="2-字符打印流"><a href="#2-字符打印流" class="headerlink" title="2. 字符打印流"></a>2. 字符打印流</h5><p>字符打印流的构造方法和成员方法和字节打印流一样<br>字符流底层有缓冲区，想要自动刷新需要开启</p><h4 id="M-解压缩流-压缩流"><a href="#M-解压缩流-压缩流" class="headerlink" title="M. 解压缩流&#x2F;压缩流"></a>M. 解压缩流&#x2F;压缩流</h4><h5 id="1-解压缩流"><a href="#1-解压缩流" class="headerlink" title="1. 解压缩流"></a>1. 解压缩流</h5><h5 id="2-压缩流"><a href="#2-压缩流" class="headerlink" title="2. 压缩流"></a>2. 压缩流</h5><p>压缩本质：把每个文件&#x2F;文件夹看出ZipEntry对象放到压缩包中</p><h4 id="N-Commons-io和Hutool"><a href="#N-Commons-io和Hutool" class="headerlink" title="N. Commons-io和Hutool"></a>N. Commons-io和Hutool</h4><p>有关IO操作的开源工具包，提高IO流的开发效率</p><h2 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4. 多线程"></a>4. 多线程</h2><h4 id="A-什么是多线程"><a href="#A-什么是多线程" class="headerlink" title="A. 什么是多线程"></a>A. 什么是多线程</h4><ul><li>进程是程序的基本执行实体</li><li>线程是操作系统能够进行运算调度的最小单位。被包含在进程中，是进程的实际运作单位。</li><li>有了多线程，就可以让程序同时做多件事情，提高效率</li></ul><h4 id="B-并发和并行"><a href="#B-并发和并行" class="headerlink" title="B. 并发和并行"></a>B. 并发和并行</h4><ul><li>并发： 在同一时刻，有多个指令在单个CPU上<strong>交替执行</strong></li><li>并行： 在同一时刻，有多个指令在多个CPU上<strong>同时执行</strong></li></ul><h4 id="C-多线程的实现方式"><a href="#C-多线程的实现方式" class="headerlink" title="C. 多线程的实现方式"></a>C. 多线程的实现方式</h4><h5 id="1-继承Thread类的方式"><a href="#1-继承Thread类的方式" class="headerlink" title="1. 继承Thread类的方式"></a>1. 继承Thread类的方式</h5><ol><li>自己定义一个类继承Thread</li><li>重写run方法</li><li>创建子类的对象,并启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-comment">//重写run方法</span><br>&#125;<br><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(); <span class="hljs-comment">//MyThread是自己创建的类</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><br>t1.setName(<span class="hljs-string">&quot;线程1&quot;</span>);<br>t2.setName(<span class="hljs-string">&quot;线程2&quot;</span>);<br><br>t1.start();<br>t2.start();<br></code></pre></td></tr></table></figure><h5 id="2-实现Runnable接口的方式"><a href="#2-实现Runnable接口的方式" class="headerlink" title="2. 实现Runnable接口的方式"></a>2. 实现Runnable接口的方式</h5><ol><li>自己定义一个类实现Runnable接口</li><li>重写里面的run方法</li><li>创建自己的类的对象</li><li>创建一个Thread类的对象,并开启线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRun</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-comment">//重写run方法</span><br>&#125;<br><br><span class="hljs-comment">//创建MyRun的对象</span><br><span class="hljs-type">MyRun</span> <span class="hljs-variable">mr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRun</span>();<br><br><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mr);<br><br><span class="hljs-comment">//给线程设置名字</span><br>t1.setName(<span class="hljs-string">&quot;线程1&quot;</span>);<br>t2.setName(<span class="hljs-string">&quot;线程2&quot;</span>);<br><br><span class="hljs-comment">//开启线程</span><br>t1.start();<br>t2.start();<br></code></pre></td></tr></table></figure><h5 id="3-利用Callable接口和Future接口"><a href="#3-利用Callable接口和Future接口" class="headerlink" title="3. 利用Callable接口和Future接口"></a>3. 利用Callable接口和Future接口</h5><p>特点:可以获取到多线程运行的结果</p><ol><li>创建一个类MyCallable实现Callable接口</li><li>重写call(是有返回值的,表示多线程运行的结果)</li><li>创建MyCallable的对象(表示多线程要执行的任务)</li><li>创建FutureTask的对象(作用管理多线程运行的结果)</li><li>创建Thread类的对象,并启动(表示线程)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br>    <span class="hljs-comment">//重写run方法</span><br>&#125;<br><br><span class="hljs-comment">//创建MyCallable的对象(表示多线程要执行的任务)</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-comment">//创建FutureTask的对象(作用管理多线程运行的结果)</span><br>FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(mc);<br><span class="hljs-comment">//创建线程的对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ft);<br><span class="hljs-comment">//启动线程</span><br>t1.start();<br><br><span class="hljs-comment">//获取多线程运行的结果</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ft.get();<br>System.out.println(result);|<br></code></pre></td></tr></table></figure><h5 id="4-三种实现方式对比"><a href="#4-三种实现方式对比" class="headerlink" title="4. 三种实现方式对比"></a>4. 三种实现方式对比</h5><p><img src="/img/blogs/java/javase/3.4.1.png"></p><h4 id="D-Thread常见的成员方法"><a href="#D-Thread常见的成员方法" class="headerlink" title="D. Thread常见的成员方法"></a>D. Thread常见的成员方法</h4><table><thead><tr><th>成员方法</th><th>作用</th></tr></thead><tbody><tr><td>String getName()</td><td>返回此线程的名称</td></tr><tr><td>void setName(String name)</td><td>设置线程的名字(构造方法也可以设置名字)</td></tr><tr><td>static Thread currentThread()</td><td>获取当前线程的对象</td></tr><tr><td>static void sleep(long time)</td><td>让线程休眠指定的时间,单位为毫秒</td></tr><tr><td>setPriority(int newPriority)</td><td>设置线程的优先级</td></tr><tr><td>final int getPriority()</td><td>获取线程的优先级</td></tr><tr><td>final void setDaemon(boolean on)</td><td>设置为守护线程</td></tr><tr><td>public static void yield()</td><td>出让线程&#x2F;礼让线程</td></tr><tr><td>public static void join()</td><td>插入线程&#x2F;插队线程</td></tr></tbody></table><p>细节：</p><ol><li>如果我们没有给线程设置名字,线程也是有默认的名字的<br> 格式:Thread-X(X序号,从0开始的)</li><li>如果我们要给线程设置名字,可以用set方法进行设置,也可以构造方法设置</li><li>优先级：1~10，1最低，10最高(java是抢占式调度)</li><li>守护线程：当其他非守护线程执行完毕之后，守护线程会尽快结束不再进行</li></ol><h4 id="E-线程的生命周期"><a href="#E-线程的生命周期" class="headerlink" title="E. 线程的生命周期"></a>E. 线程的生命周期</h4><p><img src="/img/blogs/java/javase/3.4.2.png"></p><h4 id="F-线程安全"><a href="#F-线程安全" class="headerlink" title="F. 线程安全"></a>F. 线程安全</h4><p>当多个线程同时操作同一个资源时，可能会导致数据出错或程序行为异常</p><h4 id="G-同步代码块"><a href="#G-同步代码块" class="headerlink" title="G. 同步代码块"></a>G. 同步代码块</h4><p>把操作共享数据的代码锁起来<br>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(锁)&#123;<br>    操作共享数据的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：<br>    1. 锁默认打开，有一个线程进去了，锁自动关闭<br>    2. 里面的代码全部执行完毕，线程出来，锁自动打开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//表示这个类所有的对象,都共享ticket数据</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//0 ~ 99</span><br><span class="hljs-comment">//锁对象,一定要是唯一的</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">//同步代码块</span><br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>            <span class="hljs-keyword">if</span>(ticket &lt; <span class="hljs-number">100</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                        &#125;<br>                        ticket++;<br>                        System.out.println(getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket + <span class="hljs-string">&quot;张票! ! &quot;</span>);<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br></code></pre></td></tr></table></figure><h4 id="H-同步方法"><a href="#H-同步方法" class="headerlink" title="H. 同步方法"></a>H. 同步方法</h4><p>就是把synchronized关键字加到方法上<br>格式：<code>修饰符 synchronized 返回值类型 方法名(方法参数) {...}</code></p><ol><li>同步方法是锁住方法里面所有代码</li><li>锁对象不能自己指定<ul><li>非静态：this</li><li>静态：当前类的字节码文件对象</li></ul></li></ol><h4 id="I-Lock锁"><a href="#I-Lock锁" class="headerlink" title="I. Lock锁"></a>I. Lock锁</h4><p>可以手动上锁、手动解锁</p><ul><li><code>void lock()</code>: 获得锁</li><li><code>void unlock()</code>: 释放锁</li><li>Lock是接口不能直接实例化,采用它的实现类ReentrantLock来实例化<ul><li><code>ReentrantLock()</code>:创建一个ReentrantLock的实例</li></ul></li></ul><h4 id="J-生产者和消费者-等待唤醒机制"><a href="#J-生产者和消费者-等待唤醒机制" class="headerlink" title="J. 生产者和消费者(等待唤醒机制)"></a>J. 生产者和消费者(等待唤醒机制)</h4><h5 id="1-常见方法"><a href="#1-常见方法" class="headerlink" title="1. 常见方法"></a>1. 常见方法</h5><table><thead><tr><th>常见方法</th><th>作用</th></tr></thead><tbody><tr><td>void wait()</td><td>当前线程等待,直到被其他线程唤醒</td></tr><tr><td>void notify()</td><td>随机唤醒单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒所有线程</td></tr></tbody></table><h5 id="2-阻塞队列实现等待唤醒机制"><a href="#2-阻塞队列实现等待唤醒机制" class="headerlink" title="2. 阻塞队列实现等待唤醒机制"></a>2. 阻塞队列实现等待唤醒机制</h5><p>生产者和消费者必须使用同一个阻塞队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayBlockingQueue&lt;String&gt; queue;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Foodie</span><span class="hljs-params">(ArrayBlockingQueue&lt;String&gt; queue)</span> &#123; <br>    <span class="hljs-built_in">this</span>.queue = queue;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-comment">//不断从阻塞队列中获取面条</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">food</span> <span class="hljs-operator">=</span> queue.take();<br>            System.out.println(food);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="K-线程的六种状态"><a href="#K-线程的六种状态" class="headerlink" title="K. 线程的六种状态"></a>K. 线程的六种状态</h4><p><img src="/img/blogs/java/javase/3.4.3.png"></p><h4 id="L-线程池"><a href="#L-线程池" class="headerlink" title="L. 线程池"></a>L. 线程池</h4><h5 id="1-线程池主要原理"><a href="#1-线程池主要原理" class="headerlink" title="1. 线程池主要原理"></a>1. 线程池主要原理</h5><ol><li>创建一个池子,池子中是空的</li><li>提交任务时,池子会创建新的线程对象,任务执行完毕,线程归还给池子,下回再次提交任务时,不需要创建新的线程,直接复用已有的线程即可</li><li>但是如果提交任务时,池子中没有空闲线程,也无法创建新的线程,任务就会排队等待</li></ol><h5 id="2-代码实现："><a href="#2-代码实现：" class="headerlink" title="2. 代码实现："></a>2. 代码实现：</h5><ol><li>创建线程池</li><li>提交任务</li><li>所有任务全部执行完毕，关闭线程池<br>Executors:线程池的工具类通过调用方法返回不同类型的线程池对象</li></ol><table><thead><tr><th>方法名称</th><th>作用</th></tr></thead><tbody><tr><td>public static ExecutorService newCachedThreadPool()</td><td>创建一个没有上限的线程池</td></tr><tr><td>public static ExecutorService newFixedThreadPool(int nThreads)</td><td>创建有上限的线程池</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.获取线程池对象</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool1</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-comment">//2.提交任务</span><br>pool1.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br><span class="hljs-comment">//3.销毁线程池</span><br>pool1.shutdown();<br></code></pre></td></tr></table></figure><h4 id="M-自定义线程池"><a href="#M-自定义线程池" class="headerlink" title="M. 自定义线程池"></a>M. 自定义线程池</h4><p>创建线程池对象：<br><code>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);</code><br>参数一:核心线程数量   不能小于0<br>参数二:最大线程数    不能小于0,最大数量 &gt;&#x3D;核心线程数量<br>参数三:空闲线程最大存活时间  不能小于e<br>参数四:时间单位   用TimeUnit指定<br>参数五:任务队列   不能为null<br>参数六:创建线程工厂   不能为null<br>参数七:任务的拒绝策略   不能为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">3</span>,<span class="hljs-comment">//核心线程数量,能小于0</span><br>    <span class="hljs-number">6</span>, <span class="hljs-comment">//最大线程数,不能小于0,最大数量&gt;=核心线程数量</span><br>    <span class="hljs-number">60</span>,<span class="hljs-comment">//空闲线程最大存活时间</span><br>    TimeUnit.SECONDS,<span class="hljs-comment">//时间单位</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>),<span class="hljs-comment">//任务队列</span><br>    Executors.defaultThreadFactory(),<span class="hljs-comment">//创建线程工厂</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="hljs-comment">//任务的拒绝策略</span><br>);<br></code></pre></td></tr></table></figure><h2 id="5-网络编程"><a href="#5-网络编程" class="headerlink" title="5. 网络编程"></a>5. 网络编程</h2><p>计算机之间通过网络进行数据传输</p><h4 id="A-CS架构和BS架构"><a href="#A-CS架构和BS架构" class="headerlink" title="A. CS架构和BS架构"></a>A. CS架构和BS架构</h4><ul><li>C&#x2F;S: Client&#x2F;Server 客户端&#x2F;服务器</li><li>B&#x2F;S: Browser&#x2F;Server 浏览器&#x2F;服务器<br>BS架构的优缺点<ul><li>不需要开发客户端，只需要页面+服务器</li><li>用户不用下载，打开浏览器就能用</li><li>如果应用过大，用户体验差</li></ul></li></ul><p>CS架构的优缺点</p><ul><li>画面更精美，用户体验好</li><li>需要开发客户端，也要开发服务器</li><li>用户下载和更新麻烦</li></ul><h4 id="B-网络编程三要素"><a href="#B-网络编程三要素" class="headerlink" title="B. 网络编程三要素"></a>B. 网络编程三要素</h4><p>IP、端口号、协议</p><ol><li>IP<ul><li>设备在网络中的地址,是唯一的标识。</li></ul></li><li>端口号<ul><li>应用程序在设备中唯一的标识。</li></ul></li><li>协议<ul><li>数据在网络中传输的规则,常见的协议有UDP、TCP、http、https、ftp。</li></ul></li></ol><h4 id="C-IP"><a href="#C-IP" class="headerlink" title="C. IP"></a>C. IP</h4><h5 id="1-IPv4"><a href="#1-IPv4" class="headerlink" title="1. IPv4"></a>1. IPv4</h5><p>分为公网地址和私网地址(192.168.1.1~192.168.255.255)</p><ul><li>127.0.0.1： 本机地址</li><li>ipconfig:查看本机IP地址</li><li>ping:检查网络是否连通</li></ul><h5 id="2-InetAddress类"><a href="#2-InetAddress类" class="headerlink" title="2. InetAddress类"></a>2. InetAddress类</h5><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>static InetAddress getByName(String host)</td><td>确定主机名称的IP地址。主机名称可以是机器名称,也可以是IP地址</td></tr><tr><td>String getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>String getHostAddress()</td><td>返回文本显示中的IP地址字符串</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取InetAddress的对象</span><br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;DESKTOP-50JJSAM&quot;</span>);<br>System.out.println(address);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> address.getHostName();<br>System.out.println(name);<span class="hljs-comment">//DESKTOP-50JJSAM</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> address.getHostAddress();<br>System.out.println(ip);<span class="hljs-comment">//192.168.1.100</span><br></code></pre></td></tr></table></figure><h4 id="D-端口号"><a href="#D-端口号" class="headerlink" title="D. 端口号"></a>D. 端口号</h4><ul><li>取值范围0<del>65535<br>  其中0</del>1023用于知名应用或网络服务，自己只能用1024以上的端口号</li><li>一个端口号只能被一个应用程序使用</li></ul><h4 id="E-协议"><a href="#E-协议" class="headerlink" title="E. 协议"></a>E. 协议</h4><p>计算机网络中，连接和通信的规则称为网络通信协议<br><img src="/img/blogs/java/javase/3.5.1.png"></p><h5 id="1-UDP协议"><a href="#1-UDP协议" class="headerlink" title="1. UDP协议"></a>1. UDP协议</h5><p>用户数据报协议(User Datagram Protocol)</p><ul><li>UDP是面向无连接通信协议。</li><li>速度快,有大小限制一次最多发送64K,数据不安全,易丢失数据</li></ul><h5 id="2-TCP协议"><a href="#2-TCP协议" class="headerlink" title="2. TCP协议"></a>2. TCP协议</h5><p>传输控制协议TCP(Transmission Control Protocol)</p><ul><li>TCP协议是面向连接的通信协议。</li><li>速度慢,没有大小限制,数据安全。</li></ul><h4 id="F-UDP通信程序"><a href="#F-UDP通信程序" class="headerlink" title="F. UDP通信程序"></a>F. UDP通信程序</h4><h5 id="1-发送数据"><a href="#1-发送数据" class="headerlink" title="1. 发送数据"></a>1. 发送数据</h5><ol><li>创建发送端的DatagramSocket对象</li><li>数据打包(DatagramPacket)</li><li>发送数据</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建对象</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br><br><span class="hljs-comment">//2.打包数据</span><br>String str=<span class="hljs-string">&quot;你好!!!&quot;</span>;<br><span class="hljs-type">byte</span>[] bytes = str.getBytes();<br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">10086</span>;<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,bytes.length, address, port);<br><br><span class="hljs-comment">//3.发送数据</span><br>ds.send(dp);<br><span class="hljs-comment">//4.释放资源</span><br>ds.close();<br></code></pre></td></tr></table></figure><h5 id="2-接收数据"><a href="#2-接收数据" class="headerlink" title="2. 接收数据"></a>2. 接收数据</h5><ol><li>创建接收端的DatagramSocket对象</li><li>接收打包好的数据</li><li>解析数据包</li><li>释放资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.接收的端口和发送的端口保持一致</span><br><span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(<span class="hljs-number">10086</span>);<br><br><span class="hljs-comment">//2.接收数据包</span><br><span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">dp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(bytes,bytes.length);<br>ds.receive(dp);<br><br><span class="hljs-comment">//3.解析数据包</span><br><span class="hljs-type">byte</span>[] data = dp.getData();<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> dp.getLength();<br><span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> dp.getAddress();<br><span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> dp.getPort();<br>System.out.println(<span class="hljs-string">&quot;按收到数据&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, <span class="hljs-number">0</span>,len));<br>System.out.println(<span class="hljs-string">&quot;该数据是从&quot;</span>+address+<span class="hljs-string">&quot;这台电脑中的&quot;</span>+port+<span class="hljs-string">&quot;这个端口发出的&quot;</span>);<br><br><span class="hljs-comment">//4.释放资源</span><br>ds.close();<br></code></pre></td></tr></table></figure><h5 id="3-单播组播广播"><a href="#3-单播组播广播" class="headerlink" title="3. 单播组播广播"></a>3. 单播组播广播</h5><ul><li>单播：指定接收端的IP地址</li><li>组播：224.0.0.0~239.255.255.255</li><li>广播：255.255.255.255</li></ul><h4 id="G-TCP通信程序"><a href="#G-TCP通信程序" class="headerlink" title="G. TCP通信程序"></a>G. TCP通信程序</h4><ul><li>TCP通信协议是一种可靠的网络协议,它在通信的两端各建立一个Socket对象</li><li>通信之前要保证连接已经建立</li><li>通过Socket产生I0流来进行网络通信</li></ul><h5 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1. 客户端"></a>1. 客户端</h5><ol><li>创建客户端的Socket对象(Socket)与指定服务端连接<br><code>Socket(String host, int port)</code></li><li>获取输出流,写数据<br><code>OutputStream getOutputStream()</code></li><li>释放资源<br><code>void close()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建Socket对象</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">10000</span>);<br><br><span class="hljs-comment">//2.可以从连接通道中获取输出流</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> socket.getOutputStream();<br>os.write(<span class="hljs-string">&quot;你好你好&quot;</span>.getBytes());<br><br><span class="hljs-comment">//3.释放资源</span><br>os.close();<br>socket.close();<br></code></pre></td></tr></table></figure><h5 id="2-服务器端"><a href="#2-服务器端" class="headerlink" title="2. 服务器端"></a>2. 服务器端</h5><ol><li>创建服务器端的Socket对象(ServerSocket)<br><code>ServerSocket (int port)</code></li><li>监听客户端连接,返回一个Socket对象<br><code>Socket accept()</code></li><li>获取输入流,读数据,并把数据显示在控制台<br><code>InputStream getInputStream()</code></li><li>释放资源<br><code>void close()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.创建对象ServerSocker</span><br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">10000</span>);<br><br><span class="hljs-comment">//2.监听客户端的链接</span><br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> ss.accept();<br><br><span class="hljs-comment">//3.从连接通道中获取输入流读取数据</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> socket.getInputStream();<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">while</span> ((b = is.read()) != -<span class="hljs-number">1</span>)&#123;<br>    System.out.println((<span class="hljs-type">char</span>) b);<br>&#125;<br><br><span class="hljs-comment">//4.释放资源</span><br>socket.close();<br>ss.close();<br></code></pre></td></tr></table></figure><h5 id="3-三次握手和四次挥手"><a href="#3-三次握手和四次挥手" class="headerlink" title="3. 三次握手和四次挥手"></a>3. 三次握手和四次挥手</h5><p><img src="/img/blogs/java/javase/3.5.2.png"><br><img src="/img/blogs/java/javase/3.5.3.png"></p><h2 id="6-反射"><a href="#6-反射" class="headerlink" title="6. 反射"></a>6. 反射</h2><h4 id="A-什么是反射"><a href="#A-什么是反射" class="headerlink" title="A. 什么是反射"></a>A. 什么是反射</h4><p>反射允许对成员变量、成员方法和构造方法的信息进行编程访问<br>反射就是从类中拿东西<br><img src="/img/blogs/java/javase/3.6.1.png"></p><h4 id="B-获取class对象的三种方式"><a href="#B-获取class对象的三种方式" class="headerlink" title="B. 获取class对象的三种方式"></a>B. 获取class对象的三种方式</h4><ol><li><strong>Class.forName(“全类名”);</strong>(常用)</li><li>类名.class</li><li>对象.getClass();</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 第一种方式 全类名:包名+类名</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.itheima.myreflect1.Student&quot;</span>);<br><br><span class="hljs-comment">//2. 第二种方式</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz2</span> <span class="hljs-operator">=</span> Student.class;<br><br><span class="hljs-comment">//3.第三种方式</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz3</span> <span class="hljs-operator">=</span> s.getClass();<br></code></pre></td></tr></table></figure><h4 id="C-反射获取构造方法"><a href="#C-反射获取构造方法" class="headerlink" title="C. 反射获取构造方法"></a>C. 反射获取构造方法</h4><table><thead><tr><th>Class类中用于获取构造方法的方法</th><th>作用</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[] getConstructors()</td><td>返回所有公共构造方法对象的数组</td></tr><tr><td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td>返回所有构造方法对象的数组</td></tr><tr><td>Constructor<T> getConstructor(Class&lt;?&gt;…parameterTypes)</td><td>返回单个公共构造方法对象</td></tr><tr><td>Constructor<T>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回单个构造方法对象</td></tr></tbody></table><table><thead><tr><th>Constructor类中用于创建对象的方法</th><th>作用</th></tr></thead><tbody><tr><td>T newlnstance(Object …initargs)</td><td>根据指定的构造方法创建对象</td></tr><tr><td>setAccessible(boolean flag)</td><td>设置为true,表示取消访问检查</td></tr></tbody></table><h4 id="D-反射获取成员变量"><a href="#D-反射获取成员变量" class="headerlink" title="D. 反射获取成员变量"></a>D. 反射获取成员变量</h4><table><thead><tr><th>Class类中用于获取成员变量的方法</th><th>作用</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td>返回所有公共成员变量对象的数组</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回所有成员变量对象的数组</td></tr><tr><td>Field getField(String name)</td><td>返回单个公共成员变量对象</td></tr><tr><td>Field getDeclaredField(String name)</td><td>返回单个成员变量对象</td></tr></tbody></table><table><thead><tr><th>Field类中用于创建对象的方法</th><th>作用</th></tr></thead><tbody><tr><td>void set(Object obj, Object value)</td><td>赋值</td></tr><tr><td>Object get(Object obj)</td><td>获取值</td></tr></tbody></table><h4 id="E-反射获取成员方法"><a href="#E-反射获取成员方法" class="headerlink" title="E. 反射获取成员方法"></a>E. 反射获取成员方法</h4><table><thead><tr><th>Class类中用于获取成员方法的方法</th><th>作用</th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>返回所有公共成员方法对象的数组,包括继承的</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>返回所有成员方法对象的数组,不包括继承的</td></tr><tr><td>Method getMethod(String name,Class&lt;?&gt; … parameterTypes)</td><td>返回单个公共成员方法对象</td></tr><tr><td>Method getDeclaredMethod(String name,Class&lt;?&gt; … parameterTypes)</td><td>返回单个成员方法对象</td></tr></tbody></table><p><strong>Method类中用于创建对象的方法</strong><br><code>Object invoke(Object obj,Object ...args)</code>:运行方法<br>    参数一:用obj对象调用该方法<br>    参数二:调用方法的传递的参数(如果没有就不写)<br>    返回值:方法的返回值(如果没有就不写)</p><h2 id="7-动态代理"><a href="#7-动态代理" class="headerlink" title="7. 动态代理"></a>7. 动态代理</h2><ul><li>无侵入式给代码增加额外的功能</li><li>代理可以无侵入式给对象增加其他功能<br>  调用者–&gt;代理–&gt;对象</li><li>JAVA通过接口保证代理，接口就是被代理的所有方法</li><li>java.lang.reflect.Proxy类：提供为对象产生代理对象的方法</li></ul><p><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code><br>    参数一:用于指定用哪个类加载器,去加载生成的代理类<br>    参数二:指定接口,这些接口用于指定生成的代理长什么,也就是有哪些方法<br>    参数三:用来指定生成的代理对象要干什么事情</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>javase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学生管理系统含用户登录系统(Java)</title>
    <link href="/2024/12/29/JAVA/java%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/12/29/JAVA/java%E5%AE%9E%E7%8E%B0%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 align="center">使用Java实现学生管理系统</h1><h2 id="一-任务"><a href="#一-任务" class="headerlink" title="一. 任务"></a>一. 任务</h2><h4 id="1-实现学生管理系统"><a href="#1-实现学生管理系统" class="headerlink" title="1. 实现学生管理系统"></a>1. 实现学生管理系统</h4><p>要求有以下功能：</p><ul><li>添加学生信息</li><li>删除学生信息</li><li>查询学生信息</li><li>修改学生信息</li></ul><h4 id="2-引入用户登录系统"><a href="#2-引入用户登录系统" class="headerlink" title="2. 引入用户登录系统"></a>2. 引入用户登录系统</h4><p>只有用户登录成功之后，才能进入到学生管理系统中进行增删改查操作。<br>要求有以下功能：</p><ul><li>注册功能</li><li>登录功能</li><li>忘记密码功能</li></ul><h2 id="二-代码实现"><a href="#二-代码实现" class="headerlink" title="二. 代码实现"></a>二. 代码实现</h2><h4 id="A-创建学生类"><a href="#A-创建学生类" class="headerlink" title="A. 创建学生类"></a>A. 创建学生类</h4><p>属性：id、姓名、年龄、家庭住址<br>创建学生JavaBean类，包括四个私有成员变量属性和两种构造方法以及getter和setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> study;<br><br><span class="hljs-comment">//学生类属性：id、姓名、年龄、家庭住址</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String homeAddress;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String id, String name, <span class="hljs-type">int</span> age, String homeAddress)</span> &#123; <span class="hljs-comment">//带全部参构造方法</span><br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.homeAddress = homeAddress;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//空参构造方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHomeAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> homeAddress;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHomeAddress</span><span class="hljs-params">(String homeAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.homeAddress = homeAddress;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;id = &quot;</span> + id + <span class="hljs-string">&quot;, name = &quot;</span> + name + <span class="hljs-string">&quot;, age = &quot;</span> + age + <span class="hljs-string">&quot;, homeAddress = &quot;</span> + homeAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-实现学生管理系统类的方法"><a href="#B-实现学生管理系统类的方法" class="headerlink" title="B. 实现学生管理系统类的方法"></a>B. 实现学生管理系统类的方法</h4><p>包括添加、删除、修改、查询、显示学生信息等功能</p><h5 id="1-菜单界面"><a href="#1-菜单界面" class="headerlink" title="1. 菜单界面"></a>1. 菜单界面</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMenu</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;---------Welcome to student manager system--------&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;1. Add student&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;2. Delete student&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;3. Modify students&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;4. Query students&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;5. Show all students&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;6. Exit&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;Please enter your choice:&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="2-添加学生信息"><a href="#2-添加学生信息" class="headerlink" title="2.添加学生信息"></a>2.添加学生信息</h5><p>键盘录入每一个学生信息并添加，需要满足要求：id唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">addStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;Please enter the student information to be ADDED, the student id is:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> sc.next();<br>    <span class="hljs-comment">//判断添加学生的学号是否已经存在</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (students.get(i).getId().equals(id)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Student already exists&quot;</span>);<br>            <span class="hljs-keyword">return</span> students;<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Please enter student name:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> sc.next();<br>    System.out.println(<span class="hljs-string">&quot;Please enter student age:&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> sc.nextInt();<br>    System.out.println(<span class="hljs-string">&quot;Please enter student&#x27;s home address:&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">homeAddress</span> <span class="hljs-operator">=</span> sc.next();<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">newStudent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, name, age, homeAddress);<br>    students.add(newStudent);  <span class="hljs-comment">//添加</span><br>    <span class="hljs-keyword">return</span> students;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断学生的学号是否存在，已经存在直接返回；不存在则添加新的学生信息(学号、姓名、年龄、住址)</p><h5 id="3-删除学生信息"><a href="#3-删除学生信息" class="headerlink" title="3.删除学生信息"></a>3.删除学生信息</h5><p>键盘录入要删除的学生id，需要满足以下要求：</p><ul><li>id存在删除</li><li>id不存在，需要提示不存在，并回到初始菜单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除学生信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">deleteStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Please enter the student id to be DELETE:&quot;</span>);<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">delId</span> <span class="hljs-operator">=</span> sc.next();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (students.get(i).getId().equals(delId)) &#123;<br>            students.remove(i);  <span class="hljs-comment">//删除</span><br>            <span class="hljs-keyword">return</span> students;<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Student does not exist&quot;</span>);<br>    <span class="hljs-keyword">return</span> students;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-修改学生信息"><a href="#4-修改学生信息" class="headerlink" title="4. 修改学生信息"></a>4. 修改学生信息</h5><p>键盘录入要修改的学生id，需要满足以下要求</p><ul><li>id存在，继续录入其他信息</li><li>id不存在，需要提示不存在</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改学生信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">modifyStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Please enter the student id to be MODIFY:&quot;</span>);<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">modId</span> <span class="hljs-operator">=</span> sc.next();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (students.get(i).getId().equals(modId)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Student exists,please enter student&#x27;s new ID:&quot;</span>);<br>            students.get(i).setId(sc.next());<br>            System.out.println(<span class="hljs-string">&quot;enter student&#x27;s new name:&quot;</span>);<br>            students.get(i).setName(sc.next());<br>            System.out.println(<span class="hljs-string">&quot;enter student&#x27;s new age:&quot;</span>);<br>            students.get(i).setAge(sc.nextInt());<br>            System.out.println(<span class="hljs-string">&quot;enter student&#x27;s new home address:&quot;</span>);<br>            students.get(i).setHomeAddress(sc.next());<br>            <span class="hljs-keyword">return</span> students;<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Student does not exist&quot;</span>);<br>    <span class="hljs-keyword">return</span> students;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-查询学生信息"><a href="#5-查询学生信息" class="headerlink" title="5.查询学生信息"></a>5.查询学生信息</h5><p>查询某个学生信息，并输出显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询某个学生信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryStudents</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Please enter the student id to be QUERY:&quot;</span>);<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">queId</span> <span class="hljs-operator">=</span> sc.next();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (students.get(i).getId().equals(queId)) &#123;<br>            System.out.println(students.get(i));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Not found the student&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-打印全部学生信息"><a href="#6-打印全部学生信息" class="headerlink" title="6. 打印全部学生信息"></a>6. 打印全部学生信息</h5><p>打印所有的学生信息，需要满足以下要求</p><ul><li>如果没有学生信息，提示：当前无学生信息，请添加后再查询</li><li>如果有学生信息，输出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//显示所有学生信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAllStudents</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>    <span class="hljs-keyword">if</span> (students.size() == <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;No students found, please add a student!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Students Information is as Follows:&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;id     name     age     home address&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>        System.out.println(students.get(i).getId() + <span class="hljs-string">&quot;  &quot;</span> + students.get(i).getName() + <span class="hljs-string">&quot;  &quot;</span> + students.get(i).getAge() + <span class="hljs-string">&quot;   &quot;</span> + students.get(i).getHomeAddress());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-创建用户类"><a href="#C-创建用户类" class="headerlink" title="C. 创建用户类"></a>C. 创建用户类</h4><p>属性：用户名、密码、身份证号码、手机号码，创建对应的JavaBean类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> study;<br><br><span class="hljs-comment">//用户类属性：用户名、密码、身份证号码、手机号码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String idCard;<br>    <span class="hljs-keyword">private</span> String phoneNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, String password, String idCard, String phoneNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.idCard = idCard;<br>        <span class="hljs-built_in">this</span>.phoneNumber = phoneNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName</span><span class="hljs-params">(String userName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIdCard</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> idCard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIdCard</span><span class="hljs-params">(String idCard)</span> &#123;<br>        <span class="hljs-built_in">this</span>.idCard = idCard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPhoneNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> phoneNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPhoneNumber</span><span class="hljs-params">(String phoneNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.phoneNumber = phoneNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;userName = &quot;</span> + userName + <span class="hljs-string">&quot;, password = &quot;</span> + password + <span class="hljs-string">&quot;, idCard = &quot;</span> + idCard + <span class="hljs-string">&quot;, phoneNumber = &quot;</span> + phoneNumber + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="D-实现用户登录功能的方法"><a href="#D-实现用户登录功能的方法" class="headerlink" title="D. 实现用户登录功能的方法"></a>D. 实现用户登录功能的方法</h4><p>包括注册、登录、忘记密码等功能</p><h5 id="1-菜单"><a href="#1-菜单" class="headerlink" title="1. 菜单"></a>1. 菜单</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//菜单</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMenu</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;---------Welcome to student manager system-------&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;please choose your option: 1 is Login, 2 is Register, 3 is Forget password, 4 is Exit&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-注册功能"><a href="#2-注册功能" class="headerlink" title="2. 注册功能"></a>2. 注册功能</h5><ol><li>用户名需要满足以下要求：<ul><li>用户名唯一</li><li>用户名长度必须在3~15位之间 </li><li>只能是字母加数字的组合，但是不能是纯数字</li></ul></li><li>密码键盘输入两次，两次一致才可以进行注册。</li><li>身份证号码需要验证：<ul><li>​长度为18位</li><li>​不能以0为开头</li><li>​前17位，必须都是数字</li><li>​最后一位可以是数字，也可以是大写X或小写x</li></ul></li><li>手机号验证：<ul><li>长度为11位</li><li>不能以0为开头</li><li>必须都是数字</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    System.out.println(<span class="hljs-string">&quot;please enter username: &quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> sc.next();<br><br>    <span class="hljs-comment">//用户名唯一</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; users.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (users.get(i).getUserName().equals(userName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;username already exists!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//用户名长度必须在3-15位</span><br>    <span class="hljs-keyword">if</span> (userName.length() &lt; <span class="hljs-number">3</span> || userName.length() &gt; <span class="hljs-number">15</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;username length must be between 3 and 15 characters!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//用户名必须是字母加数字组合</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">countLetters</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countNumbers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countOthers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; userName.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> userName.charAt(i);<br>        <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> || ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>            countLetters++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            countNumbers++;<br>        &#125; <span class="hljs-keyword">else</span><br>            countOthers++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (countOthers != <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;username cannot be special characters!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countLetters == <span class="hljs-number">0</span> || countNumbers == <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;username cannot be only letters or numbers!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//密码键盘输入两次，两次一致才可以进行注册。</span><br>    System.out.println(<span class="hljs-string">&quot;please enter password: &quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">psw1</span> <span class="hljs-operator">=</span> sc.next();<br>    System.out.println(<span class="hljs-string">&quot;please enter password again: &quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">psw2</span> <span class="hljs-operator">=</span> sc.next();<br>    <span class="hljs-keyword">if</span> (!psw1.equals(psw2)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;passwords do not match!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;please enter id card Number: &quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idCardNumber</span> <span class="hljs-operator">=</span> sc.next();<br><br>    <span class="hljs-comment">//长度为18位,不能以0为开头</span><br>    <span class="hljs-keyword">if</span> (idCardNumber.length() != <span class="hljs-number">18</span> || idCardNumber.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;id card number is not valid!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//前17位必须都是数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; idCardNumber.length() - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> idCardNumber.charAt(i);<br>        <span class="hljs-keyword">if</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;id card number is not valid!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//最后一位可以是数字，也可以是大写X或小写x</span><br>    <span class="hljs-keyword">if</span> (!((idCardNumber.charAt(<span class="hljs-number">17</span>) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; idCardNumber.charAt(<span class="hljs-number">17</span>) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || idCardNumber.charAt(<span class="hljs-number">17</span>) == <span class="hljs-string">&#x27;x&#x27;</span> || idCardNumber.charAt(<span class="hljs-number">17</span>) == <span class="hljs-string">&#x27;X&#x27;</span>)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;id card number is not valid!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//长度为11位 不能以0为开头必须都是数字</span><br>    System.out.println(<span class="hljs-string">&quot;please enter phone number: &quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> sc.next();<br><br>    <span class="hljs-keyword">if</span> (phoneNumber.length() != <span class="hljs-number">11</span> || phoneNumber.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;phone number is not valid!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; phoneNumber.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> phoneNumber.charAt(i);<br>        <span class="hljs-keyword">if</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;phone number is not valid!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(userName, psw1, idCardNumber, phoneNumber);<br>    users.add(newUser); <span class="hljs-comment">//注册</span><br>    System.out.println(<span class="hljs-string">&quot;user registered successfully!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-登录功能"><a href="#3-登录功能" class="headerlink" title="3. 登录功能"></a>3. 登录功能</h5><ol><li>键盘输入用户名，用户名如果未注册，直接结束方法，并提示：用户名未注册，请先注册</li><li>生成验证码，判断验证码是否正确，如不正确，重新输入</li><li>键盘输入密码，再判断用户名和密码是否正确，有3次机会</li><li>验证码规则:<ul><li>长度为5</li><li>由4位大写或者小写字母和1位数字组成，同一个字母可重复</li><li>数字可以出现在任意位置</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//登录</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>     System.out.println(<span class="hljs-string">&quot;please enter username: &quot;</span>);<br>     <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> sc.next();<br>     <span class="hljs-comment">//用户名是否已注册</span><br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">userExists</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; users.size(); i++) &#123;<br>         <span class="hljs-keyword">if</span> (users.get(i).getUserName().equals(userName)) &#123;<br>             userExists = <span class="hljs-literal">true</span>;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (!userExists) &#123;<br>         System.out.println(<span class="hljs-string">&quot;Username does not register!&quot;</span>);<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果用户名没有注册，直接返回</span><br>     &#125;<br><br>     <span class="hljs-comment">//随机生成验证码</span><br>     <span class="hljs-type">Random</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>     <span class="hljs-type">int</span> <span class="hljs-variable">randomInt</span> <span class="hljs-operator">=</span> rd.nextInt(<span class="hljs-number">5</span>);<span class="hljs-comment">//生成0-4随机整数</span><br>     <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>         <span class="hljs-keyword">if</span> (i == randomInt) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">randomInt1</span> <span class="hljs-operator">=</span> rd.nextInt(<span class="hljs-number">10</span>);<br>             sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;0&#x27;</span> + randomInt1)); <span class="hljs-comment">//生成0-9随机字符</span><br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">randomInt2</span> <span class="hljs-operator">=</span> rd.nextInt(<span class="hljs-number">52</span>);<br>             <span class="hljs-keyword">if</span> (randomInt2 &lt; <span class="hljs-number">26</span>) &#123;<br>                 sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + randomInt2));<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                 sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;A&#x27;</span> + randomInt2 - <span class="hljs-number">26</span>));<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">verifyCode</span> <span class="hljs-operator">=</span> sb.toString();<br>     System.out.println(<span class="hljs-string">&quot;the verify code is:&quot;</span> + verifyCode);<br><br>     <span class="hljs-comment">//验证验证码</span><br>     <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>         System.out.println(<span class="hljs-string">&quot;please enter verification code: &quot;</span>);<br>         <span class="hljs-type">String</span> <span class="hljs-variable">inputCode</span> <span class="hljs-operator">=</span> sc.next();<br>         <span class="hljs-keyword">if</span> (!(verifyCode.equals(inputCode))) &#123;<br>             System.out.println(<span class="hljs-string">&quot;verification code is valid! Please try again!&quot;</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             System.out.println(<span class="hljs-string">&quot;verification code is passed!&quot;</span>);<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-comment">// 三次登录机会</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>         <span class="hljs-type">boolean</span> <span class="hljs-variable">passwordCorrect</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>         System.out.println(<span class="hljs-string">&quot;please enter password: &quot;</span>);<br>         <span class="hljs-type">String</span> <span class="hljs-variable">psw</span> <span class="hljs-operator">=</span> sc.next();<br>         <span class="hljs-comment">// 遍历用户列表，检查用户名和密码是否匹配</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; users.size(); j++) &#123;<br>             <span class="hljs-keyword">if</span> (users.get(j).getUserName().equals(userName) &amp;&amp; users.get(j).getPassword().equals(psw)) &#123;<br>                 passwordCorrect = <span class="hljs-literal">true</span>;<br>                 <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 密码匹配，跳出循环</span><br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">if</span> (passwordCorrect) &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 密码正确，登录成功</span><br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             System.out.println(<span class="hljs-string">&quot;Password is incorrect! Please try again!&quot;</span>);<br>         &#125;<br>     &#125;<br><br>     System.out.println(<span class="hljs-string">&quot;Three opportunities have been used up! Account has been locked!&quot;</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h5 id="4-忘记密码功能"><a href="#4-忘记密码功能" class="headerlink" title="4. 忘记密码功能"></a>4. 忘记密码功能</h5><ol><li>键盘录入用户名，判断当前用户名是否存在，如不存在，直接结束方法</li><li>键盘录入身份证号码和手机号码</li><li>判断当前用户的身份证号码和手机号码是否一致:<ul><li>如果一致，则提示输入密码，进行修改。</li><li>如果不一致，则提示：账号信息不匹配，修改失败。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//忘记密码</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ForgetPassword</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>       System.out.println(<span class="hljs-string">&quot;please enter username: &quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> sc.next();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">currentUserIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>       <span class="hljs-comment">//用户名是否存在</span><br>       <span class="hljs-comment">// 检查用户名是否存在</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; users.size(); i++) &#123;<br>           <span class="hljs-keyword">if</span> (users.get(i).getUserName().equals(userName)) &#123;<br>               currentUserIndex = i;<br>               <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到用户名，跳出循环</span><br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">// 如果用户不存在</span><br>       <span class="hljs-keyword">if</span> (currentUserIndex == -<span class="hljs-number">1</span>) &#123;<br>           System.out.println(<span class="hljs-string">&quot;Username does not register!&quot;</span>);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       System.out.println(<span class="hljs-string">&quot;please enter id card Number: &quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">idCardNumber</span> <span class="hljs-operator">=</span> sc.next();<br>       System.out.println(<span class="hljs-string">&quot;please enter phone number: &quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> sc.next();<br>       <span class="hljs-comment">//身份证号和手机号是否一致</span><br>       <span class="hljs-keyword">if</span> (!(users.get(currentUserIndex).getIdCard().equals(idCardNumber) &amp;&amp; users.get(currentUserIndex).getPhoneNumber().equals(phoneNumber))) &#123;<br>           System.out.println(<span class="hljs-string">&quot;Account information does not match! Modification failed!&quot;</span>);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       System.out.println(<span class="hljs-string">&quot;please enter new password: &quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">newPassword</span> <span class="hljs-operator">=</span> sc.next();<br>       users.get(currentUserIndex).setPassword(newPassword);  <span class="hljs-comment">//修改当前密码</span><br><br>       System.out.println(<span class="hljs-string">&quot;Modify successfully!&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="E-主函数"><a href="#E-主函数" class="headerlink" title="E. 主函数"></a>E. 主函数</h4><ol><li>new一个学生集合</li><li>进入用户登录界面</li><li>登录成功则进入学生管理系统</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLoginIn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//用户登录功能</span><br>        <span class="hljs-keyword">while</span> (!isLoginIn) &#123;<br>            UserManager.showMenu();<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            System.out.print(<span class="hljs-string">&quot;Enter your choice: &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">userChoice</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-keyword">switch</span> (userChoice) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    isLoginIn = UserManager.login();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    UserManager.registerUser();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    UserManager.ForgetPassword();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    System.out.println(<span class="hljs-string">&quot;EXIT&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//进入学生管理系统</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            showMenu();<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">choice</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//选择相应的功能</span><br>            <span class="hljs-keyword">switch</span> (choice) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                    System.out.println(<span class="hljs-string">&quot;please enter the number of students you want to add&quot;</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>                        students = addStudent(students);<br>                    &#125;<br>                &#125;<br>                ;<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    students = deleteStudent(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    students = modifyStudent(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    queryStudents(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    showAllStudents(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                    System.out.println(<span class="hljs-string">&quot;EXIT&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="三-测试"><a href="#三-测试" class="headerlink" title="三. 测试"></a>三. 测试</h2><p><img src="/img/blogs/java/StudentSystem/1.png"></p><p><img src="/img/blogs/java/StudentSystem/2.png"></p><p><img src="/img/blogs/java/StudentSystem/3.png"></p><p><img src="/img/blogs/java/StudentSystem/4.png"></p><h2 id="四-完整代码"><a href="#四-完整代码" class="headerlink" title="四. 完整代码"></a>四. 完整代码</h2><p>创建四个类，分别为<strong>Student.java, User.java, StudentSystem.java, UserManager.java</strong><br>主函数在StudentSystem.java中，直接运行StudentSystem类即可</p><h3 id="1-Student-java-学生类"><a href="#1-Student-java-学生类" class="headerlink" title="1. Student.java(学生类)"></a>1. Student.java(学生类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> study;<br><br><span class="hljs-comment">//学生类属性：id、姓名、年龄、家庭住址</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String homeAddress;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String id, String name, <span class="hljs-type">int</span> age, String homeAddress)</span> &#123; <span class="hljs-comment">//带全部参构造方法</span><br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.homeAddress = homeAddress;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//空参构造方法</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHomeAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> homeAddress;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHomeAddress</span><span class="hljs-params">(String homeAddress)</span> &#123;<br>        <span class="hljs-built_in">this</span>.homeAddress = homeAddress;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;id = &quot;</span> + id + <span class="hljs-string">&quot;, name = &quot;</span> + name + <span class="hljs-string">&quot;, age = &quot;</span> + age + <span class="hljs-string">&quot;, homeAddress = &quot;</span> + homeAddress + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-User-java-用户类"><a href="#2-User-java-用户类" class="headerlink" title="2. User.java(用户类)"></a>2. User.java(用户类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> study;<br><br><span class="hljs-comment">//用户类属性：用户名、密码、身份证号码、手机号码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String idCard;<br>    <span class="hljs-keyword">private</span> String phoneNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String userName, String password, String idCard, String phoneNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>        <span class="hljs-built_in">this</span>.password = password;<br>        <span class="hljs-built_in">this</span>.idCard = idCard;<br>        <span class="hljs-built_in">this</span>.phoneNumber = phoneNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName</span><span class="hljs-params">(String userName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassword</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIdCard</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> idCard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIdCard</span><span class="hljs-params">(String idCard)</span> &#123;<br>        <span class="hljs-built_in">this</span>.idCard = idCard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPhoneNumber</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> phoneNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPhoneNumber</span><span class="hljs-params">(String phoneNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.phoneNumber = phoneNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;userName = &quot;</span> + userName + <span class="hljs-string">&quot;, password = &quot;</span> + password + <span class="hljs-string">&quot;, idCard = &quot;</span> + idCard + <span class="hljs-string">&quot;, phoneNumber = &quot;</span> + phoneNumber + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-UserManager-java-用户登录类"><a href="#3-UserManager-java-用户登录类" class="headerlink" title="3. UserManager.java(用户登录类)"></a>3. UserManager.java(用户登录类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> study;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Random;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//注册</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        System.out.println(<span class="hljs-string">&quot;please enter username: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> sc.next();<br><br>        <span class="hljs-comment">//用户名唯一</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; users.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (users.get(i).getUserName().equals(userName)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;username already exists!&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//用户名长度必须在3-15位</span><br>        <span class="hljs-keyword">if</span> (userName.length() &lt; <span class="hljs-number">3</span> || userName.length() &gt; <span class="hljs-number">15</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;username length must be between 3 and 15 characters!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//用户名必须是字母加数字组合</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">countLetters</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">countNumbers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">countOthers</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; userName.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> userName.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> || ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>                countLetters++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                countNumbers++;<br>            &#125; <span class="hljs-keyword">else</span><br>                countOthers++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (countOthers != <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;username cannot be special characters!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (countLetters == <span class="hljs-number">0</span> || countNumbers == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;username cannot be only letters or numbers!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br><br>        <span class="hljs-comment">//密码键盘输入两次，两次一致才可以进行注册。</span><br>        System.out.println(<span class="hljs-string">&quot;please enter password: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">psw1</span> <span class="hljs-operator">=</span> sc.next();<br>        System.out.println(<span class="hljs-string">&quot;please enter password again: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">psw2</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-keyword">if</span> (!psw1.equals(psw2)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;passwords do not match!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;please enter id card Number: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">idCardNumber</span> <span class="hljs-operator">=</span> sc.next();<br><br>        <span class="hljs-comment">//长度为18位,不能以0为开头</span><br>        <span class="hljs-keyword">if</span> (idCardNumber.length() != <span class="hljs-number">18</span> || idCardNumber.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;id card number is not valid!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//前17位必须都是数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; idCardNumber.length() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> idCardNumber.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;id card number is not valid!&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//最后一位可以是数字，也可以是大写X或小写x</span><br>        <span class="hljs-keyword">if</span> (!((idCardNumber.charAt(<span class="hljs-number">17</span>) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; idCardNumber.charAt(<span class="hljs-number">17</span>) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || idCardNumber.charAt(<span class="hljs-number">17</span>) == <span class="hljs-string">&#x27;x&#x27;</span> || idCardNumber.charAt(<span class="hljs-number">17</span>) == <span class="hljs-string">&#x27;X&#x27;</span>)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;id card number is not valid!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//长度为11位 不能以0为开头必须都是数字</span><br>        System.out.println(<span class="hljs-string">&quot;please enter phone number: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> sc.next();<br><br>        <span class="hljs-keyword">if</span> (phoneNumber.length() != <span class="hljs-number">11</span> || phoneNumber.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;phone number is not valid!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; phoneNumber.length(); i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> phoneNumber.charAt(i);<br>            <span class="hljs-keyword">if</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;phone number is not valid!&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(userName, psw1, idCardNumber, phoneNumber);<br>        users.add(newUser); <span class="hljs-comment">//注册</span><br>        System.out.println(<span class="hljs-string">&quot;user registered successfully!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//登录</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;please enter username: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-comment">//用户名是否已注册</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">userExists</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; users.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (users.get(i).getUserName().equals(userName)) &#123;<br>                userExists = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!userExists) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Username does not register!&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果用户名没有注册，直接返回</span><br>        &#125;<br><br><br>        <span class="hljs-comment">//随机生成验证码</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomInt</span> <span class="hljs-operator">=</span> rd.nextInt(<span class="hljs-number">5</span>);<span class="hljs-comment">//生成0-4随机整数</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == randomInt) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">randomInt1</span> <span class="hljs-operator">=</span> rd.nextInt(<span class="hljs-number">10</span>);<br>                sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;0&#x27;</span> + randomInt1)); <span class="hljs-comment">//生成0-9随机字符</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">randomInt2</span> <span class="hljs-operator">=</span> rd.nextInt(<span class="hljs-number">52</span>);<br>                <span class="hljs-keyword">if</span> (randomInt2 &lt; <span class="hljs-number">26</span>) &#123;<br>                    sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + randomInt2));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    sb.append((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;A&#x27;</span> + randomInt2 - <span class="hljs-number">26</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">verifyCode</span> <span class="hljs-operator">=</span> sb.toString();<br>        System.out.println(<span class="hljs-string">&quot;the verify code is:&quot;</span> + verifyCode);<br><br>        <span class="hljs-comment">//验证验证码</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;please enter verification code: &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">inputCode</span> <span class="hljs-operator">=</span> sc.next();<br>            <span class="hljs-keyword">if</span> (!(verifyCode.equals(inputCode))) &#123;<br>                System.out.println(<span class="hljs-string">&quot;verification code is valid! Please try again!&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;verification code is passed!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 三次登录机会</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">passwordCorrect</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            System.out.println(<span class="hljs-string">&quot;please enter password: &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">psw</span> <span class="hljs-operator">=</span> sc.next();<br>            <span class="hljs-comment">// 遍历用户列表，检查用户名和密码是否匹配</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; users.size(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (users.get(j).getUserName().equals(userName) &amp;&amp; users.get(j).getPassword().equals(psw)) &#123;<br>                    passwordCorrect = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 密码匹配，跳出循环</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (passwordCorrect) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 密码正确，登录成功</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Password is incorrect! Please try again!&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Three opportunities have been used up! Account has been locked!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//忘记密码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ForgetPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;please enter username: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentUserIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//用户名是否存在</span><br>        <span class="hljs-comment">// 检查用户名是否存在</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; users.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (users.get(i).getUserName().equals(userName)) &#123;<br>                currentUserIndex = i;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到用户名，跳出循环</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果用户不存在</span><br>        <span class="hljs-keyword">if</span> (currentUserIndex == -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Username does not register!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;please enter id card Number: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">idCardNumber</span> <span class="hljs-operator">=</span> sc.next();<br>        System.out.println(<span class="hljs-string">&quot;please enter phone number: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phoneNumber</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-comment">//身份证号和手机号是否一致</span><br>        <span class="hljs-keyword">if</span> (!(users.get(currentUserIndex).getIdCard().equals(idCardNumber) &amp;&amp; users.get(currentUserIndex).getPhoneNumber().equals(phoneNumber))) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Account information does not match! Modification failed!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;please enter new password: &quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">newPassword</span> <span class="hljs-operator">=</span> sc.next();<br>        users.get(currentUserIndex).setPassword(newPassword);  <span class="hljs-comment">//修改当前密码</span><br><br>        System.out.println(<span class="hljs-string">&quot;Modify successfully!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//菜单</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMenu</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---------Welcome to student manager system-------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;please choose your option: 1 is Login, 2 is Register, 3 is Forget password, 4 is Exit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-StudentSystem-java-学生管理系统测试类"><a href="#4-StudentSystem-java-学生管理系统测试类" class="headerlink" title="4. StudentSystem.java(学生管理系统测试类)"></a>4. StudentSystem.java(学生管理系统测试类)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> study;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentSystem</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLoginIn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//用户登录功能</span><br>        <span class="hljs-keyword">while</span> (!isLoginIn) &#123;<br>            UserManager.showMenu();<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            System.out.print(<span class="hljs-string">&quot;Enter your choice: &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">userChoice</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-keyword">switch</span> (userChoice) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    isLoginIn = UserManager.login();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    UserManager.registerUser();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    UserManager.ForgetPassword();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    System.out.println(<span class="hljs-string">&quot;EXIT&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            showMenu();<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">choice</span> <span class="hljs-operator">=</span> sc.nextInt();<span class="hljs-comment">//选择相应的功能</span><br>            <span class="hljs-keyword">switch</span> (choice) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                    System.out.println(<span class="hljs-string">&quot;please enter the number of students you want to add&quot;</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>                        students = addStudent(students);<br>                    &#125;<br>                &#125;<br>                ;<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    students = deleteStudent(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    students = modifyStudent(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    queryStudents(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    showAllStudents(students);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                    System.out.println(<span class="hljs-string">&quot;EXIT&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//菜单界面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showMenu</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;---------Welcome to student manager system--------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;1. Add student&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;2. Delete student&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;3. Modify students&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;4. Query students&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;5. Show all students&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;6. Exit&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Please enter your choice:&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//添加功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">addStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;Please enter the student information to be ADDED, the student id is:&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-comment">//判断添加学生的学号是否已经存在</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (students.get(i).getId().equals(id)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Student already exists&quot;</span>);<br>                <span class="hljs-keyword">return</span> students;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Please enter student name:&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> sc.next();<br>        System.out.println(<span class="hljs-string">&quot;Please enter student age:&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;Please enter student&#x27;s home address:&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">homeAddress</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">newStudent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id, name, age, homeAddress);<br>        students.add(newStudent);  <span class="hljs-comment">//添加</span><br>        <span class="hljs-keyword">return</span> students;<br>    &#125;<br><br>    <span class="hljs-comment">//删除学生信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">deleteStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Please enter the student id to be DELETE:&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">delId</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (students.get(i).getId().equals(delId)) &#123;<br>                students.remove(i);  <span class="hljs-comment">//删除</span><br>                <span class="hljs-keyword">return</span> students;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Student does not exist&quot;</span>);<br>        <span class="hljs-keyword">return</span> students;<br>    &#125;<br><br>    <span class="hljs-comment">//修改学生信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Student&gt; <span class="hljs-title function_">modifyStudent</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Please enter the student id to be MODIFY:&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">modId</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (students.get(i).getId().equals(modId)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Student exists,please enter student&#x27;s new ID:&quot;</span>);<br>                students.get(i).setId(sc.next());<br>                System.out.println(<span class="hljs-string">&quot;enter student&#x27;s new name:&quot;</span>);<br>                students.get(i).setName(sc.next());<br>                System.out.println(<span class="hljs-string">&quot;enter student&#x27;s new age:&quot;</span>);<br>                students.get(i).setAge(sc.nextInt());<br>                System.out.println(<span class="hljs-string">&quot;enter student&#x27;s new home address:&quot;</span>);<br>                students.get(i).setHomeAddress(sc.next());<br>                <span class="hljs-keyword">return</span> students;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Student does not exist&quot;</span>);<br>        <span class="hljs-keyword">return</span> students;<br>    &#125;<br><br>    <span class="hljs-comment">//查询某个学生信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryStudents</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Please enter the student id to be QUERY:&quot;</span>);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">queId</span> <span class="hljs-operator">=</span> sc.next();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (students.get(i).getId().equals(queId)) &#123;<br>                System.out.println(students.get(i));<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Not found the student&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//显示所有学生信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAllStudents</span><span class="hljs-params">(ArrayList&lt;Student&gt; students)</span> &#123;<br>        <span class="hljs-keyword">if</span> (students.size() == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;No students found, please add a student!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Students Information is as Follows:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;id     name     age     home address&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; students.size(); i++) &#123;<br>            System.out.println(students.get(i).getId() + <span class="hljs-string">&quot;  &quot;</span> + students.get(i).getName() + <span class="hljs-string">&quot;  &quot;</span> + students.get(i).getAge() + <span class="hljs-string">&quot;   &quot;</span> + students.get(i).getHomeAddress());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>学习</tag>
      
      <tag>javase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript学习笔记</title>
    <link href="/2024/12/18/FrontEnd/JS%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/18/FrontEnd/JS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-JS介绍"><a href="#1-JS介绍" class="headerlink" title="1. JS介绍"></a>1. JS介绍</h2><p>JS是一种运行在客户端(浏览器)的编程语言，实现人机交互效果</p><h2 id="2-JS的组成"><a href="#2-JS的组成" class="headerlink" title="2. JS的组成"></a>2. JS的组成</h2><h4 id="A-ECMAScript"><a href="#A-ECMAScript" class="headerlink" title="A. ECMAScript"></a>A. ECMAScript</h4><p>JavaScript语言基础规定了JS基础语法核心知识</p><ul><li>变量，分支语句，循环语句，对象等</li></ul><h4 id="B-Web-APIS"><a href="#B-Web-APIS" class="headerlink" title="B. Web APIS"></a>B. Web APIS</h4><ul><li>DOM(页面文档对象模型): 操作文档，对页面元素进行移动，大小，添加，删除等</li><li>BOM(浏览器对象模型): 操作浏览器，如页面弹窗，检测窗口宽度，存储数据到浏览器等</li></ul><h2 id="3-JS书写位置"><a href="#3-JS书写位置" class="headerlink" title="3. JS书写位置"></a>3. JS书写位置</h2><h4 id="A-内部JS"><a href="#A-内部JS" class="headerlink" title="A. 内部JS"></a>A. 内部JS</h4><p>直接写在HTML文件中，用Script标签包住；通常将JS代码放在HTML页面底部最好</p><h4 id="B-外部JS"><a href="#B-外部JS" class="headerlink" title="B. 外部JS"></a>B. 外部JS</h4><p>JS代码写在以.js结尾的文件中，然后在HTML的body中引入<br>引入方式： <code>&lt;script src=&quot;./1.js&quot;&gt;&lt;/script&gt;</code></p><h4 id="C-内联JS"><a href="#C-内联JS" class="headerlink" title="C. 内联JS"></a>C. 内联JS</h4><p>代码写在标签内部</p><h2 id="4-JS输入输出语法"><a href="#4-JS输入输出语法" class="headerlink" title="4. JS输入输出语法"></a>4. JS输入输出语法</h2><h4 id="A-输出语法"><a href="#A-输出语法" class="headerlink" title="A. 输出语法"></a>A. 输出语法</h4><ol><li>语法1</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;输出的内容&#x27;</span>)<br></code></pre></td></tr></table></figure><p>向body内输出内容</p><ol start="2"><li>语法2</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;输出的内容&#x27;</span>)<br></code></pre></td></tr></table></figure><p>页面弹出警告对话框用于输出</p><ol start="3"><li>语法3</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;输出的内容&#x27;</span>)<br></code></pre></td></tr></table></figure><p>控制台输出的语句，用于程序员调试使用</p><h4 id="B-输入语法"><a href="#B-输入语法" class="headerlink" title="B. 输入语法"></a>B. 输入语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入：&#x27;</span>)<br></code></pre></td></tr></table></figure><p>显示一个对话框用于用户输入内容</p><h2 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h2><h4 id="A-变量的使用"><a href="#A-变量的使用" class="headerlink" title="A. 变量的使用"></a>A. 变量的使用</h4><h5 id="1-声明变量"><a href="#1-声明变量" class="headerlink" title="1. 声明变量"></a>1. 声明变量</h5><p>语法：  <code>let 变量名</code><br>声明变量由声明关键字和变量名组成，其中let是关键字<br>例：声明一个年龄变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age<br></code></pre></td></tr></table></figure><h5 id="2-变量赋值"><a href="#2-变量赋值" class="headerlink" title="2. 变量赋值"></a>2. 变量赋值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age<br>age = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><h5 id="3-更新变量"><a href="#3-更新变量" class="headerlink" title="3. 更新变量"></a>3. 更新变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span><br>age = <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><h5 id="4-声明多个变量"><a href="#4-声明多个变量" class="headerlink" title="4.声明多个变量"></a>4.声明多个变量</h5><p>多个变量中间用逗号隔开</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>, uname = <span class="hljs-string">&#x27;前端&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="B-变量的本质"><a href="#B-变量的本质" class="headerlink" title="B. 变量的本质"></a>B. 变量的本质</h4><p>程序在内存中开辟的存放数据的小空间</p><h4 id="C-变量命名规则与规范"><a href="#C-变量命名规则与规范" class="headerlink" title="C. 变量命名规则与规范"></a>C. 变量命名规则与规范</h4><h5 id="1-规则"><a href="#1-规则" class="headerlink" title="1. 规则"></a>1. 规则</h5><ul><li>不能用关键字</li><li>只能用下划线、字母、数字和$组成，且数字不能开头</li><li>区分大小写</li></ul><h5 id="2-规范"><a href="#2-规范" class="headerlink" title="2. 规范"></a>2. 规范</h5><ul><li>起名要有意义</li><li>遵守小驼峰命名法，如userName</li></ul><h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><h4 id="A-声明语法"><a href="#A-声明语法" class="headerlink" title="A. 声明语法"></a>A. 声明语法</h4><p><code>let 数组名 = [数据1，数据2，...,数据n]</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-string">&#x27;小蓝&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="B-取值语法"><a href="#B-取值语法" class="headerlink" title="B. 取值语法"></a>B. 取值语法</h4><p><code>数组名[下标]</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>)<br></code></pre></td></tr></table></figure><p>分别输出5，3，5</p><h2 id="7-常量"><a href="#7-常量" class="headerlink" title="7. 常量"></a>7. 常量</h2><p>使用const声明的是常量，不能改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><h2 id="8-数据类型"><a href="#8-数据类型" class="headerlink" title="8. 数据类型"></a>8. 数据类型</h2><h4 id="A-分类"><a href="#A-分类" class="headerlink" title="A. 分类"></a>A. 分类</h4><h5 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h5><p>包括number数字型，string字符串型，boolean布尔型，undefined未定义型和null空类型</p><h5 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2. 引用数据类型"></a>2. 引用数据类型</h5><p>object对象</p><h4 id="B-数字类型-number"><a href="#B-数字类型-number" class="headerlink" title="B. 数字类型(number)"></a>B. 数字类型(number)</h4><p>包括整数、小数、正数和负数，JS是弱数据类型的语言</p><ul><li>算术运算符： +，-，*，&#x2F;，%(取模)</li></ul><h4 id="C-字符串类型-string"><a href="#C-字符串类型-string" class="headerlink" title="C. 字符串类型(string)"></a>C. 字符串类型(string)</h4><p>通过单引号(‘’),双引号(“”),反引号(&#96;&#96;)包裹的数据都叫字符串类型，推荐使用单引号(‘’)</p><h5 id="1-字符串拼接"><a href="#1-字符串拼接" class="headerlink" title="1. 字符串拼接"></a>1. 字符串拼接</h5><p>使用’+’运算符实现字符串的拼接<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;我是&#x27;</span> + <span class="hljs-string">&#x27;JS&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出”我是JS”<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;我今年&#x27;</span> + age + <span class="hljs-string">&#x27;岁了&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出”我今年20岁了”，当age改变时，输出也会改变</p><h5 id="2-模板字符串"><a href="#2-模板字符串" class="headerlink" title="2. 模板字符串"></a>2. 模板字符串</h5><p>用于拼接字符串和变量<br>外面用&#96;&#96;(反引号)，内容拼接变量时，用${}包住变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;大家好，我叫$&#123;name&#125;,今年$&#123;age&#125;岁&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="D-布尔类型-boolean"><a href="#D-布尔类型-boolean" class="headerlink" title="D. 布尔类型(boolean)"></a>D. 布尔类型(boolean)</h4><p>仅有true和false<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> isColl = <span class="hljs-literal">true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isCool) <span class="hljs-comment">//输出true</span><br></code></pre></td></tr></table></figure><h4 id="E-未定义类型-undefined"><a href="#E-未定义类型-undefined" class="headerlink" title="E. 未定义类型(undefined)"></a>E. 未定义类型(undefined)</h4><p>只有一个值undefined;只声明变量，不赋值的情况下<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num<br>consoole.<span class="hljs-title function_">log</span>(num)  <span class="hljs-comment">//输出undefined</span><br></code></pre></td></tr></table></figure><h4 id="F-空类型-null"><a href="#F-空类型-null" class="headerlink" title="F. 空类型(null)"></a>F. 空类型(null)</h4><p>代表空的，无<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-literal">null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)  <span class="hljs-comment">//输出null</span><br></code></pre></td></tr></table></figure><h4 id="G-检测数据类型"><a href="#G-检测数据类型" class="headerlink" title="G. 检测数据类型"></a>G. 检测数据类型</h4><p>使用typeof关键字检测数据类型<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span><br><span class="hljs-keyword">let</span> uname = <span class="hljs-string">&#x27;JS&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> age)  <span class="hljs-comment">//输出number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> uname)  <span class="hljs-comment">//输出string</span><br></code></pre></td></tr></table></figure><h2 id="9-类型转换"><a href="#9-类型转换" class="headerlink" title="9. 类型转换"></a>9. 类型转换</h2><h4 id="A-隐式转换"><a href="#A-隐式转换" class="headerlink" title="A. 隐式转换"></a>A. 隐式转换</h4><ul><li>+号两边只要有一个是字符串，都会把另一个转成字符串</li><li>除了+以外的算术运算符，比如-*&#x2F;等都会把数据转成数字类型</li></ul><h4 id="B-显示转换"><a href="#B-显示转换" class="headerlink" title="B. 显示转换"></a>B. 显示转换</h4><p>转换成数字型(使用Number)<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(str)) <span class="hljs-comment">//输出数字123</span><br></code></pre></td></tr></table></figure><h2 id="10-运算符"><a href="#10-运算符" class="headerlink" title="10. 运算符"></a>10. 运算符</h2><h4 id="A-赋值运算符"><a href="#A-赋值运算符" class="headerlink" title="A. 赋值运算符"></a>A. 赋值运算符</h4><p>&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</p><h4 id="B-一元运算符"><a href="#B-一元运算符" class="headerlink" title="B. 一元运算符"></a>B. 一元运算符</h4><p>自增： ++<br>自减： –</p><h4 id="C-比较运算符"><a href="#C-比较运算符" class="headerlink" title="C. 比较运算符"></a>C. 比较运算符</h4><p><code>&gt;,&lt;,&gt;=,&lt;=</code><br>&#x3D;&#x3D;: 左右两边值是否相等<br>&#x3D;&#x3D;&#x3D;： 左右两边是否类型和值都相等<br><code>!==: 左右两边是否不全等</code><br>比较结果为boolean类型，true或false，开发中判断是否相等，推荐使用<code>===</code></p><h4 id="D-逻辑运算符"><a href="#D-逻辑运算符" class="headerlink" title="D. 逻辑运算符"></a>D. 逻辑运算符</h4><p>&amp;&amp;(与)，||(或)，！(非)</p><h2 id="11-分支语句"><a href="#11-分支语句" class="headerlink" title="11. 分支语句"></a>11. 分支语句</h2><h4 id="A-if分支语句"><a href="#A-if分支语句" class="headerlink" title="A. if分支语句"></a>A. if分支语句</h4><h5 id="1-单分支"><a href="#1-单分支" class="headerlink" title="1. 单分支"></a>1. 单分支</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件)&#123;满足条件时执行的代码&#125;<br></code></pre></td></tr></table></figure><h5 id="2-双分支"><a href="#2-双分支" class="headerlink" title="2. 双分支"></a>2. 双分支</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件)&#123;满足条件时执行的代码&#125;<br><span class="hljs-keyword">else</span>&#123;不满足条件时执行的代码&#125;<br></code></pre></td></tr></table></figure><h5 id="3-多分支"><a href="#3-多分支" class="headerlink" title="3. 多分支"></a>3. 多分支</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>)&#123;代码<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>)&#123;代码<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">3</span>)&#123;代码<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">else</span>&#123;代码n&#125;<br></code></pre></td></tr></table></figure><h4 id="B-三元运算符"><a href="#B-三元运算符" class="headerlink" title="B. 三元运算符"></a>B. 三元运算符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">条件？满足条件执行的代码:不满足条件时执行的代码<br></code></pre></td></tr></table></figure><h4 id="C-switch语句"><a href="#C-switch语句" class="headerlink" title="C. switch语句"></a>C. switch语句</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span>(数据)&#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>    代码<span class="hljs-number">1</span><br>    <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>    代码<span class="hljs-number">2</span><br>    <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>    代码n<br>    <span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-循环语句"><a href="#12-循环语句" class="headerlink" title="12. 循环语句"></a>12. 循环语句</h2><h4 id="A-while循环"><a href="#A-while循环" class="headerlink" title="A. while循环"></a>A. while循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>    要重复执行的代码(循环体)<br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> (i&lt;=<span class="hljs-number">3</span>)&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;循环三次&lt;br&gt;&#x27;</span>)<br>    i++<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-break和continue"><a href="#B-break和continue" class="headerlink" title="B. break和continue"></a>B. break和continue</h4><ul><li>break: 退出整个循环</li><li>continue: 退出本次循环</li></ul><h4 id="C-for循环"><a href="#C-for循环" class="headerlink" title="C. for循环"></a>C. for循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(变量起始值;终止条件;变量变化量)&#123;<br>    循环体<br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;循环三次&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-打印数组"><a href="#1-打印数组" class="headerlink" title="1. 打印数组"></a>1. 打印数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-循环嵌套"><a href="#2-循环嵌套" class="headerlink" title="2. 循环嵌套"></a>2. 循环嵌套</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        循环体<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-99乘法表"><a href="#3-99乘法表" class="headerlink" title="3. 99乘法表"></a>3. 99乘法表</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>;j &lt;= i;j++)&#123;<br>         <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;span&gt;$&#123;j&#125;X$&#123;i&#125; = $&#123;i*j&#125;&lt;/span&gt;&#x27;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-数组"><a href="#13-数组" class="headerlink" title="13. 数组"></a>13. 数组</h2><p>数组是一种可以按顺序保存数据的数据类型</p><h4 id="A-数组的基本使用"><a href="#A-数组的基本使用" class="headerlink" title="A. 数组的基本使用"></a>A. 数组的基本使用</h4><h5 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1. 声明数组"></a>1. 声明数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> 数组名 = [数据<span class="hljs-number">1</span>,数据<span class="hljs-number">2</span>,...,数据n]<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;pink&#x27;</span>,<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><h5 id="2-取值数组"><a href="#2-取值数组" class="headerlink" title="2. 取值数组"></a>2. 取值数组</h5><p><code>数组名[下标]</code></p><h4 id="B-操作数组"><a href="#B-操作数组" class="headerlink" title="B. 操作数组"></a>B. 操作数组</h4><h5 id="1-修改"><a href="#1-修改" class="headerlink" title="1. 修改"></a>1. 修改</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;pink&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">lengh</span>; i++)&#123;<br>    arr[i] = arr[i] + <span class="hljs-string">&#x27;老师&#x27;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br></code></pre></td></tr></table></figure><h5 id="2-新增"><a href="#2-新增" class="headerlink" title="2. 新增"></a>2. 新增</h5><p><code>数组.push()</code>将元素添加到数组末尾，并返回数组新长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">push</span>(元素<span class="hljs-number">1</span>,...,元素n)<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;pink&#x27;</span>,<span class="hljs-string">&#x27;hotpink&#x27;</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;red&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)  <span class="hljs-comment">//输出[&#x27;pink&#x27;,&#x27;hotpink&#x27;,&#x27;red&#x27;]</span><br></code></pre></td></tr></table></figure><p><code>数组.unshift(新增内容)</code>将元素添加到数组开头，并返回数组新长度</p><h5 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h5><ul><li><code>数组.pop()</code>  删除最后一个元素，并返回该元素的值</li><li><code>数组.splice()</code>  删除指定元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.<span class="hljs-title function_">splice</span>(start,deleteCount)<br>arr.<span class="hljs-title function_">splice</span>(起始位置，删除几个元素)<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>]<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)  <span class="hljs-comment">//输出[&#x27;red&#x27;,&#x27;blue&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><code>数组.shift()</code>  删除开头第一个元素，并返回该元素的值</li></ul><h2 id="14-函数"><a href="#14-函数" class="headerlink" title="14. 函数"></a>14. 函数</h2><h4 id="A-函数使用"><a href="#A-函数使用" class="headerlink" title="A. 函数使用"></a>A. 函数使用</h4><h5 id="1-函数的声明"><a href="#1-函数的声明" class="headerlink" title="1. 函数的声明"></a>1. 函数的声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> 函数名()&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello,world&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-函数的调用"><a href="#2-函数的调用" class="headerlink" title="2. 函数的调用"></a>2. 函数的调用</h5><p>语法： <code>函数名()</code></p><h4 id="B-函数传参"><a href="#B-函数传参" class="headerlink" title="B. 函数传参"></a>B. 函数传参</h4><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">num1, num2</span>)&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(num1 + num2)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)   <span class="hljs-comment">//输出30</span><br></code></pre></td></tr></table></figure><p>调用函数时，需要传入几个数据就写几个，用逗号隔开</p><h4 id="C-函数返回值"><a href="#C-函数返回值" class="headerlink" title="C. 函数返回值"></a>C. 函数返回值</h4><p>当调用某个函数，这个函数会返回一个结果出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">20</span><br>&#125;<br><span class="hljs-keyword">let</span> red = <span class="hljs-title function_">fn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)  <span class="hljs-comment">//输出20</span><br></code></pre></td></tr></table></figure><p>return后面代码不会再被执行，会立即结束当前函数</p><h4 id="D-作用域"><a href="#D-作用域" class="headerlink" title="D. 作用域"></a>D. 作用域</h4><p>一段程序代码中用到的名字并不总是有效和可用的，而限定这个名字的可用性代码范围就是这个名字的作用域</p><ul><li>全局作用域：作用于所有代码执行的环境</li><li>局部作用域：仅作用于函数内的代码环境</li><li>全局变量</li><li>局部变量</li></ul><h4 id="E-匿名函数"><a href="#E-匿名函数" class="headerlink" title="E. 匿名函数"></a>E. 匿名函数</h4><ul><li>具名函数：<code>function fn(){}</code>  调用：<code>fn()</code></li><li>匿名函数：<code>function(){}</code></li></ul><h5 id="1-函数表达式"><a href="#1-函数表达式" class="headerlink" title="1. 函数表达式"></a>1. 函数表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y)<br>&#125;<br><span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">//输出3</span><br></code></pre></td></tr></table></figure><h5 id="2-立即执行函数"><a href="#2-立即执行函数" class="headerlink" title="2. 立即执行函数"></a>2. 立即执行函数</h5><p><code>(function(){})();</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + y)<br>&#125;)(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">//输出3</span><br></code></pre></td></tr></table></figure><p>无需调用，立即执行。多个立即执行函数之间用分号隔开</p><h2 id="15-对象"><a href="#15-对象" class="headerlink" title="15. 对象"></a>15. 对象</h2><h4 id="A-对象的定义"><a href="#A-对象的定义" class="headerlink" title="A. 对象的定义"></a>A. 对象的定义</h4><p>是一种数据类型，是一只无序的数据集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink老师&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;女&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="B-对象使用"><a href="#B-对象使用" class="headerlink" title="B. 对象使用"></a>B. 对象使用</h4><p>对象声明：  <code>let 对象名={}</code></p><ul><li>属性：信息或特征</li><li>方法：功能或行为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> 对象名=&#123;<br>    属性名: 属性值,<br>    方法名: 函数<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-对象的增删改查"><a href="#C-对象的增删改查" class="headerlink" title="C. 对象的增删改查"></a>C. 对象的增删改查</h4><h5 id="1-属性–查"><a href="#1-属性–查" class="headerlink" title="1. 属性–查"></a>1. 属性–查</h5><p>语法：<code>对象名.属性</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">uname</span>)  <span class="hljs-comment">//输出&#x27;小红&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>)  <span class="hljs-comment">//输出18</span><br></code></pre></td></tr></table></figure><h5 id="2-属性-改"><a href="#2-属性-改" class="headerlink" title="2. 属性-改"></a>2. 属性-改</h5><p>语法： <code>对象名.属性 = 新值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br>person.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>)  <span class="hljs-comment">//修改为了20</span><br></code></pre></td></tr></table></figure><h5 id="3-属性-增"><a href="#3-属性-增" class="headerlink" title="3. 属性-增"></a>3. 属性-增</h5><p>语法： <code>对象名.新属性 = 新值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br>person.<span class="hljs-property">gender</span> = <span class="hljs-string">&#x27;女&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person)  <span class="hljs-comment">//输出&#x27;小红&#x27;,18,&#x27;女&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="4-属性-删"><a href="#4-属性-删" class="headerlink" title="4. 属性-删"></a>4. 属性-删</h5><p>语法： <code>delete 对象名.属性</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> person.<span class="hljs-property">gender</span><br></code></pre></td></tr></table></figure><h5 id="5-属性-查的另一种写法"><a href="#5-属性-查的另一种写法" class="headerlink" title="5. 属性-查的另一种写法"></a>5. 属性-查的另一种写法</h5><p>对于多词属性或则一等属性，采用<code>对象[&#39;属性&#39;]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">&#x27;num&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="D-对象的方法-函数"><a href="#D-对象的方法-函数" class="headerlink" title="D. 对象的方法(函数)"></a>D. 对象的方法(函数)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>    <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello,world&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法：    <code>方法名:函数</code></p><h4 id="E-遍历对象"><a href="#E-遍历对象" class="headerlink" title="E. 遍历对象"></a>E. 遍历对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k)    <span class="hljs-comment">//输出&#x27;uname&#x27;,&#x27;age&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[k])  <span class="hljs-comment">//输出&#x27;小红&#x27;,18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>k是获得对象的属性名，对象名[k]获得属性值</p><h4 id="F-内置对象"><a href="#F-内置对象" class="headerlink" title="F. 内置对象"></a>F. 内置对象</h4><p>常用的内置对象有：</p><ul><li>document.write()</li><li>console.log()</li></ul><h4 id="G-内置对象Math"><a href="#G-内置对象Math" class="headerlink" title="G. 内置对象Math"></a>G. 内置对象Math</h4><p>Math对象常用方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>Math.random()</td><td>生成0~1之间的随机数</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.max()</td><td>找最大数</td></tr><tr><td>Math.min()</td><td>找最小数</td></tr><tr><td>Math.pow()</td><td>幂运算</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr></tbody></table><h2 id="16-声明变量用let还是const"><a href="#16-声明变量用let还是const" class="headerlink" title="16. 声明变量用let还是const"></a>16. 声明变量用let还是const</h2><p>优先使用const<br>除非变量后面是要被修改的，再改为let</p><h2 id="17-API的作用和分类"><a href="#17-API的作用和分类" class="headerlink" title="17. API的作用和分类"></a>17. API的作用和分类</h2><p>作用：使用JS去操作HTML和浏览器<br>分类：DOM(文档对象模型)，BOM(浏览器对象模型)</p><h2 id="18-DOM"><a href="#18-DOM" class="headerlink" title="18. DOM"></a>18. DOM</h2><h4 id="A-定义"><a href="#A-定义" class="headerlink" title="A. 定义"></a>A. 定义</h4><p>DOM(Document Object Model-文档对象模型)用来呈现与任意HTML或XML文档交互的API<br>DOM是浏览器提供的一套专门用于操作网页内容的功能</p><h4 id="B-DOM树"><a href="#B-DOM树" class="headerlink" title="B. DOM树"></a>B. DOM树</h4><p>将HTML文档以树状结构直观的表现出来，直观的体现了标签与标签之间的关系</p><h4 id="C-DOM对象"><a href="#C-DOM对象" class="headerlink" title="C. DOM对象"></a>C. DOM对象</h4><p>浏览器根据HTML标签生成的JS对象</p><ul><li>所有的标签属性都能在这个对象上找到</li><li>修改这个对象属性会自动映射到标签上</li></ul><h2 id="19-获取DOM元素"><a href="#19-获取DOM元素" class="headerlink" title="19. 获取DOM元素"></a>19. 获取DOM元素</h2><p>查找DOM元素就是利用JS选择页面中标签元素<br>根据CSS选择器来获取DOM元素</p><h4 id="A-选择匹配的第一个元素"><a href="#A-选择匹配的第一个元素" class="headerlink" title="A. 选择匹配的第一个元素"></a>A. 选择匹配的第一个元素</h4><p>语法： <code>document.querySelector(&#39;CSS选择器&#39;)</code><br>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>abc<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>导航栏<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)  <span class="hljs-comment">//获取&#x27;123&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)  <span class="hljs-comment">//获取&#x27;123&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> nav = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#nav&#x27;</span>)  <span class="hljs-comment">//获取&#x27;导航栏&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul li:first-child&#x27;</span>)  <span class="hljs-comment">//获取测试1</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-选择匹配的多个元素"><a href="#B-选择匹配的多个元素" class="headerlink" title="B. 选择匹配的多个元素"></a>B. 选择匹配的多个元素</h4><p>语法：<code>document.querySelectorAll(&#39;CSS选择器&#39;)</code><br>返回值：CSS选择器匹配的NodeList对象集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;ul li&#x27;</span>)<span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>得到的是个伪数组，想要得到里面每个对象需要遍历(for)获得</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>测试1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>测试2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>测试3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> lis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.nav li&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lis.<span class="hljs-property">length</span>; i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lis[i])</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="20-操作元素内容"><a href="#20-操作元素内容" class="headerlink" title="20. 操作元素内容"></a>20. 操作元素内容</h2><h4 id="A-对象-innerText"><a href="#A-对象-innerText" class="headerlink" title="A. 对象.innerText"></a>A. 对象.innerText</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;我是一段文字&lt;/div&gt;<br><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)  <span class="hljs-comment">//获取元素</span><br>box.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;我是一个盒子&#x27;</span>  <span class="hljs-comment">//修改页面文字内容</span><br></code></pre></td></tr></table></figure><p>只显示纯文本的修改，不解析标签</p><h4 id="B-对象-innerHTML"><a href="#B-对象-innerHTML" class="headerlink" title="B. 对象.innerHTML"></a>B. 对象.innerHTML</h4><p>会解析标签，一同修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">box.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;strong&gt;我是一个盒子&lt;/strong&gt;&#x27;</span> <span class="hljs-comment">//此时页面显示的标签会加粗</span><br></code></pre></td></tr></table></figure><h2 id="21-操作元素属性"><a href="#21-操作元素属性" class="headerlink" title="21. 操作元素属性"></a>21. 操作元素属性</h2><h4 id="A-操作元素常用属性"><a href="#A-操作元素常用属性" class="headerlink" title="A. 操作元素常用属性"></a>A. 操作元素常用属性</h4><p>通过JS设置&#x2F;修改标签元素属性，通过src更换图片<br>语法：  <code>对象.属性 = 值</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pic = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;img&#x27;</span>)<br>pic.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;./images/2.jpg&#x27;</span><br>pic.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;图片的修改标题&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="B-操作元素样式属性"><a href="#B-操作元素样式属性" class="headerlink" title="B. 操作元素样式属性"></a>B. 操作元素样式属性</h4><p>通过JS设置&#x2F;修改标签元素的样式属性</p><h5 id="1-通过style属性操作CSS"><a href="#1-通过style属性操作CSS" class="headerlink" title="1. 通过style属性操作CSS"></a>1. 通过style属性操作CSS</h5><p>语法：   <code>对象.style.样式属性 = 值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.<span class="hljs-property">box</span>&#123;<br>    <span class="hljs-attr">width</span>: 200px;<br>    <span class="hljs-attr">height</span>: 200px;<br>    background-<span class="hljs-attr">color</span>: pink;<br>&#125;<br>&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">box.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&#x27;300px&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;hotpink&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">box.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;2px solid blue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="2-通过类名修改样式"><a href="#2-通过类名修改样式" class="headerlink" title="2. 通过类名修改样式"></a>2. 通过类名修改样式</h5><p>语法： <code>元素.className = &#39;active&#39;  //active是一个CSS类名</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">div&#123;<br>    <span class="hljs-attr">width</span>: 200px;<br>    <span class="hljs-attr">height</span>: 200px;<br>&#125;<br>.<span class="hljs-property">box</span>&#123;<br>    <span class="hljs-attr">width</span>: 300px;<br>    <span class="hljs-attr">height</span>: 300px;<br>&#125;<br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>div.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;box&#x27;</span>  <span class="hljs-comment">//此时div的样式被box类替换</span><br></code></pre></td></tr></table></figure><h5 id="3-通过classList操作类控制CSS"><a href="#3-通过classList操作类控制CSS" class="headerlink" title="3. 通过classList操作类控制CSS"></a>3. 通过classList操作类控制CSS</h5><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">元素.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;类名&#x27;</span>)  <span class="hljs-comment">//追加一个类</span><br>元素.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;类名&#x27;</span>)  <span class="hljs-comment">//删除一个类</span><br>元素.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;类名&#x27;</span>)  <span class="hljs-comment">//切换一个类</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.<span class="hljs-property">box</span>&#123;<br>    <span class="hljs-attr">width</span>: 200px;<br>    <span class="hljs-attr">height</span>: 200px;<br>    <span class="hljs-attr">color</span>: blue;<br>&#125;<br>.<span class="hljs-property">active</span>&#123;<br>    <span class="hljs-attr">color</span>: red;<br>    background-<span class="hljs-attr">color</span>: pink;<br>&#125;<br>&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;文字&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>)  <span class="hljs-comment">//追加类</span></span></span><br><span class="language-javascript"><span class="language-xml">box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;box&#x27;</span>)  <span class="hljs-comment">//删除类</span></span></span><br><span class="language-javascript"><span class="language-xml">box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;active&#x27;</span>)  <span class="hljs-comment">//切换类</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="C-操作表单元素属性"><a href="#C-操作表单元素属性" class="headerlink" title="C. 操作表单元素属性"></a>C. 操作表单元素属性</h4><p>表单也需要修改属性，比如点击眼睛才可以看到密码，本质是把表单类型转换为文本框</p><ul><li>获取：<code>DOM对象.属性名</code></li><li>设置：<code>DOM对象.属性名=新值</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">表单.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;用户名&#x27;</span><br>表单.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;password&#x27;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=<span class="hljs-string">&quot;电脑&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> uname = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unmae.<span class="hljs-property">value</span>)  <span class="hljs-comment">//获取值，输出&quot;电脑&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">uname.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;我要买电脑&#x27;</span>  <span class="hljs-comment">//设置新值</span></span></span><br><span class="language-javascript"><span class="language-xml">uname.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;password&#x27;</span>  <span class="hljs-comment">//设置新属性</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="D-自定义属性"><a href="#D-自定义属性" class="headerlink" title="D. 自定义属性"></a>D. 自定义属性</h4><ul><li>可以由我们自己定义的属性</li><li>在标签上一律由”data-“开头</li><li>在DOM对象上一律以”dataset”对象方式获取</li></ul><h2 id="22-定时器-间歇函数"><a href="#22-定时器-间歇函数" class="headerlink" title="22. 定时器-间歇函数"></a>22. 定时器-间歇函数</h2><p>网页中的倒计时</p><h4 id="A-开启定时器"><a href="#A-开启定时器" class="headerlink" title="A. 开启定时器"></a>A. 开启定时器</h4><p>语法：  <code>setInterval(函数，间隔时间)</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一秒执行一次&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">setInterval</span>(fn,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><h4 id="B-关闭定时器"><a href="#B-关闭定时器" class="headerlink" title="B. 关闭定时器"></a>B. 关闭定时器</h4><p>语法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> 变量名 = <span class="hljs-built_in">setInterval</span>(函数，间隔时间)<br><span class="hljs-built_in">clearInterval</span>(变量名)<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一秒执行一次&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> n = <span class="hljs-built_in">setInterval</span>(fn,<span class="hljs-number">1000</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n)<br><span class="hljs-built_in">clearInterval</span>(n)  <span class="hljs-comment">//关闭</span><br></code></pre></td></tr></table></figure><h2 id="23-事件监听"><a href="#23-事件监听" class="headerlink" title="23. 事件监听"></a>23. 事件监听</h2><p>用户在网页上单击一个按钮即为事件，让程序检测是否有事件产生，若有则做出响应，即为事件监听<br>语法： <code>元素对象.addEventListener(&#39;事件类型&#39;,要执行的函数)</code><br>例：点击按钮后，会弹出一个对话框</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button&gt;点击&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="24-事件类型"><a href="#24-事件类型" class="headerlink" title="24. 事件类型"></a>24. 事件类型</h2><h4 id="A-鼠标事件"><a href="#A-鼠标事件" class="headerlink" title="A. 鼠标事件"></a>A. 鼠标事件</h4><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td>click</td><td>鼠标点击</td></tr><tr><td>mouseenter</td><td>鼠标经过</td></tr><tr><td>mouseleave</td><td>鼠标离开</td></tr></tbody></table><h4 id="B-焦点事件"><a href="#B-焦点事件" class="headerlink" title="B. 焦点事件"></a>B. 焦点事件</h4><p>表单获得光标</p><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td>focus</td><td>获得焦点</td></tr><tr><td>blur</td><td>失去焦点</td></tr></tbody></table><h4 id="C-键盘事件"><a href="#C-键盘事件" class="headerlink" title="C. 键盘事件"></a>C. 键盘事件</h4><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td>Keydown</td><td>键盘按下触发</td></tr><tr><td>Keyup</td><td>键盘抬起触发</td></tr></tbody></table><h4 id="D-文本事件"><a href="#D-文本事件" class="headerlink" title="D. 文本事件"></a>D. 文本事件</h4><p>input: 用户输入事件</p><h2 id="25-事件对象"><a href="#25-事件对象" class="headerlink" title="25. 事件对象"></a>25. 事件对象</h2><p>事件对象也是对象，存储了事件触发时的相关信息</p><h4 id="A-获取方式"><a href="#A-获取方式" class="headerlink" title="A. 获取方式"></a>A. 获取方式</h4><p>事件绑定的回调函数的第一个参数就是事件对象<br>一般命名为event,ev,e<br>语法： <code>元素.addEventListener(&#39;click&#39;,function(e){})</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button&gt;点击&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="B-事件对象属性"><a href="#B-事件对象属性" class="headerlink" title="B. 事件对象属性"></a>B. 事件对象属性</h4><table><thead><tr><th>常用属性</th><th>含义</th></tr></thead><tbody><tr><td>type</td><td>获取当前事件类型</td></tr><tr><td>clientX&#x2F;clientY</td><td>获取光标相对于浏览器可见窗口左上角的位置</td></tr><tr><td>offsetX&#x2F;offsetY</td><td>获取光标相对于当前DOM元素左上角的位置</td></tr><tr><td>key</td><td>用户按下键盘键的值</td></tr></tbody></table><h2 id="26-环境对象"><a href="#26-环境对象" class="headerlink" title="26. 环境对象"></a>26. 环境对象</h2><p>指的是函数内部特殊的变量this,代表当前函数运行时所处的环境</p><ul><li>普通函数里的this指的是window</li><li>谁调用，this就是谁</li></ul><h2 id="27-回调函数"><a href="#27-回调函数" class="headerlink" title="27. 回调函数"></a>27. 回调函数</h2><p>如果将函数A作为参数传递给函数B，称函数A为回调函数</p><h2 id="28-事件流"><a href="#28-事件流" class="headerlink" title="28. 事件流"></a>28. 事件流</h2><p>事件流指事件完整执行过程中的流动路径</p><ul><li>捕获阶段：从大到小，父到子</li><li>冒泡阶段：从小到大，子到父</li></ul><h2 id="29-事件捕获"><a href="#29-事件捕获" class="headerlink" title="29. 事件捕获"></a>29. 事件捕获</h2><p>从DOM的根元素开始执行对应事件(从外到里)<br>事件捕获需写对应代码才能看到效果<br>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">DOM</span>.<span class="hljs-title function_">addEventListener</span>(事件类型,事件处理函数,是否使用捕获机制)<br></code></pre></td></tr></table></figure><h2 id="30-事件冒泡"><a href="#30-事件冒泡" class="headerlink" title="30. 事件冒泡"></a>30. 事件冒泡</h2><ul><li>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发</li><li>当一个元素触发事件后，会依次向上调用所有父级元素的同名事件<br>例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> father = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.father&#x27;</span>)<br><span class="hljs-keyword">const</span> son = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.son&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是1&#x27;</span>)<br>&#125;)<br>fa.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是2&#x27;</span>)<br>&#125;)<br>son.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;我是3&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="31-阻止冒泡"><a href="#31-阻止冒泡" class="headerlink" title="31. 阻止冒泡"></a>31. 阻止冒泡</h2><p>语法： <code>事件对象.stopPropagation()</code></p><h2 id="32-解绑事件"><a href="#32-解绑事件" class="headerlink" title="32. 解绑事件"></a>32. 解绑事件</h2><h4 id="A-on事件方式"><a href="#A-on事件方式" class="headerlink" title="A. on事件方式"></a>A. on事件方式</h4><p>直接使用null覆盖就可以实现事件的解绑</p><h4 id="B-removeEventListener"><a href="#B-removeEventListener" class="headerlink" title="B. removeEventListener()"></a>B. removeEventListener()</h4><p>若使用addEventListener方式，必须使用removeEventListener(事件类型,事件处理函数,[获取捕获或者冒泡阶段])<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button&gt;点击&lt;/button&gt;<br>&lt;script&gt;<br><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;点击了&#x27;</span>)<br>&#125;<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,fn)<br>btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,fn)<br></code></pre></td></tr></table></figure><h2 id="33-阻止默认行为"><a href="#33-阻止默认行为" class="headerlink" title="33. 阻止默认行为"></a>33. 阻止默认行为</h2><p>语法：  <code>e.preventDefault()</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;form action = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;form&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;submit&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    e.<span class="hljs-title function_">preventDefault</span>()</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="34-页面加载事件"><a href="#34-页面加载事件" class="headerlink" title="34. 页面加载事件"></a>34. 页面加载事件</h2><p>加载外部资源，加载完毕时触发的事件</p><h4 id="A-load事件-慢"><a href="#A-load事件-慢" class="headerlink" title="A. load事件(慢)"></a>A. load事件(慢)</h4><p>监听页面所有资源加载完毕：给window添加load事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//执行的操作</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="B-DOMContentLoaded事件-快"><a href="#B-DOMContentLoaded事件-快" class="headerlink" title="B. DOMContentLoaded事件(快)"></a>B. DOMContentLoaded事件(快)</h4><p>当初始的HTML文档被完全加载和解析完成之后，事件被触发，无需等待样式表、图像等完全加载<br>监听页面DOM加载完毕:给document添加DOMContentLoaded事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//执行的操作</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="35-页面滚动事件"><a href="#35-页面滚动事件" class="headerlink" title="35. 页面滚动事件"></a>35. 页面滚动事件</h2><p>滚动条在滚动时持续触发的事件<br>事件名：<code>scroll</code><br>监听整个页面滚动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//执行的操作</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="36-页面尺寸事件"><a href="#36-页面尺寸事件" class="headerlink" title="36. 页面尺寸事件"></a>36. 页面尺寸事件</h2><p>语法： resize事件<br>在窗口尺寸改变时触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//执行的操作</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>检测屏幕宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> w = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(w)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="37-日期对象"><a href="#37-日期对象" class="headerlink" title="37. 日期对象"></a>37. 日期对象</h2><p>让网页显示日期，可以得到当前系统时间</p><h4 id="A-实例化"><a href="#A-实例化" class="headerlink" title="A. 实例化"></a>A. 实例化</h4><p>在代码中发现new关键字时，这种操作称为实例化<br>创建一个时间对象并获取时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()   <span class="hljs-comment">//获取当前时间</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2000-1-1&#x27;</span>)  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date)       <span class="hljs-comment">//获取指定时间</span><br></code></pre></td></tr></table></figure><h4 id="B-日期对象方法"><a href="#B-日期对象方法" class="headerlink" title="B. 日期对象方法"></a>B. 日期对象方法</h4><table><thead><tr><th>方法</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>getFullYear()</td><td>获取年份</td><td>获取四位年份</td></tr><tr><td>getMonth()</td><td>获取月份</td><td>取值为0~11</td></tr><tr><td>getDate()</td><td>获取月份每一天</td><td>不同月份取值也不相同</td></tr><tr><td>getDay()</td><td>获取星期几</td><td>取值为0~6</td></tr><tr><td>getHours()</td><td>获取小时</td><td>取值为0~23</td></tr><tr><td>getMinutes()</td><td>获取分钟</td><td>取值为0~59</td></tr><tr><td>getSeconds()</td><td>获取秒</td><td>取值为0~59</td></tr></tbody></table><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">getFullYear</span>())<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="C-时间戳"><a href="#C-时间戳" class="headerlink" title="C. 时间戳"></a>C. 时间戳</h4><p>是指1970年1月1日0时0分0秒到现在的<strong>毫秒数</strong>。常用于实现倒计时效果<br>算法：</p><ul><li>将来的时间戳 - 现在的时间戳 &#x3D; 剩余时间毫秒数</li><li>剩余时间毫秒数转换为年月日时分秒 &#x3D; 倒计时时间</li></ul><h5 id="1-getTime-方法"><a href="#1-getTime-方法" class="headerlink" title="1. getTime()方法"></a>1. getTime()方法</h5><p>需要实例化</p><h5 id="2-new-Date-推荐使用"><a href="#2-new-Date-推荐使用" class="headerlink" title="2. +new Date()(推荐使用)"></a>2. +new Date()(推荐使用)</h5><p>无需实例化</p><h5 id="3-Date-now"><a href="#3-Date-now" class="headerlink" title="3. Date.now()"></a>3. Date.now()</h5><p>无需实例化<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">getTime</span>())  <span class="hljs-comment">//getTime()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())  <span class="hljs-comment">//+new Date</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())   <span class="hljs-comment">//Date.now()</span><br></code></pre></td></tr></table></figure><h2 id="38-节点操作"><a href="#38-节点操作" class="headerlink" title="38. 节点操作"></a>38. 节点操作</h2><h4 id="A-DOM节点"><a href="#A-DOM节点" class="headerlink" title="A. DOM节点"></a>A. DOM节点</h4><p>DOM树中每个内容都是节点</p><ul><li>元素节点：所有的标签，比如body、div</li><li>属性节点：所有的属性，比如href</li><li>文本节点：所有的文本</li></ul><h4 id="B-查找节点"><a href="#B-查找节点" class="headerlink" title="B. 查找节点"></a>B. 查找节点</h4><p>根据节点关系查找相应的节点</p><h5 id="1-父节点查找"><a href="#1-父节点查找" class="headerlink" title="1. 父节点查找"></a>1. 父节点查找</h5><p>parentNode属性,返回最近一级的父节点，找不到返回NULL<br><code>子元素.parentNode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<br>我是广告<br>&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;X&lt;/div&gt;<br>&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> box1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box1&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">box1.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentNode</span>.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">I</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="2-子节点查找"><a href="#2-子节点查找" class="headerlink" title="2. 子节点查找"></a>2. 子节点查找</h5><ul><li>childNodes</li><li><strong>children属性(重点)</strong><br>获得所有元素的节点，返回一个伪数组<br><code>父元素.children</code><br>例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>) </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ul.<span class="hljs-property">children</span>)   <span class="hljs-comment">//得到伪数组,全儿子选择</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h5 id="3-兄弟关系查找"><a href="#3-兄弟关系查找" class="headerlink" title="3. 兄弟关系查找"></a>3. 兄弟关系查找</h5><ul><li>下一个兄弟节点  <code>nextElementSibling</code>属性</li><li>上一个兄弟节点  <code>previousElementSibling</code>属性</li></ul><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> li2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul li:nth-child(2)&#x27;</span>) </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(li2.<span class="hljs-property">previousElementSibling</span>)   <span class="hljs-comment">//上一个兄弟</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(li2.<span class="hljs-property">nextElementSibling</span>)   <span class="hljs-comment">//下一个兄弟</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="C-增加节点"><a href="#C-增加节点" class="headerlink" title="C. 增加节点"></a>C. 增加节点</h4><h5 id="1-创建节点"><a href="#1-创建节点" class="headerlink" title="1. 创建节点"></a>1. 创建节点</h5><p><code>document.createElement(&#39;标签名&#39;)</code></p><h5 id="2-追加节点"><a href="#2-追加节点" class="headerlink" title="2. 追加节点"></a>2. 追加节点</h5><ul><li>插入到父元素的最后一个子元素<br><code>父元素.appendChild(要插入的元素)</code></li><li>插入到父元素中某个子元素的前面<br><code>父元素.insertBefore(要插入的元素,在哪个元素前面)</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;ul&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div)  <span class="hljs-comment">//作为最后一个子元素</span></span></span><br><span class="language-javascript"><span class="language-xml">ul.<span class="hljs-title function_">insertBefore</span>(li, ul.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>])  <span class="hljs-comment">//放在最前面一个元素</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="D-克隆节点"><a href="#D-克隆节点" class="headerlink" title="D. 克隆节点"></a>D. 克隆节点</h4><p><code>元素.cloneNode(布尔值)</code>  克隆一个已有元素节点<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;ul&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> li1 = ul.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">//克隆</span></span></span><br><span class="language-javascript"><span class="language-xml">ul.<span class="hljs-title function_">appendChild</span>(li1)  <span class="hljs-comment">//添加</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="E-删除节点"><a href="#E-删除节点" class="headerlink" title="E. 删除节点"></a>E. 删除节点</h4><p><code>父元素.removeChild(要删除的元素)</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>没用了<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">ul.<span class="hljs-title function_">removeChild</span>(ul.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>])</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="39-M端事件"><a href="#39-M端事件" class="headerlink" title="39. M端事件"></a>39. M端事件</h2><p>触屏事件touch</p><table><thead><tr><th>触屏touch事件</th><th>说明</th></tr></thead><tbody><tr><td>touchstart</td><td>手指触摸到一个DOM元素时触发</td></tr><tr><td>touchmove</td><td>手指在一个DOM元素上滑动时触发</td></tr><tr><td>touchend</td><td>手指从一个DOM元素上移开触发</td></tr></tbody></table><h2 id="40-Window对象"><a href="#40-Window对象" class="headerlink" title="40. Window对象"></a>40. Window对象</h2><h4 id="A-BOM-浏览器对象模型"><a href="#A-BOM-浏览器对象模型" class="headerlink" title="A. BOM(浏览器对象模型)"></a>A. BOM(浏览器对象模型)</h4><p>window对象是全局对象，是JS的顶级对象</p><h4 id="B-定时器-延时函数"><a href="#B-定时器-延时函数" class="headerlink" title="B. 定时器-延时函数"></a>B. 定时器-延时函数</h4><p>语法： <code>setTimeout(回调函数,等待的毫秒数)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;时间到了&#x27;</span>)<br>&#125;,<span class="hljs-number">2000</span>) <span class="hljs-comment">//延时两秒输出&#x27;时间到了&#x27;</span><br></code></pre></td></tr></table></figure><p>清除延时函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(回调函数,等待的毫秒数)<br><span class="hljs-built_in">clearTimeout</span>(timer)<br></code></pre></td></tr></table></figure><h4 id="C-JS执行机制"><a href="#C-JS执行机制" class="headerlink" title="C. JS执行机制"></a>C. JS执行机制</h4><p>JS是单线程的，同一个时间只能做一件事。</p><ul><li><p>同步任务(立刻执行)<br>在主线程上依次执行，形成一个执行栈</p></li><li><p>异步任务(耗时)<br>通过回调函数实现，异步任务添加到任务队列</p><ol><li>普通事件：如click,resize等</li><li>资源加载：如load,error等</li><li>定时器：如setInterval,setTimeout等</li></ol></li><li><p>执行机制</p><ol><li>先执行执行栈中的同步任务</li><li>异步任务放在任务队列</li><li>当执行栈中所有同步任务执行完毕，系统按次序读取任务队列中的异步任务，被读取的异步任务结束等待状态，进入执行栈，开始执行</li></ol></li></ul><h4 id="D-location对象"><a href="#D-location对象" class="headerlink" title="D. location对象"></a>D. location对象</h4><p>location拆分并保存URL地址的各个组成部分</p><ul><li>href利用JS的方法跳转页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><p>search属性获取地址中携带的参数，符号？后面部分<br><code>console.log(location.search)</code></p></li><li><p>hash属性获取地址的哈希值，符号#后面部分<br><code>console.log(location.hash)</code></p></li><li><p>reload方法用来刷新当前页面，传入参数true时表示强制刷新</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button&gt;点击刷新&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    location.<span class="hljs-title function_">reload</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// 强制刷新</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="E-navigator对象"><a href="#E-navigator对象" class="headerlink" title="E. navigator对象"></a>E. navigator对象</h4><p>记录了浏览器自身的相关信息</p><ul><li>userAgent检测浏览器的版本及平台</li></ul><h4 id="F-history对象"><a href="#F-history对象" class="headerlink" title="F. history对象"></a>F. history对象</h4><p>管理历史记录</p><table><thead><tr><th>history对象方法</th><th>作用</th></tr></thead><tbody><tr><td>back()</td><td>可以后退功能</td></tr><tr><td>forward()</td><td>前进功能</td></tr><tr><td>go(参数)</td><td>前进后退功能 参数为1则前进一个页面 参数为-1则后退一个页面</td></tr></tbody></table><h2 id="41-本地存储"><a href="#41-本地存储" class="headerlink" title="41. 本地存储"></a>41. 本地存储</h2><h4 id="A-介绍"><a href="#A-介绍" class="headerlink" title="A. 介绍"></a>A. 介绍</h4><ul><li>在本地存储数据，存储在用户浏览器</li><li>设置，读取方便，页面刷新也不丢失数据</li><li>容量较大</li></ul><h4 id="B-localStorage"><a href="#B-localStorage" class="headerlink" title="B. localStorage"></a>B. localStorage</h4><p>可以将数据永久存储在本地，除非手动删除，关闭页面也存在</p><h5 id="1-存储数据"><a href="#1-存储数据" class="headerlink" title="1. 存储数据"></a>1. 存储数据</h5><p><code>localStorage.setItem(key,value)</code></p><h5 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2. 读取数据"></a>2. 读取数据</h5><p><code>localStorage.getItem(key)</code></p><h5 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h5><p><code>localStorage.removeItem(key)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;uname&#x27;</span>,<span class="hljs-string">&#x27;pink老师&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;uname&#x27;</span>))<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;uname&#x27;</span>)  <span class="hljs-comment">//删除名字</span><br></code></pre></td></tr></table></figure><h4 id="C-sessionStorage"><a href="#C-sessionStorage" class="headerlink" title="C. sessionStorage"></a>C. sessionStorage</h4><p>关闭浏览器窗口就会消失，用法和localStorage基本相同</p><h4 id="D-存储复杂数据类型"><a href="#D-存储复杂数据类型" class="headerlink" title="D. 存储复杂数据类型"></a>D. 存储复杂数据类型</h4><p>需要将复杂数据类型转换为JSON字符串，存储到本地</p><ul><li>存储：<code>JSON.stringify(复杂数据类型)</code></li><li>取出：<code>JSON.parse(JSON字符串)</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;female&#x27;</span><br>&#125;<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;obj&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)) <span class="hljs-comment">//存储为JSON字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;obj&#x27;</span>)))<span class="hljs-comment">//把JSON字符串转换为对象取出</span><br></code></pre></td></tr></table></figure><h2 id="42-map-和join"><a href="#42-map-和join" class="headerlink" title="42. map()和join()"></a>42. map()和join()</h2><p>实现字符串拼接</p><ul><li>map可以遍历数组处理数据，并返回新的数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br><span class="hljs-keyword">const</span> newArr = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">ele, index</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ele)  <span class="hljs-comment">// 数组元素</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index)  <span class="hljs-comment">// 数组索引号</span><br><span class="hljs-keyword">return</span> ele + <span class="hljs-string">&#x27;颜色&#x27;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr)  <span class="hljs-comment">//[&#x27;red颜色&#x27;,&#x27;blue颜色&#x27;,&#x27;green颜色&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li>join()把数组中的所有元素转换为一个字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;red颜色&#x27;</span>,<span class="hljs-string">&#x27;blue颜色&#x27;</span>,<span class="hljs-string">&#x27;green颜色&#x27;</span>] <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment">//red颜色blue颜色green颜色</span><br></code></pre></td></tr></table></figure><h2 id="43-正则表达式"><a href="#43-正则表达式" class="headerlink" title="43. 正则表达式"></a>43. 正则表达式</h2><h4 id="A-介绍-1"><a href="#A-介绍-1" class="headerlink" title="A. 介绍"></a>A. 介绍</h4><p>用于匹配字符串中字符组合的模式</p><ul><li>表单验证(匹配)</li><li>过滤敏感词(替换)</li><li>字符串中提取我们想要的部分(提取)</li></ul><h4 id="B-语法"><a href="#B-语法" class="headerlink" title="B. 语法"></a>B. 语法</h4><h5 id="1-定义正则表达式语法"><a href="#1-定义正则表达式语法" class="headerlink" title="1. 定义正则表达式语法"></a>1. 定义正则表达式语法</h5><p><code>const 变量名 = /表达式/</code></p><h5 id="2-判断是否有符合规则的字符串"><a href="#2-判断是否有符合规则的字符串" class="headerlink" title="2. 判断是否有符合规则的字符串"></a>2. 判断是否有符合规则的字符串</h5><p><code>test()</code> 用于查看正则表达式与指定字符串是否匹配,返回true or false<br>语法： <code>regObj.test(被检测的字符串)</code><br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;现在太阳下山了，太阳光要看不到了&#x27;</span><br><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/太阳/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str)) <span class="hljs-comment">//返回true</span><br></code></pre></td></tr></table></figure><h4 id="C-元字符"><a href="#C-元字符" class="headerlink" title="C. 元字符"></a>C. 元字符</h4><p>具有特殊意义的字符，例如26个英文字母abcdefg…表示为：[a-z]</p><h5 id="1-边界符-表示位置，开头结尾，必须用什么开头什么结尾"><a href="#1-边界符-表示位置，开头结尾，必须用什么开头什么结尾" class="headerlink" title="1. 边界符(表示位置，开头结尾，必须用什么开头什么结尾)"></a>1. 边界符(表示位置，开头结尾，必须用什么开头什么结尾)</h5><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本(以谁开始)</td></tr><tr><td>$</td><td>表示匹配行尾的文本(以谁结尾)</td></tr></tbody></table><h5 id="2-量词-表示重复次数"><a href="#2-量词-表示重复次数" class="headerlink" title="2. 量词(表示重复次数)"></a>2. 量词(表示重复次数)</h5><table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h5 id="3-字符类-比如-d表示0-9"><a href="#3-字符类-比如-d表示0-9" class="headerlink" title="3. 字符类(比如\d表示0~9)"></a>3. 字符类(比如\d表示0~9)</h5><ul><li>[]匹配字符集合<br>只要包含[]中任何一个都返回true;如[abc]包含abc任何一个都为true</li><li>[]里面加上-连字符<br>使用连字符-表示一个范围；如[a-z]表示a到z26个字母</li><li>[]里面加上^取反符号<br>比如[^a-z]匹配除了小写字母以外的字符</li><li>.(点)匹配除换行符之外的任何单个字符</li><li>预定义：某些常见模式的简写方式</li></ul><table><thead><tr><th>预定类</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>匹配0-9之间任一数字</td></tr><tr><td>\D</td><td>匹配所有0-9以外的字符</td></tr><tr><td>\w</td><td>匹配任意的字母、数字和下划线</td></tr><tr><td>\W</td><td>匹配除所有字母、数字和下划线以外的字符</td></tr><tr><td>\s</td><td>匹配空格</td></tr><tr><td>\S</td><td>匹配非空格的字符</td></tr></tbody></table><h4 id="D-修饰符"><a href="#D-修饰符" class="headerlink" title="D. 修饰符"></a>D. 修饰符</h4><p>约束正则执行的细节问题，如是否区分大小写，是否支持多行匹配<br>语法： <code>/表达式/修饰符</code></p><ul><li>i是ignore的缩写，正则匹配时字母不区分大小写</li><li>g是global的缩写，匹配所有满足正则表达式的结果</li><li>替换replace:  <code>字符串.replace(/正则表达式/, &#39;替换的文本&#39;)</code></li></ul><h2 id="44-作用域"><a href="#44-作用域" class="headerlink" title="44. 作用域"></a>44. 作用域</h2><h4 id="A-局部作用域"><a href="#A-局部作用域" class="headerlink" title="A. 局部作用域"></a>A. 局部作用域</h4><h5 id="1-函数作用域"><a href="#1-函数作用域" class="headerlink" title="1. 函数作用域"></a>1. 函数作用域</h5><p>在函数内部声明的变量只能在函数内部被访问，外部无法直接访问</p><h5 id="2-块作用域"><a href="#2-块作用域" class="headerlink" title="2. 块作用域"></a>2. 块作用域</h5><p>在JS中使用{}包裹的代码称为代码块，代码块中声明的变量外部有可能无法被访问</p><ul><li>let和const声明的变量会产生块作用域，var不会产生块作用域</li></ul><h4 id="B-全局作用域"><a href="#B-全局作用域" class="headerlink" title="B. 全局作用域"></a>B. 全局作用域</h4><p>全局作用域声明的变量，任何其他作用域都可以被访问</p><h4 id="C-作用域链"><a href="#C-作用域链" class="headerlink" title="C. 作用域链"></a>C. 作用域链</h4><p>作用域链的本质是底层的变量查找机制</p><ul><li>函数执行时会优先查找当前函数作用域中查找变量</li><li>如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域</li></ul><h4 id="D-垃圾回收机制"><a href="#D-垃圾回收机制" class="headerlink" title="D. 垃圾回收机制"></a>D. 垃圾回收机制</h4><ul><li>内存的生命周期<ol><li>内存分配</li><li>内存使用</li><li>内存回收<br>全局变量一般不会回收，局部变量一般会被自动回收</li></ol></li><li>内存泄漏<br>程序中分配的内存由于某种原因，程序未释放或无法释放叫内存泄漏</li><li>回收算法-标记清除法<br>从根部扫描对象，能查找到的就是使用的，查找不到就要回收</li></ul><h4 id="E-闭包"><a href="#E-闭包" class="headerlink" title="E. 闭包"></a>E. 闭包</h4><p>闭包 &#x3D; 内层函数 + 外层函数的变量<br>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>    &#125;<br>    <span class="hljs-title function_">f</span>()<br>&#125;<br><span class="hljs-title function_">outer</span>()<br></code></pre></td></tr></table></figure><ul><li>闭包的作用： 外部也可以访问使用函数内部的变量</li></ul><h4 id="F-变量提升"><a href="#F-变量提升" class="headerlink" title="F. 变量提升"></a>F. 变量提升</h4><ul><li>仅存在于var声明变量</li><li>把所有var声明的变量提升到当前作用域的最前面</li><li>只提升声明，不提升赋值</li></ul><h2 id="45-函数进阶"><a href="#45-函数进阶" class="headerlink" title="45. 函数进阶"></a>45. 函数进阶</h2><h4 id="A-函数提升"><a href="#A-函数提升" class="headerlink" title="A. 函数提升"></a>A. 函数提升</h4><ul><li>会把所有函数声明提升到当前作用域最前面</li><li>只提升函数声明，不提升函数调用</li><li>函数先声明再调用</li></ul><h4 id="B-函数参数"><a href="#B-函数参数" class="headerlink" title="B. 函数参数"></a>B. 函数参数</h4><h5 id="1-动态参数"><a href="#1-动态参数" class="headerlink" title="1. 动态参数"></a>1. 动态参数</h5><p><code>arguments</code>是函数内部内置的伪数组变量，包含调用函数时传入的所有实参<br>例：求和函数，参数数量不限</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += <span class="hljs-variable language_">arguments</span>[i]<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h5 id="2-剩余参数-建议"><a href="#2-剩余参数-建议" class="headerlink" title="2. 剩余参数(建议)"></a>2. 剩余参数(建议)</h5><p><code>...</code>获取的剩余实参，是个真数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">a, b, ...arr</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<br>&#125;<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h4 id="C-箭头函数"><a href="#C-箭头函数" class="headerlink" title="C. 箭头函数"></a>C. 箭头函数</h4><p>更适用于本来需要匿名函数的地方</p><h5 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h5><ul><li>语法1：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;普通函数&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><ul><li>语法2：只有一个参数可以省略小括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>)&#123;<br>    <span class="hljs-keyword">return</span> x + x<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = x =&gt; &#123;<br>    <span class="hljs-keyword">return</span> x + x<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><ul><li>语法3：如果函数体只有一行代码，可以写在一行上，无需写return直接返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>)&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">x, y</span>) =&gt; x + y<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><ul><li>语法4：加括号的函数体返回对象字面量表达式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn1</span> = uname =&gt; (&#123; <span class="hljs-attr">uname</span>: uname&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn1</span>(<span class="hljs-string">&#x27;fzh&#x27;</span>))<br></code></pre></td></tr></table></figure><h5 id="2-箭头函数参数"><a href="#2-箭头函数参数" class="headerlink" title="2. 箭头函数参数"></a>2. 箭头函数参数</h5><p>箭头函数没有arguments动态参数，但是有剩余函数…args<br>例：用箭头函数求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSum</span> = (<span class="hljs-params">...arr</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += arr[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">getSum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><h5 id="3-箭头函数this"><a href="#3-箭头函数this" class="headerlink" title="3. 箭头函数this"></a>3. 箭头函数this</h5><p>箭头函数不会创建自己的this,只会从自己的作用域链上一层沿用this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">//指向 user</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)  <span class="hljs-comment">//指向user 该箭头函数中的this与sleep中的this一致</span><br>        &#125;<br>        <span class="hljs-title function_">fn</span>()<br>    &#125;<br>&#125;<br>user.<span class="hljs-title function_">sleep</span>()<br></code></pre></td></tr></table></figure><h2 id="46-解构赋值"><a href="#46-解构赋值" class="headerlink" title="46. 解构赋值"></a>46. 解构赋值</h2><p>使用解构简洁的语法快速为变量赋值</p><h4 id="A-数组解构"><a href="#A-数组解构" class="headerlink" title="A. 数组解构"></a>A. 数组解构</h4><p>将数组的单元值快速批量赋值给一系列变量的语法</p><ul><li>基本语法：<ol><li>赋值运算符 &#x3D; 左侧的[]用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量</li><li>变量的顺序对应数组单元值的位置依次进行赋值操作</li></ol></li></ul><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> [a, b, c] = arr<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h4 id="B-对象解构"><a href="#B-对象解构" class="headerlink" title="B. 对象解构"></a>B. 对象解构</h4><p>将对象属性和方法快速批量赋值给一系列变量的语法</p><ul><li>对象属性的值和将被赋值与属性名相同的变量</li></ul><h5 id="1-简单对象解构"><a href="#1-简单对象解构" class="headerlink" title="1. 简单对象解构"></a>1. 简单对象解构</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;;<br><span class="hljs-keyword">const</span> &#123;name, age&#125; = user<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)  <span class="hljs-comment">// 小明</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)  <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure><h5 id="2-数组对象解构"><a href="#2-数组对象解构" class="headerlink" title="2. 数组对象解构"></a>2. 数组对象解构</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pig = [<br>    &#123;<br>        <span class="hljs-attr">uname</span>:<span class="hljs-string">&#x27;佩奇&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">6</span><br>    &#125;<br>]<br><span class="hljs-keyword">const</span> [&#123; uname, age &#125;] = pig<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uname)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)<br></code></pre></td></tr></table></figure><h5 id="3-多级对象解构"><a href="#3-多级对象解构" class="headerlink" title="3. 多级对象解构"></a>3. 多级对象解构</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pig = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;佩奇&#x27;</span>,<br>    <span class="hljs-attr">family</span>: &#123;<br>        <span class="hljs-attr">mother</span>: <span class="hljs-string">&#x27;猪妈妈&#x27;</span>,<br>        <span class="hljs-attr">father</span>: <span class="hljs-string">&#x27;猪爸爸’,</span><br><span class="hljs-string">        sister: &#x27;</span>乔治<span class="hljs-string">&#x27;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        age: 6</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">const &#123; name, family: &#123; mother, father, sister &#125; &#125; = pig</span><br><span class="hljs-string">console.log(name)</span><br><span class="hljs-string">console.log(mother)</span><br><span class="hljs-string">console.log(father)</span><br><span class="hljs-string">console.log(sister)</span><br></code></pre></td></tr></table></figure><h2 id="47-遍历数组forEach方法"><a href="#47-遍历数组forEach方法" class="headerlink" title="47. 遍历数组forEach方法"></a>47. 遍历数组forEach方法</h2><p>用于调用数组的每个元素，并将元素传递给回调函数<br>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">被遍历的数组.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">当前数组元素, 当前元素索引号</span>)&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;pink&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span> ]<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前数组元素是: <span class="hljs-subst">$&#123;item&#125;</span>`</span>)  <span class="hljs-comment">//依次打印数组每一个元素</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前数组元素的索引是: <span class="hljs-subst">$&#123;index&#125;</span>`</span>)  <span class="hljs-comment">//依次打印数组每一个元素的索引</span><br></code></pre></td></tr></table></figure><h2 id="48-深入对象"><a href="#48-深入对象" class="headerlink" title="48. 深入对象"></a>48. 深入对象</h2><h4 id="A-创建对象三种方式"><a href="#A-创建对象三种方式" class="headerlink" title="A. 创建对象三种方式"></a>A. 创建对象三种方式</h4><h5 id="1-利用对象字面量创建对象"><a href="#1-利用对象字面量创建对象" class="headerlink" title="1. 利用对象字面量创建对象"></a>1. 利用对象字面量创建对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;one&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-用new-Object创建对象"><a href="#2-用new-Object创建对象" class="headerlink" title="2. 用new Object创建对象"></a>2. 用new Object创建对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>obj.<span class="hljs-property">uname</span> = <span class="hljs-string">&#x27;one&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="3-利用构造函数创建对象"><a href="#3-利用构造函数创建对象" class="headerlink" title="3. 利用构造函数创建对象"></a>3. 利用构造函数创建对象</h5><h4 id="B-构造函数"><a href="#B-构造函数" class="headerlink" title="B. 构造函数"></a>B. 构造函数</h4><p>构造函数主要用于初始化对象</p><ul><li>命名要以大写字母开头且只能由new来创建(约定)<br>例：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Pig</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gener</span> = gender<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Peppa</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>(<span class="hljs-string">&#x27;佩奇&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;女&#x27;</span>)<span class="hljs-comment">// 创建佩奇对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">George</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>(<span class="hljs-string">&#x27;乔治&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<span class="hljs-comment">// 创建乔治对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Mum</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>(<span class="hljs-string">&#x27;猪妈妈&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;女&#x27;</span>)<span class="hljs-comment">// 创建猪妈妈对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Dad</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>(<span class="hljs-string">&#x27;猪爸爸&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<span class="hljs-comment">// 创建猪爸爸对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Peppa</span>)<span class="hljs-comment">//&#123;name:&#x27;佩奇&#x27;,age:6,gener:&#x27;女&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员(实例属性和实例方法)</li><li>构造函数中的属性和方法称为静态成员(静态属性和静态方法)</li></ul><h2 id="49-内置构造函数"><a href="#49-内置构造函数" class="headerlink" title="49. 内置构造函数"></a>49. 内置构造函数</h2><h4 id="A-Object"><a href="#A-Object" class="headerlink" title="A. Object"></a>A. Object</h4><p>是内置的构造函数，创建普通对象</p><h5 id="1-Object-keys静态方法获取对象中所有属性"><a href="#1-Object-keys静态方法获取对象中所有属性" class="headerlink" title="1. Object.keys静态方法获取对象中所有属性"></a>1. <code>Object.keys</code>静态方法获取对象中所有属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;佩奇&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(o)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)   <span class="hljs-comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o))  <span class="hljs-comment">//[&#x27;佩奇&#x27;, 6]</span><br></code></pre></td></tr></table></figure><h5 id="2-Object-assign静态方法用于对象拷贝"><a href="#2-Object-assign静态方法用于对象拷贝" class="headerlink" title="2. Object.assign静态方法用于对象拷贝"></a>2. <code>Object.assign</code>静态方法用于对象拷贝</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;佩奇&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, o)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)  <span class="hljs-comment">//&#123;name:&#x27;佩奇&#x27;,age:6&#125;</span><br></code></pre></td></tr></table></figure><h4 id="B-Array"><a href="#B-Array" class="headerlink" title="B. Array"></a>B. Array</h4><h5 id="1-数组的常见实例方法"><a href="#1-数组的常见实例方法" class="headerlink" title="1. 数组的常见实例方法"></a>1. 数组的常见实例方法</h5><table><thead><tr><th>方法</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>forEach</td><td>遍历数组</td><td>不返回数组，经常用于查找遍历数组元素</td></tr><tr><td>filter</td><td>过滤数组</td><td>返回新数组，返回的是筛选满足条件的数组元素</td></tr><tr><td>map</td><td>迭代数组</td><td>返回新数组，返回的是处理之后的数组元素，想要使用返回的新数组</td></tr><tr><td>reduce</td><td>累计器</td><td>返回累计处理的结果，经常用于求和等</td></tr><tr><td>join</td><td>拼接数组</td><td>将数组元素拼接为字符串，返回字符串</td></tr><tr><td>find</td><td>查找元素</td><td>查找元素，返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回undefined</td></tr><tr><td>every</td><td>检测数组</td><td>检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回true,否则返回false</td></tr></tbody></table><h5 id="2-reduce方法"><a href="#2-reduce方法" class="headerlink" title="2. reduce方法"></a>2. reduce方法</h5><p>语法：<br><code>arr.reduce(function(){}, 起始值)</code><br><code>arr.reduce(function(上一次值, 当前值){}, 初始值)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]<br><br><span class="hljs-comment">// 1. 没有初始值</span><br><span class="hljs-keyword">const</span> total = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, current</span>) &#123;<br><span class="hljs-keyword">return</span> prev + current<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total)<br><br><span class="hljs-comment">// 2. 有初始值</span><br><span class="hljs-keyword">const</span> total = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, current</span>) &#123;<br><span class="hljs-keyword">return</span> prev + current<br>&#125;, <span class="hljs-number">10</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total)<br><br><span class="hljs-comment">// 3. 箭头函数的写法</span><br><span class="hljs-keyword">const</span> total = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, current</span>) =&gt;</span> prev + current, <span class="hljs-number">10</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total)<br></code></pre></td></tr></table></figure><h4 id="C-String"><a href="#C-String" class="headerlink" title="C. String"></a>C. String</h4><p>常见实例方法</p><table><thead><tr><th>实例方法</th><th>作用</th></tr></thead><tbody><tr><td>length</td><td>用于获取字符串的长度</td></tr><tr><td>split(‘分隔符’)</td><td>将字符串拆分成数组</td></tr><tr><td>substring(需要截取的第一个字符的索引[,结束的索引号])</td><td>用于字符串截取</td></tr><tr><td>startsWith(检测字符串[,检测位置索引号])</td><td>检测是否以某字符开头</td></tr></tbody></table><h4 id="D-Number"><a href="#D-Number" class="headerlink" title="D. Number"></a>D. Number</h4><p>用于创建数值<br>常用方法： <code>toFixed()</code>设置保留小数位的长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> price = <span class="hljs-number">12.345</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(price.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>))  <span class="hljs-comment">//输出12.35</span><br></code></pre></td></tr></table></figure><h2 id="50-编程思想"><a href="#50-编程思想" class="headerlink" title="50. 编程思想"></a>50. 编程思想</h2><h4 id="A-面向过程编程"><a href="#A-面向过程编程" class="headerlink" title="A. 面向过程编程"></a>A. 面向过程编程</h4><p>分析出解决问题所需的步骤，然后用函数把这些步骤依次解决</p><h4 id="B-面向对象编程"><a href="#B-面向对象编程" class="headerlink" title="B. 面向对象编程"></a>B. 面向对象编程</h4><p>把事务分解成一个个对象，然后由对象之间分工合作</p><ul><li>面向对象的特性<ol><li>封装性</li><li>继承性</li><li>多态性</li></ol></li></ul><h2 id="51-构造函数"><a href="#51-构造函数" class="headerlink" title="51. 构造函数"></a>51. 构造函数</h2><ul><li>构造函数实现封装性，封装一个函数</li><li>构造函数方法会存在内存浪费的问题</li></ul><h2 id="52-原型"><a href="#52-原型" class="headerlink" title="52. 原型"></a>52. 原型</h2><h4 id="A-介绍和prototype属性"><a href="#A-介绍和prototype属性" class="headerlink" title="A. 介绍和prototype属性"></a>A. 介绍和prototype属性</h4><p>构造函数通过原型分配实现方法共享<br>每个构造函数都有一个<code>prototype</code>属性，指向另一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">uname, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uname</span> = uname<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">//返回一个对象称为原型对象</span><br><span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sing</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&#x27;刘德华&#x27;</span>,<span class="hljs-number">18</span>)<br><span class="hljs-keyword">const</span> zxy= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&#x27;张学友&#x27;</span>,<span class="hljs-number">19</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">sing</span> === zxy.<span class="hljs-property">sing</span>)<span class="hljs-comment">// 结果是true 说明俩函数一样,共享</span><br></code></pre></td></tr></table></figure><h4 id="B-constructor属性"><a href="#B-constructor属性" class="headerlink" title="B. constructor属性"></a>B. constructor属性</h4><p>每个原型对象里面都有个constructor属性<br>该属性指向该原型对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Star</span>,<span class="hljs-comment">//手动利用constructor指回Star构造函数</span><br>    <span class="hljs-attr">sing</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;唱&#x27;</span>) &#125;,<br>    <span class="hljs-attr">dance</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;跳&#x27;</span>) &#125;,<br>    <span class="hljs-attr">rap</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rap&#x27;</span>) &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Star</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>) <span class="hljs-comment">//指向Star</span><br></code></pre></td></tr></table></figure><h4 id="C-对象原型"><a href="#C-对象原型" class="headerlink" title="C. 对象原型"></a>C. 对象原型</h4><p>对象都有一个属性<code>_proto_</code>指向构造函数的prototype原型对象</p><h4 id="D-原型继承"><a href="#D-原型继承" class="headerlink" title="D. 原型继承"></a>D. 原型继承</h4><p>JS大多借助原型对象实现继承的特性</p><h4 id="E-原型链"><a href="#E-原型链" class="headerlink" title="E. 原型链"></a>E. 原型链</h4><p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，称为原型链</p><h2 id="53-深浅拷贝"><a href="#53-深浅拷贝" class="headerlink" title="53. 深浅拷贝"></a>53. 深浅拷贝</h2><p>浅拷贝和深拷贝只针对引用类型</p><h4 id="A-浅拷贝"><a href="#A-浅拷贝" class="headerlink" title="A. 浅拷贝"></a>A. 浅拷贝</h4><ul><li>拷贝的是地址</li><li>如果是单层对象没问题，如果有多层就有问题<br>常见方法：</li></ul><ol><li>拷贝对象：<code>Object.assgin()</code>或<code>展开运算符{...obj}</code></li><li>拷贝数组：<code>Array.prototype.concat()</code>或<code>[...arr]</code></li></ol><h4 id="B-深拷贝"><a href="#B-深拷贝" class="headerlink" title="B. 深拷贝"></a>B. 深拷贝</h4><p>拷贝的是对象，不是地址<br>常见方法：</p><ol><li>通过递归实现深拷贝</li><li>lodash&#x2F;cloneDeep</li><li>通过JSON.stringify()</li></ol><h2 id="54-异常处理"><a href="#54-异常处理" class="headerlink" title="54. 异常处理"></a>54. 异常处理</h2><p>指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p><h4 id="A-throw抛异常"><a href="#A-throw抛异常" class="headerlink" title="A. throw抛异常"></a>A. throw抛异常</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!x || !y) &#123;<br>        <span class="hljs-comment">// throw &#x27;参数不能为空!&#x27;;</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数不能为空!&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-title function_">counter</span>()<br></code></pre></td></tr></table></figure><h4 id="B-try-catch捕获异常"><a href="#B-try-catch捕获异常" class="headerlink" title="B. try&#x2F;catch捕获异常"></a>B. try&#x2F;catch捕获异常</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;p&gt;<span class="hljs-number">123</span>&lt;/p&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 可能发送错误的代码 要写到 try</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.p&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">        p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125; <span class="hljs-keyword">catch</span> (err) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 拦截错误,提示浏览器提供的错误信息,但是不中断程序的执行</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;你看看,选择器错误了吧&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 需要加return 中断程序</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">finally</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;弹出对话框&#x27;</span>)<span class="hljs-comment">// 不管你程序对不对,一定会执行的代码</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">11</span>)</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">fn</span>()</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="C-debugger"><a href="#C-debugger" class="headerlink" title="C. debugger"></a>C. debugger</h4><h2 id="55-处理this"><a href="#55-处理this" class="headerlink" title="55. 处理this"></a>55. 处理this</h2><h4 id="A-this指向"><a href="#A-this指向" class="headerlink" title="A. this指向"></a>A. this指向</h4><h5 id="1-普通函数this指向"><a href="#1-普通函数this指向" class="headerlink" title="1. 普通函数this指向"></a>1. 普通函数this指向</h5><p>谁调用我，我指向谁</p><h5 id="2-箭头函数this指向"><a href="#2-箭头函数this指向" class="headerlink" title="2. 箭头函数this指向"></a>2. 箭头函数this指向</h5><ul><li>箭头函数中并不存在this</li><li>箭头函数中的this引用就是最近作用域的this</li><li>向外层作用域，一层一层查找this，直到有this定义</li></ul><h4 id="B-改变this"><a href="#B-改变this" class="headerlink" title="B. 改变this"></a>B. 改变this</h4><h5 id="1-call"><a href="#1-call" class="headerlink" title="1. call()"></a>1. call()</h5><p>使用call方法调用函数，同时指定被调用函数中this的值<br>语法： <code>fun.call(thisArg,arg1,arg2,...)</code></p><h5 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply()"></a>2. apply()</h5><p>语法： <code>fun.apply(thisArg,[argsArray])</code></p><ul><li>thisArg: 在fun函数运行时指定的this值</li><li>argsArray: 传递的值，必须包含在数组里面</li></ul><h5 id="3-bind-重要"><a href="#3-bind-重要" class="headerlink" title="3. bind()(重要)"></a>3. bind()(重要)</h5><p>bind()不会调用函数，但是能改变函数内部this指向<br>语法： <code>fun.bind(thisArg,arg1,arg2,...)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">let</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">let</span> sayHello = sayHi.<span class="hljs-title function_">bind</span>(user);  <span class="hljs-comment">//用 bind 指定 this 的值</span><br><span class="hljs-title function_">sayHello</span>()<span class="hljs-comment">//调用使用 bind 创建的新函数</span><br></code></pre></td></tr></table></figure><h2 id="56-性能优化"><a href="#56-性能优化" class="headerlink" title="56. 性能优化"></a>56. 性能优化</h2><ul><li>防抖：单位时间内，频繁触发事件，只执行最后一次</li><li>节流：单位时间内，频繁触发事件，只执行一次</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown简单学习笔记</title>
    <link href="/2024/12/18/FrontEnd/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/12/18/FrontEnd/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="一-标题"><a href="#一-标题" class="headerlink" title="一. 标题"></a>一. 标题</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><h1 id="二-字体"><a href="#二-字体" class="headerlink" title="二. 字体"></a>二. 字体</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">加粗：   <span class="hljs-strong">**这是加粗的文字**</span> (两个星号包起来)<br>斜体：   <span class="hljs-emphasis">*这是斜体的文字*</span>  (一个星号包起来)<br>斜体加粗：<span class="hljs-strong">**<span class="hljs-emphasis">*这是斜体加粗的文字*</span>**</span> (三个星号包起来)<br>删除线： ~~这是加删除线的文字~~ (两个波浪号包起来)<br></code></pre></td></tr></table></figure><h1 id="三-引用"><a href="#三-引用" class="headerlink" title="三. 引用"></a>三. 引用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">这是引用的内容</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;这是引用的内容</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。</span><br></code></pre></td></tr></table></figure><h1 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四. 分割线"></a>四. 分割线</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">---</span><br><span class="hljs-section">----</span><br><span class="hljs-bullet">***</span><br><span class="hljs-bullet"></span>*****<br>___<br>____<br>效果都是一样的<br></code></pre></td></tr></table></figure><h1 id="五-链接"><a href="#五-链接" class="headerlink" title="五. 链接"></a>五. 链接</h1><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">知乎(https:<span class="hljs-comment">//www.zhihu.com/)</span><br><span class="hljs-string">[百度]</span>(https:<span class="hljs-comment">//www.baidu.com/)</span><br></code></pre></td></tr></table></figure><h1 id="六-列表"><a href="#六-列表" class="headerlink" title="六. 列表"></a>六. 列表</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表<br><span class="hljs-bullet">*</span> 一级无序列表内容(敲一个TAB键)<br><span class="hljs-bullet">    1.</span> 二级有序列表内容<br><span class="hljs-bullet">    2.</span> 二级有序列表内容<br><span class="hljs-bullet">    3.</span> 二级有序列表内容<br><span class="hljs-bullet">2.</span> 无序列表<br><span class="hljs-bullet">*</span> 无序列表内容<br><span class="hljs-bullet">*</span> 一级无序列表内容(敲一个TAB键)<br><span class="hljs-bullet">    *</span> 二级无序列表内容<br><span class="hljs-bullet">    *</span> 二级无序列表内容<br><span class="hljs-bullet">    *</span> 二级无序列表内容<br></code></pre></td></tr></table></figure><h1 id="七-表格"><a href="#七-表格" class="headerlink" title="七. 表格"></a>七. 表格</h1><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">第二行是分割线，两边加：表示居中；右边加：表示靠右<br>|<span class="hljs-string">姓名</span>|<span class="hljs-string">性别</span>|<span class="hljs-string">分数</span>|<br>|<span class="hljs-string">--</span>|<span class="hljs-string">:--:</span>|<span class="hljs-string">--:</span>|<br>|<span class="hljs-string">小明</span>|<span class="hljs-string">男</span>|<span class="hljs-string">100</span>|<br>|<span class="hljs-string">小红</span>|<span class="hljs-string">女</span>|<span class="hljs-string">89</span>|<br>|<span class="hljs-string">小飞</span>|<span class="hljs-string">男</span>|<span class="hljs-string">88</span>|<br></code></pre></td></tr></table></figure><h1 id="八-代码"><a href="#八-代码" class="headerlink" title="八. 代码"></a>八. 代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 单行代码<br>`<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)`<br>两边加上单引号即可<br><span class="hljs-number">2.</span> 代码块<br>~~~c++<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello CSDN!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>~~~<br>用三个波浪号包起来，可以指定对应的语言。<br>或者用```包起来<br>```c++<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello CSDN!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编辑器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="/2024/10/31/FrontEnd/CSS%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/31/FrontEnd/CSS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-CSS介绍"><a href="#1-CSS介绍" class="headerlink" title="1. CSS介绍"></a>1. CSS介绍</h2><ul><li>CSS：层叠样式表</li><li>CSS作用：给页面HTML标签设置样式</li></ul><h2 id="2-CSS引入方式"><a href="#2-CSS引入方式" class="headerlink" title="2. CSS引入方式"></a>2. CSS引入方式</h2><h4 id="A-内嵌式"><a href="#A-内嵌式" class="headerlink" title="A. 内嵌式"></a>A. 内嵌式</h4><ul><li>CSS写在style标签中</li><li>style标签通常写在head标签中</li></ul><h4 id="B-外联式-常用"><a href="#B-外联式-常用" class="headerlink" title="B. 外联式(常用)"></a>B. 外联式(常用)</h4><ul><li>CSS写在一个单独的.css文件中</li><li>通过link标签引入网页中</li></ul><h4 id="C-行内式-常配合JS使用"><a href="#C-行内式-常配合JS使用" class="headerlink" title="C. 行内式(常配合JS使用)"></a>C. 行内式(常配合JS使用)</h4><ul><li>CSS直接写在标签的style属性中</li></ul><h2 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3. 选择器"></a>3. 选择器</h2><h4 id="A-标签选择器"><a href="#A-标签选择器" class="headerlink" title="A. 标签选择器"></a>A. 标签选择器</h4><p>写法： <code>标签名{CSS属性名: 属性值;}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">示例：   <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>标签选择器选择一类标签中的所有，而不是单独某一个</p><h4 id="B-类选择器"><a href="#B-类选择器" class="headerlink" title="B. 类选择器"></a>B. 类选择器</h4><p>写法：<code>.类名{CSS属性名: 属性值;}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.red</span>&#123;<span class="hljs-attribute">color</span>: red;&#125;<br><span class="hljs-selector-class">.size</span>&#123;<span class="hljs-attribute">font-size</span>: <span class="hljs-number">88px</span>;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>一段话<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red size&quot;</span>&gt;</span>红且变大<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>也变红<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>类名由数字、字母、下划线和中划线组成，但不能以数字或中划线开头。</li><li>一个标签可以同时有多个类名，类名之间以空格隔开</li></ul><h4 id="C-ID选择器"><a href="#C-ID选择器" class="headerlink" title="C. ID选择器"></a>C. ID选择器</h4><p>写法： <code> #ID属性值{CSS属性名: 属性值;}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#blue</span>&#123;<span class="hljs-attribute">color</span>: blue;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>我是blue<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>id属性值在一个页面是唯一的，不可重复！</li><li>一个标签只能有一个id属性值，是一对一的</li></ul><h4 id="D-通配符选择器"><a href="#D-通配符选择器" class="headerlink" title="D. 通配符选择器"></a>D. 通配符选择器</h4><p>写法： <code> *{CSS属性名：属性值;}</code><br>作用：对页面中所有标签设置相应样式</p><h2 id="4-字体样式"><a href="#4-字体样式" class="headerlink" title="4. 字体样式"></a>4. 字体样式</h2><h4 id="A-属性"><a href="#A-属性" class="headerlink" title="A. 属性"></a>A. 属性</h4><table><thead><tr><th>属性名</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>font-size</td><td>数字+px</td><td>字体大小</td></tr><tr><td>font-weight</td><td>100~900整百数</td><td>字体粗细</td></tr><tr><td>font-style</td><td>normal&#x2F;italic</td><td>字体是否倾斜</td></tr><tr><td>font-family</td><td>微软雅黑&#x2F;宋体&#x2F;等等</td><td>字体系列</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;<br>   <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">900</span>;<br>   <span class="hljs-attribute">font-style</span>: italic;<br>   <span class="hljs-attribute">font-family</span>: 宋体;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">P</span>&gt;</span>这是一段30像素、加粗、倾斜的宋体文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-样式的层叠性"><a href="#B-样式的层叠性" class="headerlink" title="B. 样式的层叠性"></a>B. 样式的层叠性</h4><p>给同一个标签设置相同属性，样式会层叠，最下面的生效</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时blue样式生效，red样式不生效。</p><h4 id="C-font的复合属性"><a href="#C-font的复合属性" class="headerlink" title="C. font的复合属性"></a>C. font的复合属性</h4><p>写法:  <code>font: style weight size family;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">例：<br><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font</span>: italic <span class="hljs-number">700</span> <span class="hljs-number">50px</span> 宋体;&#125;<br><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font</span>: <span class="hljs-number">100px</span> 微软雅黑;&#125;<br></code></pre></td></tr></table></figure><p>**注意：**只能省略前两个(style和weight)，size和family必须存在</p><h2 id="5-文本样式"><a href="#5-文本样式" class="headerlink" title="5. 文本样式"></a>5. 文本样式</h2><table><thead><tr><th>属性名</th><th>作用</th><th>取值</th></tr></thead><tbody><tr><td>text-indent</td><td>文本缩进</td><td>数字+px;<br>数字+em(1em&#x3D;1个字的大小)</td></tr><tr><td>text-align</td><td>文本水平对齐</td><td>left, center, right(左中右)</td></tr><tr><td>text-decoration</td><td>文本修饰</td><td>underline:下划线(常用)<br>none:无装饰线(常用)<br>line-through:删除线<br>overline:上划线</td></tr><tr><td>line-height</td><td>行高</td><td>数字+px;<br>倍数(当前font-size的倍数)</td></tr></tbody></table><h2 id="6-标签水平居中"><a href="#6-标签水平居中" class="headerlink" title="6. 标签水平居中"></a>6. 标签水平居中</h2><p>让div、p、h等标签大盒子水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br></code></pre></td></tr></table></figure><h2 id="7-选择器进阶"><a href="#7-选择器进阶" class="headerlink" title="7. 选择器进阶"></a>7. 选择器进阶</h2><h4 id="A-复合选择器"><a href="#A-复合选择器" class="headerlink" title="A.复合选择器"></a>A.复合选择器</h4><p><strong>1. 后代选择器</strong><br>根据HTML标签的嵌套关系，选择父元素后代中满足条件的元素<br>语法：<code>选择器1 选择器2{css}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是div的儿子p<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2. 子代选择器: &gt;</strong><br>根据HTML标签的嵌套关系，选择父元素子代中满足条件的元素<br>语法： <code>选择器1&gt;选择器2{css}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">a</span>&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    父级<br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>这是div里面的a<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>这是div中p的a<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-并集选择器"><a href="#B-并集选择器" class="headerlink" title="B. 并集选择器"></a>B. 并集选择器</h4><p>同时选择多组标签，设置相同的样式<br>语法： <code>选择器1,选择器2{css}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">div</span>,<span class="hljs-selector-tag">span</span>,<span class="hljs-selector-tag">h1</span>&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">P</span>&gt;</span>p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>h1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="C-交集选择器"><a href="#C-交集选择器" class="headerlink" title="C. 交集选择器"></a>C. 交集选择器</h4><p>选中页面中同时满足多个选择器的标签<br>语法： <code>选择器1选择器2{css}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.box</span>&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>这是p标签：box<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>这是div标签：box<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="D-hover伪类选择器"><a href="#D-hover伪类选择器" class="headerlink" title="D. hover伪类选择器"></a>D. hover伪类选择器</h4><p>选中鼠标悬停在元素上的状态，设置样式<br>语法：  <code>选择器:hover{css}</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">background-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-背景相关属性"><a href="#8-背景相关属性" class="headerlink" title="8. 背景相关属性"></a>8. 背景相关属性</h2><h4 id="A-属性-1"><a href="#A-属性-1" class="headerlink" title="A. 属性"></a>A. 属性</h4><table><thead><tr><th>属性名</th><th>作用</th><th>取值</th></tr></thead><tbody><tr><td>background-color</td><td>背景颜色</td><td>关键字，rgb法，rgba法等</td></tr><tr><td>background-image</td><td>背景图片</td><td>background-image: url(‘图片路径’);</td></tr><tr><td>background-repeat</td><td>背景平铺</td><td>repeat:水平垂直都平铺(默认)<br>no-repeat:不平铺<br>repeat-x:水平方向平铺<br>repeat-y:垂直方向平铺</td></tr><tr><td>background-position</td><td>背景位置</td><td>background-position:水平方向位置 垂直方向位置;</td></tr></tbody></table><h4 id="B-背景相关属性的连写形式"><a href="#B-背景相关属性的连写形式" class="headerlink" title="B.背景相关属性的连写形式"></a>B.背景相关属性的连写形式</h4><p>写法：<code>background: color image repeat position</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: pink <span class="hljs-built_in">url</span>(<span class="hljs-string">./image/1.jpg</span>) no-repeat center bottom;<br></code></pre></td></tr></table></figure><h2 id="9-元素显示模式"><a href="#9-元素显示模式" class="headerlink" title="9. 元素显示模式"></a>9. 元素显示模式</h2><h4 id="A-块级元素"><a href="#A-块级元素" class="headerlink" title="A. 块级元素"></a>A. 块级元素</h4><ul><li>独占一行</li><li>宽度默认是父元素的宽度，高度默认由内容撑开</li><li>可以设置宽高</li></ul><p>代表标签：div、p、h、ul等</p><h4 id="B-行内元素"><a href="#B-行内元素" class="headerlink" title="B. 行内元素"></a>B. 行内元素</h4><ul><li>一行可以显示多个</li><li>宽度和高度默认由内容撑开</li><li>不可以设置宽高</li></ul><p>代表标签：a、span、b、u等</p><h4 id="C-行内块元素"><a href="#C-行内块元素" class="headerlink" title="C. 行内块元素"></a>C. 行内块元素</h4><ul><li>一行可以显示多个</li><li>可以设置宽高</li></ul><p>代表标签: input、textarea、button、select等</p><h4 id="D-元素显示模式转换"><a href="#D-元素显示模式转换" class="headerlink" title="D. 元素显示模式转换"></a>D. 元素显示模式转换</h4><ul><li>改变元素默认的显示特点，让元素符合要求</li></ul><table><thead><tr><th>属性</th><th>效果</th></tr></thead><tbody><tr><td>display:block</td><td>转为块级元素(常用)</td></tr><tr><td>display:inline-block</td><td>转为行内块元素(常用)</td></tr><tr><td>display:inline</td><td>转为行内元素</td></tr></tbody></table><h4 id="E-HTML嵌套注意"><a href="#E-HTML嵌套注意" class="headerlink" title="E. HTML嵌套注意"></a>E. HTML嵌套注意</h4><ul><li>块级元素一般作为大容器，可以嵌套其他元素<br>但：p标签不能嵌套div、p、h等块级元素</li><li>a标签内部可以嵌套任意元素<br>但：a不能套a标签</li></ul><h2 id="10-CSS特性"><a href="#10-CSS特性" class="headerlink" title="10. CSS特性"></a>10. CSS特性</h2><h4 id="A-继承性"><a href="#A-继承性" class="headerlink" title="A. 继承性"></a>A. 继承性</h4><p>子元素有默认继承父元素样式的特点；但如果自己本身有相应的属性，就不会继承父元素的属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    这是div标签中的文字<br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>这是div中span的字,此时span中的字也变红<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-层叠性"><a href="#B-层叠性" class="headerlink" title="B. 层叠性"></a>B. 层叠性</h4><ul><li>给同一个标签设置不同样式时，样式会叠加</li><li>给同一个标签设置相同样式时，样式会覆盖掉，以最后样式生效</li></ul><h4 id="C-优先级"><a href="#C-优先级" class="headerlink" title="C. 优先级"></a>C. 优先级</h4><p>下面介绍</p><h2 id="11-CSS的优先级"><a href="#11-CSS的优先级" class="headerlink" title="11. CSS的优先级"></a>11. CSS的优先级</h2><p>定义：不同选择器具有不同的优先级，优先级高的选择器样式会覆盖优先级低的选择器样式<br>优先级大小：<br>继承&lt;通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;！important</p><h2 id="12-优先级的权重叠加计算"><a href="#12-优先级的权重叠加计算" class="headerlink" title="12. 优先级的权重叠加计算"></a>12. 优先级的权重叠加计算</h2><p>如果是复合选择器，需要通过权重叠加计算方法判断最终哪个选择器优先级最高最终生效。<br>公式：(0,0,0,0)&#x3D;&#x3D;&gt;(第一级,第二级,第三级,第四级)<br>复合选择器中：(行内样式个数,id选择器个数,类选择器个数,标签选择器个数)</p><p><strong>比较规则：</strong><br>从第一级开始比较，若能比较出来，则完成；否则继续下一级的比较；以此类推<br>例如：(1,0,0,0)&gt;(0,2,0,0)&gt;(0,1,0,1)&gt;(0,0,5,0)</p><p><strong>注意：</strong></p><ul><li>记住:(行内,id,类,标签)</li><li>!important永远是最高优先级，继承最低</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-id">#one</span>&#123;<span class="hljs-attribute">color</span>: orange;&#125;<br><span class="hljs-selector-class">.father</span> <span class="hljs-selector-class">.son</span>&#123;<span class="hljs-attribute">color</span>: skyblue;&#125;<br><span class="hljs-selector-class">.father</span> <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>: purple;&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">color</span>: pink;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>猜我的颜色<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于(0,1,0,1)&gt;(0,0,2,0)&gt;(0,0,1,1)&gt;(0,0,0,2);所以最终orange颜色生效。</p><h2 id="13-盒子模型"><a href="#13-盒子模型" class="headerlink" title="13. 盒子模型"></a>13. 盒子模型</h2><p>盒子就是标签<br>每个盒子由内容区域(content)、内边距区域(padding)、边框区域(border)和外边距区域(margin)构成</p><h4 id="A-内容区域的宽度和高度"><a href="#A-内容区域的宽度和高度" class="headerlink" title="A. 内容区域的宽度和高度"></a>A. 内容区域的宽度和高度</h4><p>使用width和height属性设置盒子内容区域的大小</p><h4 id="B-边框区域"><a href="#B-边框区域" class="headerlink" title="B. 边框区域"></a>B. 边框区域</h4><p>属性使用border;<br>语法： <code>border: 粗细 线条种类 颜色;</code><br>例子：<code>border: 10px solid #000;</code></p><h4 id="C-内边距区域"><a href="#C-内边距区域" class="headerlink" title="C. 内边距区域"></a>C. 内边距区域</h4><p>padding属性可以当作复合属性使用</p><ul><li>一值(上下左右)：    <code>padding: 50px;</code></li><li>二值(上下 左右)：   <code>padding: 10px 80px;</code></li><li>三值(上 左右 下):   <code>padding: 10px 20px 50px;</code></li><li>四值(上 右 下 左):  <code>padding: 10px 20px 40px 80px;</code></li></ul><h4 id="D-外边距区域"><a href="#D-外边距区域" class="headerlink" title="D. 外边距区域"></a>D. 外边距区域</h4><p>使用margin属性，与padding属性使用方式一样</p><h4 id="E-清除默认内外边距"><a href="#E-清除默认内外边距" class="headerlink" title="E. 清除默认内外边距"></a>E. 清除默认内外边距</h4><p>使用以下方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br>    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="F-版心居中"><a href="#F-版心居中" class="headerlink" title="F. 版心居中"></a>F. 版心居中</h4><p>网页的有效内容在网页居中<br>使用：<code>margin: 0 auto;</code></p><h2 id="14-结构伪类选择器"><a href="#14-结构伪类选择器" class="headerlink" title="14. 结构伪类选择器"></a>14. 结构伪类选择器</h2><p>根据元素在HTML中的结构关系查找元素</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-child{}</td><td>匹配父元素中第一个子元素，且是E元素</td></tr><tr><td>E:last-child{}</td><td>匹配父元素中最后一个子元素，且是E元素</td></tr><tr><td>E:nth-child(n){}</td><td>匹配父元素中第n个子元素，且是E元素</td></tr><tr><td>E:nth-last-child(n){}</td><td>匹配父元素中倒数第n个子元素，且是E元素</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第1个li元素,我会变绿吗<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第2个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第3个li元素,我会变黄吗<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第4个li元素,我会变红吗<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第5个li元素,我会变蓝吗<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first-child</span>&#123;<span class="hljs-attribute">background-color</span>: green;&#125;<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>&#123;<span class="hljs-attribute">background-color</span>: blue;&#125;<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">4</span>)&#123;<span class="hljs-attribute">background-color</span>: red;&#125;<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">3</span>)&#123;<span class="hljs-attribute">background-color</span>: yellow;&#125;<br></code></pre></td></tr></table></figure><h2 id="15-伪元素"><a href="#15-伪元素" class="headerlink" title="15. 伪元素"></a>15. 伪元素</h2><ul><li>元素：HTML设置的标签</li><li>伪元素：由CSS模拟出的标签效果</li></ul><table><thead><tr><th>伪元素</th><th>作用</th></tr></thead><tbody><tr><td>::before</td><td>在父元素内容的最前添加一个伪元素</td></tr><tr><td>::after</td><td>在父元素内容的最后添加一个伪元素</td></tr></tbody></table><p><strong>注意：</strong> content属性必须有，否则不生效</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span><span class="hljs-selector-pseudo">::before</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;我爱&#x27;</span>;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.father</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;呀&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span>喝开水<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="16-浮动-不够详细"><a href="#16-浮动-不够详细" class="headerlink" title="16. 浮动(不够详细)"></a>16. 浮动(不够详细)</h2><p>用作网页布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1226px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">460px</span>;<br>    <span class="hljs-attribute">background-color</span>: green;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">234px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">460px</span>;<br>    <span class="hljs-attribute">background-color</span>: blue;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">992px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">460px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="17-清除浮动"><a href="#17-清除浮动" class="headerlink" title="17. 清除浮动"></a>17. 清除浮动</h2><p>清除浮动给其他元素带来的影响</p><h4 id="A-额外标签法"><a href="#A-额外标签法" class="headerlink" title="A. 额外标签法"></a>A. 额外标签法</h4><ol><li>在父元素内容的最后添加一个块级元素</li><li>给添加的块级元素设置： <code>clear: both;</code></li></ol><h4 id="B-单伪元素清除法-推荐"><a href="#B-单伪元素清除法-推荐" class="headerlink" title="B. 单伪元素清除法(推荐)"></a>B. 单伪元素清除法(推荐)</h4><p>用伪元素替代了额外标签<br>写法1：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>写法2(用于解决浏览器兼容性)：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-双伪元素清除法-推荐"><a href="#C-双伪元素清除法-推荐" class="headerlink" title="C. 双伪元素清除法(推荐)"></a>C. 双伪元素清除法(推荐)</h4><p>写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::before</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-attribute">clear</span>:both;&#125;<br></code></pre></td></tr></table></figure><h4 id="D-overflow法-推荐"><a href="#D-overflow法-推荐" class="headerlink" title="D. overflow法(推荐)"></a>D. overflow法(推荐)</h4><p>给父元素加上：<code>overflow:hidden;</code></p><h2 id="18-定位"><a href="#18-定位" class="headerlink" title="18. 定位"></a>18. 定位</h2><h4 id="A-定位的作用"><a href="#A-定位的作用" class="headerlink" title="A. 定位的作用"></a>A. 定位的作用</h4><p>让元素自由的摆放在网页的任意位置，一般用于盒子间的层叠情况</p><h4 id="B-定位的基本使用"><a href="#B-定位的基本使用" class="headerlink" title="B. 定位的基本使用"></a>B. 定位的基本使用</h4><p><strong>(1) 定位方法</strong><br>属性名：position</p><table><thead><tr><th>定位方式</th><th>属性值</th></tr></thead><tbody><tr><td>静态定位</td><td>static</td></tr><tr><td>相对定位</td><td>relative</td></tr><tr><td>绝对定位</td><td>absolute</td></tr><tr><td>固定定位</td><td>fixed</td></tr></tbody></table><p><strong>(2) 偏移值</strong></p><table><thead><tr><th>方向</th><th>属性名</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>水平</td><td>left</td><td>数字+px</td><td>距离左边的距离</td></tr><tr><td>水平</td><td>right</td><td>数字+px</td><td>距离右边的距离</td></tr><tr><td>垂直</td><td>top</td><td>数字+px</td><td>距离上边的距离</td></tr><tr><td>垂直</td><td>bottom</td><td>数字+px</td><td>距离下边的距离</td></tr></tbody></table><h2 id="19-元素层级"><a href="#19-元素层级" class="headerlink" title="19. 元素层级"></a>19. 元素层级</h2><h4 id="A-不同布局方式元素的层级关系"><a href="#A-不同布局方式元素的层级关系" class="headerlink" title="A. 不同布局方式元素的层级关系"></a>A. 不同布局方式元素的层级关系</h4><ul><li>标准流&lt;浮动&lt;定位</li></ul><h4 id="B-不同定位之间的层级关系"><a href="#B-不同定位之间的层级关系" class="headerlink" title="B. 不同定位之间的层级关系"></a>B. 不同定位之间的层级关系</h4><ul><li>相对、绝对和固定默认层级相同</li><li>HTML写在后面的元素层级更高</li></ul><h2 id="20-装饰"><a href="#20-装饰" class="headerlink" title="20. 装饰"></a>20. 装饰</h2><h4 id="A-垂直对齐方式"><a href="#A-垂直对齐方式" class="headerlink" title="A. 垂直对齐方式"></a>A. 垂直对齐方式</h4><p>属性名: <code>vertical-align</code></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>baseline</td><td>默认</td></tr><tr><td>top</td><td>顶部对齐</td></tr><tr><td>middle</td><td>中部对齐</td></tr><tr><td>bottom</td><td>底部对齐</td></tr></tbody></table><h4 id="B-光标类型"><a href="#B-光标类型" class="headerlink" title="B. 光标类型"></a>B. 光标类型</h4><p>设置鼠标移动到元素上显示的样式<br>属性名: <code>cursor</code></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>default</td><td>默认，箭头</td></tr><tr><td>pointer</td><td>小手效果，可以点击</td></tr><tr><td>text</td><td>工字型，可以选择文字</td></tr><tr><td>move</td><td>十字光标，可以移动</td></tr></tbody></table><h4 id="C-边框圆角"><a href="#C-边框圆角" class="headerlink" title="C. 边框圆角"></a>C. 边框圆角</h4><p>盒子的四个角变得圆润<br>属性名： <code>border-radius</code><br>取值： 数字+px，百分比</p><ul><li>画一个正圆<ul><li>盒子必须是正方形</li><li>设置border-radius: 50%;</li></ul></li><li>胶囊按钮<ul><li>盒子必须是长方形</li><li>设置border-radius: 盒子高度的一半</li></ul></li></ul><h4 id="D-overflow溢出显示效果"><a href="#D-overflow溢出显示效果" class="headerlink" title="D. overflow溢出显示效果"></a>D. overflow溢出显示效果</h4><p>解决溢出部分问题，溢出指盒子内容部分超过盒子的内容区域。<br>属性名： <code>overflow</code></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>visible</td><td>默认，溢出部分可见</td></tr><tr><td>hidden</td><td>溢出部分隐藏</td></tr><tr><td>scroll</td><td>显示滚动条</td></tr><tr><td>auto</td><td>自动显示或隐藏滚动条</td></tr></tbody></table><h4 id="E-元素显示隐藏"><a href="#E-元素显示隐藏" class="headerlink" title="E. 元素显示隐藏"></a>E. 元素显示隐藏</h4><p>让某元素本身在屏幕不可见<br>属性： <code>visibility:hidden</code>或<code>display:none</code></p><h4 id="F-元素透明度"><a href="#F-元素透明度" class="headerlink" title="F. 元素透明度"></a>F. 元素透明度</h4><p>让元素整体变得更透明<br>属性名： <code>opacity</code><br>属性值： 0~1之间的数字</p><ul><li>1：完全不透明</li><li>0：完全透明</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="/2024/10/31/FrontEnd/HTML%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/31/FrontEnd/HTML%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Web标准"><a href="#1-Web标准" class="headerlink" title="1. Web标准"></a>1. Web标准</h2><table><thead><tr><th align="center">语言</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td align="center">HTML</td><td>结构</td><td>页面元素和内容</td></tr><tr><td align="center">CSS</td><td>表现</td><td>美化用的，网页元素的外观位置颜色等</td></tr><tr><td align="center">JavaScript</td><td>行为</td><td>页面交互和动态效果</td></tr></tbody></table><h2 id="2-HTML页面固定结构"><a href="#2-HTML页面固定结构" class="headerlink" title="2. HTML页面固定结构"></a>2. HTML页面固定结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页的标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        网页的主体内容<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h2><p>VScode用<code>Ctrl+/</code>注释和取消注释<br><code>&lt;!--这是注释--&gt;</code></p><h2 id="4-标签之间的关系"><a href="#4-标签之间的关系" class="headerlink" title="4. 标签之间的关系"></a>4. 标签之间的关系</h2><ol><li>父子关系(嵌套关系)</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>兄弟关系(并列关系)</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-标题标签"><a href="#5-标题标签" class="headerlink" title="5. 标题标签"></a>5. 标题标签</h2><p>使用h系列标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>1级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>2级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>3级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>4级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>5级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>6级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>1~6级标题的重要程度依次递减</li><li>加粗，变大，独占一行</li></ul><h2 id="6-段落标签"><a href="#6-段落标签" class="headerlink" title="6. 段落标签"></a>6. 段落标签</h2><p>使用p标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是一段文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>段落之间存在间隙</li><li>独占一行</li></ul><h2 id="7-换行标签"><a href="#7-换行标签" class="headerlink" title="7. 换行标签"></a>7. 换行标签</h2><p><code>&lt;br&gt;</code>用来强制换行</p><h2 id="8-水平分割线标签"><a href="#8-水平分割线标签" class="headerlink" title="8. 水平分割线标签"></a>8. 水平分割线标签</h2><p><code>&lt;hr&gt;</code>用来分割不同区域的水平线</p><h2 id="9-文本格式化标签"><a href="#9-文本格式化标签" class="headerlink" title="9. 文本格式化标签"></a>9. 文本格式化标签</h2><table><thead><tr><th>作用</th><th align="center">标签1</th><th align="center">标签2</th></tr></thead><tbody><tr><td>加粗</td><td align="center">b</td><td align="center">strong</td></tr><tr><td>下划线</td><td align="center">u</td><td align="center">ins</td></tr><tr><td>倾斜</td><td align="center">i</td><td align="center">em</td></tr><tr><td>删除线</td><td align="center">s</td><td align="center">del</td></tr></tbody></table><ul><li>两种标签最终实现的效果是一样的</li><li>只不过标签2更加突出强调语境</li></ul><h2 id="10-图片标签"><a href="#10-图片标签" class="headerlink" title="10. 图片标签"></a>10. 图片标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot; &quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot; &quot;</span>&gt;</span> src和alt是属性<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./1.jpg&quot;</span>&gt;</span>  显示当前文件夹的1.jpg图片<br></code></pre></td></tr></table></figure><ul><li>标签属性写在开始标签内部</li><li>标签可以有多个属性，且属性之间没有顺序之分</li><li>属性之间以空格隔开；标签与属性之间以空格隔开</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;dog.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;这是一只狗&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;鼠标悬停时显示&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;800&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>alt属性是替换文本，图片不显示的时候显示alt</li><li>title是图片的标题，鼠标悬停时显示</li><li>width和height设置一个即可，等比例缩放不变形</li></ul><h2 id="11-路径"><a href="#11-路径" class="headerlink" title="11. 路径"></a>11. 路径</h2><p>页面需要加载图片，音频或视频等，怎么找到对应的文件</p><ol><li>绝对路径(了解)<br>目录下的绝对位置，可直接到达目标位置，从盘符开始<br>例：<code>D:\study\html\image\1.jpg</code> (盘符开头)<br><code>https://www.abc.cn/1234/1.jpg</code> (完整网址)</li><li>相对路径(常用)<br>从当前文件出发找目标文件的过程</li></ol><ul><li>同级目录<br>使用<code>&lt;img src=&quot;目标图片.jpg&quot;&gt;</code>或者<code>&lt;img src=&quot;./目标图片.jpg&quot;&gt;</code></li><li>下级目录<br>使用<code>&lt;img src=&quot;目标文件夹/目标图片.jpg&quot;&gt;</code></li><li>上级目录<br>到上一级目录用<code>../</code>;返回上两级就是<code>../../</code></li></ul><h2 id="12-音频标签"><a href="#12-音频标签" class="headerlink" title="12.音频标签"></a>12.音频标签</h2><p>在页面插入音频</p><table><thead><tr><th align="center">属性</th><th>功能</th></tr></thead><tbody><tr><td align="center">src</td><td>音频的路径</td></tr><tr><td align="center">controls</td><td>显示播放的控件</td></tr><tr><td align="center">autoplay</td><td>自动播放</td></tr><tr><td align="center">loop</td><td>循环播放</td></tr></tbody></table><p>例: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./music.mp3&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="13-视频标签"><a href="#13-视频标签" class="headerlink" title="13. 视频标签"></a>13. 视频标签</h2><p>属性类型与音频相同</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./video.mp4&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">muted</span> <span class="hljs-attr">loop</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性muted用来静音播放</p><h2 id="14-超链接"><a href="#14-超链接" class="headerlink" title="14. 超链接"></a>14. 超链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;目标地址.html&quot;</span>&gt;</span>跳转到目标地址<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>空链接用#<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><table border="1">    <tr>        <th>属性</th>         <th>取值</th>         <th>效果</th>      </tr>    <tr>        <td rowspan="2">target</td>        <td>_self</td>        <td>默认，在当前窗口中跳转(覆盖原网页)</td>    </tr>    <tr>        <td>_blank</td>        <td>在新窗口中跳转(保留原网页)</td>    </tr></table>在新窗口跳转：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>跳转到百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="15-列表标签"><a href="#15-列表标签" class="headerlink" title="15. 列表标签"></a>15. 列表标签</h2><h4 id="1-无序标签"><a href="#1-无序标签" class="headerlink" title="1. 无序标签"></a>1. 无序标签</h4><table><thead><tr><th align="center">标签</th><th>说明</th></tr></thead><tbody><tr><td align="center">ul</td><td>无序标签的整体</td></tr><tr><td align="center">li</td><td>无序列表的每一项</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>华为<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>小米<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>ul只允许包含li标签</li><li>li标签可包含任意内容</li></ul><h4 id="2-有序标签"><a href="#2-有序标签" class="headerlink" title="2. 有序标签"></a>2. 有序标签</h4><p>与无序列表类似；用ol和li</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第三<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-自定义标签"><a href="#3-自定义标签" class="headerlink" title="3. 自定义标签"></a>3. 自定义标签</h4><table><thead><tr><th align="center">标签</th><th>说明</th></tr></thead><tbody><tr><td align="center">dl</td><td>自定义列表的整体</td></tr><tr><td align="center">dt</td><td>自定义列表的主题</td></tr><tr><td align="center">dd</td><td>自定义列表中主题下的每一项</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>985大学<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>清华大学<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京大学<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong> dl中只允许包含dt和dd标签</p><h2 id="16-表格标签"><a href="#16-表格标签" class="headerlink" title="16. 表格标签"></a>16. 表格标签</h2><h4 id="A-标签"><a href="#A-标签" class="headerlink" title="A. 标签"></a>A. 标签</h4><table><thead><tr><th align="center">标签名</th><th>作用</th></tr></thead><tbody><tr><td align="center">table</td><td>表格整体</td></tr><tr><td align="center">tr</td><td>表格每行</td></tr><tr><td align="center">td</td><td>表格单元格</td></tr><tr><td align="center">caption</td><td>表格大标题</td></tr><tr><td align="center">th</td><td>表头单元格</td></tr></tbody></table><h4 id="B-属性"><a href="#B-属性" class="headerlink" title="B. 属性"></a>B. 属性</h4><table><thead><tr><th align="center">属性名</th><th>作用</th><th align="center">属性值</th></tr></thead><tbody><tr><td align="center">border</td><td>边框宽度</td><td align="center">数字</td></tr><tr><td align="center">width</td><td>表格宽度</td><td align="center">数字</td></tr><tr><td align="center">height</td><td>表格高度</td><td align="center">数字</td></tr><tr><td align="center">rowspan</td><td>跨行合并</td><td align="center">合并单元格的个数</td></tr><tr><td align="center">colspan</td><td>跨列合并</td><td align="center">合并单元格的个数</td></tr></tbody></table><h4 id="C-示例"><a href="#C-示例" class="headerlink" title="C. 示例"></a>C. 示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>高校简介<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>高校<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>人数<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>面积<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>清华<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>北大<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>4000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>安大<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="17-表单标签"><a href="#17-表单标签" class="headerlink" title="17. 表单标签"></a>17. 表单标签</h2><h4 id="A-input标签"><a href="#A-input标签" class="headerlink" title="A. input标签"></a>A. input标签</h4><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>type</td><td>指明类型</td></tr><tr><td>placeholder</td><td>输入框中的提示字</td></tr><tr><td>name</td><td>分组，有相同Name值的是同一组</td></tr><tr><td>checked</td><td>默认选中</td></tr><tr><td>multiple</td><td>多文件选择</td></tr><tr><td>form</td><td>按钮的父标签</td></tr><tr><td>value</td><td>按钮名字</td></tr></tbody></table><table><thead><tr><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>text</td><td>文本框，输入单行文本</td></tr><tr><td>password</td><td>密码框，输入密码</td></tr><tr><td>radio</td><td>单选框</td></tr><tr><td>checkbox</td><td>多选框</td></tr><tr><td>file</td><td>文件选择，上传文件</td></tr><tr><td>submit</td><td>提交按钮</td></tr><tr><td>reset</td><td>重置按钮</td></tr><tr><td>button</td><td>普通按钮，默认无功能</td></tr></tbody></table><ul><li>placeholder属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>name和checked属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>女<br></code></pre></td></tr></table></figure><ul><li>multiple属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>form和value属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;提交的地址&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;注册&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;普通按钮&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="B-button按钮标签"><a href="#B-button按钮标签" class="headerlink" title="B. button按钮标签"></a>B. button按钮标签</h4><table><thead><tr><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>submit</td><td>提交按钮</td></tr><tr><td>reset</td><td>重置按钮</td></tr><tr><td>button</td><td>普通按钮，默认无功能</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>普通按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="C-select下拉菜单按钮"><a href="#C-select下拉菜单按钮" class="headerlink" title="C. select下拉菜单按钮"></a>C. select下拉菜单按钮</h4><table><thead><tr><th>标签名</th><th>作用</th></tr></thead><tbody><tr><td>select</td><td>下拉菜单的整体</td></tr><tr><td>option</td><td>下拉菜单的每一项</td></tr></tbody></table><ul><li>selected属性：默认选中</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="D-textarea文本域标签"><a href="#D-textarea文本域标签" class="headerlink" title="D. textarea文本域标签"></a>D. textarea文本域标签</h4><p>提供可输入多行文本的控件</p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>cols</td><td>宽度</td></tr><tr><td>rows</td><td>行数</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="E-label标签"><a href="#E-label标签" class="headerlink" title="E. label标签"></a>E. label标签</h4><p>使用label标签把内容和表单标签一起包裹起来；把label中的for属性删除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="18-语义化标签"><a href="#18-语义化标签" class="headerlink" title="18. 语义化标签"></a>18. 语义化标签</h2><p>无语义的布局标签</p><ul><li>div:一行只显示一个</li><li>span:一行可显示多个</li></ul><h2 id="19-字符实体"><a href="#19-字符实体" class="headerlink" title="19. 字符实体"></a>19. 字符实体</h2><p>例如空格用<code>&amp;nbsp;</code><br>其他的不用记，用到的时候上网查。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在VS2019安装crypto包</title>
    <link href="/2024/06/15/CyberSec/%E5%A6%82%E4%BD%95%E5%9C%A8VS2019%E5%AE%89%E8%A3%85crypto%E5%8C%85/"/>
    <url>/2024/06/15/CyberSec/%E5%A6%82%E4%BD%95%E5%9C%A8VS2019%E5%AE%89%E8%A3%85crypto%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>首先点开python环境。</p><p><img src="/img/blogs/VS2019-crypto/1.png"></p><p>在搜索框下载这两个包：crypto和pycryptodome</p><p><img src="/img/blogs/VS2019-crypto/2.png"></p><p>此时如果运行会发现还是不能运行，显示报错包未存在。</p><p>crypto包最坑的地方就在于大小写要自己修改：</p><p>根据路径C:\Program Files (x86)\Microsoft Visual Studio\Shared\Python37_64\Lib\site-packages找到crypto文件夹，把crypto首字母c改成大写C即可，也就是Crypto。</p><p><img src="/img/blogs/VS2019-crypto/3.png"></p><p>这样就可以运行，正常使用crypto啦。</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于深度强化学习的 IRS 辅助节能安全 WBAN 传输</title>
    <link href="/2024/06/08/Paper/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%20IRS%20%E8%BE%85%E5%8A%A9%E8%8A%82%E8%83%BD%E5%AE%89%E5%85%A8%20WBAN%20%E4%BC%A0%E8%BE%93/"/>
    <url>/2024/06/08/Paper/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%9A%84%20IRS%20%E8%BE%85%E5%8A%A9%E8%8A%82%E8%83%BD%E5%AE%89%E5%85%A8%20WBAN%20%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://ieeexplore.ieee.org/abstract/document/9762319">IRS-Aided Energy-Efficient Secure WBAN Transmission Based on Deep Reinforcement Learning</a></p><h3 id="〇-简要综述"><a href="#〇-简要综述" class="headerlink" title="〇 简要综述"></a>〇 简要综述</h3><p>本文分别使用强化学习和深度强化学习的方法通过改变系统模型的参数(传感器的密钥、传输功率和IRS的相位偏移)防御窃听者的窃听攻击从而保证WBAN的安全传输，同时提高传输性能(降低能耗，提高传输效率)。</p><h3 id="Ⅰ-引言和相关工作"><a href="#Ⅰ-引言和相关工作" class="headerlink" title="Ⅰ 引言和相关工作"></a>Ⅰ 引言和相关工作</h3><ol><li>无线体域网(WBAN)</li></ol><p>WBAN是一种专门用于在人体周围进行无线通信的网络技术。主要用于医疗健康领域，通过在人体内或体表放置的多个传感器来采集和传输生理数据，以便进行实时监测、诊断和治疗。</p><ol start="2"><li>智能反射面(IRS)</li></ol><p>智能反射面由智能反射单元阵列组成，每个智能反射单元能够独立地对入射信号进行某些改变。大量的研究基本考虑到入射信号的相位偏移，所以IRS不消耗传输功率。IRS的主要作用是通过反射信号传输的角度和方向，增强特定区域的信号强度。</p><ol start="3"><li><p>强化学习(RL)</p></li><li><p>状态（State）：状态就是在某个时刻环境的具体描述，系统所处情景的完整表述，包含所有观测到的信息。</p></li><li><p>动作（Action）：动作是在特定状态下可以采取的行为或选择。每个动作会使智能体从一个状态转移到另一个状态。在本文中动作是改变加密密钥、传感器的发射功率级别以及IRS的相移。</p></li><li><p>策略（Policy）：策略是在当前状态下应该采取的动作是什么，通过制定策略长期内获得最大化累计奖励。</p></li><li><p>奖励（Reward）：就是执行动作后得到的反馈信号,用于评估该动作的好坏,它指导如何调整策略以实现目标。</p></li></ol><p>本文通过强化学习要改变的有以下这三个动作：</p><ul><li>密钥长度：由于WBAN主要用AES加密，如果密钥过长虽然安全性有所保障，但容易消耗过多的通信带宽，传输延迟过高。</li><li>传感器的发射功率：功率分配方案应用了值迭代动态规划，可以根据窃听者的干扰策略做出相应调整。</li><li>IRS的相位偏移：IRS反射信号通过增加协调器接收到的信号功率，减少窃听者接收到的信号功率，从而对抗窃听。</li></ul><h3 id="Ⅱ-系统模型和问题表述"><a href="#Ⅱ-系统模型和问题表述" class="headerlink" title="Ⅱ 系统模型和问题表述"></a>Ⅱ 系统模型和问题表述</h3><h5 id="A．无线体域网模型的工作原理"><a href="#A．无线体域网模型的工作原理" class="headerlink" title="A．无线体域网模型的工作原理"></a>A．无线体域网模型的工作原理</h5><ol><li>首先传感器从人体采集健康数据，通过A&#x2F;D转化器以速率R进行采样。</li><li>采集的数据用AES加密，密钥是由椭圆曲线DH算法生成的。</li><li>加密后的数据再进行信道编码(channel coding)（例如BCH编码）</li><li>编码后的数据使用例如DBPSK进行调制，用于无线信道的传输</li><li>传感器根据协调器的指令调整发送功率，然后将调制后的数据发送到协调器。</li><li>协调器接收到传感器的数据后，进行解调和信道解码。</li><li>解码后的数据经过AES解密恢复原始数据。</li><li>IRS由M个反射元件组成，协调器的指令通过设置PIN二极管的偏置电压可以调整IRS的相位偏移。</li><li>控制信道(control channel)：协调器通过控制信道向传感器和IRS发送加密密钥、相位偏移和发射功率等控制信息</li></ol><h5 id="B-WBAN-信道模型"><a href="#B-WBAN-信道模型" class="headerlink" title="B. WBAN 信道模型"></a>B. WBAN 信道模型</h5><p>主要介绍了信道估计的过程，信道估计的主要作用是得到信道当前状态信息</p><ol><li>协调器评估接收到的传感器导频信号从而获得传感器与协调器之间的信道状态信息（CSI）</li><li>IRS使用半被动元件辅助的信道估计方法来估计传感器-IRS和IRS-协调器的信道状态信息</li></ol><h5 id="C-攻击模型"><a href="#C-攻击模型" class="headerlink" title="C. 攻击模型"></a>C. 攻击模型</h5><p>主动窃听者选择合适的干扰功率发送干扰信号，诱导传感器提高发射功率，从而获取更多的数据。获得数据之后再解密数据。</p><p>主要展示了从传感器到协调器的传输过程，以及如何应对主动窃听者的窃听攻击。在每个时间段中动态调整传感器和IRS的操作参数，从而实现数据传输的安全性以及防御窃听攻击。</p><ol><li>信道估计和干扰测量：a窃听者发送干扰信号；b进行信道估计测量接收到的干扰功率(power)</li><li>协调器向IRS和传感器发送信标，通知其开始传输过程</li><li>传感器发送RTS(数据的优先级)，IRS发送RTS(IRS信道状态)。</li><li>安全传输策略选择：协调器基于接收的(数据优先级、IRS信道状态、前一个time slot的SINR)选择传感器的CTR_S(加密密钥、发射功率)和IRS的CTR_R(相位偏移)。</li><li>调整IRS反射元件的相位偏移从而优化信号传输。</li><li>传感器对数据进行加密和channel coding并且发送消息(MSG)</li><li>协调器对数据解码和解密，并且协调器估计信噪比（SINR），发送确认消息（ACK）给传感器和IRS，表示数据已成功接收。</li></ol><h3 id="Ⅲ-基于-IRS-辅助-RL-的节能安全-WBAN-传输"><a href="#Ⅲ-基于-IRS-辅助-RL-的节能安全-WBAN-传输" class="headerlink" title="Ⅲ 基于 IRS 辅助 RL 的节能安全 WBAN 传输"></a>Ⅲ 基于 IRS 辅助 RL 的节能安全 WBAN 传输</h3><p>因为协调器很难知道窃听信道状态和窃听策略，所以很难保证WBAN传输的安全，提出了强化学习的WBAN传输方案实现最优策略，包括选择传感器加密密钥、发射功率以及IRS相位调整。同时使用传感器信号的信噪比（SINR）作为安全性标准。</p><h5 id="A．state"><a href="#A．state" class="headerlink" title="A．state"></a>A．state</h5><p>某个时刻环境的具体描述：</p><p>输入的信息有干扰功率(jamming power)、基于导频的信道估计(pilot-based channel estimation)、数据优先级(data priority)、IRS信道状态(IRS channel states)、前一个时间段的传感器能耗和传输延迟(previous sensor energy consumption &amp; transmission latency)、传感器到IRS的信道状态和IRS到协调器的信道状态。</p><p>总之，传感器的状态向量。包含数据优先级、接收到的干扰功率、传感器和IRS的信道状态、传感器能量消耗和传输延迟。</p><h5 id="B-Action"><a href="#B-Action" class="headerlink" title="B. Action"></a>B. Action</h5><p>当下可以做出的改变，动作集(所有的传输策略的集合)：组成要素包括加密密钥、传感器的发射功率级别以及IRS的相移。</p><p>动作集是一个具有三维的有限集合，包含以下部分：</p><ol><li>传感器加密密钥的取值（1到Z）。</li><li>传感器发射功率级别的取值（1到D）。</li><li>IRS相移的取值（每个相移从0到N-1）</li></ol><h5 id="C-Policy"><a href="#C-Policy" class="headerlink" title="C. Policy"></a>C. Policy</h5><p>通过计算和评估策略分布以选择合适的传输策略。</p><p>协调器根据传感器信号的SINR 设置一个安全标准。如果在状态-动作对下的SINR低于安全标准，则认为该状态-动作对的风险水平为1，否则为0。</p><h5 id="D-Reward"><a href="#D-Reward" class="headerlink" title="D. Reward"></a>D. Reward</h5><p>1.效用函数u的计算</p><p>效用函数 u 结合了数据保护等级、窃听率、SINR、传感器能耗和传输延迟</p><p>协调器的目标是最大化期望的长期效用</p><p>其中γ是折扣因子，表示未来效用的重要性。</p><p>2.强化学习和经验回放：</p><p>状态转移概率由状态-动作对和下一状态计数器和出现次数向量得到</p><p>建模效用 ω 定义为所有真实反窃听传输经验的平均效用</p><p>生成 J 个模拟经验，根据这些经验更新长期风险水平和预期长期效用，最终通过迭代Bellman方程进行优化。</p><h3 id="IV-基于DRL的安全WBAN传输"><a href="#IV-基于DRL的安全WBAN传输" class="headerlink" title="IV 基于DRL的安全WBAN传输"></a>IV 基于DRL的安全WBAN传输</h3><p>主要是为了提高WBAN的传输性能，使用了深度RL。</p><ol><li>actor-critic模型：</li></ol><p>Critic 是评判网络：当输入为环境状态时，它可以评估当前状态的价值；当输入为环境状态和采取的动作时，它可以评估当前状态下采取该动作的价值。</p><p>Critic 网络的输入一般有两种形式：（1）如果输入为状态，则该评价网络的作用为评价当前状态价值；（2）如果输入为状态和动作，则该评价网络的作用为评价当前状态的动作价值。</p><p>Actor 为策略网络，以当前的状态作为输入，输出为动作的概率分布或者连续动作值，再由 Critic 网络来评价该动作的好坏从而调整策略。</p><ol start="2"><li>本文中的深度强化学习模型</li></ol><p>actor网络根据当前状态生成传输策略，critic网络评估状态值。</p><p>Actor：用于生成策略，即决定在当前状态下采取哪种动作（如选择传感器的加密密钥、传感器发射功率和IRS相移）。</p><p>Critic：用于评估当前策略的表现，即计算在当前状态和动作下的价值函数（Q值）。</p><h3 id="Ⅴ-性能分析和仿真结果"><a href="#Ⅴ-性能分析和仿真结果" class="headerlink" title="Ⅴ 性能分析和仿真结果"></a>Ⅴ 性能分析和仿真结果</h3><p>在模型中协调器选择传输策略（包括加密密钥长度、传输功率和IRS相位移），而窃听者选择干扰功率。</p><p>随着时间的推移，窃听率ITDL比ITRL收敛的更快，ITDL的窃听率始终比ITRL低。</p><p>同样的：在能耗方面、传输延迟方面，ITDL也始终比ITRL低</p><p>在传输的安全容量上，ITDL也始终比ITRL传输的安全容量更高。</p><p>ITDL的效用(综合指标)也一直比ITRL更高，更快的逼近理想状态。</p><p>结论：</p><ol><li>随着时间的推移，ITDL和ITRL的效用(utility)相比于BDL(基线策略)都提高了很多。</li><li>窃听者距离传感器从6米增加到10米，而ITRL的效用提高了38.6%。主要因为窃听者信道条件的恶化。</li><li>增加IRS的反射元件的数量可以提高效用。</li></ol><p>总之，通过强化学习改变协调器的选择(传感器的密钥、传输功率和IRS的相位偏移)降低窃听者的窃听率和拦截概率。</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>信息与通信</tag>
      
      <tag>强化学习</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2020-13821漏洞复现</title>
    <link href="/2024/04/28/CyberSec/CVE-2020-13821%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <url>/2024/04/28/CyberSec/CVE-2020-13821%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>​</p><h3 id="Ⅰ-漏洞介绍"><a href="#Ⅰ-漏洞介绍" class="headerlink" title="Ⅰ 漏洞介绍"></a>Ⅰ 漏洞介绍</h3><p>官网：<a href="https://www.cve.org/CVERecord?id=CVE-2020-13821">CVE - CVE-2020-13821 (mitre.org)</a></p><p>下载地址：<a href="https://www.hivemq.com/changelog/hivemq-4-3-2-released/">HiveMQ 4.3.2 Maintenance Release</a></p><p>Description: An issue was discovered in HiveMQ Broker Control Center 4.3.2. A crafted clientid parameter in an MQTT packet (sent to the Broker) is reflected in the client section of the management console. The attacker’s JavaScript is loaded in a browser, which can lead to theft of the session and cookie of the administrator’s account of the Broker.</p><p>描述: 在HiveMQ Broker Control Center 4.3.2中发现了一个问题。在发送给Broker的MQTT数据包中的一个精心构造的clientid参数在管理控制台的客户端部分中被反射。攻击者的JavaScript会加载在浏览器中，这可能导致管理员账户的会话和Cookie被盗取。</p><p>其他信息</p><p>CVE-ID：CVE-2020-13821</p><p>披露时间：2020.5.18</p><h3 id="Ⅱ-漏洞原理"><a href="#Ⅱ-漏洞原理" class="headerlink" title="Ⅱ 漏洞原理"></a>Ⅱ 漏洞原理</h3><ol><li>XSS漏洞</li></ol><p>跨站脚本攻击（Cross-Site Scripting，XSS）是一种常见的Web漏洞，它允许攻击者向网页中注入恶意脚本代码（通常是JavaScript代码）。当其他用户访问受到XSS攻击的网页时，这些恶意脚本代码将在他们的浏览器上执行，从而导致攻击者能够窃取用户的会话信息、篡改网页内容、重定向用户到恶意网站等恶意行为。</p><p>XSS漏洞通常存在于网站的输入验证不足或输出过滤不当的情况下。攻击者可以利用用户输入的地方（比如搜索框、评论框等）来注入恶意脚本代码，然后这些代码被存储在服务器上，并在其他用户访问该页面时被服务器发送给他们的浏览器执行。</p><p>XSS攻击可以分为三种类型：</p><ol><li>存储型XSS：恶意脚本被存储在服务器上，当其他用户访问包含该恶意脚本的页面时，恶意脚本会被执行。</li><li>反射型XSS：恶意脚本作为URL参数或表单提交数据的一部分，被发送到服务器。服务器在响应中返回并执行这些恶意脚本，从而使攻击者能够攻击访问者。</li><li>DOM型XSS：攻击者通过修改页面的DOM环境，使恶意脚本被执行。这种XSS攻击不涉及服务器端的存储和响应，而是完全在客户端执行。</li></ol><p><strong>在 HiveMQ MQTT Broker 上发现的问题：管理控制台中未针对 XSS 清理任何已连接设备的客户端 ID，从而导致存储 XSS。</strong></p><ol start="2"><li>MQTT协议</li></ol><p>MQTT（Message Queuing Telemetry Transport,消息队列遥测传输）是一个ISO 标准（ISO&#x2F;IEC PRF 20922）下基于发布 (Publish)&#x2F;订阅 (Subscribe)范式的消息协议，它工作在TCP&#x2F;IP协议族上，是为硬件性能低下的远程设备以及网络状况不好的情况下而设计的发布&#x2F;订阅型消息协议。MQTT最大优点在于可以以极少的代码和有限的带宽，为远程连接设备提过实时可靠的消息服务，作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p><p><img src="/img/blogs/CVE-2020-13821/1.png"></p><p>​</p><h3 id="Ⅲ-漏洞复现"><a href="#Ⅲ-漏洞复现" class="headerlink" title="Ⅲ 漏洞复现"></a>Ⅲ 漏洞复现</h3><ol><li>环境搭建</li></ol><p>在以下官网下载有漏洞未修复的4.3.2版本：</p><p><a href="https://www.hivemq.com/changelog/hivemq-4-3-2-released/">HiveMQ 4.3.2 Maintenance Release</a></p><p>下载完成后，通过这个目录路径”D:\hivemq-4.3.2\bin\run.bat”找到run.bat文件，以管理员运行即可启动hivemq，如下图所示：</p><p><img src="/img/blogs/CVE-2020-13821/2.png"></p><p>​<br>这里显示运行HiveMQ至少需要Java 11的版本，以下是下载Java 11的文章：</p><p><a href="https://blog.csdn.net/aixinxin1314myl/article/details/128163668">jdk11 下载与安装（非常详细，一步不落！！！）-CSDN博客</a></p><p>下载安装至少JDK11之后，再次点击run.bat文件，如下图所示，说明hivemq成功运行：</p><p><img src="/img/blogs/CVE-2020-13821/3.png"></p><p>如上图所示，我们看到页面对应的IP和端口分别是：127.0.0.1和8080</p><ol start="2"><li>访问网站</li></ol><p>我们在浏览器键入：127.0.0.1:8080</p><p>成功打开hivemq的网址页面如下：</p><p><img src="/img/blogs/CVE-2020-13821/4.png"></p><p>我们输入账号和密码分别是：admin和hivemq，登录进入如下图所示：</p><p><img src="/img/blogs/CVE-2020-13821/5.png"></p><p><img src="/img/blogs/CVE-2020-13821/6.png"></p><p>如上图所示，点击左侧的Clients,查看连接的客户端，点击Refresh Snapshot更新系统的快照。</p><ol start="3"><li>攻击脚本</li></ol><p>编写脚本代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#attack.py</span><br><span class="hljs-keyword">import</span> paho.mqtt.client <span class="hljs-keyword">as</span> mqtt<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randrange, uniform<br><span class="hljs-keyword">import</span> time<br> <br>mqttBroker = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br> <br>client = mqtt.Client(<span class="hljs-string">&quot;UU&lt;img src=x onerror=alert(/HelloWorld/)&gt;ZZ&quot;</span>)<br>client.connect(mqttBroker)<br> <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    randNumber = uniform(<span class="hljs-number">10000.0</span>, <span class="hljs-number">1000000.0</span>)<br>    client.publish(<span class="hljs-string">&quot;随机数：&quot;</span>,randNumber)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is  &quot;</span> + <span class="hljs-built_in">str</span>(randNumber)+<span class="hljs-string">&quot;  in this program&quot;</span>)<br>    time.sleep(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>(1) mqttBroker &#x3D; “127.0.0.1”</p><p>设置MQTT Broker的地址，我们使用的本地地址127.0.0.1</p><p>(2)<code>client = mqtt.Client(&quot;UU&lt;img src=x onerror=alert(/HelloWorld/)&gt;ZZ&quot;)</code></p><p>创建一个MQTT客户端，设置了客户端ID(即clientid)为 <code>&quot;UU&lt;img src=x onerror=alert(/HelloWorld/)&gt;ZZ&quot;</code>。clientid中包含了恶意的HTML代码 <code>&lt;img src=x onerror=alert(/HelloWorld/)&gt;</code>，这段代码将在管理控制台的客户端部分中被反射执行，从而触发XSS漏洞。</p><p>(3) while True:…………</p><p>设置一个无限循环用来发布恶意信息。这里的关键是主题部分可能会被用于反射恶意的clientid参数。</p><ol start="4"><li>攻击结果</li></ol><p>在以上attack.py中导入Paho MQTT 版本请使用如下命令：pip install paho-mqtt&#x3D;&#x3D;1.5.1。较高的版本不支持我们使用的回调 API 版本</p><p>我们直接编译运行：</p><p><img src="/img/blogs/CVE-2020-13821/7.png"></p><p>在Web页面，点击“Refresh Snapshot”刷新一下客户端：</p><p><img src="/img/blogs/CVE-2020-13821/8.png"></p><p>看到弹窗显示我们的恶意XSS。漏洞攻击成功！</p><p>​</p><h3 id="Ⅳ-漏洞修复"><a href="#Ⅳ-漏洞修复" class="headerlink" title="Ⅳ 漏洞修复"></a>Ⅳ 漏洞修复</h3><p>HiveMQ团队在2020.5.27发布4-3-3版本，修复了该漏洞,请使用更高版本的hivemq-4-3-3：</p><p><a href="https://www.hivemq.com/changelog/hivemq-4-3-3-released/">CONFIRM:https://www.hivemq.com/blog/hivemq-4-3-3-released/</a></p><p>This maintenance release for the 4.3 series includes the following improvements:</p><p>Security: Fixed the vulnerability of CVE-2020-13821</p><p>​​</p><h3 id="Ⅴ-参考资料"><a href="#Ⅴ-参考资料" class="headerlink" title="Ⅴ 参考资料"></a>Ⅴ 参考资料</h3><p><a href="https://kafroc.github.io/2021/03/28/CVE%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0.html">CVE漏洞环境搭建笔记 | kafroc</a></p><p><a href="https://blog.csdn.net/jackwmj12/article/details/129163012">MQTT协议详解(完整版)-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/397940947">Web漏洞之XSS(跨站脚本攻击)详解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.anquanke.com/post/id/216074#h2-0">物联网安全之MQTT渗透实战-安全客 - 安全资讯平台 (anquanke.com)</a></p><p><a href="https://avd.aliyun.com/detail?id=AVD-2020-13821&timestamp__1384=eq0x0iG=GQdCqY5YGNuCBbK0Qki=dK8bH4D">阿里云漏洞库 (aliyun.com)</a></p><p><a href="https://github.com/advisories/GHSA-9qcc-v828-vgx7">An issue was discovered in HiveMQ Broker Control Center 4… · CVE-2020-13821 · GitHub Advisory Database · GitHub</a></p><p><a href="https://www.hivemq.com/changelog/hivemq-4-3-3-released/">HiveMQ 4.3.3 Maintenance Release</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>漏洞分析</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reversing.kr网站的Flash Encrypt</title>
    <link href="/2024/04/27/CyberSec/reversing.kr%E7%BD%91%E7%AB%99%E7%9A%84Flash%20Encrypt/"/>
    <url>/2024/04/27/CyberSec/reversing.kr%E7%BD%91%E7%AB%99%E7%9A%84Flash%20Encrypt/</url>
    
    <content type="html"><![CDATA[<p>​<br>韩国人的逆向题目网站：<a href="http://reversing.kr/challenge.php?ckattempt=1">Reversing.Kr</a></p><p>浏览器点击Flash Encrypt自动下载flashenc.swf文件。</p><p>这题我们使用前辈们推荐的ffdec软件进行反编译。(以下给出github链接，也可以浏览器搜索下载)</p><p><a href="https://github.com/jindrapetrik/jpexs-decompiler">GitHub - jindrapetrik&#x2F;jpexs-decompiler: JPEXS Free Flash Decompiler</a></p><p>​<br><img src="/img/blogs/FlashEncrypt/1.png"></p><p>如上图所示，打开flashenc.swf之后，可以看到这个视频一共有七个帧。每个帧里面只有一个文本框和一个按钮。</p><p>我们可以发现七个帧中只有第一个帧的文本框中输入了字符1234567890，其他都没有，而如下图所示：最后一个帧显示Key is。很明显我们如果掌握了这个帧的信息，那么密钥就获得了。</p><p><img src="/img/blogs/FlashEncrypt/2.png"></p><p>我们首先查看第一个帧：鼠标移动到按钮位置，可以看到按钮响应函数是DefineButton2(4)。</p><p><img src="/img/blogs/FlashEncrypt/3.png"></p><p>打开脚本之前，要先在设置一栏勾选自动反混淆，这样看到的代码能看懂</p><p><img src="/img/blogs/FlashEncrypt/4.png"></p><p>于是我们在脚本中找到这个DefineButton2(4)函数，如下图所示：看到函数内部代码逻辑</p><p><img src="/img/blogs/FlashEncrypt/5.png"></p><p>如下图所示，让我们看的更清晰。很明显，spw是我们文本框输入的字符串，这段代码逻辑就是当spw&#x3D;&#x3D;1456的时候，跳转播放到第三个帧。</p><p><img src="/img/blogs/FlashEncrypt/6.png"></p><p>好的，那我们接下来查看第三个帧，如下图所示。</p><p><img src="/img/blogs/FlashEncrypt/7.png"></p><p>同理，第三个帧的按钮响应函数是DefineButton2(9),我们找到该函数，如下图所示：</p><p><img src="/img/blogs/FlashEncrypt/8.png"></p><p>如上图所示，看到同样的代码逻辑：当spwd&#x3D;&#x3D;25时，执行运算、清空，然后跳转播放第四帧。</p><p>……后续的推理过程同理，最终的就是跳转到第七帧，然后输出Key，就成功了！</p><p>在文件一栏另存为exe文件，打开。如果没有下载Adobe Flash Player是打不开这个.exe文件的，下载地址：<a href="https://www.flash.cn/">https://www.flash.cn/</a></p><p>依次在弹出的文本框中输入：</p><ol><li>1456</li><li>25</li><li>44</li><li>8</li><li>88</li><li>20546</li></ol><p>最后输出结果如下：Key is 16876</p><p><img src="/img/blogs/FlashEncrypt/9.png"></p><p><img src="/img/blogs/FlashEncrypt/10.png"></p><p>成功获得240分。</p><p><strong>参考资料</strong><br><a href="https://blog.csdn.net/whklhhhh/article/details/78279512">171018 逆向-Reversing.kr（Flash Encrypt）_ffdec 怎么运行脚本-CSDN博客</a></p><p><a href="https://github.com/L1B0/CTF/blob/master/Reversing-Kr/FlashEncrypt/Reversing-Kr%20Flash-Encrypt%20Writeup.md">CTF&#x2F;Reversing-Kr&#x2F;FlashEncrypt&#x2F;Reversing-Kr Flash-Encrypt Writeup.md at master · L1B0&#x2F;CTF · GitHub</a></p><p><a href="https://github.com/DoubleLabyrinth/reversing.kr/blob/master/Flash%20Encrypt/README.md">reversing.kr&#x2F;Flash Encrypt&#x2F;README.md at master · DoubleLabyrinth&#x2F;reversing.kr · GitHub</a></p><p><a href="https://chatgpt.com/">ChatGPT (openai.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矢量图：PNG格式转换为SVG格式</title>
    <link href="/2024/03/26/Paper/%E7%9F%A2%E9%87%8F%E5%9B%BE%EF%BC%9APNG%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BASVG%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/03/26/Paper/%E7%9F%A2%E9%87%8F%E5%9B%BE%EF%BC%9APNG%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BASVG%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>图片的格式有很多种，最常见的是位图和矢量图。在论文写作时，尤其对于理工科的论文，当一个图片是流程图、数据统计的柱形图、折线图等等，图片大部分内容是公式和文字以及一些基本的形状，那么这个时候最好使用矢量图格式。如果要插入的图片是拍照得到的照片和一些像素点很多很复杂的图片时，最好使用位图格式。矢量图最大的优点就是放大不模糊。很多期刊要求最好使用矢量图（svg,eps）。</p><ol><li>矢量图格式： 矢量图是使用数学公式来描述图像的，因此它们可以无限放大而不失真。矢量图形文件通常存储为文本文件，其中包含了用于绘制图像的几何形状、线条、颜色和文本信息。</li><li>位图格式： 位图图像是由像素阵列组成的图像，每个像素都有自己的颜色信息。当放大位图图像时，像素会变得更加明显，导致图像失真。</li></ol><p>常见的矢量图格式包括：</p><ol><li>SVG（Scalable Vector Graphics）：一种基于 XML 格式的矢量图形格式，支持动画和互动性。</li><li>AI（Adobe Illustrator Artwork）：Adobe Illustrator 的原生文件格式，用于存储矢量图形。</li><li>EPS（Encapsulated PostScript）：一种支持矢量图形和位图图像的文件格式，常用于印刷和桌面出版领域。</li></ol><p>常见的位图格式包括：</p><ol><li>JPEG（Joint Photographic Experts Group）：一种广泛用于存储照片和复杂图像的有损压缩格式，支持不同的压缩质量。</li><li>PNG（Portable Network Graphics）：一种支持透明度和损失less压缩的位图图像格式，常用于网络图像和图标。</li><li>GIF（Graphics Interchange Format）：一种支持动画和透明度的位图图像格式，适合简单图形和动画。</li><li>BMP（Bitmap）：Windows 系统中常用的无损位图图像格式，不支持压缩。</li><li>TIFF（Tagged Image File Format）：一种支持多页和多种图像数据格式（如矢量和位图）的高质量图像格式，常用于印刷和出版领域。</li></ol><p>新手在写论文的时候，可能不太了解要使用矢量图，很多时候会导出JPEG或PNG格式，如果使用word写论文再导出PDF格式的时候，很容易把图片压缩的很模糊。这里推荐一个免费的好用的网站，可以很好的把PNG格式转成SVG格式：</p><p><a href="https://png2svg.com/">png2svg</a></p><p><img src="/img/blogs/paper/pngtosvg.png"></p><p>这个网站也可以把JPEG转成SVG格式等等。挺好用的，不打广告。</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归--鸡哥的魔法石</title>
    <link href="/2024/03/19/Algorithm/%E9%80%92%E5%BD%92-%E9%B8%A1%E5%93%A5%E7%9A%84%E9%AD%94%E6%B3%95%E7%9F%B3/"/>
    <url>/2024/03/19/Algorithm/%E9%80%92%E5%BD%92-%E9%B8%A1%E5%93%A5%E7%9A%84%E9%AD%94%E6%B3%95%E7%9F%B3/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述</strong>:</p><p>在鸡哥的家乡，有一个传说，说是有一块神奇的魔法石，这块石头有个奇特的属性，它可以吸收一个整数X的能量。每次吸收时，它会将这个数字的所有数位上的数字之和从X中减去，并继续吸收新的能量，直到吸收的能量为0。鸡哥被这个奇怪的现象所吸引，它想知道，如果它有一个整数X，魔法石需要吸收几次能量才能将这个数字消耗为0。</p><p><strong>输入：</strong></p><p>第一行输入整数X</p><p><strong>输出：</strong></p><p>第一行包含一个整数，代表魔法石需要吸收的次数。</p><p><strong>代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> sumN)</span>  <span class="hljs-comment">//求一个整数的数位之和</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">10</span>)<br><span class="hljs-keyword">return</span> sumN += N;  <span class="hljs-comment">//递归终止条件</span><br>sumN += N % <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(N / <span class="hljs-number">10</span>, sumN); <span class="hljs-comment">//递归表达式</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> num)</span> <span class="hljs-comment">//递归相减，鸡哥吸收能量</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> num;   <span class="hljs-comment">//递归终止条件</span><br><span class="hljs-type">int</span> sumN = <span class="hljs-number">0</span>;<br>sumN = <span class="hljs-built_in">sum</span>(N, <span class="hljs-number">0</span>);<br>N -= sumN;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fun1</span>(N, num += <span class="hljs-number">1</span>);  <span class="hljs-comment">//递归表达式</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, num = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>cout &lt;&lt; <span class="hljs-built_in">fun1</span>(N, num);<span class="hljs-comment">//原题目有问题，这里最后要加1才对？我不理解</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>CPP</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于加法同态加密和多MSB预测的三维网格密文域可逆信息隐藏</title>
    <link href="/2024/02/24/CyberSec/%E5%9F%BA%E4%BA%8E%E5%8A%A0%E6%B3%95%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%92%8C%E5%A4%9AMSB%E9%A2%84%E6%B5%8B%E7%9A%84%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%AF%86%E6%96%87%E5%9F%9F%E5%8F%AF%E9%80%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/"/>
    <url>/2024/02/24/CyberSec/%E5%9F%BA%E4%BA%8E%E5%8A%A0%E6%B3%95%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E5%92%8C%E5%A4%9AMSB%E9%A2%84%E6%B5%8B%E7%9A%84%E4%B8%89%E7%BB%B4%E7%BD%91%E6%A0%BC%E5%AF%86%E6%96%87%E5%9F%9F%E5%8F%AF%E9%80%86%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<p>原文：Reversible Data Hiding for 3D Mesh Model Based on Block Modulus Encryption and Multi-MSB Prediction</p><p>链接：<a href="https://link.springer.com/chapter/10.1007/978-981-97-8746-3_7">Reversible Data Hiding for 3D Mesh Model Based on Block Modulus Encryption and Multi-MSB Prediction</a></p><p><strong>主要算法思想</strong>：</p><ol><li>预处理：将顶点信息进行整数映射以及坐标转换</li><li>网格划分，同态加密和子块置乱：将三维网格划分为大小相等的子块，大小为N×N×N。对子块内的顶点信息使用相同的密钥进行加法同态加密，使其保留空间相关性。然后对加密后的子块进行置乱操作，只对子块间进行置乱，而非子块内顶点的置乱，提高其密文域的安全性。</li><li>多MSB预测：得到密文域顶点信息，在每个子块内进行多MSB预测得到嵌入位置。</li><li>信息隐藏：将秘密信息嵌入到密文域中</li><li>信息恢复：提取秘密信息，将子块逆置乱，逆加法同态加密操作得到原始网格信息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>信息隐藏</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
